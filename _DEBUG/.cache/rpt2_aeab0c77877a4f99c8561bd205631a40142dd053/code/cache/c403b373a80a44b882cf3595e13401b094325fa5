{"code":"export class Async {\r\n    constructor(parent, onError) {\r\n        this._timeoutIds = null;\r\n        this._immediateIds = null;\r\n        this._intervalIds = null;\r\n        this._animationFrameIds = null;\r\n        this._isDisposed = false;\r\n        this._parent = parent || null;\r\n        this._onErrorHandler = onError;\r\n        this._noop = () => {\r\n        };\r\n    }\r\n    dispose() {\r\n        let id;\r\n        this._isDisposed = true;\r\n        this._parent = null;\r\n        if (this._timeoutIds) {\r\n            for (id in this._timeoutIds) {\r\n                if (this._timeoutIds.hasOwnProperty(id)) {\r\n                    this.clearTimeout(parseInt(id, 10));\r\n                }\r\n            }\r\n            this._timeoutIds = null;\r\n        }\r\n        if (this._immediateIds) {\r\n            for (id in this._immediateIds) {\r\n                if (this._immediateIds.hasOwnProperty(id)) {\r\n                    this.clearImmediate(parseInt(id, 10));\r\n                }\r\n            }\r\n            this._immediateIds = null;\r\n        }\r\n        if (this._intervalIds) {\r\n            for (id in this._intervalIds) {\r\n                if (this._intervalIds.hasOwnProperty(id)) {\r\n                    this.clearInterval(parseInt(id, 10));\r\n                }\r\n            }\r\n            this._intervalIds = null;\r\n        }\r\n        if (this._animationFrameIds) {\r\n            for (id in this._animationFrameIds) {\r\n                if (this._animationFrameIds.hasOwnProperty(id)) {\r\n                    this.cancelAnimationFrame(parseInt(id, 10));\r\n                }\r\n            }\r\n            this._animationFrameIds = null;\r\n        }\r\n    }\r\n    setTimeout(callback, duration) {\r\n        let timeoutId = 0;\r\n        if (!this._isDisposed) {\r\n            if (!this._timeoutIds) {\r\n                this._timeoutIds = {};\r\n            }\r\n            timeoutId = setTimeout(() => {\r\n                try {\r\n                    if (this._timeoutIds) {\r\n                        delete this._timeoutIds[timeoutId];\r\n                    }\r\n                    callback.apply(this._parent);\r\n                }\r\n                catch (e) {\r\n                    if (this._onErrorHandler) {\r\n                        this._onErrorHandler(e);\r\n                    }\r\n                }\r\n            }, duration);\r\n            this._timeoutIds[timeoutId] = true;\r\n        }\r\n        return timeoutId;\r\n    }\r\n    clearTimeout(id) {\r\n        if (this._timeoutIds && this._timeoutIds[id]) {\r\n            clearTimeout(id);\r\n            delete this._timeoutIds[id];\r\n        }\r\n    }\r\n    setImmediate(callback) {\r\n        let immediateId = 0;\r\n        if (!this._isDisposed) {\r\n            if (!this._immediateIds) {\r\n                this._immediateIds = {};\r\n            }\r\n            let setImmediateCallback = () => {\r\n                try {\r\n                    if (this._immediateIds) {\r\n                        delete this._immediateIds[immediateId];\r\n                    }\r\n                    callback.apply(this._parent);\r\n                }\r\n                catch (e) {\r\n                    this._logError(e);\r\n                }\r\n            };\r\n            immediateId = window.setImmediate ? window.setImmediate(setImmediateCallback) : window.setTimeout(setImmediateCallback, 0);\r\n            this._immediateIds[immediateId] = true;\r\n        }\r\n        return immediateId;\r\n    }\r\n    clearImmediate(id) {\r\n        if (this._immediateIds && this._immediateIds[id]) {\r\n            window.clearImmediate ? window.clearImmediate(id) : window.clearTimeout(id);\r\n            delete this._immediateIds[id];\r\n        }\r\n    }\r\n    setInterval(callback, duration) {\r\n        let intervalId = 0;\r\n        if (!this._isDisposed) {\r\n            if (!this._intervalIds) {\r\n                this._intervalIds = {};\r\n            }\r\n            intervalId = setInterval(() => {\r\n                try {\r\n                    callback.apply(this._parent);\r\n                }\r\n                catch (e) {\r\n                    this._logError(e);\r\n                }\r\n            }, duration);\r\n            this._intervalIds[intervalId] = true;\r\n        }\r\n        return intervalId;\r\n    }\r\n    clearInterval(id) {\r\n        if (this._intervalIds && this._intervalIds[id]) {\r\n            clearInterval(id);\r\n            delete this._intervalIds[id];\r\n        }\r\n    }\r\n    throttle(func, wait, options) {\r\n        if (this._isDisposed) {\r\n            return this._noop;\r\n        }\r\n        let waitMS = wait || 0;\r\n        let leading = true;\r\n        let trailing = true;\r\n        let lastExecuteTime = 0;\r\n        let lastResult;\r\n        let lastArgs;\r\n        let timeoutId = null;\r\n        if (options && typeof options.leading === 'boolean') {\r\n            leading = options.leading;\r\n        }\r\n        if (options && typeof options.trailing === 'boolean') {\r\n            trailing = options.trailing;\r\n        }\r\n        let callback = (userCall) => {\r\n            let now = new Date().getTime();\r\n            let delta = now - lastExecuteTime;\r\n            let waitLength = leading ? waitMS - delta : waitMS;\r\n            if (delta >= waitMS && (!userCall || leading)) {\r\n                lastExecuteTime = now;\r\n                if (timeoutId) {\r\n                    this.clearTimeout(timeoutId);\r\n                    timeoutId = null;\r\n                }\r\n                lastResult = func.apply(this._parent, lastArgs);\r\n            }\r\n            else if (timeoutId === null && trailing) {\r\n                timeoutId = this.setTimeout(callback, waitLength);\r\n            }\r\n            return lastResult;\r\n        };\r\n        let resultFunction = (...args) => {\r\n            lastArgs = args;\r\n            return callback(true);\r\n        };\r\n        return resultFunction;\r\n    }\r\n    debounce(func, wait, options) {\r\n        if (this._isDisposed) {\r\n            let noOpFunction = (() => {\r\n            });\r\n            noOpFunction.cancel = () => {\r\n                return;\r\n            };\r\n            noOpFunction.flush = (() => null);\r\n            noOpFunction.pending = () => false;\r\n            return noOpFunction;\r\n        }\r\n        let waitMS = wait || 0;\r\n        let leading = false;\r\n        let trailing = true;\r\n        let maxWait = null;\r\n        let lastCallTime = 0;\r\n        let lastExecuteTime = new Date().getTime();\r\n        let lastResult;\r\n        let lastArgs;\r\n        let timeoutId = null;\r\n        if (options && typeof options.leading === 'boolean') {\r\n            leading = options.leading;\r\n        }\r\n        if (options && typeof options.trailing === 'boolean') {\r\n            trailing = options.trailing;\r\n        }\r\n        if (options && typeof options.maxWait === 'number' && !isNaN(options.maxWait)) {\r\n            maxWait = options.maxWait;\r\n        }\r\n        let markExecuted = (time) => {\r\n            if (timeoutId) {\r\n                this.clearTimeout(timeoutId);\r\n                timeoutId = null;\r\n            }\r\n            lastExecuteTime = time;\r\n        };\r\n        let invokeFunction = (time) => {\r\n            markExecuted(time);\r\n            lastResult = func.apply(this._parent, lastArgs);\r\n        };\r\n        let callback = (userCall) => {\r\n            let now = new Date().getTime();\r\n            let executeImmediately = false;\r\n            if (userCall) {\r\n                if (leading && now - lastCallTime >= waitMS) {\r\n                    executeImmediately = true;\r\n                }\r\n                lastCallTime = now;\r\n            }\r\n            let delta = now - lastCallTime;\r\n            let waitLength = waitMS - delta;\r\n            let maxWaitDelta = now - lastExecuteTime;\r\n            let maxWaitExpired = false;\r\n            if (maxWait !== null) {\r\n                if (maxWaitDelta >= maxWait && timeoutId) {\r\n                    maxWaitExpired = true;\r\n                }\r\n                else {\r\n                    waitLength = Math.min(waitLength, maxWait - maxWaitDelta);\r\n                }\r\n            }\r\n            if (delta >= waitMS || maxWaitExpired || executeImmediately) {\r\n                invokeFunction(now);\r\n            }\r\n            else if ((timeoutId === null || !userCall) && trailing) {\r\n                timeoutId = this.setTimeout(callback, waitLength);\r\n            }\r\n            return lastResult;\r\n        };\r\n        let pending = () => {\r\n            return !!timeoutId;\r\n        };\r\n        let cancel = () => {\r\n            if (pending()) {\r\n                markExecuted(new Date().getTime());\r\n            }\r\n        };\r\n        let flush = () => {\r\n            if (pending()) {\r\n                invokeFunction(new Date().getTime());\r\n            }\r\n            return lastResult;\r\n        };\r\n        let resultFunction = ((...args) => {\r\n            lastArgs = args;\r\n            return callback(true);\r\n        });\r\n        resultFunction.cancel = cancel;\r\n        resultFunction.flush = flush;\r\n        resultFunction.pending = pending;\r\n        return resultFunction;\r\n    }\r\n    requestAnimationFrame(callback) {\r\n        let animationFrameId = 0;\r\n        if (!this._isDisposed) {\r\n            if (!this._animationFrameIds) {\r\n                this._animationFrameIds = {};\r\n            }\r\n            let animationFrameCallback = () => {\r\n                try {\r\n                    if (this._animationFrameIds) {\r\n                        delete this._animationFrameIds[animationFrameId];\r\n                    }\r\n                    callback.apply(this._parent);\r\n                }\r\n                catch (e) {\r\n                    this._logError(e);\r\n                }\r\n            };\r\n            animationFrameId = window.requestAnimationFrame\r\n                ? window.requestAnimationFrame(animationFrameCallback)\r\n                : window.setTimeout(animationFrameCallback, 0);\r\n            this._animationFrameIds[animationFrameId] = true;\r\n        }\r\n        return animationFrameId;\r\n    }\r\n    cancelAnimationFrame(id) {\r\n        if (this._animationFrameIds && this._animationFrameIds[id]) {\r\n            window.cancelAnimationFrame ? window.cancelAnimationFrame(id) : window.clearTimeout(id);\r\n            delete this._animationFrameIds[id];\r\n        }\r\n    }\r\n    _logError(e) {\r\n        if (this._onErrorHandler) {\r\n            this._onErrorHandler(e);\r\n        }\r\n    }\r\n}\r\n"}
