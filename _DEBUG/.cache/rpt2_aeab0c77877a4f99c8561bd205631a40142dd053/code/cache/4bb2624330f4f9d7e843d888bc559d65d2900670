{"code":"import { Stylesheet } from './Stylesheet';\r\nimport { kebabRules } from './transforms/kebabRules';\r\nimport { prefixRules } from './transforms/prefixRules';\r\nimport { provideUnits } from './transforms/provideUnits';\r\nimport { rtlifyRules } from './transforms/rtlifyRules';\r\nconst DISPLAY_NAME = 'displayName';\r\nfunction getDisplayName(rules) {\r\n    const rootStyle = rules && rules['&'];\r\n    return rootStyle ? rootStyle.displayName : undefined;\r\n}\r\nfunction expandSelector(newSelector, currentSelector) {\r\n    if (newSelector.indexOf(':global(') === 0) {\r\n        return newSelector.replace(/:global\\(|\\)$/g, '');\r\n    }\r\n    else if (newSelector.indexOf(':') === 0) {\r\n        return currentSelector + newSelector;\r\n    }\r\n    else if (newSelector.indexOf('&') < 0) {\r\n        return currentSelector + ' ' + newSelector;\r\n    }\r\n    return newSelector;\r\n}\r\nfunction extractRules(args, rules = { __order: [] }, currentSelector = '&') {\r\n    const stylesheet = Stylesheet.getInstance();\r\n    let currentRules = rules[currentSelector];\r\n    if (!currentRules) {\r\n        currentRules = {};\r\n        rules[currentSelector] = currentRules;\r\n        rules.__order.push(currentSelector);\r\n    }\r\n    for (const arg of args) {\r\n        if (typeof arg === 'string') {\r\n            const expandedRules = stylesheet.argsFromClassName(arg);\r\n            if (expandedRules) {\r\n                extractRules(expandedRules, rules, currentSelector);\r\n            }\r\n        }\r\n        else if (Array.isArray(arg)) {\r\n            extractRules(arg, rules, currentSelector);\r\n        }\r\n        else {\r\n            for (const prop in arg) {\r\n                if (prop === 'selectors') {\r\n                    const selectors = arg.selectors;\r\n                    for (let newSelector in selectors) {\r\n                        if (selectors.hasOwnProperty(newSelector)) {\r\n                            const selectorValue = selectors[newSelector];\r\n                            if (newSelector.indexOf('@') === 0) {\r\n                                newSelector = newSelector + '{' + currentSelector;\r\n                                extractRules([selectorValue], rules, newSelector);\r\n                            }\r\n                            else if (newSelector.indexOf(',') > -1) {\r\n                                const commaSeparatedSelectors = newSelector.split(/,/g).map((s) => s.trim());\r\n                                extractRules([selectorValue], rules, commaSeparatedSelectors\r\n                                    .map((commaSeparatedSelector) => expandSelector(commaSeparatedSelector, currentSelector))\r\n                                    .join(', '));\r\n                            }\r\n                            else {\r\n                                extractRules([selectorValue], rules, expandSelector(newSelector, currentSelector));\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    if (arg[prop] !== undefined) {\r\n                        if (prop === 'margin' || prop === 'padding') {\r\n                            expandQuads(currentRules, prop, arg[prop]);\r\n                        }\r\n                        else {\r\n                            currentRules[prop] = arg[prop];\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return rules;\r\n}\r\nfunction expandQuads(currentRules, name, value) {\r\n    const parts = typeof value === 'string' ? value.split(' ') : [value];\r\n    currentRules[name + 'Top'] = parts[0];\r\n    currentRules[name + 'Right'] = parts[1] || parts[0];\r\n    currentRules[name + 'Bottom'] = parts[2] || parts[0];\r\n    currentRules[name + 'Left'] = parts[3] || parts[1] || parts[0];\r\n}\r\nfunction getKeyForRules(rules) {\r\n    const serialized = [];\r\n    let hasProps = false;\r\n    for (const selector of rules.__order) {\r\n        serialized.push(selector);\r\n        const rulesForSelector = rules[selector];\r\n        for (const propName in rulesForSelector) {\r\n            if (rulesForSelector.hasOwnProperty(propName) && rulesForSelector[propName] !== undefined) {\r\n                hasProps = true;\r\n                serialized.push(propName, rulesForSelector[propName]);\r\n            }\r\n        }\r\n    }\r\n    return hasProps ? serialized.join('') : undefined;\r\n}\r\nexport function serializeRuleEntries(ruleEntries) {\r\n    if (!ruleEntries) {\r\n        return '';\r\n    }\r\n    const allEntries = [];\r\n    for (const entry in ruleEntries) {\r\n        if (ruleEntries.hasOwnProperty(entry) && entry !== DISPLAY_NAME && ruleEntries[entry] !== undefined) {\r\n            allEntries.push(entry, ruleEntries[entry]);\r\n        }\r\n    }\r\n    for (let i = 0; i < allEntries.length; i += 2) {\r\n        kebabRules(allEntries, i);\r\n        provideUnits(allEntries, i);\r\n        rtlifyRules(allEntries, i);\r\n        prefixRules(allEntries, i);\r\n    }\r\n    for (let i = 1; i < allEntries.length; i += 4) {\r\n        allEntries.splice(i, 1, ':', allEntries[i], ';');\r\n    }\r\n    return allEntries.join('');\r\n}\r\nexport function styleToRegistration(...args) {\r\n    const rules = extractRules(args);\r\n    const key = getKeyForRules(rules);\r\n    if (key) {\r\n        const stylesheet = Stylesheet.getInstance();\r\n        const registration = {\r\n            className: stylesheet.classNameFromKey(key),\r\n            key,\r\n            args\r\n        };\r\n        if (!registration.className) {\r\n            registration.className = stylesheet.getClassName(getDisplayName(rules));\r\n            const rulesToInsert = [];\r\n            for (const selector of rules.__order) {\r\n                rulesToInsert.push(selector, serializeRuleEntries(rules[selector]));\r\n            }\r\n            registration.rulesToInsert = rulesToInsert;\r\n        }\r\n        return registration;\r\n    }\r\n}\r\nexport function applyRegistration(registration, classMap) {\r\n    const stylesheet = Stylesheet.getInstance();\r\n    const { className, key, args, rulesToInsert } = registration;\r\n    if (rulesToInsert) {\r\n        for (let i = 0; i < rulesToInsert.length; i += 2) {\r\n            const rules = rulesToInsert[i + 1];\r\n            if (rules) {\r\n                let selector = rulesToInsert[i];\r\n                selector = selector.replace(/(&)|\\$([\\w-]+)\\b/g, (match, amp, cn) => {\r\n                    if (amp) {\r\n                        return '.' + registration.className;\r\n                    }\r\n                    else if (cn) {\r\n                        return '.' + ((classMap && classMap[cn]) || cn);\r\n                    }\r\n                    return '';\r\n                });\r\n                const processedRule = `${selector}{${rules}}${selector.indexOf('@') === 0 ? '}' : ''}`;\r\n                stylesheet.insertRule(processedRule);\r\n            }\r\n        }\r\n        stylesheet.cacheClassName(className, key, args, rulesToInsert);\r\n    }\r\n}\r\nexport function styleToClassName(...args) {\r\n    const registration = styleToRegistration(...args);\r\n    if (registration) {\r\n        applyRegistration(registration);\r\n        return registration.className;\r\n    }\r\n    return '';\r\n}\r\n"}
