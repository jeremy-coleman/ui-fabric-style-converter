import { Component, Children, createContext, createElement, forwardRef, createRef, Fragment } from 'react';
import { __decorate } from 'tslib';
import { createPortal, findDOMNode } from 'react-dom';
import { bool, object } from 'prop-types';

// A packages cache that makes sure that we don't inject the same packageName twice in the same bundle -
// this cache is local to the module closure inside this bundle
const packagesCache = {};
function setVersion(packageName, packageVersion) {
    if (typeof window !== 'undefined') {
        // tslint:disable-next-line:no-any
        const packages = (window.__packages__ = window.__packages__ || {});
        // We allow either the global packages or local packages caches to invalidate so testing can just clear the global to set this state
        if (!packages[packageName] || !packagesCache[packageName]) {
            packagesCache[packageName] = packageVersion;
            const versions = (packages[packageName] = packages[packageName] || []);
            versions.push(packageVersion);
        }
    }
}

setVersion('@uifabric/set-version', '6.0.0');

// office-ui-fabric-react@6.123.0
setVersion('office-ui-fabric-react', '6.123.0');

/**
 * Bugs often appear in async code when stuff gets disposed, but async operations don't get canceled.
 * This Async helper class solves these issues by tying async code to the lifetime of a disposable object.
 *
 * Usage: Anything class extending from BaseModel can access this helper via this.async. Otherwise create a
 * new instance of the class and remember to call dispose() during your code's dispose handler.
 *
 * @public
 */
class Async {
    // tslint:disable-next-line:no-any
    constructor(parent, onError) {
        this._timeoutIds = null;
        this._immediateIds = null;
        this._intervalIds = null;
        this._animationFrameIds = null;
        this._isDisposed = false;
        this._parent = parent || null;
        this._onErrorHandler = onError;
        this._noop = () => {
            /* do nothing */
        };
    }
    /**
     * Dispose function, clears all async operations.
     */
    dispose() {
        let id;
        this._isDisposed = true;
        this._parent = null;
        // Clear timeouts.
        if (this._timeoutIds) {
            for (id in this._timeoutIds) {
                if (this._timeoutIds.hasOwnProperty(id)) {
                    this.clearTimeout(parseInt(id, 10));
                }
            }
            this._timeoutIds = null;
        }
        // Clear immediates.
        if (this._immediateIds) {
            for (id in this._immediateIds) {
                if (this._immediateIds.hasOwnProperty(id)) {
                    this.clearImmediate(parseInt(id, 10));
                }
            }
            this._immediateIds = null;
        }
        // Clear intervals.
        if (this._intervalIds) {
            for (id in this._intervalIds) {
                if (this._intervalIds.hasOwnProperty(id)) {
                    this.clearInterval(parseInt(id, 10));
                }
            }
            this._intervalIds = null;
        }
        // Clear animation frames.
        if (this._animationFrameIds) {
            for (id in this._animationFrameIds) {
                if (this._animationFrameIds.hasOwnProperty(id)) {
                    this.cancelAnimationFrame(parseInt(id, 10));
                }
            }
            this._animationFrameIds = null;
        }
    }
    /**
     * SetTimeout override, which will auto cancel the timeout during dispose.
     * @param callback - Callback to execute.
     * @param duration - Duration in milliseconds.
     * @returns The setTimeout id.
     */
    setTimeout(callback, duration) {
        let timeoutId = 0;
        if (!this._isDisposed) {
            if (!this._timeoutIds) {
                this._timeoutIds = {};
            }
            /* tslint:disable:ban-native-functions */
            timeoutId = setTimeout(() => {
                // Time to execute the timeout, enqueue it as a foreground task to be executed.
                try {
                    // Now delete the record and call the callback.
                    if (this._timeoutIds) {
                        delete this._timeoutIds[timeoutId];
                    }
                    callback.apply(this._parent);
                }
                catch (e) {
                    if (this._onErrorHandler) {
                        this._onErrorHandler(e);
                    }
                }
            }, duration);
            /* tslint:enable:ban-native-functions */
            this._timeoutIds[timeoutId] = true;
        }
        return timeoutId;
    }
    /**
     * Clears the timeout.
     * @param id - Id to cancel.
     */
    clearTimeout(id) {
        if (this._timeoutIds && this._timeoutIds[id]) {
            /* tslint:disable:ban-native-functions */
            clearTimeout(id);
            delete this._timeoutIds[id];
            /* tslint:enable:ban-native-functions */
        }
    }
    /**
     * SetImmediate override, which will auto cancel the immediate during dispose.
     * @param callback - Callback to execute.
     * @returns The setTimeout id.
     */
    setImmediate(callback) {
        let immediateId = 0;
        if (!this._isDisposed) {
            if (!this._immediateIds) {
                this._immediateIds = {};
            }
            /* tslint:disable:ban-native-functions */
            let setImmediateCallback = () => {
                // Time to execute the timeout, enqueue it as a foreground task to be executed.
                try {
                    // Now delete the record and call the callback.
                    if (this._immediateIds) {
                        delete this._immediateIds[immediateId];
                    }
                    callback.apply(this._parent);
                }
                catch (e) {
                    this._logError(e);
                }
            };
            //@ts-ignore
            immediateId = window.setImmediate ? window.setImmediate(setImmediateCallback) : window.setTimeout(setImmediateCallback, 0);
            /* tslint:enable:ban-native-functions */
            this._immediateIds[immediateId] = true;
        }
        return immediateId;
    }
    /**
     * Clears the immediate.
     * @param id - Id to cancel.
     */
    clearImmediate(id) {
        if (this._immediateIds && this._immediateIds[id]) {
            /* tslint:disable:ban-native-functions */
            //@ts-ignore
            window.clearImmediate ? window.clearImmediate(id) : window.clearTimeout(id);
            delete this._immediateIds[id];
            /* tslint:enable:ban-native-functions */
        }
    }
    /**
     * SetInterval override, which will auto cancel the timeout during dispose.
     * @param callback - Callback to execute.
     * @param duration - Duration in milliseconds.
     * @returns The setTimeout id.
     */
    setInterval(callback, duration) {
        let intervalId = 0;
        if (!this._isDisposed) {
            if (!this._intervalIds) {
                this._intervalIds = {};
            }
            /* tslint:disable:ban-native-functions */
            intervalId = setInterval(() => {
                // Time to execute the interval callback, enqueue it as a foreground task to be executed.
                try {
                    callback.apply(this._parent);
                }
                catch (e) {
                    this._logError(e);
                }
            }, duration);
            /* tslint:enable:ban-native-functions */
            this._intervalIds[intervalId] = true;
        }
        return intervalId;
    }
    /**
     * Clears the interval.
     * @param id - Id to cancel.
     */
    clearInterval(id) {
        if (this._intervalIds && this._intervalIds[id]) {
            /* tslint:disable:ban-native-functions */
            clearInterval(id);
            delete this._intervalIds[id];
            /* tslint:enable:ban-native-functions */
        }
    }
    /**
     * Creates a function that, when executed, will only call the func function at most once per
     * every wait milliseconds. Provide an options object to indicate that func should be invoked
     * on the leading and/or trailing edge of the wait timeout. Subsequent calls to the throttled
     * function will return the result of the last func call.
     *
     * Note: If leading and trailing options are true func will be called on the trailing edge of
     * the timeout only if the the throttled function is invoked more than once during the wait timeout.
     *
     * @param func - The function to throttle.
     * @param wait - The number of milliseconds to throttle executions to. Defaults to 0.
     * @param options - The options object.
     * @returns The new throttled function.
     */
    throttle(func, wait, options) {
        if (this._isDisposed) {
            return this._noop;
        }
        let waitMS = wait || 0;
        let leading = true;
        let trailing = true;
        let lastExecuteTime = 0;
        let lastResult;
        // tslint:disable-next-line:no-any
        let lastArgs;
        let timeoutId = null;
        if (options && typeof options.leading === 'boolean') {
            leading = options.leading;
        }
        if (options && typeof options.trailing === 'boolean') {
            trailing = options.trailing;
        }
        let callback = (userCall) => {
            let now = new Date().getTime();
            let delta = now - lastExecuteTime;
            let waitLength = leading ? waitMS - delta : waitMS;
            if (delta >= waitMS && (!userCall || leading)) {
                lastExecuteTime = now;
                if (timeoutId) {
                    this.clearTimeout(timeoutId);
                    timeoutId = null;
                }
                lastResult = func.apply(this._parent, lastArgs);
            }
            else if (timeoutId === null && trailing) {
                timeoutId = this.setTimeout(callback, waitLength);
            }
            return lastResult;
        };
        // tslint:disable-next-line:no-any
        let resultFunction = (...args) => {
            lastArgs = args;
            return callback(true);
        };
        return resultFunction;
    }
    /**
     * Creates a function that will delay the execution of func until after wait milliseconds have
     * elapsed since the last time it was invoked. Provide an options object to indicate that func
     * should be invoked on the leading and/or trailing edge of the wait timeout. Subsequent calls
     * to the debounced function will return the result of the last func call.
     *
     * Note: If leading and trailing options are true func will be called on the trailing edge of
     * the timeout only if the the debounced function is invoked more than once during the wait
     * timeout.
     *
     * @param func - The function to debounce.
     * @param wait - The number of milliseconds to delay.
     * @param options - The options object.
     * @returns The new debounced function.
     */
    debounce(func, wait, options) {
        if (this._isDisposed) {
            let noOpFunction = (() => {
                /** Do nothing */
            });
            noOpFunction.cancel = () => {
                return;
            };
            /* tslint:disable:no-any */
            noOpFunction.flush = (() => null);
            /* tslint:enable:no-any */
            noOpFunction.pending = () => false;
            return noOpFunction;
        }
        let waitMS = wait || 0;
        let leading = false;
        let trailing = true;
        let maxWait = null;
        let lastCallTime = 0;
        let lastExecuteTime = new Date().getTime();
        let lastResult;
        // tslint:disable-next-line:no-any
        let lastArgs;
        let timeoutId = null;
        if (options && typeof options.leading === 'boolean') {
            leading = options.leading;
        }
        if (options && typeof options.trailing === 'boolean') {
            trailing = options.trailing;
        }
        if (options && typeof options.maxWait === 'number' && !isNaN(options.maxWait)) {
            maxWait = options.maxWait;
        }
        let markExecuted = (time) => {
            if (timeoutId) {
                this.clearTimeout(timeoutId);
                timeoutId = null;
            }
            lastExecuteTime = time;
        };
        let invokeFunction = (time) => {
            markExecuted(time);
            lastResult = func.apply(this._parent, lastArgs);
        };
        let callback = (userCall) => {
            let now = new Date().getTime();
            let executeImmediately = false;
            if (userCall) {
                if (leading && now - lastCallTime >= waitMS) {
                    executeImmediately = true;
                }
                lastCallTime = now;
            }
            let delta = now - lastCallTime;
            let waitLength = waitMS - delta;
            let maxWaitDelta = now - lastExecuteTime;
            let maxWaitExpired = false;
            if (maxWait !== null) {
                // maxWait only matters when there is a pending callback
                if (maxWaitDelta >= maxWait && timeoutId) {
                    maxWaitExpired = true;
                }
                else {
                    waitLength = Math.min(waitLength, maxWait - maxWaitDelta);
                }
            }
            if (delta >= waitMS || maxWaitExpired || executeImmediately) {
                invokeFunction(now);
            }
            else if ((timeoutId === null || !userCall) && trailing) {
                timeoutId = this.setTimeout(callback, waitLength);
            }
            return lastResult;
        };
        let pending = () => {
            return !!timeoutId;
        };
        let cancel = () => {
            if (pending()) {
                // Mark the debounced function as having executed
                markExecuted(new Date().getTime());
            }
        };
        let flush = () => {
            if (pending()) {
                invokeFunction(new Date().getTime());
            }
            return lastResult;
        };
        // tslint:disable-next-line:no-any
        let resultFunction = ((...args) => {
            lastArgs = args;
            return callback(true);
        });
        resultFunction.cancel = cancel;
        resultFunction.flush = flush;
        resultFunction.pending = pending;
        return resultFunction;
    }
    requestAnimationFrame(callback) {
        let animationFrameId = 0;
        if (!this._isDisposed) {
            if (!this._animationFrameIds) {
                this._animationFrameIds = {};
            }
            /* tslint:disable:ban-native-functions */
            let animationFrameCallback = () => {
                try {
                    // Now delete the record and call the callback.
                    if (this._animationFrameIds) {
                        delete this._animationFrameIds[animationFrameId];
                    }
                    callback.apply(this._parent);
                }
                catch (e) {
                    this._logError(e);
                }
            };
            animationFrameId = window.requestAnimationFrame
                ? window.requestAnimationFrame(animationFrameCallback)
                : window.setTimeout(animationFrameCallback, 0);
            /* tslint:enable:ban-native-functions */
            this._animationFrameIds[animationFrameId] = true;
        }
        return animationFrameId;
    }
    cancelAnimationFrame(id) {
        if (this._animationFrameIds && this._animationFrameIds[id]) {
            /* tslint:disable:ban-native-functions */
            window.cancelAnimationFrame ? window.cancelAnimationFrame(id) : window.clearTimeout(id);
            /* tslint:enable:ban-native-functions */
            delete this._animationFrameIds[id];
        }
    }
    // tslint:disable-next-line:no-any
    _logError(e) {
        if (this._onErrorHandler) {
            this._onErrorHandler(e);
        }
    }
}

/**
 * Combine a set of styles together (but does not register css classes).
 * @param styleSets - One or more stylesets to be merged (each param can also be falsy).
 */
function concatStyleSets(...styleSets) {
    const mergedSet = {};
    // We process sub component styles in two phases. First we collect them, then we combine them into 1 style function.
    const workingSubcomponentStyles = {};
    for (const currentSet of styleSets) {
        if (currentSet) {
            for (const prop in currentSet) {
                if (currentSet.hasOwnProperty(prop)) {
                    if (prop === 'subComponentStyles' && currentSet.subComponentStyles !== undefined) {
                        // subcomponent styles - style functions or objects
                        const currentComponentStyles = currentSet.subComponentStyles;
                        for (const subCompProp in currentComponentStyles) {
                            if (currentComponentStyles.hasOwnProperty(subCompProp)) {
                                if (workingSubcomponentStyles.hasOwnProperty(subCompProp)) {
                                    workingSubcomponentStyles[subCompProp].push(currentComponentStyles[subCompProp]);
                                }
                                else {
                                    workingSubcomponentStyles[subCompProp] = [currentComponentStyles[subCompProp]];
                                }
                            }
                        }
                        continue;
                    }
                    // the as any casts below is a workaround for ts 2.8.
                    // todo: remove cast to any in ts 2.9.
                    const mergedValue = mergedSet[prop];
                    const currentValue = currentSet[prop];
                    if (mergedValue === undefined) {
                        mergedSet[prop] = currentValue;
                    }
                    else {
                        mergedSet[prop] = [
                            // https://github.com/Microsoft/TypeScript/issues/25474
                            ...(Array.isArray(mergedValue) ? mergedValue : [mergedValue]),
                            ...(Array.isArray(currentValue) ? currentValue : [currentValue])
                        ];
                    }
                }
            }
        }
    }
    let isFunction = (v) => v === typeof 'function';
    if (Object.keys(workingSubcomponentStyles).length > 0) {
        mergedSet.subComponentStyles = {};
        const mergedSubStyles = mergedSet.subComponentStyles;
        // now we process the subcomponent styles if there are any
        for (const subCompProp in workingSubcomponentStyles) {
            if (workingSubcomponentStyles.hasOwnProperty(subCompProp)) {
                const workingSet = workingSubcomponentStyles[subCompProp];
                mergedSubStyles[subCompProp] = (styleProps) => {
                    return concatStyleSets(...workingSet.map((_S) => isFunction(_S) ? _S(styleProps) : _S));
                };
            }
        }
    }
    return mergedSet;
}

const InjectionMode = {
    /**
     * Avoids style injection, use getRules() to read the styles.
     */
    none: 0,
    /**
     * Inserts rules using the insertRule api.
     */
    insertNode: 1,
    /**
     * Appends rules using appendChild.
     */
    appendChild: 2
};
const STYLESHEET_SETTING = '__stylesheet__';
// tslint:disable-next-line:no-any
const _fileScopedGlobal = {};
let _stylesheet;
/**
 * Represents the state of styles registered in the page. Abstracts
 * the surface for adding styles to the stylesheet, exposes helpers
 * for reading the styles registered in server rendered scenarios.
 *
 * @public
 */
class Stylesheet {
    constructor(config) {
        this._rules = [];
        this._preservedRules = [];
        this._rulesToInsert = [];
        this._counter = 0;
        this._keyToClassName = {};
        this._onResetCallbacks = [];
        // tslint:disable-next-line:no-any
        this._classNameToArgs = {};
        this._config = {
            injectionMode: InjectionMode.insertNode,
            defaultPrefix: 'css',
            namespace: undefined,
            ...config
        };
    }
    /**
     * Gets the singleton instance.
     */
    static getInstance() {
        // tslint:disable-next-line:no-any
        const global = typeof window !== 'undefined' ? window : typeof process !== 'undefined' ? process : _fileScopedGlobal;
        _stylesheet = global[STYLESHEET_SETTING];
        if (!_stylesheet || (_stylesheet._lastStyleElement && _stylesheet._lastStyleElement.ownerDocument !== document)) {
            // tslint:disable-next-line:no-string-literal
            const fabricConfig = (global && global['FabricConfig']) || {};
            _stylesheet = global[STYLESHEET_SETTING] = new Stylesheet(fabricConfig.mergeStyles);
        }
        return _stylesheet;
    }
    /**
     * Configures the stylesheet.
     */
    setConfig(config) {
        this._config = {
            ...this._config,
            ...config
        };
    }
    /**
     * Configures a reset callback.
     *
     * @param callback - A callback which will be called when the Stylesheet is reset.
     */
    onReset(callback) {
        this._onResetCallbacks.push(callback);
    }
    /**
     * Generates a unique classname.
     *
     * @param displayName - Optional value to use as a prefix.
     */
    getClassName(displayName) {
        const { namespace } = this._config;
        const prefix = displayName || this._config.defaultPrefix;
        return `${namespace ? namespace + '-' : ''}${prefix}-${this._counter++}`;
    }
    /**
     * Used internally to cache information about a class which was
     * registered with the stylesheet.
     */
    cacheClassName(className, key, args, rules) {
        this._keyToClassName[key] = className;
        this._classNameToArgs[className] = {
            args,
            rules
        };
    }
    /**
     * Gets the appropriate classname given a key which was previously
     * registered using cacheClassName.
     */
    classNameFromKey(key) {
        return this._keyToClassName[key];
    }
    /**
     * Gets the arguments associated with a given classname which was
     * previously registered using cacheClassName.
     */
    argsFromClassName(className) {
        const entry = this._classNameToArgs[className];
        return entry && entry.args;
    }
    /**
     * Gets the arguments associated with a given classname which was
     * previously registered using cacheClassName.
     */
    insertedRulesFromClassName(className) {
        const entry = this._classNameToArgs[className];
        return entry && entry.rules;
    }
    /**
     * Inserts a css rule into the stylesheet.
     * @param preserve - Preserves the rule beyond a reset boundary.
     */
    insertRule(rule, preserve) {
        const { injectionMode } = this._config;
        const element = injectionMode !== InjectionMode.none ? this._getStyleElement() : undefined;
        if (preserve) {
            this._preservedRules.push(rule);
        }
        if (element) {
            switch (this._config.injectionMode) {
                case InjectionMode.insertNode:
                    const { sheet } = element;
                    try {
                        sheet.insertRule(rule, sheet.cssRules.length);
                    }
                    catch (e) {
                        // The browser will throw exceptions on unsupported rules (such as a moz prefix in webkit.)
                        // We need to swallow the exceptions for this scenario, otherwise we'd need to filter
                        // which could be slower and bulkier.
                    }
                    break;
                case InjectionMode.appendChild:
                    element.appendChild(document.createTextNode(rule));
                    break;
            }
        }
        else {
            this._rules.push(rule);
        }
        if (this._config.onInsertRule) {
            this._config.onInsertRule(rule);
        }
    }
    /**
     * Gets all rules registered with the stylesheet; only valid when
     * using InsertionMode.none.
     */
    getRules(includePreservedRules) {
        return (includePreservedRules ? this._preservedRules.join('') : '') + this._rules.join('') + this._rulesToInsert.join('');
    }
    /**
     * Resets the internal state of the stylesheet. Only used in server
     * rendered scenarios where we're using InsertionMode.none.
     */
    reset() {
        this._rules = [];
        this._rulesToInsert = [];
        this._counter = 0;
        this._classNameToArgs = {};
        this._keyToClassName = {};
        this._onResetCallbacks.forEach((callback) => callback());
    }
    // Forces the regeneration of incoming styles without totally resetting the stylesheet.
    resetKeys() {
        this._keyToClassName = {};
    }
    _getStyleElement() {
        if (!this._styleElement && typeof document !== 'undefined') {
            this._styleElement = this._createStyleElement();
            // Reset the style element on the next frame.
            window.requestAnimationFrame(() => {
                this._styleElement = undefined;
            });
        }
        return this._styleElement;
    }
    _createStyleElement() {
        const styleElement = document.createElement('style');
        styleElement.setAttribute('data-merge-styles', 'true');
        styleElement.type = 'text/css';
        if (this._lastStyleElement && this._lastStyleElement.nextElementSibling) {
            document.head.insertBefore(styleElement, this._lastStyleElement.nextElementSibling);
        }
        else {
            document.head.appendChild(styleElement);
        }
        this._lastStyleElement = styleElement;
        return styleElement;
    }
}

/**
 * Separates the classes and style objects. Any classes that are pre-registered
 * args are auto expanded into objects.
 */
function extractStyleParts(...args) {
    const classes = [];
    const objects = [];
    const stylesheet = Stylesheet.getInstance();
    function _processArgs(argsList) {
        for (const arg of argsList) {
            if (arg) {
                if (typeof arg === 'string') {
                    if (arg.indexOf(' ') >= 0) {
                        _processArgs(arg.split(' '));
                    }
                    else {
                        const translatedArgs = stylesheet.argsFromClassName(arg);
                        if (translatedArgs) {
                            _processArgs(translatedArgs);
                        }
                        else {
                            // Avoid adding the same class twice.
                            if (classes.indexOf(arg) === -1) {
                                classes.push(arg);
                            }
                        }
                    }
                }
                else if (Array.isArray(arg)) {
                    _processArgs(arg);
                }
                else if (typeof arg === 'object') {
                    objects.push(arg);
                }
            }
        }
    }
    _processArgs(args);
    return {
        classes,
        objects
    };
}

function kebabRules(rulePairs, index) {
    rulePairs[index] = rulePairs[index].replace(/([A-Z])/g, '-$1').toLowerCase();
}

let _vendorSettings;
function getVendorSettings() {
    if (!_vendorSettings) {
        const doc = typeof document !== 'undefined' ? document : undefined;
        const nav = typeof navigator !== 'undefined' ? navigator : undefined;
        const userAgent = nav ? nav.userAgent.toLowerCase() : undefined;
        if (!doc) {
            _vendorSettings = {
                isWebkit: true,
                isMoz: true,
                isOpera: true,
                isMs: true
            };
        }
        else {
            _vendorSettings = {
                isWebkit: !!(doc && 'WebkitAppearance' in doc.documentElement.style),
                isMoz: !!(userAgent && userAgent.indexOf('firefox') > -1),
                isOpera: !!(userAgent && userAgent.indexOf('opera') > -1),
                isMs: !!(nav && (/rv:11.0/i.test(nav.userAgent) || /Edge\/\d./i.test(navigator.userAgent)))
            };
        }
    }
    return _vendorSettings;
}

const autoPrefixNames = {
    'user-select': 1
};
function prefixRules(rulePairs, index) {
    const vendorSettings = getVendorSettings();
    const name = rulePairs[index];
    if (autoPrefixNames[name]) {
        const value = rulePairs[index + 1];
        if (autoPrefixNames[name]) {
            if (vendorSettings.isWebkit) {
                rulePairs.push('-webkit-' + name, value);
            }
            if (vendorSettings.isMoz) {
                rulePairs.push('-moz-' + name, value);
            }
            if (vendorSettings.isMs) {
                rulePairs.push('-ms-' + name, value);
            }
            if (vendorSettings.isOpera) {
                rulePairs.push('-o-' + name, value);
            }
        }
    }
}

const NON_PIXEL_NUMBER_PROPS = [
    'column-count',
    'font-weight',
    'flex-basis',
    'flex',
    'flex-grow',
    'flex-shrink',
    'fill-opacity',
    'opacity',
    'order',
    'z-index',
    'zoom'
];
function provideUnits(rulePairs, index) {
    const name = rulePairs[index];
    const value = rulePairs[index + 1];
    if (typeof value === 'number') {
        const unit = NON_PIXEL_NUMBER_PROPS.indexOf(name) === -1 ? 'px' : '';
        rulePairs[index + 1] = `${value}${unit}`;
    }
}

const LEFT = 'left';
const RIGHT = 'right';
const NO_FLIP = '@noflip';
const NAME_REPLACEMENTS = {
    [LEFT]: RIGHT,
    [RIGHT]: LEFT
};
const VALUE_REPLACEMENTS = {
    'w-resize': 'e-resize',
    'sw-resize': 'se-resize',
    'nw-resize': 'ne-resize'
};
let _rtl = _msGetRTL();
/**
 * Sets the current RTL value.
 */
function _msSetRTL(isRTL) {
    if (_rtl !== isRTL) {
        Stylesheet.getInstance().resetKeys();
        _rtl = isRTL;
    }
}
/**
 * Gets the current RTL value.
 */
function _msGetRTL() {
    if (_rtl === undefined) {
        _rtl = typeof document !== 'undefined' && !!document.documentElement && document.documentElement.getAttribute('dir') === 'rtl';
    }
    return _rtl;
}
/**
 * RTLifies the rulePair in the array at the current index. This mutates the array for performance
 * reasons.
 */
function rtlifyRules(rulePairs, index) {
    if (_msGetRTL()) {
        const name = rulePairs[index];
        if (!name) {
            return;
        }
        const value = rulePairs[index + 1];
        if (typeof value === 'string' && value.indexOf(NO_FLIP) >= 0) {
            rulePairs[index + 1] = value.replace(/\s*(?:\/\*\s*)?\@noflip\b(?:\s*\*\/)?\s*?/g, '');
        }
        else if (name.indexOf(LEFT) >= 0) {
            rulePairs[index] = name.replace(LEFT, RIGHT);
        }
        else if (name.indexOf(RIGHT) >= 0) {
            rulePairs[index] = name.replace(RIGHT, LEFT);
        }
        else if (String(value).indexOf(LEFT) >= 0) {
            rulePairs[index + 1] = value.replace(LEFT, RIGHT);
        }
        else if (String(value).indexOf(RIGHT) >= 0) {
            rulePairs[index + 1] = value.replace(RIGHT, LEFT);
        }
        else if (NAME_REPLACEMENTS[name]) {
            rulePairs[index] = NAME_REPLACEMENTS[name];
        }
        else if (VALUE_REPLACEMENTS[value]) {
            rulePairs[index + 1] = VALUE_REPLACEMENTS[value];
        }
        else {
            switch (name) {
                case 'margin':
                case 'padding':
                    rulePairs[index + 1] = flipQuad(value);
                    break;
                case 'box-shadow':
                    rulePairs[index + 1] = negateNum(value, 0);
                    break;
            }
        }
    }
}
/**
 * Given a string value in a space delimited format (e.g. "1 2 3 4"), negates a particular value.
 */
function negateNum(value, partIndex) {
    const parts = value.split(' ');
    const numberVal = parseInt(parts[partIndex], 10);
    parts[0] = parts[0].replace(String(numberVal), String(numberVal * -1));
    return parts.join(' ');
}
/**
 * Given a string quad, flips the left and right values.
 */
function flipQuad(value) {
    if (typeof value === 'string') {
        const parts = value.split(' ');
        if (parts.length === 4) {
            return `${parts[0]} ${parts[3]} ${parts[2]} ${parts[1]}`;
        }
    }
    return value;
}

const DISPLAY_NAME = 'displayName';
function getDisplayName(rules) {
    const rootStyle = rules && rules['&'];
    return rootStyle ? rootStyle.displayName : undefined;
}
function expandSelector(newSelector, currentSelector) {
    if (newSelector.indexOf(':global(') === 0) {
        return newSelector.replace(/:global\(|\)$/g, '');
    }
    else if (newSelector.indexOf(':') === 0) {
        return currentSelector + newSelector;
    }
    else if (newSelector.indexOf('&') < 0) {
        return currentSelector + ' ' + newSelector;
    }
    return newSelector;
}
function extractRules(args, rules = { __order: [] }, currentSelector = '&') {
    const stylesheet = Stylesheet.getInstance();
    let currentRules = rules[currentSelector];
    if (!currentRules) {
        currentRules = {};
        rules[currentSelector] = currentRules;
        rules.__order.push(currentSelector);
    }
    for (const arg of args) {
        // If the arg is a string, we need to look up the class map and merge.
        if (typeof arg === 'string') {
            const expandedRules = stylesheet.argsFromClassName(arg);
            if (expandedRules) {
                extractRules(expandedRules, rules, currentSelector);
            }
            // Else if the arg is an array, we need to recurse in.
        }
        else if (Array.isArray(arg)) {
            extractRules(arg, rules, currentSelector);
        }
        else {
            // tslint:disable-next-line:no-any
            for (const prop in arg) {
                if (prop === 'selectors') {
                    // tslint:disable-next-line:no-any
                    const selectors = arg.selectors;
                    for (let newSelector in selectors) {
                        if (selectors.hasOwnProperty(newSelector)) {
                            const selectorValue = selectors[newSelector];
                            if (newSelector.indexOf('@') === 0) {
                                newSelector = newSelector + '{' + currentSelector;
                                extractRules([selectorValue], rules, newSelector);
                            }
                            else if (newSelector.indexOf(',') > -1) {
                                const commaSeparatedSelectors = newSelector.split(/,/g).map((s) => s.trim());
                                extractRules([selectorValue], rules, commaSeparatedSelectors
                                    .map((commaSeparatedSelector) => expandSelector(commaSeparatedSelector, currentSelector))
                                    .join(', '));
                            }
                            else {
                                extractRules([selectorValue], rules, expandSelector(newSelector, currentSelector));
                            }
                        }
                    }
                }
                else {
                    if (arg[prop] !== undefined) {
                        // Else, add the rule to the currentSelector.
                        if (prop === 'margin' || prop === 'padding') {
                            // tslint:disable-next-line:no-any
                            expandQuads(currentRules, prop, arg[prop]);
                        }
                        else {
                            // tslint:disable-next-line:no-any
                            currentRules[prop] = arg[prop];
                        }
                    }
                }
            }
        }
    }
    return rules;
}
function expandQuads(currentRules, name, value) {
    const parts = typeof value === 'string' ? value.split(' ') : [value];
    currentRules[name + 'Top'] = parts[0];
    currentRules[name + 'Right'] = parts[1] || parts[0];
    currentRules[name + 'Bottom'] = parts[2] || parts[0];
    currentRules[name + 'Left'] = parts[3] || parts[1] || parts[0];
}
function getKeyForRules(rules) {
    const serialized = [];
    let hasProps = false;
    for (const selector of rules.__order) {
        serialized.push(selector);
        const rulesForSelector = rules[selector];
        for (const propName in rulesForSelector) {
            if (rulesForSelector.hasOwnProperty(propName) && rulesForSelector[propName] !== undefined) {
                hasProps = true;
                serialized.push(propName, rulesForSelector[propName]);
            }
        }
    }
    return hasProps ? serialized.join('') : undefined;
}
function serializeRuleEntries(ruleEntries) {
    if (!ruleEntries) {
        return '';
    }
    const allEntries = [];
    for (const entry in ruleEntries) {
        if (ruleEntries.hasOwnProperty(entry) && entry !== DISPLAY_NAME && ruleEntries[entry] !== undefined) {
            allEntries.push(entry, ruleEntries[entry]);
        }
    }
    // Apply transforms.
    for (let i = 0; i < allEntries.length; i += 2) {
        kebabRules(allEntries, i);
        provideUnits(allEntries, i);
        rtlifyRules(allEntries, i);
        prefixRules(allEntries, i);
    }
    // Apply punctuation.
    for (let i = 1; i < allEntries.length; i += 4) {
        allEntries.splice(i, 1, ':', allEntries[i], ';');
    }
    return allEntries.join('');
}
function styleToRegistration(...args) {
    const rules = extractRules(args);
    const key = getKeyForRules(rules);
    if (key) {
        const stylesheet = Stylesheet.getInstance();
        const registration = {
            className: stylesheet.classNameFromKey(key),
            key,
            args
        };
        if (!registration.className) {
            registration.className = stylesheet.getClassName(getDisplayName(rules));
            const rulesToInsert = [];
            for (const selector of rules.__order) {
                rulesToInsert.push(selector, serializeRuleEntries(rules[selector]));
            }
            registration.rulesToInsert = rulesToInsert;
        }
        return registration;
    }
}
function applyRegistration(registration, classMap) {
    const stylesheet = Stylesheet.getInstance();
    const { className, key, args, rulesToInsert } = registration;
    if (rulesToInsert) {
        // rulesToInsert is an ordered array of selector/rule pairs.
        for (let i = 0; i < rulesToInsert.length; i += 2) {
            const rules = rulesToInsert[i + 1];
            if (rules) {
                let selector = rulesToInsert[i];
                // Fix selector using map.
                selector = selector.replace(/(&)|\$([\w-]+)\b/g, (match, amp, cn) => {
                    if (amp) {
                        return '.' + registration.className;
                    }
                    else if (cn) {
                        return '.' + ((classMap && classMap[cn]) || cn);
                    }
                    return '';
                });
                // Insert. Note if a media query, we must close the query with a final bracket.
                const processedRule = `${selector}{${rules}}${selector.indexOf('@') === 0 ? '}' : ''}`;
                stylesheet.insertRule(processedRule);
            }
        }
        stylesheet.cacheClassName(className, key, args, rulesToInsert);
    }
}
function styleToClassName(...args) {
    const registration = styleToRegistration(...args);
    if (registration) {
        applyRegistration(registration);
        return registration.className;
    }
    return '';
}

/**
 * Registers a font face.
 * @public
 */
function fontFace(font) {
    Stylesheet.getInstance().insertRule(`@font-face{${serializeRuleEntries(font)}}`, true);
}

/**
 * Registers keyframe definitions.
 *
 * @public
 */
function keyframes(timeline) {
    const stylesheet = Stylesheet.getInstance();
    const name = stylesheet.getClassName();
    const rulesArray = [];
    for (const prop in timeline) {
        if (timeline.hasOwnProperty(prop)) {
            rulesArray.push(prop, '{', serializeRuleEntries(timeline[prop]), '}');
        }
    }
    const rules = rulesArray.join('');
    stylesheet.insertRule(`@keyframes ${name}{${rules}}`, true);
    stylesheet.cacheClassName(name, rules, [], ['keyframes', rules]);
    return name;
}

/**
 * Concatination helper, which can merge class names together. Skips over falsey values.
 *
 * @public
 */
function mergeStyles(...args) {
    const { classes, objects } = extractStyleParts(args);
    if (objects.length) {
        classes.push(styleToClassName(objects));
    }
    return classes.join(' ');
}

/**
 * Takes in one or more style set objects, each consisting of a set of areas,
 * each which will produce a class name. Using this is analogous to calling
 * `mergeStyles` for each property in the object, but ensures we maintain the
 * set ordering when multiple style sets are merged.
 *
 * @param styleSets - One or more style sets to be merged.
 */
function mergeStyleSets(...styleSets) {
    // tslint:disable-next-line:no-any
    const classNameSet = { subComponentStyles: {} };
    const classMap = {};
    const styleSet = styleSets[0];
    if (!styleSet && styleSets.length <= 1) {
        return { subComponentStyles: {} };
    }
    let concatenatedStyleSet = 
    // we have guarded against falsey values just above.
    styleSet;
    concatenatedStyleSet = concatStyleSets(...styleSets);
    const registrations = [];
    for (const styleSetArea in concatenatedStyleSet) {
        if (concatenatedStyleSet.hasOwnProperty(styleSetArea)) {
            if (styleSetArea === 'subComponentStyles') {
                classNameSet.subComponentStyles = concatenatedStyleSet.subComponentStyles || {};
                continue;
            }
            const styles = concatenatedStyleSet[styleSetArea];
            const { classes, objects } = extractStyleParts(styles);
            const registration = styleToRegistration({ displayName: styleSetArea }, objects);
            registrations.push(registration);
            if (registration) {
                classMap[styleSetArea] = registration.className;
                // as any cast not needed in ts >=2.9
                classNameSet[styleSetArea] = classes.concat([registration.className]).join(' ');
            }
        }
    }
    for (const registration of registrations) {
        if (registration) {
            applyRegistration(registration, classMap);
        }
    }
    return classNameSet;
}

// @uifabric/merge-styles@6.15.0
setVersion('@uifabric/merge-styles', '6.15.0');

//export { IRawStyle, IStyle } from './IStyle';

// Initialize global window id.
const CURRENT_ID_PROPERTY = '__currentId__';
const DEFAULT_ID_STRING = 'id__';
// tslint:disable-next-line:no-any
let _global = (typeof window !== 'undefined' && window) || process;
if (_global[CURRENT_ID_PROPERTY] === undefined) {
    _global[CURRENT_ID_PROPERTY] = 0;
}
// tslint:disable-next-line:no-any
function checkProperties(a, b) {
    for (let propName in a) {
        if (a.hasOwnProperty(propName)) {
            if (!b.hasOwnProperty(propName) || b[propName] !== a[propName]) {
                return false;
            }
        }
    }
    return true;
}
/**
 * Compares a to b and b to a.
 *
 * @public
 */
function shallowCompare(a, b) {
    return checkProperties(a, b) && checkProperties(b, a);
}
/**
 * Makes a resulting merge of a bunch of objects. Pass in the target object followed by 1 or more
 * objects as arguments and they will be merged sequentially into the target. Note that this will
 * shallow merge; it will not create new cloned values for target members.
 *
 * @public
 * @param target - Target object to merge following object arguments into.
 * @param args - One or more objects that will be mixed into the target in the order they are provided.
 * @returns Resulting merged target.
 */
// tslint:disable-next-line:no-any
function assign(target, ...args) {
    return filteredAssign.apply(this, [null, target].concat(args));
}
/**
 * Makes a resulting merge of a bunch of objects, but allows a filter function to be passed in to filter
 * the resulting merges. This allows for scenarios where you want to merge "everything except that one thing"
 * or "properties that start with data-". Note that this will shallow merge; it will not create new cloned
 * values for target members.
 *
 * @public
 * @param isAllowed - Callback to determine if the given propName is allowed in the result.
 * @param target - Target object to merge following object arguments into.
 * @param args - One or more objects that will be mixed into the target in the order they are provided.
 * @returns Resulting merged target.
 */
// tslint:disable-next-line:no-any
function filteredAssign(isAllowed, target, ...args) {
    target = target || {};
    for (let sourceObject of args) {
        if (sourceObject) {
            for (let propName in sourceObject) {
                if (sourceObject.hasOwnProperty(propName) && (!isAllowed || isAllowed(propName))) {
                    target[propName] = sourceObject[propName];
                }
            }
        }
    }
    return target;
}
// Configure ids to reset on stylesheet resets.
const stylesheet = Stylesheet.getInstance();
if (stylesheet && stylesheet.onReset) {
    stylesheet.onReset(resetIds);
}
/**
 * Generates a unique id in the global scope (this spans across duplicate copies of the same library.)
 *
 * @public
 */
function getId(prefix) {
    let index = _global[CURRENT_ID_PROPERTY]++;
    return (prefix || DEFAULT_ID_STRING) + index;
}
/**
 * Resets id counter to an (optional) number.
 *
 * @public
 */
function resetIds(counter = 0) {
    _global[CURRENT_ID_PROPERTY] = counter;
}
/* Takes an enum and iterates over each value of the enum (as a string), running the callback on each, returning a mapped array.
 * The callback takes as a first parameter the string that represents the name of the entry, and the second parameter is the
 * value of that entry, which is the value you'd normally use when using the enum (usually a number).
 * */
function mapEnumByName(
// tslint:disable-next-line:no-any
theEnum, callback) {
    // map<any> to satisfy compiler since it doesn't realize we strip out undefineds in the .filter() call
    return Object.keys(theEnum)
        .map((p) => {
        // map on each property name as a string
        if (String(Number(p)) !== p) {
            // if the property is not just a number (because enums in TypeScript will map both ways)
            return callback(p, theEnum[p]);
        }
    })
        .filter((v) => !!v); // only return elements with values
}
/**
 * Get all values in an object dictionary
 *
 * @param obj - The dictionary to get values for
 */
// tslint:disable-next-line:no-any
function values(obj) {
    return Object.keys(obj).reduce((arr, key) => {
        arr.push(obj[key]);
        return arr;
    }, []);
}

/* tslint:disable:no-string-literal */
/** An instance of EventGroup allows anything with a handle to it to trigger events on it.
 *  If the target is an HTMLElement, the event will be attached to the element and can be
 *  triggered as usual (like clicking for onclick).
 *  The event can be triggered by calling EventGroup.raise() here. If the target is an
 *  HTMLElement, the event gets raised and is handled by the browser. Otherwise, it gets
 *  handled here in EventGroup, and the handler is called in the context of the parent
 *  (which is passed in in the constructor).
 *
 * @public
 */
class EventGroup {
    /** parent: the context in which events attached to non-HTMLElements are called */
    // tslint:disable-next-line:no-any
    constructor(parent) {
        this._id = EventGroup._uniqueId++;
        this._parent = parent;
        this._eventRecords = [];
    }
    /** For IE8, bubbleEvent is ignored here and must be dealt with by the handler.
     *  Events raised here by default have bubbling set to false and cancelable set to true.
     *  This applies also to built-in events being raised manually here on HTMLElements,
     *  which may lead to unexpected behavior if it differs from the defaults.
     *
     */
    static raise(
    // tslint:disable-next-line:no-any
    target, eventName, 
    // tslint:disable-next-line:no-any
    eventArgs, bubbleEvent) {
        let retVal;
        if (EventGroup._isElement(target)) {
            if (document.createEvent) {
                let ev = document.createEvent('HTMLEvents');
                ev.initEvent(eventName, bubbleEvent || false, true);
                assign(ev, eventArgs);
                retVal = target.dispatchEvent(ev);
                // tslint:disable-next-line:no-any
            }
            else if (document['createEventObject']) {
                // IE8
                // tslint:disable-next-line:no-any
                let evObj = document['createEventObject'](eventArgs);
                // cannot set cancelBubble on evObj, fireEvent will overwrite it
                target.fireEvent('on' + eventName, evObj);
            }
        }
        else {
            while (target && retVal !== false) {
                let events = target.__events__;
                let eventRecords = events ? events[eventName] : null;
                if (eventRecords) {
                    for (let id in eventRecords) {
                        if (eventRecords.hasOwnProperty(id)) {
                            let eventRecordList = eventRecords[id];
                            for (let listIndex = 0; retVal !== false && listIndex < eventRecordList.length; listIndex++) {
                                let record = eventRecordList[listIndex];
                                if (record.objectCallback) {
                                    retVal = record.objectCallback.call(record.parent, eventArgs);
                                }
                            }
                        }
                    }
                }
                // If the target has a parent, bubble the event up.
                target = bubbleEvent ? target.parent : null;
            }
        }
        return retVal;
    }
    // tslint:disable-next-line:no-any
    static isObserved(target, eventName) {
        let events = target && target.__events__;
        return !!events && !!events[eventName];
    }
    /** Check to see if the target has declared support of the given event. */
    // tslint:disable-next-line:no-any
    static isDeclared(target, eventName) {
        let declaredEvents = target && target.__declaredEvents;
        return !!declaredEvents && !!declaredEvents[eventName];
    }
    // tslint:disable-next-line:no-any
    static stopPropagation(event) {
        if (event.stopPropagation) {
            event.stopPropagation();
        }
        else {
            // IE8
            event.cancelBubble = true;
        }
    }
    static _isElement(target) {
        return !!target && (!!target.addEventListener || (typeof HTMLElement !== 'undefined' && target instanceof HTMLElement));
    }
    dispose() {
        if (!this._isDisposed) {
            this._isDisposed = true;
            this.off();
            this._parent = null;
        }
    }
    /** On the target, attach a set of events, where the events object is a name to function mapping. */
    // tslint:disable-next-line:no-any
    onAll(target, events, useCapture) {
        for (let eventName in events) {
            if (events.hasOwnProperty(eventName)) {
                this.on(target, eventName, events[eventName], useCapture);
            }
        }
    }
    /** On the target, attach an event whose handler will be called in the context of the parent
     * of this instance of EventGroup.
     */
    // tslint:disable-next-line:no-any
    on(target, eventName, callback, useCapture) {
        if (eventName.indexOf(',') > -1) {
            let events = eventName.split(/[ ,]+/);
            for (let i = 0; i < events.length; i++) {
                this.on(target, events[i], callback, useCapture);
            }
        }
        else {
            let parent = this._parent;
            let eventRecord = {
                target: target,
                eventName: eventName,
                parent: parent,
                callback: callback,
                useCapture: useCapture || false
            };
            // Initialize and wire up the record on the target, so that it can call the callback if the event fires.
            let events = (target.__events__ = target.__events__ || {});
            events[eventName] =
                events[eventName] ||
                    {
                        count: 0
                    };
            events[eventName][this._id] = events[eventName][this._id] || [];
            events[eventName][this._id].push(eventRecord);
            events[eventName].count++;
            if (EventGroup._isElement(target)) {
                // tslint:disable-next-line:no-any
                let processElementEvent = (...args) => {
                    if (this._isDisposed) {
                        return;
                    }
                    let result;
                    try {
                        result = callback.apply(parent, args);
                        if (result === false && args[0]) {
                            let e = args[0];
                            if (e.preventDefault) {
                                e.preventDefault();
                            }
                            if (e.stopPropagation) {
                                e.stopPropagation();
                            }
                            e.cancelBubble = true;
                        }
                    }
                    catch (e) {
                        /* ErrorHelper.log(e); */
                    }
                    return result;
                };
                eventRecord.elementCallback = processElementEvent;
                if (target.addEventListener) {
                    /* tslint:disable:ban-native-functions */
                    target.addEventListener(eventName, processElementEvent, useCapture);
                    /* tslint:enable:ban-native-functions */
                }
                else if (target.attachEvent) {
                    // IE8
                    target.attachEvent('on' + eventName, processElementEvent);
                }
            }
            else {
                // tslint:disable-next-line:no-any
                let processObjectEvent = (...args) => {
                    if (this._isDisposed) {
                        return;
                    }
                    return callback.apply(parent, args);
                };
                eventRecord.objectCallback = processObjectEvent;
            }
            // Remember the record locally, so that it can be removed.
            this._eventRecords.push(eventRecord);
        }
    }
    // tslint:disable-next-line:no-any
    off(target, eventName, callback, useCapture) {
        for (let i = 0; i < this._eventRecords.length; i++) {
            let eventRecord = this._eventRecords[i];
            if ((!target || target === eventRecord.target) &&
                (!eventName || eventName === eventRecord.eventName) &&
                (!callback || callback === eventRecord.callback) &&
                (typeof useCapture !== 'boolean' || useCapture === eventRecord.useCapture)) {
                let events = eventRecord.target.__events__;
                let targetArrayLookup = events[eventRecord.eventName];
                let targetArray = targetArrayLookup ? targetArrayLookup[this._id] : null;
                // We may have already target's entries, so check for null.
                if (targetArray) {
                    if (targetArray.length === 1 || !callback) {
                        targetArrayLookup.count -= targetArray.length;
                        delete events[eventRecord.eventName][this._id];
                    }
                    else {
                        targetArrayLookup.count--;
                        targetArray.splice(targetArray.indexOf(eventRecord), 1);
                    }
                    if (!targetArrayLookup.count) {
                        delete events[eventRecord.eventName];
                    }
                }
                if (eventRecord.elementCallback) {
                    if (eventRecord.target.removeEventListener) {
                        eventRecord.target.removeEventListener(eventRecord.eventName, eventRecord.elementCallback, eventRecord.useCapture);
                    }
                    else if (eventRecord.target.detachEvent) {
                        // IE8
                        eventRecord.target.detachEvent('on' + eventRecord.eventName, eventRecord.elementCallback);
                    }
                }
                this._eventRecords.splice(i--, 1);
            }
        }
    }
    /** Trigger the given event in the context of this instance of EventGroup. */
    // tslint:disable-next-line:no-any
    raise(eventName, eventArgs, bubbleEvent) {
        return EventGroup.raise(this._parent, eventName, eventArgs, bubbleEvent);
    }
    /** Declare an event as being supported by this instance of EventGroup. */
    declare(event) {
        let declaredEvents = (this._parent.__declaredEvents = this._parent.__declaredEvents || {});
        if (typeof event === 'string') {
            declaredEvents[event] = true;
        }
        else {
            for (let i = 0; i < event.length; i++) {
                declaredEvents[event[i]] = true;
            }
        }
    }
}
// tslint:disable-next-line:no-inferrable-types
EventGroup._uniqueId = 0;

const DATA_PORTAL_ATTRIBUTE = 'data-portal-element';
/**
 * Sets the virtual parent of an element.
 * Pass `undefined` as the `parent` to clear the virtual parent.
 *
 * @public
 */
function setVirtualParent(child, parent) {
    let virtualChild = child;
    let virtualParent = parent;
    if (!virtualChild._virtual) {
        virtualChild._virtual = {
            children: []
        };
    }
    let oldParent = virtualChild._virtual.parent;
    if (oldParent && oldParent !== parent) {
        // Remove the child from its old parent.
        let index = oldParent._virtual.children.indexOf(virtualChild);
        if (index > -1) {
            oldParent._virtual.children.splice(index, 1);
        }
    }
    virtualChild._virtual.parent = virtualParent || undefined;
    if (virtualParent) {
        if (!virtualParent._virtual) {
            virtualParent._virtual = {
                children: []
            };
        }
        virtualParent._virtual.children.push(virtualChild);
    }
}
/**
 * Gets the virtual parent given the child element, if it exists.
 *
 * @public
 */
function getVirtualParent(child) {
    let parent;
    if (child && isVirtualElement(child)) {
        parent = child._virtual.parent;
    }
    return parent;
}
/**
 * Gets the element which is the parent of a given element.
 * If `allowVirtuaParents` is `true`, this method prefers the virtual parent over
 * real DOM parent when present.
 *
 * @public
 */
function getParent(child, allowVirtualParents = true) {
    return child && ((allowVirtualParents && getVirtualParent(child)) || (child.parentNode && child.parentNode));
}
/**
 * Gets the elements which are child elements of the given element.
 * If `allowVirtualChildren` is `true`, this method enumerates virtual child elements
 * after the original children.
 * @param parent - The element to get the children of.
 * @param allowVirtualChildren - true if the method should enumerate virtual child elements.
 */
function getChildren(parent, allowVirtualChildren = true) {
    const children = [];
    if (parent) {
        for (let i = 0; i < parent.children.length; i++) {
            children.push(parent.children.item(i));
        }
        if (allowVirtualChildren && isVirtualElement(parent)) {
            children.push(...parent._virtual.children);
        }
    }
    return children;
}
/**
 * Determines whether or not a parent element contains a given child element.
 * If `allowVirtualParents` is true, this method may return `true` if the child
 * has the parent in its virtual element hierarchy.
 *
 * @public
 */
function elementContains(parent, child, allowVirtualParents = true) {
    let isContained = false;
    if (parent && child) {
        if (allowVirtualParents) {
            isContained = false;
            while (child) {
                let nextParent = getParent(child);
                if (nextParent === parent) {
                    isContained = true;
                    break;
                }
                child = nextParent;
            }
        }
        else if (parent.contains) {
            isContained = parent.contains(child);
        }
    }
    return isContained;
}
let _isSSR = false;
/**
 * Helper to set ssr mode to simulate no window object returned from getWindow helper.
 *
 * @public
 */
function setSSR(isEnabled) {
    _isSSR = isEnabled;
}
/**
 * Helper to get the window object.
 *
 * @public
 */
function getWindow(rootElement) {
    if (_isSSR || typeof window === 'undefined') {
        return undefined;
    }
    else {
        return rootElement && rootElement.ownerDocument && rootElement.ownerDocument.defaultView
            ? rootElement.ownerDocument.defaultView
            : window;
    }
}
/**
 * Helper to get the document object.
 *
 * @public
 */
function getDocument(rootElement) {
    if (_isSSR || typeof document === 'undefined') {
        return undefined;
    }
    else {
        return rootElement && rootElement.ownerDocument ? rootElement.ownerDocument : document;
    }
}
/**
 * Helper to get bounding client rect, works with window.
 *
 * @public
 */
function getRect(element) {
    let rect;
    if (element) {
        if (element === window) {
            rect = {
                left: 0,
                top: 0,
                width: window.innerWidth,
                height: window.innerHeight,
                right: window.innerWidth,
                bottom: window.innerHeight
            };
        }
        else if (element.getBoundingClientRect) {
            rect = element.getBoundingClientRect();
        }
    }
    return rect;
}
/**
 * Identify element as a portal by setting an attribute.
 * @param element - Element to mark as a portal.
 */
function setPortalAttribute(element) {
    element.setAttribute(DATA_PORTAL_ATTRIBUTE, 'true');
}
/**
 * Determine whether a target is within a portal from perspective of root or optional parent.
 * This function only works against portal components that use the setPortalAttribute function.
 * If both parent and child are within the same portal this function will return false.
 * @param target - Element to query portal containment status of.
 * @param parent - Optional parent perspective. Search for containing portal stops at parent (or root if parent is undefined or invalid.)
 */
function portalContainsElement(target, parent) {
    const elementMatch = findElementRecursive(target, (testElement) => parent === testElement || testElement.hasAttribute(DATA_PORTAL_ATTRIBUTE));
    return elementMatch !== null && elementMatch.hasAttribute(DATA_PORTAL_ATTRIBUTE);
}
/**
 * Finds the first parent element where the matchFunction returns true
 * @param element - element to start searching at
 * @param matchFunction - the function that determines if the element is a match
 * @returns the matched element or null no match was found
 */
function findElementRecursive(element, matchFunction) {
    if (!element || element === document.body) {
        return null;
    }
    return matchFunction(element) ? element : findElementRecursive(getParent(element), matchFunction);
}
/**
 * Determines if an element, or any of its ancestors, contain the given attribute
 * @param element - element to start searching at
 * @param attribute - the attribute to search for
 * @returns the value of the first instance found
 */
function elementContainsAttribute(element, attribute) {
    let elementMatch = findElementRecursive(element, (testElement) => testElement.hasAttribute(attribute));
    return elementMatch && elementMatch.getAttribute(attribute);
}
/**
 * Determines whether or not an element has the virtual hierarchy extension.
 *
 * @public
 */
function isVirtualElement(element) {
    return element && !!element._virtual;
}

let _scrollbarWidth;
let _bodyScrollDisabledCount = 0;
const DisabledScrollClassName = mergeStyles({
    overflow: 'hidden !important'
});
/**
 * Placing this attribute on scrollable divs optimizes detection to know
 * if the div is scrollable or not (given we can avoid expensive operations
 * like getComputedStyle.)
 *
 * @public
 */
const DATA_IS_SCROLLABLE_ATTRIBUTE = 'data-is-scrollable';
const _makeElementScrollAllower = () => {
    let _previousClientY = 0;
    let _element = null;
    // remember the clientY for future calls of _preventOverscrolling
    const _saveClientY = (event) => {
        if (event.targetTouches.length === 1) {
            _previousClientY = event.targetTouches[0].clientY;
        }
    };
    // prevent the body from scrolling when the user attempts
    // to scroll past the top or bottom of the element
    const _preventOverscrolling = (event) => {
        // only respond to a single-finger touch
        if (event.targetTouches.length !== 1) {
            return;
        }
        // prevent the body touchmove handler from firing
        // so that scrolling is allowed within the element
        event.stopPropagation();
        if (!_element) {
            return;
        }
        const clientY = event.targetTouches[0].clientY - _previousClientY;
        // if the element is scrolled to the top,
        // prevent the user from scrolling up
        if (_element.scrollTop === 0 && clientY > 0) {
            event.preventDefault();
        }
        // if the element is scrolled to the bottom,
        // prevent the user from scrolling down
        if (_element.scrollHeight - _element.scrollTop <= _element.clientHeight && clientY < 0) {
            event.preventDefault();
        }
    };
    return (element, events) => {
        if (!element) {
            return;
        }
        events.on(element, 'touchstart', _saveClientY);
        events.on(element, 'touchmove', _preventOverscrolling);
        _element = element;
    };
};
/**
 * Allows the user to scroll within a element,
 * while preventing the user from scrolling the body
 */
const allowScrollOnElement = _makeElementScrollAllower();
const _disableIosBodyScroll = (event) => {
    event.preventDefault();
};
/**
 * Disables the body scrolling.
 *
 * @public
 */
function disableBodyScroll() {
    let doc = getDocument();
    if (doc && doc.body && !_bodyScrollDisabledCount) {
        doc.body.classList.add(DisabledScrollClassName);
        doc.body.addEventListener('touchmove', _disableIosBodyScroll, { passive: false, capture: false });
    }
    _bodyScrollDisabledCount++;
}
/**
 * Enables the body scrolling.
 *
 * @public
 */
function enableBodyScroll() {
    if (_bodyScrollDisabledCount > 0) {
        let doc = getDocument();
        if (doc && doc.body && _bodyScrollDisabledCount === 1) {
            doc.body.classList.remove(DisabledScrollClassName);
            doc.body.removeEventListener('touchmove', _disableIosBodyScroll);
        }
        _bodyScrollDisabledCount--;
    }
}
/**
 * Calculates the width of a scrollbar for the browser/os.
 *
 * @public
 */
function getScrollbarWidth() {
    if (_scrollbarWidth === undefined) {
        let scrollDiv = document.createElement('div');
        scrollDiv.style.setProperty('width', '100px');
        scrollDiv.style.setProperty('height', '100px');
        scrollDiv.style.setProperty('overflow', 'scroll');
        scrollDiv.style.setProperty('position', 'absolute');
        scrollDiv.style.setProperty('top', '-9999px');
        document.body.appendChild(scrollDiv);
        // Get the scrollbar width
        _scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth;
        // Delete the DIV
        document.body.removeChild(scrollDiv);
    }
    return _scrollbarWidth;
}
/**
 * Traverses up the DOM for the element with the data-is-scrollable=true attribute, or returns
 * document.body.
 *
 * @public
 */
function findScrollableParent(startingElement) {
    let el = startingElement;
    // First do a quick scan for the scrollable attribute.
    while (el && el !== document.body) {
        if (el.getAttribute(DATA_IS_SCROLLABLE_ATTRIBUTE) === 'true') {
            return el;
        }
        el = el.parentElement;
    }
    // If we haven't found it, the use the slower method: compute styles to evaluate if overflow is set.
    el = startingElement;
    while (el && el !== document.body) {
        if (el.getAttribute(DATA_IS_SCROLLABLE_ATTRIBUTE) !== 'false') {
            const computedStyles = getComputedStyle(el);
            let overflowY = computedStyles ? computedStyles.getPropertyValue('overflow-y') : '';
            if (overflowY && (overflowY === 'scroll' || overflowY === 'auto')) {
                return el;
            }
        }
        el = el.parentElement;
    }
    // Fall back to window scroll.
    if (!el || el === document.body) {
        // tslint:disable-next-line:no-any
        el = window;
    }
    return el;
}

const SCROLL_ITERATION_DELAY = 16;
const SCROLL_GUTTER_HEIGHT = 100;
const MAX_SCROLL_VELOCITY = 15;
/**
 * AutoScroll simply hooks up mouse events given a parent element, and scrolls the container
 * up/down depending on how close the mouse is to the top/bottom of the container.
 *
 * Once you don't want autoscroll any more, just dispose the helper and it will unhook events.
 *
 * @public
 */
class AutoScroll {
    constructor(element) {
        this._events = new EventGroup(this);
        this._scrollableParent = findScrollableParent(element);
        this._incrementScroll = this._incrementScroll.bind(this);
        this._scrollRect = getRect(this._scrollableParent);
        // tslint:disable-next-line:no-any
        if (this._scrollableParent === window) {
            this._scrollableParent = document.body;
        }
        if (this._scrollableParent) {
            this._events.on(window, 'mousemove', this._onMouseMove, true);
            this._events.on(window, 'touchmove', this._onTouchMove, true);
        }
    }
    dispose() {
        this._events.dispose();
        this._stopScroll();
    }
    _onMouseMove(ev) {
        this._computeScrollVelocity(ev.clientY);
    }
    _onTouchMove(ev) {
        if (ev.touches.length > 0) {
            this._computeScrollVelocity(ev.touches[0].clientY);
        }
    }
    _computeScrollVelocity(clientY) {
        if (!this._scrollRect) {
            return;
        }
        let scrollRectTop = this._scrollRect.top;
        let scrollClientBottom = scrollRectTop + this._scrollRect.height - SCROLL_GUTTER_HEIGHT;
        if (clientY < scrollRectTop + SCROLL_GUTTER_HEIGHT) {
            this._scrollVelocity = Math.max(-MAX_SCROLL_VELOCITY, -MAX_SCROLL_VELOCITY * ((SCROLL_GUTTER_HEIGHT - (clientY - scrollRectTop)) / SCROLL_GUTTER_HEIGHT));
        }
        else if (clientY > scrollClientBottom) {
            this._scrollVelocity = Math.min(MAX_SCROLL_VELOCITY, MAX_SCROLL_VELOCITY * ((clientY - scrollClientBottom) / SCROLL_GUTTER_HEIGHT));
        }
        else {
            this._scrollVelocity = 0;
        }
        if (this._scrollVelocity) {
            this._startScroll();
        }
        else {
            this._stopScroll();
        }
    }
    _startScroll() {
        if (!this._timeoutId) {
            this._incrementScroll();
        }
    }
    _incrementScroll() {
        if (this._scrollableParent) {
            this._scrollableParent.scrollTop += Math.round(this._scrollVelocity);
        }
        this._timeoutId = setTimeout(this._incrementScroll, SCROLL_ITERATION_DELAY);
    }
    _stopScroll() {
        if (this._timeoutId) {
            clearTimeout(this._timeoutId);
            delete this._timeoutId;
        }
    }
}

let _warningCallback = undefined;
/**
 * Warns when a deprecated props are being used.
 *
 * @public
 * @param componentName - The name of the component being used.
 * @param props - The props passed into the component.
 * @param deprecationMap - The map of deprecations, where key is the prop name and the value is
 * either null or a replacement prop name.
 */
function warnDeprecations(componentName, props, deprecationMap) {
    for (const propName in deprecationMap) {
        if (props && propName in props) {
            let deprecationMessage = `${componentName} property '${propName}' was used but has been deprecated.`;
            const replacementPropName = deprecationMap[propName];
            if (replacementPropName) {
                deprecationMessage += ` Use '${replacementPropName}' instead.`;
            }
            warn(deprecationMessage);
        }
    }
}
/**
 * Warns when two props which are mutually exclusive are both being used.
 *
 * @public
 * @param componentName - The name of the component being used.
 * @param props - The props passed into the component.
 * @param exclusiveMap - A map where the key is a parameter, and the value is the other parameter.
 */
function warnMutuallyExclusive(componentName, props, exclusiveMap) {
    for (const propName in exclusiveMap) {
        if (props && propName in props) {
            let propInExclusiveMapValue = exclusiveMap[propName];
            if (propInExclusiveMapValue && propInExclusiveMapValue in props) {
                warn(`${componentName} property '${propName}' is mutually exclusive with '${exclusiveMap[propName]}'. Use one or the other.`);
            }
        }
    }
}
/**
 * Warns when props are required if a condition is met.
 *
 * @public
 * @param componentName - The name of the component being used.
 * @param props - The props passed into the component.
 * @param requiredProps - The name of the props that are required when the condition is met.
 * @param conditionalPropName - The name of the prop that the condition is based on.
 * @param condition - Whether the condition is met.
 */
function warnConditionallyRequiredProps(componentName, props, requiredProps, conditionalPropName, condition) {
    if (condition === true) {
        for (const requiredPropName of requiredProps) {
            if (!(requiredPropName in props)) {
                warn(`${componentName} property '${requiredPropName}' is required when '${conditionalPropName}' is used.'`);
            }
        }
    }
}
/**
 * Sends a warning to console, if the api is present.
 *
 * @public
 * @param message - Warning message.
 */
function warn(message) {
    if (_warningCallback) {
        _warningCallback(message);
    }
    else if (console && console.warn) {
        console.warn(message);
    }
}
/**
 * Configures the warning callback. Passing in undefined will reset it to use the default
 * console.warn function.
 *
 * @public
 * @param warningCallback - Callback to override the generated warnings.
 */
function setWarningCallback(warningCallback) {
    _warningCallback = warningCallback;
}

/**
 * Simulated enum for keycodes. These will get inlined by uglify when used much like an enum
 *
 * @public
 */
const KeyCodes = {
    backspace: 8,
    tab: 9,
    enter: 13,
    shift: 16,
    ctrl: 17,
    alt: 18,
    pauseBreak: 19,
    capslock: 20,
    escape: 27,
    space: 32,
    pageUp: 33,
    pageDown: 34,
    end: 35,
    home: 36,
    left: 37,
    up: 38,
    right: 39,
    down: 40,
    insert: 45,
    del: 46,
    zero: 48,
    one: 49,
    two: 50,
    three: 51,
    four: 52,
    five: 53,
    six: 54,
    seven: 55,
    eight: 56,
    nine: 57,
    a: 65,
    b: 66,
    c: 67,
    d: 68,
    e: 69,
    f: 70,
    g: 71,
    h: 72,
    i: 73,
    j: 74,
    k: 75,
    l: 76,
    m: 77,
    n: 78,
    o: 79,
    p: 80,
    q: 81,
    r: 82,
    s: 83,
    t: 84,
    u: 85,
    v: 86,
    w: 87,
    x: 88,
    y: 89,
    z: 90,
    leftWindow: 91,
    rightWindow: 92,
    select: 93,
    zero_numpad: 96,
    one_numpad: 97,
    two_numpad: 98,
    three_numpad: 99,
    four_numpad: 100,
    five_numpad: 101,
    six_numpad: 102,
    seven_numpad: 103,
    eight_numpad: 104,
    nine_numpad: 105,
    multiply: 106,
    add: 107,
    subtract: 109,
    decimalPoint: 110,
    divide: 111,
    f1: 112,
    f2: 113,
    f3: 114,
    f4: 115,
    f5: 116,
    f6: 117,
    f7: 118,
    f8: 119,
    f9: 120,
    f10: 121,
    f11: 122,
    f12: 123,
    numlock: 144,
    scrollLock: 145,
    semicolon: 186,
    equalSign: 187,
    comma: 188,
    dash: 189,
    period: 190,
    forwardSlash: 191,
    graveAccent: 192,
    openBracket: 219,
    backSlash: 220,
    closeBracket: 221,
    singleQuote: 222
};

const DirectionalKeyCodes = {
    [KeyCodes.up]: 1,
    [KeyCodes.down]: 1,
    [KeyCodes.left]: 1,
    [KeyCodes.right]: 1,
    [KeyCodes.home]: 1,
    [KeyCodes.end]: 1,
    [KeyCodes.tab]: 1,
    [KeyCodes.pageUp]: 1,
    [KeyCodes.pageDown]: 1
};
/**
 * Returns true if the keycode is a directional keyboard key.
 */
function isDirectionalKeyCode(which) {
    return !!DirectionalKeyCodes[which];
}
/**
 * Adds a keycode to the list of keys that, when pressed, should cause the focus outlines to be visible.
 * This can be used to add global shortcut keys that directionally move from section to section within
 * an app or between focus trap zones.
 */
function addDirectionalKeyCode(which) {
    DirectionalKeyCodes[which] = 1;
}

const IsFocusVisibleClassName = 'ms-Fabric--isFocusVisible';
/**
 * Initializes the logic which:
 *
 * 1. Subscribes keydown and mousedown events. (It will only do it once per window,
 *    so it's safe to call this method multiple times.)
 * 2. When the user presses directional keyboard keys, adds the 'ms-Fabric--isFocusVisible' classname
 *    to the document body.
 * 3. When the user clicks a mouse button, we remove the classname if it exists.
 *
 * This logic allows components on the page to conditionally render focus treatments only
 * if the global classname exists, which simplifies logic overall.
 *
 * @param window - the window used to add the event listeners
 */
function initializeFocusRects(window) {
    const win = (window || getWindow());
    if (win && !win.__hasInitializeFocusRects__) {
        win.__hasInitializeFocusRects__ = true;
        win.addEventListener('mousedown', _onMouseDown, true);
        win.addEventListener('keydown', _onKeyDown, true);
    }
}
function _onMouseDown(ev) {
    const win = getWindow(ev.target);
    if (win) {
        const { classList } = win.document.body;
        if (classList.contains(IsFocusVisibleClassName)) {
            classList.remove(IsFocusVisibleClassName);
        }
    }
}
function _onKeyDown(ev) {
    const win = getWindow(ev.target);
    if (win) {
        const { classList } = win.document.body;
        if (isDirectionalKeyCode(ev.which) && !classList.contains(IsFocusVisibleClassName)) {
            classList.add(IsFocusVisibleClassName);
        }
    }
}

function initializeDir(window) {
    const win = (window || getWindow());
    if (win && !win.__hasInitializedDir__) {
        win.__hasInitializedDir__ = true;
        // Ensure that the documentElement has a 'dir' attribute.
        const { documentElement } = win.document;
        if (!documentElement.hasAttribute('dir')) {
            documentElement.setAttribute('dir', 'ltr');
        }
    }
}

/**
 * BaseComponent class, which provides basic helpers for all components.
 *
 * @public
 */
class BaseComponent extends Component {
    // tslint:enable:variable-name
    /**
     * BaseComponent constructor
     * @param props - The props for the component.
     * @param context - The context for the component.
     */
    // tslint:disable-next-line:no-any
    constructor(props, context) {
        super(props, context);
        // Ensure basic assumptions about the environment.
        initializeFocusRects();
        initializeDir();
        _makeAllSafe(this, BaseComponent.prototype, [
            'componentDidMount',
            'shouldComponentUpdate',
            'getSnapshotBeforeUpdate',
            'render',
            'componentDidUpdate',
            'componentWillUnmount'
        ]);
    }
    /**
     * When the component receives props, make sure the componentRef is updated.
     */
    componentDidUpdate(prevProps, prevState) {
        this._updateComponentRef(prevProps, this.props);
    }
    /**
     * When the component has mounted, update the componentRef.
     */
    componentDidMount() {
        this._setComponentRef(this.props.componentRef, this);
    }
    /**
     * If we have disposables, dispose them automatically on unmount.
     */
    componentWillUnmount() {
        this._setComponentRef(this.props.componentRef, null);
        if (this.__disposables) {
            for (let i = 0, len = this._disposables.length; i < len; i++) {
                let disposable = this.__disposables[i];
                if (disposable.dispose) {
                    disposable.dispose();
                }
            }
            this.__disposables = null;
        }
    }
    /**
     * Gets the object's class name.
     */
    get className() {
        if (!this.__className) {
            let funcNameRegex = /function (.{1,})\(/;
            let results = funcNameRegex.exec(this.constructor.toString());
            this.__className = results && results.length > 1 ? results[1] : '';
        }
        return this.__className;
    }
    /**
     * Allows subclasses to push things to this._disposables to be auto disposed.
     */
    get _disposables() {
        if (!this.__disposables) {
            this.__disposables = [];
        }
        return this.__disposables;
    }
    /**
     * Gets the async instance associated with the component, created on demand. The async instance gives
     * subclasses a way to execute setTimeout/setInterval async calls safely, where the callbacks
     * will be cleared/ignored automatically after unmounting. The helpers within the async object also
     * preserve the this pointer so that you don't need to "bind" the callbacks.
     */
    get _async() {
        if (!this.__async) {
            this.__async = new Async(this);
            this._disposables.push(this.__async);
        }
        return this.__async;
    }
    /**
     * Gets the event group instance assocaited with the component, created on demand. The event instance
     * provides on/off methods for listening to DOM (or regular javascript object) events. The event callbacks
     * will be automatically disconnected after unmounting. The helpers within the events object also
     * preserve the this reference so that you don't need to "bind" the callbacks.
     */
    get _events() {
        if (!this.__events) {
            this.__events = new EventGroup(this);
            this._disposables.push(this.__events);
        }
        return this.__events;
    }
    /**
     * Helper to return a memoized ref resolver function.
     * @param refName - Name of the member to assign the ref to.
     * @returns A function instance keyed from the given refname.
     * @deprecated Use `createRef` from React.createRef.
     */
    _resolveRef(refName) {
        if (!this.__resolves) {
            this.__resolves = {};
        }
        if (!this.__resolves[refName]) {
            // tslint:disable-next-line:no-any
            this.__resolves[refName] = (ref) => {
                // tslint:disable-next-line:no-any
                return (this[refName] = ref);
            };
        }
        return this.__resolves[refName];
    }
    /**
     * Updates the componentRef (by calling it with "this" when necessary.)
     */
    _updateComponentRef(currentProps, newProps = {}) {
        // currentProps *should* always be defined, but verify that just in case a subclass is manually
        // calling a lifecycle method with no parameters (which has happened) or other odd usage.
        if (currentProps && newProps && currentProps.componentRef !== newProps.componentRef) {
            this._setComponentRef(currentProps.componentRef, null);
            this._setComponentRef(newProps.componentRef, this);
        }
    }
    /**
     * Warns when a deprecated props are being used.
     *
     * @param deprecationMap - The map of deprecations, where key is the prop name and the value is
     * either null or a replacement prop name.
     */
    _warnDeprecations(deprecationMap) {
        warnDeprecations(this.className, this.props, deprecationMap);
    }
    /**
     * Warns when props which are mutually exclusive with each other are both used.
     *
     * @param mutuallyExclusiveMap - The map of mutually exclusive props.
     */
    _warnMutuallyExclusive(mutuallyExclusiveMap) {
        warnMutuallyExclusive(this.className, this.props, mutuallyExclusiveMap);
    }
    /**
     * Warns when props are required if a condition is met.
     *
     * @param requiredProps - The name of the props that are required when the condition is met.
     * @param conditionalPropName - The name of the prop that the condition is based on.
     * @param condition - Whether the condition is met.
     */
    _warnConditionallyRequiredProps(requiredProps, conditionalPropName, condition) {
        warnConditionallyRequiredProps(this.className, this.props, requiredProps, conditionalPropName, condition);
    }
    _setComponentRef(ref, value) {
        if (!this._skipComponentRefResolution && ref) {
            if (typeof ref === 'function') {
                ref(value);
            }
            if (typeof ref === 'object') {
                // tslint:disable:no-any
                ref.current = value;
            }
        }
    }
}
/**
 * Helper to override a given method with a wrapper method that can try/catch the original, but also
 * ensures that the BaseComponent's methods are called before the subclass's. This ensures that
 * componentWillUnmount in the base is called and that things in the _disposables array are disposed.
 */
function _makeAllSafe(obj, prototype, methodNames) {
    for (let i = 0, len = methodNames.length; i < len; i++) {
        _makeSafe(obj, prototype, methodNames[i]);
    }
}
function _makeSafe(obj, prototype, methodName) {
    // tslint:disable:no-any
    let classMethod = obj[methodName];
    let prototypeMethod = prototype[methodName];
    // tslint:enable:no-any
    if (classMethod || prototypeMethod) {
        // tslint:disable-next-line:no-any
        obj[methodName] = function () {
            let retVal;
            if (prototypeMethod) {
                retVal = prototypeMethod.apply(this, arguments);
            }
            if (classMethod !== prototypeMethod) {
                retVal = classMethod.apply(this, arguments);
            }
            return retVal;
        };
    }
}
/**
 * Simple constant function for returning null, used to render empty templates in JSX.
 *
 * @public
 */
function nullRender() {
    return null;
}

/**
 * @deprecated This function uses the legacy context API, which is deprecated and should not be
 * used in new code. Please migrate to the new context API. https://reactjs.org/docs/context.html
 */
function provideContext(contextTypes, mapPropsToContext) {
    class Provider extends Component {
        getChildContext() {
            return mapPropsToContext(this.props);
        }
        render() {
            return Children.only(this.props.children);
        }
    }
    Provider.childContextTypes = contextTypes;
    return Provider;
}

/**
 * Storing global state in local module variables has issues when more than one copy
 * if the module gets loaded on the page (due to a bundling error or simply by consuming
 * a prebundled script.)
 *
 * This file contains helpers to deal with the getting and setting local state, and allows
 * callers to get called back when it mutates.
 */
const GLOBAL_SETTINGS_PROP_NAME = '__globalSettings__';
const CALLBACK_STATE_PROP_NAME = '__callbacks__';
// tslint:disable-next-line:no-any
let _global$1;
let _counter = 0;
if (typeof window !== 'undefined') {
    _global$1 = window;
}
else if (typeof global !== 'undefined') {
    _global$1 = global;
}
else {
    _global$1 = {};
}
// tslint:disable-next-line:no-any
let _globalSettings = (_global$1[GLOBAL_SETTINGS_PROP_NAME] = _global$1[GLOBAL_SETTINGS_PROP_NAME] || {
    [CALLBACK_STATE_PROP_NAME]: {}
});
const _callbacks = _globalSettings[CALLBACK_STATE_PROP_NAME];
/**
 * Global settings helper, which stores settings in the global (window) namespace.
 * If window is not provided, it will store settings in module scope. Provides a
 * way to observe changes as well when their values change.
 *
 * @public
 */
class GlobalSettings {
    static getValue(key, defaultValue) {
        if (_globalSettings[key] === undefined) {
            //@ts-ignore
            _globalSettings[key] = typeof defaultValue === 'function' ? defaultValue() : defaultValue;
        }
        return _globalSettings[key];
    }
    static setValue(key, value) {
        let oldValue = _globalSettings[key];
        if (value !== oldValue) {
            _globalSettings[key] = value;
            let changeDescription = {
                oldValue,
                value,
                key
            };
            for (let id in _callbacks) {
                if (_callbacks.hasOwnProperty(id)) {
                    _callbacks[id](changeDescription);
                }
            }
        }
        return value;
    }
    static addChangeListener(cb) {
        // Note: we use generated ids on the callbacks to create a map of the callbacks, which optimizes removal.
        // (It's faster to delete a key than it is to look up the index of an object and splice an array.)
        let id = cb.__id__;
        if (!id) {
            id = cb.__id__ = String(_counter++);
        }
        _callbacks[id] = cb;
    }
    static removeChangeListener(cb) {
        delete _callbacks[cb.__id__];
    }
}

const CustomizationsGlobalKey = 'customizations';
const NO_CUSTOMIZATIONS = { settings: {}, scopedSettings: {}, inCustomizerContext: false };
let _allSettings = GlobalSettings.getValue(CustomizationsGlobalKey, {
    settings: {},
    scopedSettings: {},
    inCustomizerContext: false
});
const _events = new EventGroup(_allSettings);
class Customizations {
    static reset() {
        _allSettings.settings = {};
        _allSettings.scopedSettings = {};
    }
    // tslint:disable-next-line:no-any
    static applySettings(settings) {
        _allSettings.settings = { ..._allSettings.settings, ...settings };
        Customizations._raiseChange();
    }
    // tslint:disable-next-line:no-any
    static applyScopedSettings(scopeName, settings) {
        _allSettings.scopedSettings[scopeName] = { ..._allSettings.scopedSettings[scopeName], ...settings };
        Customizations._raiseChange();
    }
    static getSettings(properties, scopeName, localSettings = NO_CUSTOMIZATIONS
    // tslint:disable-next-line:no-any
    ) {
        // tslint:disable-next-line:no-any
        const settings = {};
        const localScopedSettings = (scopeName && localSettings.scopedSettings[scopeName]) || {};
        const globalScopedSettings = (scopeName && _allSettings.scopedSettings[scopeName]) || {};
        for (let property of properties) {
            settings[property] =
                localScopedSettings[property] ||
                    localSettings.settings[property] ||
                    globalScopedSettings[property] ||
                    _allSettings.settings[property];
        }
        return settings;
    }
    static observe(onChange) {
        _events.on(_allSettings, 'change', onChange);
    }
    static unobserve(onChange) {
        _events.off(_allSettings, 'change', onChange);
    }
    static _raiseChange() {
        _events.raise('change');
    }
}

const CustomizerContext = createContext({
    customizations: {
        inCustomizerContext: false,
        settings: {},
        scopedSettings: {}
    }
});
/**
 * The Customizer component allows for default props to be mixed into components which
 * are decorated with the customizable() decorator, or use the styled HOC. This enables
 * injection scenarios like:
 *
 * 1. render svg icons instead of the icon font within all buttons
 * 2. inject a custom theme object into a component
 *
 * Props are provided via the settings prop which should be one of the following:
 * - A json map which contains 1 or more name/value pairs representing injectable props.
 * - A function that receives the current settings and returns the new ones that apply to the scope
 *
 * @public
 */
class Customizer extends BaseComponent {
    constructor() {
        super(...arguments);
        this._changeCount = 0;
        this._onCustomizationChange = () => this.forceUpdate();
    }
    componentDidMount() {
        Customizations.observe(this._onCustomizationChange);
    }
    componentWillUnmount() {
        Customizations.unobserve(this._onCustomizationChange);
    }
    render() {
        const { contextTransform } = this.props;
        return (createElement(CustomizerContext.Consumer, null, (parentContext) => {
            let newContext = mergeCustomizations(this.props, parentContext);
            if (contextTransform) {
                newContext = contextTransform(newContext);
            }
            return createElement(CustomizerContext.Provider, { value: newContext }, this.props.children);
        }));
    }
}
/**
 * Merge props and customizations giving priority to props over context.
 * NOTE: This function will always perform multiple merge operations. Use with caution.
 * @param props - New settings to merge in.
 * @param parentContext - Context containing current settings.
 * @returns Merged customizations.
 */
function mergeCustomizations(props, parentContext) {
    const { customizations = { settings: {}, scopedSettings: {} } } = parentContext || {};
    return {
        customizations: {
            settings: mergeSettings(customizations.settings, props.settings),
            scopedSettings: mergeScopedSettings(customizations.scopedSettings, props.scopedSettings),
            inCustomizerContext: true
        }
    };
}
/**
 * Merge new and old settings, giving priority to new settings.
 * New settings is optional in which case oldSettings is returned as-is.
 * @param oldSettings - Old settings to fall back to.
 * @param newSettings - New settings that will be merged over oldSettings.
 * @returns Merged settings.
 */
function mergeSettings(oldSettings = {}, newSettings) {
    const mergeSettingsWith = isSettingsFunction(newSettings) ? newSettings : settingsMergeWith(newSettings);
    return mergeSettingsWith(oldSettings);
}
function mergeScopedSettings(oldSettings = {}, newSettings) {
    const mergeSettingsWith = isSettingsFunction(newSettings) ? newSettings : scopedSettingsMergeWith(newSettings);
    return mergeSettingsWith(oldSettings);
}
function isSettingsFunction(settings) {
    return typeof settings === 'function';
}
function settingsMergeWith(newSettings) {
    return (settings) => (newSettings ? { ...settings, ...newSettings } : settings);
}
function scopedSettingsMergeWith(scopedSettingsFromProps = {}) {
    return (oldScopedSettings) => {
        const newScopedSettings = { ...oldScopedSettings };
        for (let scopeName in scopedSettingsFromProps) {
            if (scopedSettingsFromProps.hasOwnProperty(scopeName)) {
                newScopedSettings[scopeName] = { ...oldScopedSettings[scopeName], ...scopedSettingsFromProps[scopeName] };
            }
        }
        return newScopedSettings;
    };
}

/**
 * Utility component for delaying the render of a child component after a given delay. This component
 * requires a single child component; don't pass in many components. Wrap multiple components in a DIV
 * if necessary.
 *
 * @public
 */
class DelayedRender extends Component {
    constructor(props) {
        super(props);
        this.state = {
            isRendered: false
        };
    }
    componentDidMount() {
        let { delay } = this.props;
        this._timeoutId = window.setTimeout(() => {
            this.setState({
                isRendered: true
            });
        }, delay);
    }
    componentWillUnmount() {
        if (this._timeoutId) {
            clearTimeout(this._timeoutId);
        }
    }
    render() {
        return this.state.isRendered ? Children.only(this.props.children) : null;
    }
}
DelayedRender.defaultProps = {
    delay: 0
};

const now = () => (typeof performance !== 'undefined' && !!performance.now ? performance.now() : Date.now());
const RESET_INTERVAL = 3 * 60 * 1000; // auto reset every 3 minutes
/**
 * Performance helper class for measuring things.
 *
 * @public
 */
class FabricPerformance {
    /**
     * Measures execution time of the given syncronous function. If the same logic is executed multiple times,
     * each individual measurement will be collected as well the overall numbers.
     * @param name - The name of this measurement
     * @param func - The logic to be measured for execution time
     */
    static measure(name, func) {
        if (FabricPerformance._timeoutId) {
            FabricPerformance.setPeriodicReset();
        }
        const start = now();
        func();
        const end = now();
        const measurement = FabricPerformance.summary[name] || {
            totalDuration: 0,
            count: 0,
            all: []
        };
        const duration = end - start;
        measurement.totalDuration += duration;
        measurement.count++;
        measurement.all.push({
            duration: duration,
            timeStamp: end
        });
        FabricPerformance.summary[name] = measurement;
    }
    static reset() {
        FabricPerformance.summary = {};
        clearTimeout(FabricPerformance._timeoutId);
        FabricPerformance._timeoutId = NaN;
    }
    static setPeriodicReset() {
        FabricPerformance._timeoutId = setTimeout(() => FabricPerformance.reset(), RESET_INTERVAL);
    }
}
FabricPerformance.summary = {};

/**
 * Rectangle helper class.
 *
 * @public
 */
class Rectangle {
    constructor(left = 0, right = 0, top = 0, bottom = 0) {
        this.top = top;
        this.bottom = bottom;
        this.left = left;
        this.right = right;
    }
    /**
     * Calculated automatically by subtracting the right from left
     */
    get width() {
        return this.right - this.left;
    }
    /**
     * Calculated automatically by subtracting the bottom from top.
     */
    get height() {
        return this.bottom - this.top;
    }
    /**
     * Tests if another rect is approximately equal to this rect (within 4 decimal places.)
     */
    equals(rect) {
        // I'm fixing it to 4 decimal places because it allows enough precision and will handle cases when something should be rounded,
        // like .999999 should round to 1.
        return (parseFloat(this.top.toFixed(4)) === parseFloat(rect.top.toFixed(4)) &&
            parseFloat(this.bottom.toFixed(4)) === parseFloat(rect.bottom.toFixed(4)) &&
            parseFloat(this.left.toFixed(4)) === parseFloat(rect.left.toFixed(4)) &&
            parseFloat(this.right.toFixed(4)) === parseFloat(rect.right.toFixed(4)));
    }
}

/**
 * ARIA helper to concatenate attributes, returning undefined if all attributes
 * are undefined. (Empty strings are not a valid ARIA attribute value.)
 *
 * NOTE: This function will NOT insert whitespace between provided attributes.
 *
 * @param ariaAttributes - ARIA attributes to merge
 */
function mergeAriaAttributeValues(...ariaAttributes) {
    const mergedAttribute = ariaAttributes.filter((arg) => arg !== undefined && arg !== null).join('');
    return mergedAttribute === '' ? undefined : mergedAttribute;
}

/**
 * Helper to find the index of an item within an array, using a callback to
 * determine the match.
 *
 * @public
 * @param array - Array to search.
 * @param cb - Callback which returns true on matches.
 */
function findIndex(array, cb) {
    let index = -1;
    for (let i = 0; array && i < array.length; i++) {
        if (cb(array[i], i)) {
            index = i;
            break;
        }
    }
    return index;
}
/**
 * Helper to find the first item within an array that satisfies the callback.
 * @param array - Array to search
 * @param cb - Callback which returns true on matches
 */
function find(array, cb) {
    let index = findIndex(array, cb);
    if (index < 0) {
        return undefined;
    }
    return array[index];
}
/**
 * Creates an array of a given size and helper method to populate.
 *
 * @public
 * @param size - Size of array.
 * @param getItem - Callback to populate given cell index.
 */
function createArray(size, getItem) {
    let array = [];
    for (let i = 0; i < size; i++) {
        array.push(getItem(i));
    }
    return array;
}
/**
 * Convert the given array to a matrix with columnCount number
 * of columns.
 *
 * @public
 * @param items - The array to convert
 * @param columnCount - The number of columns for the resulting matrix
 * @returns A matrix of items
 */
function toMatrix(items, columnCount) {
    return items.reduce((rows, currentValue, index) => {
        if (index % columnCount === 0) {
            rows.push([currentValue]);
        }
        else {
            rows[rows.length - 1].push(currentValue);
        }
        return rows;
    }, []);
}
/**
 * Given an array, it returns a new array that does not contain the item at the given index.
 * @param array - The array to operate on
 * @param index - The index of the element to remove
 */
function removeIndex(array, index) {
    return array.filter((_, i) => index !== i);
}
/**
 * Given an array, this function returns a new array where the element at a given index has been replaced.
 * @param array - The array to operate on
 * @param newElement - The element that will be placed in the new array
 * @param index - The index of the element that should be replaced
 */
function replaceElement(array, newElement, index) {
    const copy = array.slice();
    copy[index] = newElement;
    return copy;
}
/**
 * Given an array, this function returns a new array where an element has been inserted at the given index.
 * @param array - The array to operate on
 * @param index - The index where an element should be inserted
 * @param itemToAdd - The element to insert
 */
function addElementAtIndex(array, index, itemToAdd) {
    const copy = array.slice();
    copy.splice(index, 0, itemToAdd);
    return copy;
}
/**
 * Given an array where each element is of type T or T[], flatten it into an array of T
 * @param array - The array where each element can optionally also be an array
 */
function flatten(array) {
    let result = [];
    array.forEach((item) => (result = result.concat(item)));
    return result;
}
/**
 * Returns a boolean indicating if the two given arrays are equal in length and values.
 *
 * @param array1 - First array to compare
 * @param array2 - Second array to compare
 * @returns True if the arrays are the same length and have the same values in the same positions, false otherwise.
 */
function arraysEqual(array1, array2) {
    if (array1.length !== array2.length) {
        return false;
    }
    for (let i = 0; i < array1.length; i++) {
        if (array1[i] !== array2[i]) {
            return false;
        }
    }
    return true;
}

/**
 * asAsync - a HOC for async loading components.
 *
 * Usage:
 *
 * const AsyncDialog = asAsync({
 *   load: () => import('Dialog').then(result => result.default),
 * });
 *
 * React.render(domElement, <AsyncDialog asyncPlaceholder={ () => <Spinner/> } { ...dialogProps } />);
 *
 * Note the `asyncPlaceholder` prop will be respected when rendering the async component and it hasn't
 * been loaded yet.
 */
/**
 * If possible, use a WeakMap to maintain a cache of loaded components.
 * This can be used to synchronously render components that have already been loaded,
 * rather than having to wait for at least one async tick.
 */
const _syncModuleCache = typeof WeakMap !== 'undefined'
    ? // tslint:disable-next-line:no-any
        new WeakMap()
    : undefined;
/**
 * Produces a component which internally loads the target component before first mount.
 * The component passes all props through to the loaded component.
 *
 * This overload accepts a module with a default export for the component.
 */
function asAsync(options) {
    class Async extends Component {
        constructor() {
            super(...arguments);
            //@ts-ignore
            this.state = {
                Component: _syncModuleCache ? _syncModuleCache.get(options.load) : undefined
            };
        }
        render() {
            // Typescript issue: the rest can't be pulled without the any cast, as TypeScript fails with rest on generics.
            // tslint:disable-next-line:no-any
            const { forwardedRef, asyncPlaceholder: Placeholder, ...rest } = this.props;
            const { Component: Component$$1 } = this.state;
            //@ts-ignore
            return Component$$1 ? createElement(Component$$1, Object.assign({ ref: forwardedRef }, rest)) : Placeholder ? createElement(Placeholder, null) : null;
        }
        componentDidMount() {
            let { Component: Component$$1 } = this.state;
            if (!Component$$1) {
                options
                    .load()
                    .then((LoadedComponent) => {
                    if (LoadedComponent) {
                        // Cache component for future reference.
                        _syncModuleCache && _syncModuleCache.set(options.load, LoadedComponent);
                        // Set state.
                        this.setState({
                            Component: LoadedComponent
                        }, options.onLoad);
                    }
                })
                    .catch(options.onError);
            }
        }
    }
    //@ts-ignore
    return forwardRef((props, ref) => (createElement(Async, Object.assign({}, props, { forwardedRef: ref }))));
}

/**
 * AssertNever is a utility function that can be used for exhaustiveness checks in switch statements.
 *
 * @public
 */
function assertNever(x) {
    throw new Error('Unexpected object: ' + x);
}

/**
 * Autobind is a utility for binding methods in a class. This simplifies tagging methods as being "bound" to the this pointer
 * so that they can be used in scenarios that simply require a function callback.
 * @deprecated This has been deprecated in favor of using arrow function properties
 */
function autobind(
// tslint:disable-next-line:no-any
target, key, descriptor) {
    let fn = descriptor.value;
    let defining = false;
    return {
        configurable: true,
        get() {
            if (defining || (fn && this === fn.prototype) || this.hasOwnProperty(key)) {
                return fn;
            }
            // Bind method only once, and update the property to return the bound value from now on
            let fnBound = fn && fn.bind(this);
            defining = true;
            Object.defineProperty(this, key, {
                configurable: true,
                writable: true,
                enumerable: true,
                value: fnBound
            });
            defining = false;
            return fnBound;
        },
        // tslint:disable-next-line:no-any
        set(newValue) {
            Object.defineProperty(this, key, {
                configurable: true,
                writable: true,
                enumerable: true,
                value: newValue
            });
        }
    };
}

/**
 * Creates a getClassNames function which calls getStyles given the props, and injects them
 * into mergeStyleSets.
 */
function classNamesFunction() {
    // TODO: memoize.
    const getClassNames = (styleFunctionOrObject, styleProps = {}) => {
        // styleSet might be undefined if styleFunctionOrObject is undefined, but getStyles should never
        // ordinarily be undefined (it would hardly make any sense).
        // However, because we usually use `props.styles` as the argument to an invocation of this method, and
        // `props.styles` itself is defined as optional, this avoids the need to use `!` at all invocation points.
        if (styleFunctionOrObject === undefined) {
            return {};
        }
        const styleSet = styleFunctionOrObject && (typeof styleFunctionOrObject === 'function' ? styleFunctionOrObject(styleProps) : styleFunctionOrObject);
        return mergeStyleSets(styleSet);
    };
    return getClassNames;
}

/**
 * @deprecated Use React.createRef.
 * May be removed in 6 months (Jan '19).
 */
function createRef$1() {
    const refObject = ((element) => {
        refObject.current = element;
    });
    // This getter is here to support the deprecated value prop on the refObject.
    Object.defineProperty(refObject, 'value', {
        get() {
            return refObject.current;
        }
    });
    refObject.current = null;
    return refObject;
}

/**
 * Concatination helper, which can merge class names together. Skips over falsey values.
 *
 * @public
 */
function css(...args) {
    let classes = [];
    for (let arg of args) {
        if (arg) {
            if (typeof arg === 'string') {
                classes.push(arg);
            }
            else if (arg.hasOwnProperty('toString') && typeof arg.toString === 'function') {
                classes.push(arg.toString());
            }
            else {
                // tslint:disable-next-line:no-any
                for (let key in arg) {
                    // tslint:disable-next-line:no-any
                    if (arg[key]) {
                        classes.push(key);
                    }
                }
            }
        }
    }
    return classes.join(' ');
}

/**
 * Allows you to hoist static functions in components.
 * Created for the purpose of fixing broken static functions in classes
 * that utilize decorators.
 *
 * @public
 * @param source - The object where the methods are hoisted from.
 * @param dest - The object to hoist the methods onto.
 * @returns The dest object with methods added
 */
function hoistStatics(source, dest) {
    for (const name in source) {
        if (source.hasOwnProperty(name)) {
            // tslint:disable-next-line:no-any
            dest[name] = source[name];
        }
    }
    return dest;
}

function customizable(scope, fields, concatStyles
// tslint:disable-next-line:no-any
) {
    // tslint:disable-next-line:no-shadowed-variable
    return function customizableFactory(
    // tslint:disable-next-line:no-any
    ComposedComponent
    // tslint:disable-next-line:no-any
    ) {
        var _a;
        const resultClass = (_a = class ComponentWithInjectedProps extends Component {
                // tslint:disable-next-line:no-any
                constructor(props) {
                    super(props);
                    this._onSettingChanged = this._onSettingChanged.bind(this);
                }
                componentDidMount() {
                    Customizations.observe(this._onSettingChanged);
                }
                componentWillUnmount() {
                    Customizations.unobserve(this._onSettingChanged);
                }
                render() {
                    return (createElement(CustomizerContext.Consumer, null, (context) => {
                        const defaultProps = Customizations.getSettings(fields, scope, context.customizations);
                        // tslint:disable-next-line:no-any
                        const componentProps = this.props;
                        if (concatStyles) {
                            const mergedStyles = concatStyleSets(defaultProps.styles, componentProps.styles);
                            return createElement(ComposedComponent, Object.assign({}, defaultProps, componentProps, { styles: mergedStyles }));
                        }
                        return createElement(ComposedComponent, Object.assign({}, defaultProps, componentProps));
                    }));
                }
                _onSettingChanged() {
                    this.forceUpdate();
                }
            },
            _a.displayName = 'Customized' + scope,
            _a);
        return hoistStatics(ComposedComponent, resultClass);
    };
}

/* tslint:disable:no-string-literal */
const IS_FOCUSABLE_ATTRIBUTE = 'data-is-focusable';
const IS_VISIBLE_ATTRIBUTE = 'data-is-visible';
const FOCUSZONE_ID_ATTRIBUTE = 'data-focuszone-id';
const FOCUSZONE_SUB_ATTRIBUTE = 'data-is-sub-focuszone';
/**
 * Gets the first focusable element.
 *
 * @public
 */
function getFirstFocusable(rootElement, currentElement, includeElementsInFocusZones) {
    return getNextElement(rootElement, currentElement, true /*checkNode*/, false /*suppressParentTraversal*/, false /*suppressChildTraversal*/, includeElementsInFocusZones);
}
/**
 * Gets the last focusable element.
 *
 * @public
 */
function getLastFocusable(rootElement, currentElement, includeElementsInFocusZones) {
    return getPreviousElement(rootElement, currentElement, true /*checkNode*/, false /*suppressParentTraversal*/, true /*traverseChildren*/, includeElementsInFocusZones);
}
/**
 * Gets the first tabbable element.
 * The difference between focusable and tabbable is that tabbable elements are focusable elements that also have tabIndex != -1.
 * @param rootElement - The parent element to search beneath.
 * @param currentElement - The descendant of rootElement to start the search at.  This element is the first one checked,
 * and iteration continues forward.  Typical use passes rootElement.firstChild.
 * @param includeElementsInFocusZones - true if traversal should go into FocusZone descendants.
 * @public
 */
function getFirstTabbable(rootElement, currentElement, includeElementsInFocusZones) {
    return getNextElement(rootElement, currentElement, true /*checkNode*/, false /*suppressParentTraversal*/, false /*suppressChildTraversal*/, includeElementsInFocusZones, false /*allowFocusRoot*/, true /*tabbable*/);
}
/**
 * Gets the last tabbable element.
 * The difference between focusable and tabbable is that tabbable elements are focusable elements that also have tabIndex != -1.
 * @param rootElement - The parent element to search beneath.
 * @param currentElement - The descendant of rootElement to start the search at.  This element is the first one checked,
 * and iteration continues in reverse.  Typical use passes rootElement.lastChild.
 * @param includeElementsInFocusZones - true if traversal should go into FocusZone descendants.
 * @public
 */
function getLastTabbable(rootElement, currentElement, includeElementsInFocusZones) {
    return getPreviousElement(rootElement, currentElement, true /*checkNode*/, false /*suppressParentTraversal*/, true /*traverseChildren*/, includeElementsInFocusZones, false /*allowFocusRoot*/, true /*tabbable*/);
}
/**
 * Attempts to focus the first focusable element that is a child or child's child of the rootElement.
 *
 * @public
 * @param rootElement - Element to start the search for a focusable child.
 * @returns True if focus was set, false if it was not.
 */
function focusFirstChild(rootElement) {
    let element = getNextElement(rootElement, rootElement, true, false, false, true);
    if (element) {
        focusAsync(element);
        return true;
    }
    return false;
}
/**
 * Traverse to find the previous element.
 * If tabbable is true, the element must have tabIndex != -1.
 *
 * @public
 */
function getPreviousElement(rootElement, currentElement, checkNode, suppressParentTraversal, traverseChildren, includeElementsInFocusZones, allowFocusRoot, tabbable) {
    if (!currentElement || (!allowFocusRoot && currentElement === rootElement)) {
        return null;
    }
    let isCurrentElementVisible = isElementVisible(currentElement);
    // Check its children.
    if (traverseChildren &&
        isCurrentElementVisible &&
        (includeElementsInFocusZones || !(isElementFocusZone(currentElement) || isElementFocusSubZone(currentElement)))) {
        const childMatch = getPreviousElement(rootElement, currentElement.lastElementChild, true, true, true, includeElementsInFocusZones, allowFocusRoot, tabbable);
        if (childMatch) {
            if ((tabbable && isElementTabbable(childMatch, true)) || !tabbable) {
                return childMatch;
            }
            const childMatchSiblingMatch = getPreviousElement(rootElement, childMatch.previousElementSibling, true, true, true, includeElementsInFocusZones, allowFocusRoot, tabbable);
            if (childMatchSiblingMatch) {
                return childMatchSiblingMatch;
            }
            let childMatchParent = childMatch.parentElement;
            // At this point if we have not found any potential matches
            // start looking at the rest of the subtree under the currentParent.
            // NOTE: We do not want to recurse here because doing so could
            // cause elements to get skipped.
            while (childMatchParent && childMatchParent !== currentElement) {
                const childMatchParentMatch = getPreviousElement(rootElement, childMatchParent.previousElementSibling, true, true, true, includeElementsInFocusZones, allowFocusRoot, tabbable);
                if (childMatchParentMatch) {
                    return childMatchParentMatch;
                }
                childMatchParent = childMatchParent.parentElement;
            }
        }
    }
    // Check the current node, if it's not the first traversal.
    if (checkNode && isCurrentElementVisible && isElementTabbable(currentElement)) {
        return currentElement;
    }
    // Check its previous sibling.
    const siblingMatch = getPreviousElement(rootElement, currentElement.previousElementSibling, true, true, true, includeElementsInFocusZones, allowFocusRoot, tabbable);
    if (siblingMatch) {
        return siblingMatch;
    }
    // Check its parent.
    if (!suppressParentTraversal) {
        return getPreviousElement(rootElement, currentElement.parentElement, true, false, false, includeElementsInFocusZones, allowFocusRoot, tabbable);
    }
    return null;
}
/**
 * Traverse to find the next focusable element.
 * If tabbable is true, the element must have tabIndex != -1.
 *
 * @public
 */
function getNextElement(rootElement, currentElement, checkNode, suppressParentTraversal, suppressChildTraversal, includeElementsInFocusZones, allowFocusRoot, tabbable) {
    if (!currentElement || (currentElement === rootElement && suppressChildTraversal && !allowFocusRoot)) {
        return null;
    }
    let isCurrentElementVisible = isElementVisible(currentElement);
    // Check the current node, if it's not the first traversal.
    if (checkNode && isCurrentElementVisible && isElementTabbable(currentElement, tabbable)) {
        return currentElement;
    }
    // Check its children.
    if (!suppressChildTraversal &&
        isCurrentElementVisible &&
        (includeElementsInFocusZones || !(isElementFocusZone(currentElement) || isElementFocusSubZone(currentElement)))) {
        const childMatch = getNextElement(rootElement, currentElement.firstElementChild, true, true, false, includeElementsInFocusZones, allowFocusRoot, tabbable);
        if (childMatch) {
            return childMatch;
        }
    }
    if (currentElement === rootElement) {
        return null;
    }
    // Check its sibling.
    const siblingMatch = getNextElement(rootElement, currentElement.nextElementSibling, true, true, false, includeElementsInFocusZones, allowFocusRoot, tabbable);
    if (siblingMatch) {
        return siblingMatch;
    }
    if (!suppressParentTraversal) {
        return getNextElement(rootElement, currentElement.parentElement, false, false, true, includeElementsInFocusZones, allowFocusRoot, tabbable);
    }
    return null;
}
/**
 * Determines if an element is visible.
 *
 * @public
 */
function isElementVisible(element) {
    // If the element is not valid, return false.
    if (!element || !element.getAttribute) {
        return false;
    }
    const visibilityAttribute = element.getAttribute(IS_VISIBLE_ATTRIBUTE);
    // If the element is explicitly marked with the visibility attribute, return that value as boolean.
    if (visibilityAttribute !== null && visibilityAttribute !== undefined) {
        return visibilityAttribute === 'true';
    }
    // Fallback to other methods of determining actual visibility.
    return (element.offsetHeight !== 0 ||
        element.offsetParent !== null ||
        // tslint:disable-next-line:no-any
        element.isVisible === true); // used as a workaround for testing.
}
/**
 * Determines if an element can receive focus programmatically or via a mouse click.
 * If checkTabIndex is true, additionally checks to ensure the element can be focused with the tab key, meaning tabIndex != -1.
 *
 * @public
 */
function isElementTabbable(element, checkTabIndex) {
    // If this element is null or is disabled, it is not considered tabbable.
    if (!element || element.disabled) {
        return false;
    }
    let tabIndex = 0;
    let tabIndexAttributeValue = null;
    if (element && element.getAttribute) {
        tabIndexAttributeValue = element.getAttribute('tabIndex');
        if (tabIndexAttributeValue) {
            tabIndex = parseInt(tabIndexAttributeValue, 10);
        }
    }
    let isFocusableAttribute = element.getAttribute ? element.getAttribute(IS_FOCUSABLE_ATTRIBUTE) : null;
    let isTabIndexSet = tabIndexAttributeValue !== null && tabIndex >= 0;
    const result = !!element &&
        isFocusableAttribute !== 'false' &&
        (element.tagName === 'A' ||
            element.tagName === 'BUTTON' ||
            element.tagName === 'INPUT' ||
            element.tagName === 'TEXTAREA' ||
            isFocusableAttribute === 'true' ||
            isTabIndexSet ||
            (element.getAttribute && element.getAttribute('role') === 'button'));
    return checkTabIndex ? tabIndex !== -1 && result : result;
}
/**
 * Determines if a given element is a focus zone.
 *
 * @public
 */
function isElementFocusZone(element) {
    return !!(element && element.getAttribute && !!element.getAttribute(FOCUSZONE_ID_ATTRIBUTE));
}
/**
 * Determines if a given element is a focus sub zone.
 *
 * @public
 */
function isElementFocusSubZone(element) {
    return !!(element && element.getAttribute && element.getAttribute(FOCUSZONE_SUB_ATTRIBUTE) === 'true');
}
/**
 * Determines if an element, or any of its children, contain focus.
 *
 * @public
 */
function doesElementContainFocus(element) {
    let document = getDocument(element);
    let currentActiveElement = document && document.activeElement;
    if (currentActiveElement && elementContains(element, currentActiveElement)) {
        return true;
    }
    return false;
}
/**
 * Determines if an, or any of its ancestors, sepcificies that it doesn't want focus to wrap
 * @param element - element to start searching from
 * @param noWrapDataAttribute - the no wrap data attribute to match (either)
 * @returns true if focus should wrap, false otherwise
 */
function shouldWrapFocus(element, noWrapDataAttribute) {
    return elementContainsAttribute(element, noWrapDataAttribute) === 'true' ? false : true;
}
let targetToFocusOnNextRepaint = undefined;
/**
 * Sets focus to an element asynchronously. The focus will be set at the next browser repaint,
 * meaning it won't cause any extra recalculations. If more than one focusAsync is called during one frame,
 * only the latest called focusAsync element will actually be focused
 * @param element - The element to focus
 */
function focusAsync(element) {
    if (element) {
        // An element was already queued to be focused, so replace that one with the new element
        if (targetToFocusOnNextRepaint) {
            targetToFocusOnNextRepaint = element;
            return;
        }
        targetToFocusOnNextRepaint = element;
        const win = getWindow(element);
        if (win) {
            // element.focus() is a no-op if the element is no longer in the DOM, meaning this is always safe
            win.requestAnimationFrame(() => {
                targetToFocusOnNextRepaint && targetToFocusOnNextRepaint.focus();
                // We are done focusing for this frame, so reset the queued focus element
                targetToFocusOnNextRepaint = undefined;
            });
        }
    }
}

const REACT_LIFECYCLE_EXCLUSIONS = [
    'setState',
    'render',
    'componentWillMount',
    'UNSAFE_componentWillMount',
    'componentDidMount',
    'componentWillReceiveProps',
    'UNSAFE_componentWillReceiveProps',
    'shouldComponentUpdate',
    'componentWillUpdate',
    'getSnapshotBeforeUpdate',
    'UNSAFE_componentWillUpdate',
    'componentDidUpdate',
    'componentWillUnmount'
];
/**
 * Allows you to hoist methods, except those in an exclusion set from a source object into a destination object.
 *
 * @public
 * @param destination - The instance of the object to hoist the methods onto.
 * @param source - The instance of the object where the methods are hoisted from.
 * @param exclusions - (Optional) What methods to exclude from being hoisted.
 * @returns An array of names of methods that were hoisted.
 */
function hoistMethods(
// tslint:disable-next-line:no-any
destination, 
// tslint:disable-next-line:no-any
source, exclusions = REACT_LIFECYCLE_EXCLUSIONS) {
    let hoisted = [];
    for (let methodName in source) {
        if (typeof source[methodName] === 'function' &&
            destination[methodName] === undefined &&
            (!exclusions || exclusions.indexOf(methodName) === -1)) {
            hoisted.push(methodName);
            /* tslint:disable:no-function-expression */
            destination[methodName] = function () {
                source[methodName].apply(source, arguments);
            };
            /* tslint:enable */
        }
    }
    return hoisted;
}
/**
 * Provides a method for convenience to unhoist hoisted methods.
 *
 * @public
 * @param source - The source object upon which methods were hoisted.
 * @param methodNames - An array of method names to unhoist.
 */
// tslint:disable-next-line:no-any
function unhoistMethods(source, methodNames) {
    methodNames.forEach((methodName) => delete source[methodName]);
}

/**
 * Regular expression matching characters to ignore when calculating the initials.
 * The first part matches characters within parenthesis, including the parenthesis.
 * The second part matches special ASCII characters except space, plus some unicode special characters.
 */
const UNWANTED_CHARS_REGEX = /\([^)]*\)|[\0-\u001F\!-/:-@\[-`\{-\u00BF\u0250-\u036F\uD800-\uFFFF]/g;
/**
 * Regular expression matching phone numbers. Applied after chars matching UNWANTED_CHARS_REGEX have been removed
 * and number has been trimmed for whitespaces
 */
const PHONENUMBER_REGEX = /^\d+[\d\s]*(:?ext|x|)\s*\d+$/i;
/** Regular expression matching one or more spaces. */
const MULTIPLE_WHITESPACES_REGEX = /\s+/g;
/**
 * Regular expression matching languages for which we currently don't support initials.
 * Arabic:   Arabic, Arabic Supplement, Arabic Extended-A.
 * Korean:   Hangul Jamo, Hangul Compatibility Jamo, Hangul Jamo Extended-A, Hangul Syllables, Hangul Jamo Extended-B.
 * Japanese: Hiragana, Katakana.
 * CJK:      CJK Unified Ideographs Extension A, CJK Unified Ideographs, CJK Compatibility Ideographs, CJK Unified Ideographs Extension B
 */
/* tslint:disable:max-line-length */
const UNSUPPORTED_TEXT_REGEX = /[\u0600-\u06FF\u0750-\u077F\u08A0-\u08FF\u1100-\u11FF\u3130-\u318F\uA960-\uA97F\uAC00-\uD7AF\uD7B0-\uD7FF\u3040-\u309F\u30A0-\u30FF\u3400-\u4DBF\u4E00-\u9FFF\uF900-\uFAFF]|[\uD840-\uD869][\uDC00-\uDED6]/;
/* tslint:enable:max-line-length */
function getInitialsLatin(displayName, isRtl) {
    let initials = '';
    const splits = displayName.split(' ');
    if (splits.length === 2) {
        initials += splits[0].charAt(0).toUpperCase();
        initials += splits[1].charAt(0).toUpperCase();
    }
    else if (splits.length === 3) {
        initials += splits[0].charAt(0).toUpperCase();
        initials += splits[2].charAt(0).toUpperCase();
    }
    else if (splits.length !== 0) {
        initials += splits[0].charAt(0).toUpperCase();
    }
    if (isRtl && initials.length > 1) {
        return initials.charAt(1) + initials.charAt(0);
    }
    return initials;
}
function cleanupDisplayName(displayName) {
    displayName = displayName.replace(UNWANTED_CHARS_REGEX, '');
    displayName = displayName.replace(MULTIPLE_WHITESPACES_REGEX, ' ');
    displayName = displayName.trim();
    return displayName;
}
/**
 * Get (up to 2 characters) initials based on display name of the persona.
 *
 * @public
 */
function getInitials(displayName, isRtl, allowPhoneInitials) {
    if (!displayName) {
        return '';
    }
    displayName = cleanupDisplayName(displayName);
    // For names containing CJK characters, and phone numbers, we don't display initials
    if (UNSUPPORTED_TEXT_REGEX.test(displayName) || (!allowPhoneInitials && PHONENUMBER_REGEX.test(displayName))) {
        return '';
    }
    return getInitialsLatin(displayName, isRtl);
}

/**
 * Fetches an item from local storage without throwing an exception
 * @param key The key of the item to fetch from local storage
 */
function getItem(key) {
    let result = null;
    try {
        result = window.localStorage.getItem(key);
    }
    catch (e) {
        /* Eat the exception */
    }
    return result;
}
/**
 * Inserts an item into local storage without throwing an exception
 * @param key The key of the item to add to local storage
 * @param data The data to put into local storage
 */
function setItem(key, data) {
    try {
        window.localStorage.setItem(key, data);
    }
    catch (e) {
        /* Eat the exception */
    }
}

// Default to undefined so that we initialize on first read.
let _language;
/**
 * Gets the rtl state of the page (returns true if in rtl.)
 *
 * @public
 */
function getLanguage() {
    if (_language === undefined) {
        let doc = getDocument();
        const savedLanguage = getItem('language');
        if (savedLanguage !== null) {
            _language = savedLanguage;
        }
        if (_language === undefined && doc) {
            _language = doc.documentElement.getAttribute('lang');
        }
        if (_language === undefined) {
            _language = 'en';
        }
    }
    return _language;
}
/**
 * Sets the rtl state of the page (by adjusting the dir attribute of the html element.)
 *
 * @public
 */
function setLanguage(language, avoidPersisting = false) {
    let doc = getDocument();
    if (doc) {
        doc.documentElement.setAttribute('lang', language);
    }
    if (!avoidPersisting) {
        setItem('language', language);
    }
    _language = language;
}

/**
 * Determines the distance between two points.
 *
 * @public
 */
function getDistanceBetweenPoints(point1, point2) {
    let distance = Math.sqrt(Math.pow(point1.x - point2.x, 2) + Math.pow(point1.y - point2.y, 2));
    return distance;
}
/**
 * Produces a proportionally-scaled version of an input content size when fit to a bounding size.
 * Given a `contentSize` and a `boundsSize`, this function scales `contentSize` proportionally
 * using either `contain` or `cover` fit behaviors.
 * Use this function to pre-calculate the layout for the CSS `object-fit` and `background-fit` behaviors.
 * With `contain`, the output size must be the largest it can be while completely within the `boundsSize`.
 * With `cover`, the output size must be the smallest it can be while completely around the `boundsSize`.
 * By default, there is a `maxScale` value of 1, which prevents the `contentSize` from being scaled larger.
 *
 * @param options - the options for the bounds fit operation
 */
function fitContentToBounds(options) {
    const { contentSize, boundsSize, mode = 'contain', maxScale = 1 } = options;
    const contentAspectRatio = contentSize.width / contentSize.height;
    const boundsAspectRatio = boundsSize.width / boundsSize.height;
    let scale;
    if (mode === 'contain' ? contentAspectRatio > boundsAspectRatio : contentAspectRatio < boundsAspectRatio) {
        scale = boundsSize.width / contentSize.width;
    }
    else {
        scale = boundsSize.height / contentSize.height;
    }
    const finalScale = Math.min(maxScale, scale);
    return {
        width: contentSize.width * finalScale,
        height: contentSize.height * finalScale
    };
}
/**
 * Calculates a number's precision based on the number of trailing
 * zeros if the number does not have a decimal indicated by a negative
 * precision. Otherwise, it calculates the number of digits after
 * the decimal point indicated by a positive precision.
 * @param value - the value to determine the precision of
 */
function calculatePrecision(value) {
    /**
     * Group 1:
     * [1-9]([0]+$) matches trailing zeros
     * Group 2:
     * \.([0-9]*) matches all digits after a decimal point.
     */
    const groups = /[1-9]([0]+$)|\.([0-9]*)/.exec(String(value));
    if (!groups) {
        return 0;
    }
    if (groups[1]) {
        return -groups[1].length;
    }
    if (groups[2]) {
        return groups[2].length;
    }
    return 0;
}
/**
 * Rounds a number to a certain level of precision. Accepts negative precision.
 * @param value - The value that is being rounded.
 * @param precision - The number of decimal places to round the number to
 */
function precisionRound(value, precision, base = 10) {
    const exp = Math.pow(base, precision);
    return Math.round(value * exp) / exp;
}

const stylesheet$1 = Stylesheet.getInstance();
if (stylesheet$1 && stylesheet$1.onReset) {
    Stylesheet.getInstance().onReset(resetMemoizations);
}
let _resetCounter = 0;
const _emptyObject = { empty: true };
const _dictionary = {};
let _weakMap = typeof WeakMap === 'undefined' ? null : WeakMap;
/**
 *  Test utility for providing a custom weakmap.
 *
 * @internal
 * */
function setMemoizeWeakMap(weakMap) {
    _weakMap = weakMap;
}
/**
 * Reset memoizations.
 */
function resetMemoizations() {
    _resetCounter++;
}
/**
 * Memoize decorator to be used on class methods. Note that the "this" reference
 * will be inaccessible within a memoized method, given that a cached method's this
 * would not be instance specific.
 *
 * @public
 */
function memoize(target, key, descriptor) {
    // We bind to "null" to prevent people from inadvertently pulling values from "this",
    // rather than passing them in as input values which can be memoized.
    let fn = memoizeFunction(descriptor.value && descriptor.value.bind(null));
    return {
        configurable: true,
        get() {
            return fn;
        }
    };
}
/**
 * Memoizes a function; when you pass in the same parameters multiple times, it returns a cached result.
 * Be careful when passing in objects, you need to pass in the same INSTANCE for caching to work. Otherwise
 * it will grow the cache unnecessarily. Also avoid using default values that evaluate functions; passing in
 * undefined for a value and relying on a default function will execute it the first time, but will not
 * re-evaluate subsequent times which may have been unexpected.
 *
 * By default, the cache will reset after 100 permutations, to avoid abuse cases where the function is
 * unintendedly called with unique objects. Without a reset, the cache could grow infinitely, so we safeguard
 * by resetting. To override this behavior, pass a value of 0 to the maxCacheSize parameter.
 *
 * @public
 * @param cb - The function to memoize.
 * @param maxCacheSize - Max results to cache. If the cache exceeds this value, it will reset on the next call.
 * @returns A memoized version of the function.
 */
function memoizeFunction(cb, maxCacheSize = 100) {
    // Avoid breaking scenarios which don't have weak map.
    if (!_weakMap) {
        return cb;
    }
    let rootNode;
    let cacheSize = 0;
    let localResetCounter = _resetCounter;
    // tslint:disable-next-line:no-function-expression
    return function memoizedFunction(...args) {
        let currentNode = rootNode;
        if (rootNode === undefined || localResetCounter !== _resetCounter || (maxCacheSize > 0 && cacheSize > maxCacheSize)) {
            rootNode = _createNode();
            cacheSize = 0;
            localResetCounter = _resetCounter;
        }
        currentNode = rootNode;
        // Traverse the tree until we find the match.
        for (let i = 0; i < args.length; i++) {
            let arg = _normalizeArg(args[i]);
            if (!currentNode.map.has(arg)) {
                currentNode.map.set(arg, _createNode());
            }
            currentNode = currentNode.map.get(arg);
        }
        if (!currentNode.hasOwnProperty('value')) {
            currentNode.value = cb(...args);
            cacheSize++;
        }
        return currentNode.value;
    };
}
function _normalizeArg(val) {
    if (!val) {
        return _emptyObject;
    }
    else if (typeof val === 'object' || typeof val === 'function') {
        return val;
    }
    else if (!_dictionary[val]) {
        _dictionary[val] = { val };
    }
    return _dictionary[val];
}
function _createNode() {
    return {
        map: _weakMap ? new _weakMap() : null
    };
}

/**
 * Simple deep merge function. Takes all arguments and returns a deep copy of the objects merged
 * together in the order provided. If an object creates a circular reference, it will assign the
 * original reference.
 */
function merge(target, ...args) {
    for (const arg of args) {
        _merge(target || {}, arg);
    }
    return target;
}
/**
 * The _merge helper iterates through all props on source and assigns them to target.
 * When the value is an object, we will create a deep clone of the object. However if
 * there is a circular reference, the value will not be deep cloned and will persist
 * the reference.
 */
// tslint:disable-next-line:no-any
function _merge(target, source, circularReferences = []) {
    circularReferences.push(source);
    for (let name in source) {
        if (source.hasOwnProperty(name)) {
            const value = source[name];
            if (typeof value === 'object') {
                const isCircularReference = circularReferences.indexOf(value) > -1;
                //@ts-ignore
                target[name] = isCircularReference ? value : _merge(target[name] || {}, value, circularReferences);
            }
            else {
                target[name] = value;
            }
        }
    }
    circularReferences.pop();
    return target;
}

/**
 * Returns true if and only if the user is on a iOS device.
 * Used to determine whether iOS-specific behavior should be applied.
 */
const isIOS = () => {
    if (!window || !window.navigator || !window.navigator.userAgent) {
        return false;
    }
    return /iPad|iPhone|iPod/i.test(window.navigator.userAgent);
};

let isMacResult;
/**
 * Returns true if the user is on a Mac. Caches the result value.
 * @param reset - Reset the cached result value (mainly for testing).
 */
function isMac(reset) {
    if (typeof isMacResult === 'undefined' || reset) {
        const userAgent = typeof window !== 'undefined' && window.navigator.userAgent;
        isMacResult = !!userAgent && userAgent.indexOf('Macintosh') !== -1;
    }
    return !!isMacResult;
}

/**
 * Detects whether an element's content has horizontal overflow
 *
 * @public
 * @param element - Element to check for overflow
 * @returns True if element's content overflows
 */
function hasHorizontalOverflow(element) {
    return element.clientWidth < element.scrollWidth;
}
/**
 * Detects whether an element's content has vertical overflow
 *
 * @public
 * @param element - Element to check for overflow
 * @returns True if element's content overflows
 */
function hasVerticalOverflow(element) {
    return element.clientHeight < element.scrollHeight;
}
/**
 * Detects whether an element's content has overflow in any direction
 *
 * @public
 * @param element - Element to check for overflow
 * @returns True if element's content overflows
 */
function hasOverflow(element) {
    return hasHorizontalOverflow(element) || hasVerticalOverflow(element);
}

/**
 * An array of events that are allowed on every html element type.
 *
 * @public
 */
const baseElementEvents = [
    'onCopy',
    'onCut',
    'onPaste',
    'onCompositionEnd',
    'onCompositionStart',
    'onCompositionUpdate',
    'onFocus',
    'onFocusCapture',
    'onBlur',
    'onBlurCapture',
    'onChange',
    'onInput',
    'onSubmit',
    'onLoad',
    'onError',
    'onKeyDown',
    'onKeyDownCapture',
    'onKeyPress',
    'onKeyUp',
    'onAbort',
    'onCanPlay',
    'onCanPlayThrough',
    'onDurationChange',
    'onEmptied',
    'onEncrypted',
    'onEnded',
    'onLoadedData',
    'onLoadedMetadata',
    'onLoadStart',
    'onPause',
    'onPlay',
    'onPlaying',
    'onProgress',
    'onRateChange',
    'onSeeked',
    'onSeeking',
    'onStalled',
    'onSuspend',
    'onTimeUpdate',
    'onVolumeChange',
    'onWaiting',
    'onClick',
    'onClickCapture',
    'onContextMenu',
    'onDoubleClick',
    'onDrag',
    'onDragEnd',
    'onDragEnter',
    'onDragExit',
    'onDragLeave',
    'onDragOver',
    'onDragStart',
    'onDrop',
    'onMouseDown',
    'onMouseDownCapture',
    'onMouseEnter',
    'onMouseLeave',
    'onMouseMove',
    'onMouseOut',
    'onMouseOver',
    'onMouseUp',
    'onMouseUpCapture',
    'onSelect',
    'onTouchCancel',
    'onTouchEnd',
    'onTouchMove',
    'onTouchStart',
    'onScroll',
    'onWheel'
];
/**
 * An array of element attributes which are allowed on every html element type.
 *
 * @public
 */
const baseElementProperties = [
    'defaultChecked',
    'defaultValue',
    'accept',
    'acceptCharset',
    'accessKey',
    'action',
    'allowFullScreen',
    'allowTransparency',
    'alt',
    'async',
    'autoComplete',
    'autoFocus',
    'autoPlay',
    'capture',
    'cellPadding',
    'cellSpacing',
    'charSet',
    'challenge',
    'checked',
    'children',
    'classID',
    'className',
    'cols',
    'colSpan',
    'content',
    'contentEditable',
    'contextMenu',
    'controls',
    'coords',
    'crossOrigin',
    'data',
    'dateTime',
    'default',
    'defer',
    'dir',
    'download',
    'draggable',
    'encType',
    'form',
    'formAction',
    'formEncType',
    'formMethod',
    'formNoValidate',
    'formTarget',
    'frameBorder',
    'headers',
    'height',
    'hidden',
    'high',
    'hrefLang',
    'htmlFor',
    'httpEquiv',
    'icon',
    'id',
    'inputMode',
    'integrity',
    'is',
    'keyParams',
    'keyType',
    'kind',
    'lang',
    'list',
    'loop',
    'low',
    'manifest',
    'marginHeight',
    'marginWidth',
    'max',
    'maxLength',
    'media',
    'mediaGroup',
    'method',
    'min',
    'minLength',
    'multiple',
    'muted',
    'name',
    'noValidate',
    'open',
    'optimum',
    'pattern',
    'placeholder',
    'poster',
    'preload',
    'radioGroup',
    'readOnly',
    'rel',
    'required',
    'role',
    'rows',
    'rowSpan',
    'sandbox',
    'scope',
    'scoped',
    'scrolling',
    'seamless',
    'selected',
    'shape',
    'size',
    'sizes',
    'span',
    'spellCheck',
    'src',
    'srcDoc',
    'srcLang',
    'srcSet',
    'start',
    'step',
    'style',
    'summary',
    'tabIndex',
    'title',
    'type',
    'useMap',
    'value',
    'width',
    'wmode',
    'wrap'
];
/**
 * An array of HTML element properties and events.
 *
 * @public
 */
const htmlElementProperties = baseElementProperties.concat(baseElementEvents);
/**
 * An array of A tag properties and events.
 *
 * @public
 */
const anchorProperties = htmlElementProperties.concat(['href', 'target']);
/**
 * An array of BUTTON tag properties and events.
 *
 * @public
 */
const buttonProperties = htmlElementProperties.concat(['disabled']);
/**
 * An array of DIV tag properties and events.
 *
 * @public
 */
const divProperties = htmlElementProperties.concat(['align', 'noWrap']);
/**
 * An array of INPUT tag properties and events.
 *
 * @public
 */
const inputProperties = buttonProperties;
/**
 * An array of TEXTAREA tag properties and events.
 *
 * @public
 */
const textAreaProperties = buttonProperties;
/**
 * An array of IMAGE tag properties and events.
 *
 * @public
 */
const imageProperties = divProperties;
/**
 * Gets native supported props for an html element provided the allowance set. Use one of the property
 * sets defined (divProperties, buttonPropertes, etc) to filter out supported properties from a given
 * props set. Note that all data- and aria- prefixed attributes will be allowed.
 * NOTE: getNativeProps should always be applied first when adding props to a react component. The
 * non-native props should be applied second. This will prevent getNativeProps from overriding your custom props.
 * For example, if props passed to getNativeProps has an onClick function and getNativeProps is added to
 * the component after an onClick function is added, then the getNativeProps onClick will override it.
 *
 * @public
 * @param props - The unfiltered input props
 * @param allowedPropsNames-  The array of allowed propnames.
 * @returns The filtered props
 */
function getNativeProps(props, allowedPropNames, excludedPropNames) {
    return filteredAssign((propName) => {
        return ((!excludedPropNames || excludedPropNames.indexOf(propName) < 0) &&
            (propName.indexOf('data-') === 0 || propName.indexOf('aria-') === 0 || allowedPropNames.indexOf(propName) >= 0));
    }, {}, props);
}

let _baseUrl = '';
/** Sets the current base url used for fetching images. */
function getResourceUrl(url) {
    return _baseUrl + url;
}
/** Gets the current base url used for fetching images. */
function setBaseUrl(baseUrl) {
    _baseUrl = baseUrl;
}

/**
 * Fetches an item from session storage without throwing an exception
 * @param key The key of the item to fetch from session storage
 */
function getItem$1(key) {
    let result = null;
    try {
        result = window.sessionStorage.getItem(key);
    }
    catch (e) {
        /* Eat the exception */
    }
    return result;
}
/**
 * Inserts an item into session storage without throwing an exception
 * @param key The key of the item to add to session storage
 * @param data The data to put into session storage
 */
function setItem$1(key, data) {
    try {
        window.sessionStorage.setItem(key, data);
    }
    catch (e) {
        /* Eat the exception */
    }
}

const RTL_LOCAL_STORAGE_KEY = 'isRTL';
// Default to undefined so that we initialize on first read.
let _isRTL;
/**
 * Gets the rtl state of the page (returns true if in rtl.)
 */
function getRTL() {
    if (_isRTL === undefined) {
        // Fabric supports persisting the RTL setting between page refreshes via session storage
        let savedRTL = getItem$1(RTL_LOCAL_STORAGE_KEY);
        if (savedRTL !== null) {
            _isRTL = savedRTL === '1';
            setRTL(_isRTL);
        }
        let doc = getDocument();
        if (_isRTL === undefined && doc) {
            _isRTL = doc.documentElement.getAttribute('dir') === 'rtl';
            _msSetRTL(_isRTL);
        }
    }
    return !!_isRTL;
}
/**
 * Sets the rtl state of the page (by adjusting the dir attribute of the html element.)
 */
function setRTL(isRTL, persistSetting = false) {
    let doc = getDocument();
    if (doc) {
        doc.documentElement.setAttribute('dir', isRTL ? 'rtl' : 'ltr');
    }
    if (persistSetting) {
        setItem$1(RTL_LOCAL_STORAGE_KEY, isRTL ? '1' : '0');
    }
    _isRTL = isRTL;
    _msSetRTL(_isRTL);
}
/**
 * Returns the given key, but flips right/left arrows if necessary.
 */
function getRTLSafeKeyCode(key) {
    if (getRTL()) {
        if (key === KeyCodes.left) {
            key = KeyCodes.right;
        }
        else if (key === KeyCodes.right) {
            key = KeyCodes.left;
        }
    }
    return key;
}

// Regex that finds { and } so they can be removed on a lookup for string format
const FORMAT_ARGS_REGEX = /[\{\}]/g;
// Regex that finds {#} so it can be replaced by the arguments in string format
const FORMAT_REGEX = /\{\d+\}/g;
function format(s, ...values) {
    //'use strict';
    let args = values;
    // Callback match function
    function replace_func(match) {
        // looks up in the args
        // tslint:disable-next-line:no-any
        let replacement = args[match.replace(FORMAT_ARGS_REGEX, '')];
        // catches undefined in nondebug and null in debug and nondebug
        if (replacement === null || replacement === undefined) {
            replacement = '';
        }
        return replacement;
    }
    return s.replace(FORMAT_REGEX, replace_func);
}

const DefaultFields = ['theme', 'styles'];
/**
 * The styled HOC wrapper allows you to create a functional wrapper around a given component which will resolve
 * getStyles functional props, and mix customized props passed in using concatStyleSets.
 *
 * @example
 * ```tsx
 * export const Toggle = styled(
 *   ToggleBase,
 *   props => ({ root: { background: 'red' }})
 * );
 * ```
 * @param Component - The unstyled base component to render, which receives styles.
 * @param baseStyles - The styles which should be curried with the component.
 * @param getProps - A helper which provides default props.
 * @param customizable - An object which defines which props can be customized using the Customizer.
 */
function styled(Component$$1, baseStyles, getProps, customizable) {
    customizable = customizable || { scope: '', fields: undefined };
    const { scope, fields = DefaultFields } = customizable;
    class Wrapped extends Component {
        constructor() {
            super(...arguments);
            this._inCustomizerContext = false;
            this._onSettingsChanged = () => this.forceUpdate();
        }
        render() {
            return (createElement(CustomizerContext.Consumer, null, (context) => {
                this._inCustomizerContext = !!context.customizations.inCustomizerContext;
                const settings = Customizations.getSettings(fields, scope, context.customizations);
                const { styles: customizedStyles, ...rest } = settings;
                const styles = (styleProps) => _resolve(styleProps, baseStyles, customizedStyles, this.props.styles);
                const additionalProps = getProps ? getProps(this.props) : undefined;
                return createElement(Component$$1, Object.assign({}, rest, additionalProps, this.props, { styles: styles }));
            }));
        }
        componentDidMount() {
            if (!this._inCustomizerContext) {
                Customizations.observe(this._onSettingsChanged);
            }
        }
        componentWillUnmount() {
            if (!this._inCustomizerContext) {
                Customizations.unobserve(this._onSettingsChanged);
            }
        }
    }
    Wrapped.displayName = `Styled${Component$$1.displayName || Component$$1.name}`;
    // This preserves backwards compatibility.
    // tslint:disable-next-line:no-any
    return Wrapped;
}
function _resolve(styleProps, ...allStyles) {
    const result = [];
    for (const styles of allStyles) {
        if (styles) {
            result.push(typeof styles === 'function' ? styles(styleProps) : styles);
        }
    }
    if (result.length) {
        // cliffkoh: I cannot figure out how to avoid the cast to any here.
        // It is something to do with the use of Omit in IStyleSet.
        // It might not be necessary once  Omit becomes part of lib.d.ts (when we remove our own Omit and rely on
        // the official version).
        // tslint:disable-next-line:no-any
        return concatStyleSets(...result);
    }
    return undefined;
}

// @uifabric/utilities@6.27.2
setVersion('@uifabric/utilities', '6.27.2');

/**
 * Builds a class names object from a given map.
 *
 * @param styles - Map of unprocessed styles.
 * @returns Map of property name to class name.
 */
function buildClassMap(styles) {
    let classes = {};
    for (let styleName in styles) {
        if (styles.hasOwnProperty(styleName)) {
            let className;
            Object.defineProperty(classes, styleName, {
                get: () => {
                    if (className === undefined) {
                        // tslint:disable-next-line:no-any
                        className = mergeStyles(styles[styleName]).toString();
                    }
                    return className;
                },
                enumerable: true,
                configurable: true
            });
        }
    }
    return classes;
}

const ICON_SETTING_NAME = 'icons';
const _iconSettings = GlobalSettings.getValue(ICON_SETTING_NAME, {
    __options: {
        disableWarnings: false,
        warnOnMissingIcons: true
    },
    __remapped: {}
});
// Reset icon registration on stylesheet resets.
const stylesheet$2 = Stylesheet.getInstance();
if (stylesheet$2 && stylesheet$2.onReset) {
    stylesheet$2.onReset(() => {
        for (const name in _iconSettings) {
            if (_iconSettings.hasOwnProperty(name) && !!_iconSettings[name].subset) {
                _iconSettings[name].subset.className = undefined;
            }
        }
    });
}
/**
 * Normalizes an icon name for consistent mapping.
 * Current implementation is to convert the icon name to lower case.
 *
 * @param name - Icon name to normalize.
 * @returns {string} Normalized icon name to use for indexing and mapping.
 */
const normalizeIconName = (name) => name.toLowerCase();
/**
 * Registers a given subset of icons.
 *
 * @param iconSubset - the icon subset definition.
 */
function registerIcons(iconSubset, options) {
    let subset = {
        ...iconSubset,
        isRegistered: false,
        className: undefined
    };
    let { icons } = iconSubset;
    // Grab options, optionally mix user provided ones on top.
    options = options ? { ..._iconSettings.__options, ...options } : _iconSettings.__options;
    for (const iconName in icons) {
        if (icons.hasOwnProperty(iconName)) {
            const code = icons[iconName];
            const normalizedIconName = normalizeIconName(iconName);
            if (_iconSettings[normalizedIconName]) {
                _warnDuplicateIcon(iconName);
            }
            else {
                _iconSettings[normalizedIconName] = {
                    code,
                    subset
                };
            }
        }
    }
}
/**
 * Unregisters icons by name.
 *
 * @param iconNames - List of icons to unregister.
 */
function unregisterIcons(iconNames) {
    const options = _iconSettings.__options;
    for (const iconName of iconNames) {
        const normalizedIconName = normalizeIconName(iconName);
        if (_iconSettings[normalizedIconName]) {
            delete _iconSettings[normalizedIconName];
        }
        else {
            // Warn that we are trying to delete an icon that doesn't exist
            if (!options.disableWarnings) {
                warn(`The icon "${iconName}" tried to unregister but was not registered.`);
            }
        }
        // Delete any aliases for this iconName
        if (_iconSettings.__remapped[normalizedIconName]) {
            delete _iconSettings.__remapped[normalizedIconName];
        }
        // Delete any items that were an alias for this iconName
        Object.keys(_iconSettings.__remapped).forEach((key) => {
            if (_iconSettings.__remapped[key] === normalizedIconName) {
                delete _iconSettings.__remapped[key];
            }
        });
    }
}
/**
 * Remaps one icon name to another.
 */
function registerIconAlias(iconName, mappedToName) {
    _iconSettings.__remapped[normalizeIconName(iconName)] = normalizeIconName(mappedToName);
}
/**
 * Gets an icon definition. If an icon is requested but the subset has yet to be registered,
 * it will get registered immediately.
 *
 * @public
 * @param name - Name of icon.
 */
function getIcon(name) {
    let icon = undefined;
    const options = _iconSettings.__options;
    name = name ? normalizeIconName(name) : '';
    name = _iconSettings.__remapped[name] || name;
    if (name) {
        icon = _iconSettings[name];
        if (icon) {
            let { subset } = icon;
            if (subset && subset.fontFace) {
                if (!subset.isRegistered) {
                    fontFace(subset.fontFace);
                    subset.isRegistered = true;
                }
                if (!subset.className) {
                    subset.className = mergeStyles(subset.style, {
                        fontFamily: subset.fontFace.fontFamily,
                        fontWeight: subset.fontFace.fontWeight || 'normal',
                        fontStyle: subset.fontFace.fontStyle || 'normal'
                    });
                }
            }
        }
        else {
            if (!options.disableWarnings && options.warnOnMissingIcons) {
                warn(`The icon "${name}" was used but not registered. See http://aka.ms/fabric-icon-usage for more information.`);
            }
        }
    }
    return icon;
}
/**
 * Sets the icon options.
 *
 * @public
 */
function setIconOptions(options) {
    _iconSettings.__options = {
        ..._iconSettings.__options,
        ...options
    };
}
let _missingIcons = [];
let _missingIconsTimer = undefined;
function _warnDuplicateIcon(iconName) {
    const options = _iconSettings.__options;
    const warningDelay = 2000;
    const maxIconsInMessage = 10;
    if (!options.disableWarnings) {
        _missingIcons.push(iconName);
        if (_missingIconsTimer === undefined) {
            _missingIconsTimer = self.setTimeout(() => {
                warn(`Some icons were re-registered. Applications should only call registerIcons for any given ` +
                    `icon once. Redefining what an icon is may have unintended consequences. Duplicates ` +
                    `include: \n` +
                    _missingIcons.slice(0, maxIconsInMessage).join(', ') +
                    (_missingIcons.length > maxIconsInMessage ? ` (+ ${_missingIcons.length - maxIconsInMessage} more)` : ''));
                _missingIconsTimer = undefined;
                _missingIcons = [];
            }, warningDelay);
        }
    }
}

const defaultIconStyles = {
    display: 'inline-block'
};
/**
 * Gets an icon classname. You should be able to add this classname to an I tag with no
 * additional classnames, and render the icon.
 *
 * @public
 */
function getIconClassName(name) {
    let className = '';
    const icon = getIcon(name);
    if (icon) {
        className = mergeStyles(icon.subset.className, defaultIconStyles, {
            selectors: {
                '::before': {
                    content: `"${icon.code}"`
                }
            }
        });
    }
    return className;
}

/* Register the keyframes */
const EASING_FUNCTION_1 = 'cubic-bezier(.1,.9,.2,1)';
const EASING_FUNCTION_2 = 'cubic-bezier(.1,.25,.75,.9)';
const DURATION_1 = '0.167s';
const DURATION_2 = '0.267s';
const DURATION_3 = '0.367s';
const DURATION_4 = '0.467s';
const FADE_IN = keyframes({
    from: { opacity: 0 },
    to: { opacity: 1 }
});
const FADE_OUT = keyframes({
    from: { opacity: 1 },
    to: { opacity: 0 }
});
const SLIDE_RIGHT_IN10 = _createSlideInX(-10);
const SLIDE_RIGHT_IN20 = _createSlideInX(-20);
const SLIDE_RIGHT_IN40 = _createSlideInX(-40);
const SLIDE_RIGHT_IN400 = _createSlideInX(-400);
const SLIDE_LEFT_IN10 = _createSlideInX(10);
const SLIDE_LEFT_IN20 = _createSlideInX(20);
const SLIDE_LEFT_IN40 = _createSlideInX(40);
const SLIDE_LEFT_IN400 = _createSlideInX(400);
const SLIDE_UP_IN10 = _createSlideInY(10);
const SLIDE_UP_IN20 = _createSlideInY(20);
const SLIDE_DOWN_IN10 = _createSlideInY(-10);
const SLIDE_DOWN_IN20 = _createSlideInY(-20);
const SLIDE_RIGHT_OUT10 = _createSlideOutX(10);
const SLIDE_RIGHT_OUT20 = _createSlideOutX(20);
const SLIDE_RIGHT_OUT40 = _createSlideOutX(40);
const SLIDE_RIGHT_OUT400 = _createSlideOutX(400);
const SLIDE_LEFT_OUT10 = _createSlideOutX(-10);
const SLIDE_LEFT_OUT20 = _createSlideOutX(-20);
const SLIDE_LEFT_OUT40 = _createSlideOutX(-40);
const SLIDE_LEFT_OUT400 = _createSlideOutX(-400);
const SLIDE_UP_OUT10 = _createSlideOutY(-10);
const SLIDE_UP_OUT20 = _createSlideOutY(-20);
const SLIDE_DOWN_OUT10 = _createSlideOutY(10);
const SLIDE_DOWN_OUT20 = _createSlideOutY(20);
const SCALE_UP100 = keyframes({
    from: { transform: 'scale3d(.98,.98,1)' },
    to: { transform: 'scale3d(1,1,1)' }
});
const SCALE_DOWN98 = keyframes({
    from: { transform: 'scale3d(1,1,1)' },
    to: { transform: 'scale3d(.98,.98,1)' }
});
const SCALE_DOWN100 = keyframes({
    from: { transform: 'scale3d(1.03,1.03,1)' },
    to: { transform: 'scale3d(1,1,1)' }
});
const SCALE_UP103 = keyframes({
    from: { transform: 'scale3d(1,1,1)' },
    to: { transform: 'scale3d(1.03,1.03,1)' }
});
const ROTATE90 = keyframes({
    from: { transform: 'rotateZ(0deg)' },
    to: { transform: 'rotateZ(90deg)' }
});
const ROTATE_N90 = keyframes({
    from: { transform: 'rotateZ(0deg)' },
    to: { transform: 'rotateZ(-90deg)' }
});
/**
 * Exporting raw duraction values and easing functions to be used in custom animations
 */
const AnimationVariables = {
    easeFunction1: EASING_FUNCTION_1,
    easeFunction2: EASING_FUNCTION_2,
    durationValue1: DURATION_1,
    durationValue2: DURATION_2,
    durationValue3: DURATION_3,
    durationValue4: DURATION_4
};
/**
 * All Fabric standard animations, exposed as json objects referencing predefined
 * keyframes. These objects can be mixed in with other class definitions.
 */
const AnimationStyles = {
    slideRightIn10: _createAnimation(`${FADE_IN},${SLIDE_RIGHT_IN10}`, DURATION_3, EASING_FUNCTION_1),
    slideRightIn20: _createAnimation(`${FADE_IN},${SLIDE_RIGHT_IN20}`, DURATION_3, EASING_FUNCTION_1),
    slideRightIn40: _createAnimation(`${FADE_IN},${SLIDE_RIGHT_IN40}`, DURATION_3, EASING_FUNCTION_1),
    slideRightIn400: _createAnimation(`${FADE_IN},${SLIDE_RIGHT_IN400}`, DURATION_3, EASING_FUNCTION_1),
    slideLeftIn10: _createAnimation(`${FADE_IN},${SLIDE_LEFT_IN10}`, DURATION_3, EASING_FUNCTION_1),
    slideLeftIn20: _createAnimation(`${FADE_IN},${SLIDE_LEFT_IN20}`, DURATION_3, EASING_FUNCTION_1),
    slideLeftIn40: _createAnimation(`${FADE_IN},${SLIDE_LEFT_IN40}`, DURATION_3, EASING_FUNCTION_1),
    slideLeftIn400: _createAnimation(`${FADE_IN},${SLIDE_LEFT_IN400}`, DURATION_3, EASING_FUNCTION_1),
    slideUpIn10: _createAnimation(`${FADE_IN},${SLIDE_UP_IN10}`, DURATION_3, EASING_FUNCTION_1),
    slideUpIn20: _createAnimation(`${FADE_IN},${SLIDE_UP_IN20}`, DURATION_3, EASING_FUNCTION_1),
    slideDownIn10: _createAnimation(`${FADE_IN},${SLIDE_DOWN_IN10}`, DURATION_3, EASING_FUNCTION_1),
    slideDownIn20: _createAnimation(`${FADE_IN},${SLIDE_DOWN_IN20}`, DURATION_3, EASING_FUNCTION_1),
    slideRightOut10: _createAnimation(`${FADE_OUT},${SLIDE_RIGHT_OUT10}`, DURATION_3, EASING_FUNCTION_1),
    slideRightOut20: _createAnimation(`${FADE_OUT},${SLIDE_RIGHT_OUT20}`, DURATION_3, EASING_FUNCTION_1),
    slideRightOut40: _createAnimation(`${FADE_OUT},${SLIDE_RIGHT_OUT40}`, DURATION_3, EASING_FUNCTION_1),
    slideRightOut400: _createAnimation(`${FADE_OUT},${SLIDE_RIGHT_OUT400}`, DURATION_3, EASING_FUNCTION_1),
    slideLeftOut10: _createAnimation(`${FADE_OUT},${SLIDE_LEFT_OUT10}`, DURATION_3, EASING_FUNCTION_1),
    slideLeftOut20: _createAnimation(`${FADE_OUT},${SLIDE_LEFT_OUT20}`, DURATION_3, EASING_FUNCTION_1),
    slideLeftOut40: _createAnimation(`${FADE_OUT},${SLIDE_LEFT_OUT40}`, DURATION_3, EASING_FUNCTION_1),
    slideLeftOut400: _createAnimation(`${FADE_OUT},${SLIDE_LEFT_OUT400}`, DURATION_3, EASING_FUNCTION_1),
    slideUpOut10: _createAnimation(`${FADE_OUT},${SLIDE_UP_OUT10}`, DURATION_3, EASING_FUNCTION_1),
    slideUpOut20: _createAnimation(`${FADE_OUT},${SLIDE_UP_OUT20}`, DURATION_3, EASING_FUNCTION_1),
    slideDownOut10: _createAnimation(`${FADE_OUT},${SLIDE_DOWN_OUT10}`, DURATION_3, EASING_FUNCTION_1),
    slideDownOut20: _createAnimation(`${FADE_OUT},${SLIDE_DOWN_OUT20}`, DURATION_3, EASING_FUNCTION_1),
    scaleUpIn100: _createAnimation(`${FADE_IN},${SCALE_UP100}`, DURATION_3, EASING_FUNCTION_1),
    scaleDownIn100: _createAnimation(`${FADE_IN},${SCALE_DOWN100}`, DURATION_3, EASING_FUNCTION_1),
    scaleUpOut103: _createAnimation(`${FADE_OUT},${SCALE_UP103}`, DURATION_1, EASING_FUNCTION_2),
    scaleDownOut98: _createAnimation(`${FADE_OUT},${SCALE_DOWN98}`, DURATION_1, EASING_FUNCTION_2),
    fadeIn100: _createAnimation(FADE_IN, DURATION_1, EASING_FUNCTION_2),
    fadeIn200: _createAnimation(FADE_IN, DURATION_2, EASING_FUNCTION_2),
    fadeIn400: _createAnimation(FADE_IN, DURATION_3, EASING_FUNCTION_2),
    fadeIn500: _createAnimation(FADE_IN, DURATION_4, EASING_FUNCTION_2),
    fadeOut100: _createAnimation(FADE_OUT, DURATION_1, EASING_FUNCTION_2),
    fadeOut200: _createAnimation(FADE_OUT, DURATION_2, EASING_FUNCTION_2),
    fadeOut400: _createAnimation(FADE_OUT, DURATION_3, EASING_FUNCTION_2),
    fadeOut500: _createAnimation(FADE_OUT, DURATION_4, EASING_FUNCTION_2),
    rotate90deg: _createAnimation(ROTATE90, '0.1s', EASING_FUNCTION_2),
    rotateN90deg: _createAnimation(ROTATE_N90, '0.1s', EASING_FUNCTION_2)
    // expandCollapse 100/200/400, delay 100/200
};
function _createAnimation(animationName, animationDuration, animationTimingFunction) {
    return {
        animationName,
        animationDuration,
        animationTimingFunction,
        animationFillMode: 'both'
    };
}
function _createSlideInX(fromX) {
    return keyframes({
        from: { transform: `translate3d(${fromX}px,0,0)` },
        to: { transform: `translate3d(0,0,0)` }
    });
}
function _createSlideInY(fromY) {
    return keyframes({
        from: { transform: `translate3d(0,${fromY}px,0)` },
        to: { transform: `translate3d(0,0,0)` }
    });
}
function _createSlideOutX(toX) {
    return keyframes({
        from: { transform: `translate3d(0,0,0)` },
        to: { transform: `translate3d(${toX}px,0,0)` }
    });
}
function _createSlideOutY(toY) {
    return keyframes({
        from: { transform: `translate3d(0,0,0)` },
        to: { transform: `translate3d(0,${toY}px,0)` }
    });
}

// When adding or removing a color, make sure you keep this consistent with IColorClassNames by adding the color variants.
const DefaultPalette = {
    themeDarker: '#004578',
    themeDark: '#005a9e',
    themeDarkAlt: '#106ebe',
    themePrimary: '#0078d4',
    themeSecondary: '#2b88d8',
    themeTertiary: '#71afe5',
    themeLight: '#c7e0f4',
    themeLighter: '#deecf9',
    themeLighterAlt: '#eff6fc',
    black: '#000000',
    blackTranslucent40: 'rgba(0,0,0,.4)',
    neutralDark: '#212121',
    neutralPrimary: '#333333',
    neutralPrimaryAlt: '#3c3c3c',
    neutralSecondary: '#666666',
    neutralSecondaryAlt: '#767676',
    neutralTertiary: '#a6a6a6',
    neutralTertiaryAlt: '#c8c8c8',
    neutralQuaternary: '#d0d0d0',
    neutralQuaternaryAlt: '#dadada',
    neutralLight: '#eaeaea',
    neutralLighter: '#f4f4f4',
    neutralLighterAlt: '#f8f8f8',
    accent: '#0078d4',
    white: '#ffffff',
    whiteTranslucent40: 'rgba(255,255,255,.4)',
    yellow: '#ffb900',
    yellowLight: '#fff100',
    orange: '#d83b01',
    orangeLight: '#ea4300',
    orangeLighter: '#ff8c00',
    redDark: '#a80000',
    red: '#e81123',
    magentaDark: '#5c005c',
    magenta: '#b4009e',
    magentaLight: '#e3008c',
    purpleDark: '#32145a',
    purple: '#5c2d91',
    purpleLight: '#b4a0ff',
    blueDark: '#002050',
    blueMid: '#00188f',
    blue: '#0078d4',
    blueLight: '#00bcf2',
    tealDark: '#004b50',
    teal: '#008272',
    tealLight: '#00b294',
    greenDark: '#004b1c',
    green: '#107c10',
    greenLight: '#bad80a'
};

// Fallback fonts, if specified system or web fonts are unavailable.
const FontFamilyFallbacks = `'Segoe UI', -apple-system, BlinkMacSystemFont, 'Roboto', 'Helvetica Neue', sans-serif`;
// Font face names to be registered.
var LocalizedFontNames;
(function (LocalizedFontNames) {
    LocalizedFontNames.Arabic = 'Segoe UI Web (Arabic)';
    LocalizedFontNames.Cyrillic = 'Segoe UI Web (Cyrillic)';
    LocalizedFontNames.EastEuropean = 'Segoe UI Web (East European)';
    LocalizedFontNames.Greek = 'Segoe UI Web (Greek)';
    LocalizedFontNames.Hebrew = 'Segoe UI Web (Hebrew)';
    LocalizedFontNames.Thai = 'Leelawadee UI Web';
    LocalizedFontNames.Vietnamese = 'Segoe UI Web (Vietnamese)';
    LocalizedFontNames.WestEuropean = 'Segoe UI Web (West European)';
    LocalizedFontNames.Selawik = 'Selawik Web';
})(LocalizedFontNames || (LocalizedFontNames = {}));
// Font families with fallbacks, for the general regions.
var LocalizedFontFamilies;
(function (LocalizedFontFamilies) {
    LocalizedFontFamilies.Arabic = `'${LocalizedFontNames.Arabic}'`;
    LocalizedFontFamilies.ChineseSimplified = `'Microsoft Yahei UI', Verdana, Simsun`;
    LocalizedFontFamilies.ChineseTraditional = `'Microsoft Jhenghei UI', Pmingliu`;
    LocalizedFontFamilies.Cyrillic = `'${LocalizedFontNames.Cyrillic}'`;
    LocalizedFontFamilies.EastEuropean = `'${LocalizedFontNames.EastEuropean}'`;
    LocalizedFontFamilies.Greek = `'${LocalizedFontNames.Greek}'`;
    LocalizedFontFamilies.Hebrew = `'${LocalizedFontNames.Hebrew}'`;
    LocalizedFontFamilies.Hindi = `'Nirmala UI'`;
    LocalizedFontFamilies.Japanese = `'Yu Gothic UI', 'Meiryo UI', Meiryo, 'MS Pgothic', Osaka`;
    LocalizedFontFamilies.Korean = `'Malgun Gothic', Gulim`;
    LocalizedFontFamilies.Selawik = `'${LocalizedFontNames.Selawik}'`;
    LocalizedFontFamilies.Thai = `'Leelawadee UI Web', 'Kmer UI'`;
    LocalizedFontFamilies.Vietnamese = `'${LocalizedFontNames.Vietnamese}'`;
    LocalizedFontFamilies.WestEuropean = `'${LocalizedFontNames.WestEuropean}'`;
})(LocalizedFontFamilies || (LocalizedFontFamilies = {}));
// By default, we favor system fonts for the default.
// All localized fonts use a web font and never use the system font.
const defaultFontFamily = `'Segoe UI', '${LocalizedFontNames.WestEuropean}'`;
// Mapping of language prefix to to font family.
const LanguageToFontMap = {
    ar: LocalizedFontFamilies.Arabic,
    bg: LocalizedFontFamilies.Cyrillic,
    cs: LocalizedFontFamilies.EastEuropean,
    el: LocalizedFontFamilies.Greek,
    et: LocalizedFontFamilies.EastEuropean,
    he: LocalizedFontFamilies.Hebrew,
    hi: LocalizedFontFamilies.Hindi,
    hr: LocalizedFontFamilies.EastEuropean,
    hu: LocalizedFontFamilies.EastEuropean,
    ja: LocalizedFontFamilies.Japanese,
    kk: LocalizedFontFamilies.EastEuropean,
    ko: LocalizedFontFamilies.Korean,
    lt: LocalizedFontFamilies.EastEuropean,
    lv: LocalizedFontFamilies.EastEuropean,
    pl: LocalizedFontFamilies.EastEuropean,
    ru: LocalizedFontFamilies.Cyrillic,
    sk: LocalizedFontFamilies.EastEuropean,
    'sr-latn': LocalizedFontFamilies.EastEuropean,
    th: LocalizedFontFamilies.Thai,
    tr: LocalizedFontFamilies.EastEuropean,
    uk: LocalizedFontFamilies.Cyrillic,
    vi: LocalizedFontFamilies.Vietnamese,
    'zh-hans': LocalizedFontFamilies.ChineseSimplified,
    'zh-hant': LocalizedFontFamilies.ChineseTraditional
};
// Standard font sizes.
var FontSizes;
(function (FontSizes) {
    FontSizes.mini = '10px';
    FontSizes.xSmall = '11px';
    FontSizes.small = '12px';
    FontSizes.smallPlus = '13px';
    FontSizes.medium = '14px';
    FontSizes.mediumPlus = '15px';
    FontSizes.icon = '16px';
    FontSizes.large = '17px';
    FontSizes.xLarge = '21px';
    FontSizes.xxLarge = '28px';
    FontSizes.superLarge = '42px';
    FontSizes.mega = '72px';
})(FontSizes || (FontSizes = {}));
// Standard font weights.
var FontWeights;
(function (FontWeights) {
    FontWeights.light = 100;
    FontWeights.semilight = 300;
    FontWeights.regular = 400;
    FontWeights.semibold = 600;
    FontWeights.bold = 700;
})(FontWeights || (FontWeights = {}));
// Standard Icon Sizes.
var IconFontSizes;
(function (IconFontSizes) {
    IconFontSizes.xSmall = '10px';
    IconFontSizes.small = '12px';
    IconFontSizes.medium = '16px';
    IconFontSizes.large = '20px';
})(IconFontSizes || (IconFontSizes = {}));
function _fontFamilyWithFallbacks(fontFamily) {
    return `${fontFamily}, ${FontFamilyFallbacks}`;
}
function createFontStyles(localeCode) {
    const localizedFont = _getLocalizedFontFamily(localeCode);
    let fontFamilyWithFallback = _fontFamilyWithFallbacks(localizedFont);
    let semilightFontFamilyWithFallback = fontFamilyWithFallback;
    // Chrome has a bug where it does not render Segoe UI Semilight correctly, so we force the webfont to be used in that case
    if (localizedFont === defaultFontFamily) {
        semilightFontFamilyWithFallback = _fontFamilyWithFallbacks(LocalizedFontFamilies.WestEuropean);
    }
    const fontStyles = {
        tiny: _createFont(FontSizes.mini, FontWeights.semibold, fontFamilyWithFallback),
        xSmall: _createFont(FontSizes.xSmall, FontWeights.regular, fontFamilyWithFallback),
        small: _createFont(FontSizes.small, FontWeights.regular, fontFamilyWithFallback),
        smallPlus: _createFont(FontSizes.smallPlus, FontWeights.regular, fontFamilyWithFallback),
        medium: _createFont(FontSizes.medium, FontWeights.regular, fontFamilyWithFallback),
        mediumPlus: _createFont(FontSizes.mediumPlus, FontWeights.regular, fontFamilyWithFallback),
        large: _createFont(FontSizes.large, FontWeights.semilight, semilightFontFamilyWithFallback),
        xLarge: _createFont(FontSizes.xLarge, FontWeights.light, fontFamilyWithFallback),
        xxLarge: _createFont(FontSizes.xxLarge, FontWeights.light, fontFamilyWithFallback),
        superLarge: _createFont(FontSizes.superLarge, FontWeights.light, fontFamilyWithFallback),
        mega: _createFont(FontSizes.mega, FontWeights.light, fontFamilyWithFallback)
    };
    return fontStyles;
}
/**
 * If there is a localized font for this language, return that. Returns undefined if there is no localized font for that language.
 */
function _getLocalizedFontFamily(language) {
    for (let lang in LanguageToFontMap) {
        if (LanguageToFontMap.hasOwnProperty(lang) && language && lang.indexOf(language) === 0) {
            // tslint:disable-next-line:no-any
            return LanguageToFontMap[lang];
        }
    }
    return defaultFontFamily;
}
function _createFont(size, weight, fontFamily) {
    return {
        fontFamily: fontFamily,
        MozOsxFontSmoothing: 'grayscale',
        WebkitFontSmoothing: 'antialiased',
        fontSize: size,
        fontWeight: weight
    };
}

// Default urls.
const DefaultBaseUrl = 'https://static2.sharepointonline.com/files/fabric/assets';
// Standard font styling.
const DefaultFontStyles = createFontStyles(getLanguage());
function _registerFontFace(fontFamily, url, fontWeight, localFontName) {
    fontFamily = `'${fontFamily}'`;
    const localFontSrc = localFontName !== undefined ? `local('${localFontName}'),` : '';
    fontFace({
        fontFamily,
        src: localFontSrc + `url('${url}.woff2') format('woff2'),` + `url('${url}.woff') format('woff')`,
        fontWeight,
        fontStyle: 'normal'
    });
}
function _registerFontFaceSet(baseUrl, fontFamily, cdnFolder, cdnFontName = 'segoeui', localFontName) {
    const urlBase = `${baseUrl}/${cdnFolder}/${cdnFontName}`;
    _registerFontFace(fontFamily, urlBase + '-light', FontWeights.light, localFontName && localFontName + ' Light');
    _registerFontFace(fontFamily, urlBase + '-semilight', FontWeights.semilight, localFontName && localFontName + ' SemiLight');
    _registerFontFace(fontFamily, urlBase + '-regular', FontWeights.regular, localFontName);
    _registerFontFace(fontFamily, urlBase + '-semibold', FontWeights.semibold, localFontName && localFontName + ' SemiBold');
}
function registerDefaultFontFaces(baseUrl) {
    if (baseUrl) {
        const fontUrl = `${baseUrl}/fonts`;
        // Produce @font-face definitions for all supported web fonts.
        _registerFontFaceSet(fontUrl, LocalizedFontNames.Thai, 'leelawadeeui-thai', 'leelawadeeui');
        _registerFontFaceSet(fontUrl, LocalizedFontNames.Arabic, 'segoeui-arabic');
        _registerFontFaceSet(fontUrl, LocalizedFontNames.Cyrillic, 'segoeui-cyrillic');
        _registerFontFaceSet(fontUrl, LocalizedFontNames.EastEuropean, 'segoeui-easteuropean');
        _registerFontFaceSet(fontUrl, LocalizedFontNames.Greek, 'segoeui-greek');
        _registerFontFaceSet(fontUrl, LocalizedFontNames.Hebrew, 'segoeui-hebrew');
        _registerFontFaceSet(fontUrl, LocalizedFontNames.Vietnamese, 'segoeui-vietnamese');
        _registerFontFaceSet(fontUrl, LocalizedFontNames.WestEuropean, 'segoeui-westeuropean', 'segoeui', 'Segoe UI');
        _registerFontFaceSet(fontUrl, LocalizedFontFamilies.Selawik, 'selawik', 'selawik');
        // Leelawadee UI (Thai) does not have a 'light' weight, so we override
        // the font-face generated above to use the 'semilight' weight instead.
        _registerFontFace('Leelawadee UI Web', `${fontUrl}/leelawadeeui-thai/leelawadeeui-semilight`, FontWeights.light);
        // Leelawadee UI (Thai) does not have a 'semibold' weight, so we override
        // the font-face generated above to use the 'bold' weight instead.
        _registerFontFace('Leelawadee UI Web', `${fontUrl}/leelawadeeui-thai/leelawadeeui-bold`, FontWeights.semibold);
    }
}
/**
 * Reads the fontBaseUrl from window.FabricConfig.fontBaseUrl or falls back to a default.
 */
function _getFontBaseUrl() {
    let win = typeof window !== 'undefined' ? window : undefined;
    // tslint:disable-next-line:no-string-literal no-any
    let fabricConfig = win ? win['FabricConfig'] : undefined;
    return fabricConfig && fabricConfig.fontBaseUrl !== undefined ? fabricConfig.fontBaseUrl : DefaultBaseUrl;
}
/**
 * Register the font faces.
 */
registerDefaultFontFaces(_getFontBaseUrl());

const HighContrastSelector = '@media screen and (-ms-high-contrast: active)';
const HighContrastSelectorWhite = '@media screen and (-ms-high-contrast: black-on-white)';
const HighContrastSelectorBlack = '@media screen and (-ms-high-contrast: white-on-black)';
const ScreenWidthMinSmall = 320;
const ScreenWidthMinMedium = 480;
const ScreenWidthMinLarge = 640;
const ScreenWidthMinXLarge = 1024;
const ScreenWidthMinXXLarge = 1366;
const ScreenWidthMinXXXLarge = 1920;
const ScreenWidthMaxSmall = ScreenWidthMinMedium - 1;
const ScreenWidthMaxMedium = ScreenWidthMinLarge - 1;
const ScreenWidthMaxLarge = ScreenWidthMinXLarge - 1;
const ScreenWidthMaxXLarge = ScreenWidthMinXXLarge - 1;
const ScreenWidthMaxXXLarge = ScreenWidthMinXXXLarge - 1;
const ScreenWidthMinUhfMobile = 768;
function getScreenSelector(min, max) {
    return `@media only screen and (min-width: ${min}px) and (max-width: ${max}px)`;
}

var ZIndexes;
(function (ZIndexes) {
    ZIndexes.Nav = 1;
    ZIndexes.ScrollablePane = 1;
    ZIndexes.FocusStyle = 1;
    ZIndexes.Coachmark = 1000;
    ZIndexes.Layer = 1000000;
    ZIndexes.KeytipLayer = 1000001;
})(ZIndexes || (ZIndexes = {}));

/**
 * Generates a focus style which can be used to define an :after focus border.
 *
 * @param theme - The theme object to use.
 * @param inset - The number of pixels to inset the border.
 * @param position - The positioning applied to the container. Must
 * be 'relative' or 'absolute' so that the focus border can live around it.
 * @param highContrastStyle - Style for high contrast mode.
 * @param borderColor - Color of the border.
 * @param outlineColor - Color of the outline.
 * @param isFocusedOnly - If the styles should apply on focus or not.
 * @returns The style object.
 */
function getFocusStyle(theme, inset = 0, position = 'relative', highContrastStyle = undefined, borderColor = theme.palette.white, outlineColor = theme.palette.neutralSecondary, isFocusedOnly = true) {
    return {
        outline: 'transparent',
        position,
        selectors: {
            '::-moz-focus-inner': {
                border: '0'
            },
            [`.${IsFocusVisibleClassName} &${isFocusedOnly ? ':focus' : ''}:after`]: {
                content: '""',
                position: 'absolute',
                left: inset + 1,
                top: inset + 1,
                bottom: inset + 1,
                right: inset + 1,
                border: '1px solid ' + borderColor,
                outline: '1px solid ' + outlineColor,
                zIndex: ZIndexes.FocusStyle,
                selectors: {
                    [HighContrastSelector]: highContrastStyle
                }
            }
        }
    };
}
/**
 * Generates style to clear browser specific focus styles.
 */
function focusClear() {
    return {
        selectors: {
            '&::-moz-focus-inner': {
                // Clear the focus border in Firefox. Reference: http://stackoverflow.com/a/199319/1436671
                border: 0
            },
            '&': {
                // Clear browser specific focus styles and use transparent as placeholder for focus style
                outline: 'transparent'
            }
        }
    };
}

const hiddenContentStyle = {
    position: 'absolute',
    width: 1,
    height: 1,
    margin: -1,
    padding: 0,
    border: 0,
    overflow: 'hidden'
};

const DEFAULT_DURATION = '14s';
const DEFAULT_DELAY = '2s';
const DEFAULT_ITERATION_COUNT = '1';
function _continuousPulseStepOne(beaconColorOne, innerDimension) {
    return {
        borderColor: beaconColorOne,
        borderWidth: '0px',
        width: innerDimension,
        height: innerDimension
    };
}
function _continuousPulseStepTwo(borderWidth) {
    return {
        opacity: 1,
        borderWidth: borderWidth
    };
}
function _continuousPulseStepThree() {
    return {
        opacity: 1
    };
}
function _continuousPulseStepFour(beaconColorTwo, outerDimension) {
    return {
        borderWidth: '0',
        width: outerDimension,
        height: outerDimension,
        opacity: 0,
        borderColor: beaconColorTwo
    };
}
function _continuousPulseStepFive(beaconColorOne, innerDimension) {
    return {
        ..._continuousPulseStepOne(beaconColorOne, innerDimension),
        ...{
            opacity: 0
        }
    };
}
function _continuousPulseAnimationDouble(beaconColorOne, beaconColorTwo, innerDimension, outerDimension, borderWidth) {
    return keyframes({
        '0%': _continuousPulseStepOne(beaconColorOne, innerDimension),
        '1.42%': _continuousPulseStepTwo(borderWidth),
        '3.57%': _continuousPulseStepThree(),
        '7.14%': _continuousPulseStepFour(beaconColorTwo, outerDimension),
        '8%': _continuousPulseStepFive(beaconColorOne, innerDimension),
        '29.99%': _continuousPulseStepFive(beaconColorOne, innerDimension),
        '30%': _continuousPulseStepOne(beaconColorOne, innerDimension),
        '31.42%': _continuousPulseStepTwo(borderWidth),
        '33.57%': _continuousPulseStepThree(),
        '37.14%': _continuousPulseStepFour(beaconColorTwo, outerDimension),
        '38%': _continuousPulseStepFive(beaconColorOne, innerDimension),
        '79.42%': _continuousPulseStepFive(beaconColorOne, innerDimension),
        '79.43': _continuousPulseStepOne(beaconColorOne, innerDimension),
        '81.85': _continuousPulseStepTwo(borderWidth),
        '83.42': _continuousPulseStepThree(),
        '87%': _continuousPulseStepFour(beaconColorTwo, outerDimension),
        '100%': {}
    });
}
function _continuousPulseAnimationSingle(beaconColorOne, beaconColorTwo, innerDimension, outerDimension, borderWidth) {
    return keyframes({
        '0%': _continuousPulseStepOne(beaconColorOne, innerDimension),
        '14.2%': _continuousPulseStepTwo(borderWidth),
        '35.7%': _continuousPulseStepThree(),
        '71.4%': _continuousPulseStepFour(beaconColorTwo, outerDimension),
        '100%': {}
    });
}
function _createDefaultAnimation(animationName, delayLength) {
    return {
        animationName,
        animationIterationCount: DEFAULT_ITERATION_COUNT,
        animationDuration: DEFAULT_DURATION,
        animationDelay: delayLength || DEFAULT_DELAY
    };
}
const PulsingBeaconAnimationStyles = {
    continuousPulseAnimationDouble: _continuousPulseAnimationDouble,
    continuousPulseAnimationSingle: _continuousPulseAnimationSingle,
    createDefaultAnimation: _createDefaultAnimation
};

/**
 * Internal memoized function which simply takes in the class map and the
 * disable boolean. These immutable values can be memoized.
 */
const _getGlobalClassNames = memoizeFunction((classNames, disableGlobalClassNames) => {
    const styleSheet = Stylesheet.getInstance();
    if (disableGlobalClassNames) {
        // disable global classnames
        return Object.keys(classNames).reduce((acc, className) => {
            acc[className] = styleSheet.getClassName(classNames[className]);
            return acc;
        }, {});
    }
    // use global classnames
    return classNames;
});
/**
 * Checks for the `disableGlobalClassNames` property on the `theme` to determine if it should return `classNames`
 * Note that calls to this function are memoized.
 *
 * @param classNames - The collection of global class names that apply when the flag is false. Make sure to pass in
 * the same instance on each call to benefit from memoization.
 * @param theme - The theme to check the flag on
 * @param disableGlobalClassNames - Optional. Explicitly opt in/out of disabling global classnames. Defaults to false.
 */
function getGlobalClassNames(classNames, theme, disableGlobalClassNames) {
    return _getGlobalClassNames(classNames, disableGlobalClassNames !== undefined ? disableGlobalClassNames : theme.disableGlobalClassNames);
}

/**
 * @internal
 * This function is still in experimental phase in support of Foundation experimental development. Its API signature and existence
 * are subject to change.
 *
 * Modify context to activate the specified scheme or theme. For schemes, look in context (if available) and fall back to global
 * Customizations. If both scheme and theme are specified, scheme will be looked up in theme. In this case, scheme must be
 * present in theme arg, otherwise new context will default to theme arg (there is no fallback to settings to look up scheme.)
 *
 * @param context - Context in which to get schemed customizations.
 * @param scheme - Scheme to get customizations for from theme arg (if supplied) OR from context and global settings.
 * @param theme - Theme to merge into context.
 * @returns modified schemed context if scheme is valid and not already applied, unmodified context otherwise.
 */
function getThemedContext(context, scheme, theme) {
    let newContext = context;
    let newSettings;
    // Only fall back to context and customizations when theme arg is not provided.
    let schemeSource = theme || Customizations.getSettings(['theme'], undefined, context.customizations).theme;
    if (theme) {
        newSettings = { theme };
    }
    const schemeTheme = scheme && schemeSource && schemeSource.schemes && schemeSource.schemes[scheme];
    // These first two checks are logically redundant but TS doesn't infer schemeSource.schemes is defined when schemeTheme is defined.
    if (schemeSource && schemeTheme && schemeSource !== schemeTheme) {
        newSettings = { theme: schemeTheme };
        newSettings.theme.schemes = schemeSource.schemes;
    }
    if (newSettings) {
        newContext = {
            customizations: {
                settings: mergeSettings(context.customizations.settings, newSettings),
                scopedSettings: context.customizations.scopedSettings
            }
        };
    }
    return newContext;
}

const DefaultSpacing = {
    s2: '4px',
    s1: '8px',
    m: '16px',
    l1: '20px',
    l2: '32px'
};

const DefaultEffects = {
    // commented values are the defaults for Fluent
    elevation4: { boxShadow: '0 0 5px 0 rgba(0,0,0,.4)' },
    elevation8: { boxShadow: '0 0 5px 0 rgba(0,0,0,.4)' },
    elevation16: { boxShadow: '0 0 5px 0 rgba(0,0,0,.4)' },
    elevation64: { boxShadow: '0 0 5px 0 rgba(0,0,0,.4)' },
    roundedCorner2: 0 // 2
};

let _theme = createTheme({
    palette: DefaultPalette,
    semanticColors: _makeSemanticColorsFromPalette(DefaultPalette, false, false),
    fonts: DefaultFontStyles,
    isInverted: false,
    disableGlobalClassNames: false
});
let _onThemeChangeCallbacks = [];
const ThemeSettingName = 'theme';
if (!Customizations.getSettings([ThemeSettingName]).theme) {
    let win = typeof window !== 'undefined' ? window : undefined;
    // tslint:disable:no-string-literal no-any
    if (win && win['FabricConfig'] && win['FabricConfig'].theme) {
        _theme = createTheme(win['FabricConfig'].theme);
    }
    // tslint:enable:no-string-literal no-any
    // Set the default theme.
    Customizations.applySettings({ [ThemeSettingName]: _theme });
}
/**
 * Gets the theme object
 * @param depComments - Whether to include deprecated tags as comments for deprecated slots.
 */
function getTheme(depComments = false) {
    if (depComments === true) {
        _theme = createTheme({}, depComments);
    }
    return _theme;
}
/**
 * Registers a callback that gets called whenever the theme changes.
 * This should only be used when the component cannot automatically get theme changes through its state.
 * This will not register duplicate callbacks.
 */
function registerOnThemeChangeCallback(callback) {
    if (_onThemeChangeCallbacks.indexOf(callback) === -1) {
        _onThemeChangeCallbacks.push(callback);
    }
}
/**
 * See registerOnThemeChangeCallback().
 * Removes previously registered callbacks.
 */
function removeOnThemeChangeCallback(callback) {
    const i = _onThemeChangeCallbacks.indexOf(callback);
    if (i === -1) {
        return;
    }
    _onThemeChangeCallbacks.splice(i, 1);
}
/**
 * Applies the theme, while filling in missing slots.
 * @param theme - Partial theme object.
 * @param depComments - Whether to include deprecated tags as comments for deprecated slots.
 */
function loadTheme(theme, depComments = false) {
    _theme = createTheme(theme, depComments);
    // Invoke the legacy method of theming the page as well.
    //legacyLoadTheme({ ..._theme.palette, ..._theme.semanticColors });
    Customizations.applySettings({ [ThemeSettingName]: _theme });
    _onThemeChangeCallbacks.forEach((callback) => {
        try {
            callback(_theme);
        }
        catch (e) {
            // don't let a bad callback break everything else
        }
    });
    return _theme;
}
/**
 * Creates a custom theme definition which can be used with the Customizer.
 * @param theme - Partial theme object.
 * @param depComments - Whether to include deprecated tags as comments for deprecated slots.
 */
function createTheme(theme, depComments = false) {
    let newPalette = { ...DefaultPalette, ...theme.palette };
    if (!theme.palette || !theme.palette.accent) {
        newPalette.accent = newPalette.themePrimary;
    }
    // mix in custom overrides with good slots first, since custom overrides might be used in fixing deprecated slots
    let newSemanticColors = {
        ..._makeSemanticColorsFromPalette(newPalette, !!theme.isInverted, depComments),
        ...theme.semanticColors
    };
    let defaultFontStyles = DefaultFontStyles;
    if (theme.defaultFontStyle) {
        for (const fontStyle of Object.keys(DefaultFontStyles)) {
            defaultFontStyles[fontStyle] = { ...defaultFontStyles[fontStyle], ...theme.defaultFontStyle };
        }
    }
    if (theme.fonts) {
        for (const fontStyle of Object.keys(theme.fonts)) {
            defaultFontStyles[fontStyle] = merge(defaultFontStyles[fontStyle], theme.fonts[fontStyle]);
        }
    }
    return {
        palette: newPalette,
        fonts: {
            ...defaultFontStyles
        },
        semanticColors: newSemanticColors,
        isInverted: !!theme.isInverted,
        disableGlobalClassNames: !!theme.disableGlobalClassNames,
        spacing: {
            ...DefaultSpacing,
            ...theme.spacing
        },
        effects: {
            ...DefaultEffects,
            ...theme.effects
        }
    };
}
// Generates all the semantic slot colors based on the Fabric palette.
// We'll use these as fallbacks for semantic slots that the passed in theme did not define.
function _makeSemanticColorsFromPalette(p, isInverted, depComments) {
    let toReturn = {
        bodyBackground: p.white,
        bodyStandoutBackground: p.neutralLighterAlt,
        bodyFrameBackground: p.white,
        bodyFrameDivider: p.neutralLight,
        bodyText: p.neutralPrimary,
        bodyTextChecked: p.black,
        bodySubtext: p.neutralSecondary,
        bodyDivider: p.neutralLight,
        disabledBackground: p.neutralLighter,
        disabledText: p.neutralTertiary,
        disabledBodyText: p.neutralTertiary,
        disabledSubtext: p.neutralQuaternary,
        disabledBodySubtext: p.neutralTertiaryAlt,
        focusBorder: p.neutralSecondary,
        variantBorder: p.neutralLight,
        variantBorderHovered: p.neutralTertiary,
        defaultStateBackground: p.neutralLighterAlt,
        errorText: !isInverted ? p.redDark : '#ff5f5f',
        warningText: !isInverted ? '#333333' : '#ffffff',
        errorBackground: !isInverted ? 'rgba(232, 17, 35, .2)' : 'rgba(232, 17, 35, .5)',
        blockingBackground: !isInverted ? 'rgba(234, 67, 0, .2)' : 'rgba(234, 67, 0, .5)',
        warningBackground: !isInverted ? 'rgba(255, 185, 0, .2)' : 'rgba(255, 251, 0, .6)',
        warningHighlight: !isInverted ? '#ffb900' : '#fff100',
        successBackground: !isInverted ? 'rgba(186, 216, 10, .2)' : 'rgba(186, 216, 10, .4)',
        inputBorder: p.neutralTertiary,
        inputBorderHovered: p.neutralPrimary,
        inputBackground: p.white,
        inputBackgroundChecked: p.themePrimary,
        inputBackgroundCheckedHovered: p.themeDarkAlt,
        inputForegroundChecked: p.white,
        inputFocusBorderAlt: p.themePrimary,
        smallInputBorder: p.neutralSecondary,
        inputText: p.neutralPrimary,
        inputTextHovered: p.neutralDark,
        inputPlaceholderText: p.neutralSecondary,
        buttonBackground: p.neutralLighter,
        buttonBackgroundChecked: p.neutralTertiaryAlt,
        buttonBackgroundHovered: p.neutralLight,
        buttonBackgroundCheckedHovered: p.neutralLight,
        buttonBackgroundPressed: p.neutralLight,
        buttonBackgroundDisabled: p.neutralLighter,
        buttonBorder: 'transparent',
        buttonText: p.neutralPrimary,
        buttonTextHovered: p.neutralDark,
        buttonTextChecked: p.neutralDark,
        buttonTextCheckedHovered: p.black,
        buttonTextPressed: p.neutralDark,
        buttonTextDisabled: p.neutralTertiary,
        buttonBorderDisabled: 'transparent',
        primaryButtonBackground: p.themePrimary,
        primaryButtonBackgroundHovered: p.themeDarkAlt,
        primaryButtonBackgroundPressed: p.themeDark,
        primaryButtonBackgroundDisabled: p.neutralLighter,
        primaryButtonBorder: 'transparent',
        primaryButtonText: p.white,
        primaryButtonTextHovered: p.white,
        primaryButtonTextPressed: p.white,
        primaryButtonTextDisabled: p.neutralQuaternary,
        accentButtonBackground: p.accent,
        accentButtonText: p.white,
        menuBackground: p.white,
        menuDivider: p.neutralTertiaryAlt,
        menuIcon: p.themePrimary,
        menuHeader: p.themePrimary,
        menuItemBackgroundHovered: p.neutralLighter,
        menuItemBackgroundPressed: p.neutralLight,
        menuItemText: p.neutralPrimary,
        menuItemTextHovered: p.neutralDark,
        listBackground: p.white,
        listText: p.neutralPrimary,
        listItemBackgroundHovered: p.neutralLighter,
        listItemBackgroundChecked: p.neutralLight,
        listItemBackgroundCheckedHovered: p.neutralQuaternaryAlt,
        listHeaderBackgroundHovered: p.neutralLighter,
        listHeaderBackgroundPressed: p.neutralLight,
        actionLink: p.neutralPrimary,
        actionLinkHovered: p.neutralDark,
        link: p.themePrimary,
        linkHovered: p.themeDarker,
        // Deprecated slots, second pass by _fixDeprecatedSlots() later for self-referential slots
        listTextColor: '',
        menuItemBackgroundChecked: p.neutralLight
    };
    return _fixDeprecatedSlots(toReturn, depComments);
}
function _fixDeprecatedSlots(s, depComments) {
    // Add @deprecated tag as comment if enabled
    let dep = '';
    if (depComments === true) {
        dep = ' /* @deprecated */';
    }
    s.listTextColor = s.listText + dep;
    s.menuItemBackgroundChecked += dep;
    return s;
}

// This file mimics styles and mixins from _General.Mixins.scss
const normalize = {
    boxShadow: 'none',
    margin: 0,
    padding: 0,
    boxSizing: 'border-box'
};
const noWrap = {
    overflow: 'hidden',
    textOverflow: 'ellipsis',
    whiteSpace: 'nowrap'
};

const DEFAULT_HEIGHT = '50%';
const DEFAULT_WIDTH = 20;
/**
 * - Generates a style used to fade out an overflowing content by defining a style for an :after pseudo element.
 * - Apply it to the :after selector for all combination of states the parent of content might have (normal, hover, selected, focus).
 * - Requires the target to have position set to relative and overflow set to hidden.
 *
 * @example
 * ```tsx
 * // Assuming the following DOM structure and the different background colors coming from the parent holding the content.
 * <div className={classNames.parent}>
 *   <span className={classNames.content}>Overflown Content</span>
 * </div>
 * ```
 * ```ts
 * // This is how the style set would look in Component.styles.ts
 * const { bodyBackground } = theme.semanticColors;
 * const { neutralLighter } = theme.palette;
 *
 * // The second argument of getFadedOverflowStyle function is a string representing a key of ISemanticColors or IPalette.
 *
 * const styles = {
 *   parent: [
 *     backgroundColor: bodyBackground,
 *     selectors: {
 *       '&:hover: {
 *         backgroundColor: neutralLighter
 *       },
 *       '$content:after': {
 *         ...getFadedOverflowStyle(theme, 'bodyBackground')
 *       },
 *       '&:hover $content:after': {
 *         ...getFadedOverflowStyle(theme, 'neutralLighter')
 *       }
 *     }
 *   ],
 *   content: [
 *     width: '100%',
 *     display: 'inline-block',
 *     position: 'relative',
 *     overflow: 'hidden'
 *   ]
 * }
 * ```
 * @param theme - The theme object to use.
 * @param color - The background color to fade out to. Accepts only keys of ISemanticColors or IPalette. Defaults to 'bodyBackground'.
 * @param direction - The direction of the overflow. Defaults to horizontal.
 * @param width - The width of the fading overflow. Vertical direction defaults it to 100% vs 20px when horizontal.
 * @param height - The Height of the fading overflow. Vertical direction defaults it to 50% vs 100% when horizontal.
 * @returns The style object.
 */
function getFadedOverflowStyle(theme, color = 'bodyBackground', direction = 'horizontal', width = getDefaultValue('width', direction), height = getDefaultValue('height', direction)) {
    // Get the color value string from the theme semanticColors or palette.
    const colorValue = theme.semanticColors[color] || theme.palette[color];
    // Get the red, green, blue values of the colorValue.
    const rgbColor = color2rgb(colorValue);
    // Apply opacity 0 to serve as a start color of the gradient.
    const rgba = `rgba(${rgbColor.r}, ${rgbColor.g}, ${rgbColor.b}, 0)`;
    // Get the direction of the gradient.
    const gradientDirection = direction === 'vertical' ? 'to bottom' : 'to right'; // mergeStyles take care of RTL direction.
    return {
        content: '""',
        position: 'absolute',
        right: 0,
        bottom: 0,
        width: width,
        height: height,
        pointerEvents: 'none',
        backgroundImage: `linear-gradient(${gradientDirection}, ${rgba} 0%, ${colorValue} 100%)`
    };
}
// TODO consider moving this to a separate module along with some more color functions from OUFR/utilities.
/**
 * Helper function to convert a string hex color to an RGB object.
 *
 * @param colorValue - Color to be converted from hex to rgba.
 */
function color2rgb(colorValue) {
    if (colorValue[0] === '#') {
        // If it's a hex code
        return {
            r: parseInt(colorValue.slice(1, 3), 16),
            g: parseInt(colorValue.slice(3, 5), 16),
            b: parseInt(colorValue.slice(5, 7), 16)
        };
    }
    else if (colorValue.indexOf('rgba(') === 0) {
        // If it's an rgba color string
        colorValue = colorValue.match(/rgba\(([^)]+)\)/)[1];
        const parts = colorValue.split(/ *, */).map(Number);
        return {
            r: parts[0],
            g: parts[1],
            b: parts[2]
        };
    }
    // The only remaining possibility is transparent.
    return {
        r: 255,
        g: 255,
        b: 255
    };
}
/**
 * Helper function to get the default values for parameters of main function.
 *
 * @param style - Which style to get the default value for.
 * @param direction - What direction to take into consideration.
 */
function getDefaultValue(style, direction) {
    if (style === 'width') {
        return direction === 'horizontal' ? DEFAULT_WIDTH : '100%';
    }
    else {
        return direction === 'vertical' ? DEFAULT_HEIGHT : '100%';
    }
}

const AnimationClassNames = buildClassMap(AnimationStyles);

const FontClassNames = buildClassMap(DefaultFontStyles);

const ColorClassNames = {};
for (const colorName in DefaultPalette) {
    if (DefaultPalette.hasOwnProperty(colorName)) {
        // Foreground color
        _defineGetter(ColorClassNames, colorName, '', false, 'color');
        // Hover color
        _defineGetter(ColorClassNames, colorName, 'Hover', true, 'color');
        // Background color
        _defineGetter(ColorClassNames, colorName, 'Background', false, 'background');
        // Background hover
        _defineGetter(ColorClassNames, colorName, 'BackgroundHover', true, 'background');
        // Border color
        _defineGetter(ColorClassNames, colorName, 'Border', false, 'borderColor');
        // Border hover color
        _defineGetter(ColorClassNames, colorName, 'BorderHover', true, 'borderColor');
    }
}
/**
 * Defines a getter for the given class configuration.
 */
function _defineGetter(obj, colorName, suffix, isHover, cssProperty) {
    Object.defineProperty(obj, colorName + suffix, {
        get: () => {
            // tslint:disable-next-line:no-any
            const style = { [cssProperty]: getTheme().palette[colorName] };
            return mergeStyles(isHover ? { selectors: { ':hover': style } } : style).toString();
        },
        enumerable: true,
        configurable: true
    });
}

// @uifabric/styling@6.40.0
setVersion('@uifabric/styling', '6.40.0');

const getClassNames = memoizeFunction((styles, className, activityPersonas, isCompact) => {
    return {
        root: mergeStyles('ms-ActivityItem', className, styles.root, isCompact && styles.isCompactRoot),
        pulsingBeacon: mergeStyles('ms-ActivityItem-pulsingBeacon', styles.pulsingBeacon),
        personaContainer: mergeStyles('ms-ActivityItem-personaContainer', styles.personaContainer, isCompact && styles.isCompactPersonaContainer),
        activityPersona: mergeStyles('ms-ActivityItem-activityPersona', styles.activityPersona, isCompact && styles.isCompactPersona, !isCompact && activityPersonas && activityPersonas.length === 2 && styles.doublePersona),
        activityTypeIcon: mergeStyles('ms-ActivityItem-activityTypeIcon', styles.activityTypeIcon, isCompact && styles.isCompactIcon),
        activityContent: mergeStyles('ms-ActivityItem-activityContent', styles.activityContent, isCompact && styles.isCompactContent),
        activityText: mergeStyles('ms-ActivityItem-activityText', styles.activityText),
        commentText: mergeStyles('ms-ActivityItem-commentText', styles.commentText),
        timeStamp: mergeStyles('ms-ActivityItem-timeStamp', styles.timeStamp, isCompact && styles.isCompactTimeStamp)
    };
});

const DEFAULT_PERSONA_SIZE = '32px';
const COMPACT_PERSONA_SIZE = '16px';
const DEFAULT_ICON_SIZE = '16px';
const COMPACT_ICON_SIZE = '13px';
const ANIMATION_INNER_DIMENSION = '4px';
const ANIMATION_OUTER_DIMENSION = '28px';
const ANIMATION_BORDER_WIDTH = '4px';
const getStyles = memoizeFunction((theme = getTheme(), customStyles, animateBeaconSignal, beaconColorOne, beaconColorTwo, isCompact) => {
    const continuousPulse = PulsingBeaconAnimationStyles.continuousPulseAnimationSingle(beaconColorOne ? beaconColorOne : theme.palette.themePrimary, beaconColorTwo ? beaconColorTwo : theme.palette.themeTertiary, ANIMATION_INNER_DIMENSION, ANIMATION_OUTER_DIMENSION, ANIMATION_BORDER_WIDTH);
    const fadeIn = keyframes({
        from: { opacity: 0 },
        to: { opacity: 1 }
    });
    const slideIn = keyframes({
        from: { transform: 'translateX(-10px)' },
        to: { transform: 'translateX(0)' }
    });
    const continuousPulseAnimation = {
        animationName: continuousPulse,
        animationIterationCount: '1',
        animationDuration: '.8s',
        zIndex: 1
    };
    const slideInAnimation = {
        animationName: slideIn,
        animationIterationCount: '1',
        animationDuration: '.5s'
    };
    const fadeInAnimation = {
        animationName: fadeIn,
        animationIterationCount: '1',
        animationDuration: '.5s'
    };
    const ActivityItemStyles = {
        root: [
            theme.fonts.small,
            {
                display: 'flex',
                justifyContent: 'flex-start',
                alignItems: 'flex-start',
                boxSizing: 'border-box',
                color: theme.palette.neutralSecondary
            },
            isCompact && animateBeaconSignal && fadeInAnimation
        ],
        pulsingBeacon: [
            {
                position: 'absolute',
                top: '50%',
                left: '50%',
                transform: 'translate(-50%, -50%)',
                width: '0px',
                height: '0px',
                borderRadius: '225px',
                borderStyle: 'solid',
                opacity: 0
            },
            isCompact && animateBeaconSignal && continuousPulseAnimation
        ],
        isCompactRoot: {
            alignItems: 'center'
        },
        personaContainer: {
            display: 'flex',
            flexWrap: 'wrap',
            minWidth: DEFAULT_PERSONA_SIZE,
            width: DEFAULT_PERSONA_SIZE,
            height: DEFAULT_PERSONA_SIZE
        },
        isCompactPersonaContainer: {
            display: 'inline-flex',
            flexWrap: 'nowrap',
            flexBasis: 'auto',
            height: COMPACT_PERSONA_SIZE,
            width: 'auto',
            minWidth: '0',
            paddingRight: '6px'
        },
        activityTypeIcon: {
            height: DEFAULT_PERSONA_SIZE,
            fontSize: DEFAULT_ICON_SIZE,
            lineHeight: DEFAULT_ICON_SIZE,
            marginTop: '3px'
        },
        isCompactIcon: {
            height: COMPACT_PERSONA_SIZE,
            minWidth: COMPACT_PERSONA_SIZE,
            fontSize: COMPACT_ICON_SIZE,
            lineHeight: COMPACT_ICON_SIZE,
            color: theme.palette.themePrimary,
            marginTop: '1px',
            position: 'relative',
            display: 'flex',
            justifyContent: 'center',
            alignItems: 'center',
            selectors: {
                '.ms-Persona-imageArea': {
                    margin: '-2px 0 0 -2px',
                    border: '2px solid' + theme.palette.white,
                    borderRadius: '50%',
                    selectors: {
                        [HighContrastSelector]: {
                            border: 'none',
                            margin: '0'
                        }
                    }
                }
            }
        },
        activityPersona: {
            display: 'block'
        },
        doublePersona: {
            selectors: {
                ':first-child': {
                    alignSelf: 'flex-end'
                }
            }
        },
        isCompactPersona: {
            display: 'inline-block',
            width: '8px',
            minWidth: '8px',
            overflow: 'visible'
        },
        activityContent: [
            {
                padding: '0 8px'
            },
            isCompact && animateBeaconSignal && slideInAnimation
        ],
        activityText: {
            display: 'inline'
        },
        isCompactContent: {
            flex: '1',
            padding: '0 4px',
            whiteSpace: 'nowrap',
            textOverflow: 'ellipsis',
            overflowX: 'hidden'
        },
        commentText: {
            color: theme.palette.neutralPrimary
        },
        timeStamp: [
            theme.fonts.tiny,
            {
                fontWeight: 400,
                color: theme.palette.neutralSecondary
            }
        ],
        isCompactTimeStamp: {
            display: 'inline-block',
            paddingLeft: '0.3em',
            fontSize: '1em'
        }
    };
    return concatStyleSets(ActivityItemStyles, customStyles);
});

var TooltipDelay;
(function (TooltipDelay) {
    TooltipDelay[TooltipDelay["zero"] = 0] = "zero";
    TooltipDelay[TooltipDelay["medium"] = 1] = "medium";
    TooltipDelay[TooltipDelay["long"] = 2] = "long";
})(TooltipDelay || (TooltipDelay = {}));

const DirectionalHint = {
    /**
     * Appear above the target element, with the left edges of the callout and target aligning.
     */
    topLeftEdge: 0,
    /**
     * Appear above the target element, with the centers of the callout and target aligning.
     */
    topCenter: 1,
    /**
     * Appear above the target element, with the right edges of the callout and target aligning.
     */
    topRightEdge: 2,
    /**
     * Appear above the target element, aligning with the target element such that the callout tends toward the center of the screen.
     */
    topAutoEdge: 3,
    /**
     * Appear below the target element, with the left edges of the callout and target aligning.
     */
    bottomLeftEdge: 4,
    /**
     * Appear below the target element, with the centers of the callout and target aligning.
     */
    bottomCenter: 5,
    /**
     * Appear below the target element, with the right edges of the callout and target aligning.
     */
    bottomRightEdge: 6,
    /**
     * Appear below the target element, aligning with the target element such that the callout tends toward the center of the screen.
     */
    bottomAutoEdge: 7,
    /**
     * Appear to the left of the target element, with the top edges of the callout and target aligning.
     */
    leftTopEdge: 8,
    /**
     * Appear to the left of the target element, with the centers of the callout and target aligning.
     */
    leftCenter: 9,
    /**
     * Appear to the left of the target element, with the bottom edges of the callout and target aligning.
     */
    leftBottomEdge: 10,
    /**
     * Appear to the right of the target element, with the top edges of the callout and target aligning.
     */
    rightTopEdge: 11,
    /**
     * Appear to the right of the target element, with the centers of the callout and target aligning.
     */
    rightCenter: 12,
    /**
     * Appear to the right of the target element, with the bottom edges of the callout and target aligning.
     */
    rightBottomEdge: 13
};

var RectangleEdge;
(function (RectangleEdge) {
    RectangleEdge[RectangleEdge["top"] = 1] = "top";
    RectangleEdge[RectangleEdge["bottom"] = -1] = "bottom";
    RectangleEdge[RectangleEdge["left"] = 2] = "left";
    RectangleEdge[RectangleEdge["right"] = -2] = "right";
})(RectangleEdge || (RectangleEdge = {}));
var Position;
(function (Position) {
    Position[Position["top"] = 0] = "top";
    Position[Position["bottom"] = 1] = "bottom";
    Position[Position["start"] = 2] = "start";
    Position[Position["end"] = 3] = "end";
})(Position || (Position = {}));

class Rectangle$1 extends Rectangle {
}
function _createPositionData(targetEdge, alignmentEdge, isAuto) {
    return {
        targetEdge: targetEdge,
        alignmentEdge: alignmentEdge,
        isAuto: isAuto
    };
}
// Currently the beakPercent is set to 50 for all positions meaning that it should tend to the center of the target
const DirectionalDictionary = {
    [DirectionalHint.topLeftEdge]: _createPositionData(RectangleEdge.top, RectangleEdge.left),
    [DirectionalHint.topCenter]: _createPositionData(RectangleEdge.top),
    [DirectionalHint.topRightEdge]: _createPositionData(RectangleEdge.top, RectangleEdge.right),
    [DirectionalHint.topAutoEdge]: _createPositionData(RectangleEdge.top, undefined, true),
    [DirectionalHint.bottomLeftEdge]: _createPositionData(RectangleEdge.bottom, RectangleEdge.left),
    [DirectionalHint.bottomCenter]: _createPositionData(RectangleEdge.bottom),
    [DirectionalHint.bottomRightEdge]: _createPositionData(RectangleEdge.bottom, RectangleEdge.right),
    [DirectionalHint.bottomAutoEdge]: _createPositionData(RectangleEdge.bottom, undefined, true),
    [DirectionalHint.leftTopEdge]: _createPositionData(RectangleEdge.left, RectangleEdge.top),
    [DirectionalHint.leftCenter]: _createPositionData(RectangleEdge.left),
    [DirectionalHint.leftBottomEdge]: _createPositionData(RectangleEdge.left, RectangleEdge.bottom),
    [DirectionalHint.rightTopEdge]: _createPositionData(RectangleEdge.right, RectangleEdge.top),
    [DirectionalHint.rightCenter]: _createPositionData(RectangleEdge.right),
    [DirectionalHint.rightBottomEdge]: _createPositionData(RectangleEdge.right, RectangleEdge.bottom)
};
function _isRectangleWithinBounds(rect, boundingRect) {
    if (rect.top < boundingRect.top) {
        return false;
    }
    if (rect.bottom > boundingRect.bottom) {
        return false;
    }
    if (rect.left < boundingRect.left) {
        return false;
    }
    if (rect.right > boundingRect.right) {
        return false;
    }
    return true;
}
/**
 * Gets all of the edges of a rectangle that are outside of the given bounds.
 * If there are no out of bounds edges it returns an empty array.
 */
function _getOutOfBoundsEdges(rect, boundingRect) {
    const outOfBounds = new Array();
    if (rect.top < boundingRect.top) {
        outOfBounds.push(RectangleEdge.top);
    }
    if (rect.bottom > boundingRect.bottom) {
        outOfBounds.push(RectangleEdge.bottom);
    }
    if (rect.left < boundingRect.left) {
        outOfBounds.push(RectangleEdge.left);
    }
    if (rect.right > boundingRect.right) {
        outOfBounds.push(RectangleEdge.right);
    }
    return outOfBounds;
}
function _getEdgeValue(rect, edge) {
    return rect[RectangleEdge[edge]];
}
function _setEdgeValue(rect, edge, value) {
    rect[RectangleEdge[edge]] = value;
    return rect;
}
/**
 * Returns the middle value of an edge. Only returns 1 value rather than xy coordinates as
 * the itself already contains the other coordinate.
 * For instance, a bottom edge's current value is it's y coordinate, so the number returned is the x.
 *
 * @param {Rectangle} rect
 * @param {RectangleEdge} edge
 * @returns {number}
 */
function _getCenterValue(rect, edge) {
    const edges = _getFlankingEdges(edge);
    return (_getEdgeValue(rect, edges.positiveEdge) + _getEdgeValue(rect, edges.negativeEdge)) / 2;
}
/**
 * Flips the value depending on the edge.
 * If the edge is a "positive" edge, Top or Left, then the value should stay as it is.
 * If the edge is a "negative" edge, Bottom or Right, then the value should be flipped.
 * This is to account for the fact that the coordinates are effectively reveserved in certain cases for the "negative" edges.
 * For example, when testing to see if a bottom edge 1 is within the bounds of another bottom edge 2.
 * If edge 1 is greater than edge 2 then it is out of bounds. This is reversed for top edge 1 and top edge 2.
 * If top edge 1 is less than edge 2 then it is out of bounds.
 *
 *
 * @param {RectangleEdge} edge
 * @param {number} value
 * @returns {number}
 */
function _getRelativeEdgeValue(edge, value) {
    if (edge > 0) {
        return value;
    }
    else {
        return value * -1;
    }
}
function _getRelativeRectEdgeValue(edge, rect) {
    return _getRelativeEdgeValue(edge, _getEdgeValue(rect, edge));
}
function _getRelativeEdgeDifference(rect, hostRect, edge) {
    const edgeDifference = _getEdgeValue(rect, edge) - _getEdgeValue(hostRect, edge);
    return _getRelativeEdgeValue(edge, edgeDifference);
}
/**
 * Moves the edge of a rectangle to the value given. It only moves the edge in a linear direction based on that edge.
 * For example, if it's a bottom edge it will only change y coordinates.
 *
 * @param {Rectangle} rect
 * @param {RectangleEdge} edge
 * @param {number} newValue
 * @returns {Rectangle}
 */
function _moveEdge(rect, edge, newValue) {
    const difference = _getEdgeValue(rect, edge) - newValue;
    rect = _setEdgeValue(rect, edge, newValue);
    rect = _setEdgeValue(rect, edge * -1, _getEdgeValue(rect, edge * -1) - difference);
    return rect;
}
/**
 * Aligns the edge on the passed in rect to the target. If there is a gap then it will have that space between the two.
 *
 * @param {Rectangle} rect
 * @param {Rectangle} target
 * @param {RectangleEdge} edge
 * @param {number} [gap=0]
 * @returns {Rectangle}
 */
function _alignEdges(rect, target, edge, gap = 0) {
    return _moveEdge(rect, edge, _getEdgeValue(target, edge) + _getRelativeEdgeValue(edge, gap));
}
/**
 * Aligns the targetEdge on the passed in target to the rects corresponding opposite edge.
 * For instance if targetEdge is bottom, then the rects top will be moved to match it.
 *
 * @param {Rectangle} rect
 * @param {Rectangle} target
 * @param {RectangleEdge} targetEdge
 * @param {number} [gap=0]
 * @returns {Rectangle}
 */
function _alignOppositeEdges(rect, target, targetEdge, gap = 0) {
    const oppositeEdge = targetEdge * -1;
    const adjustedGap = _getRelativeEdgeValue(oppositeEdge, gap);
    return _moveEdge(rect, targetEdge * -1, _getEdgeValue(target, targetEdge) + adjustedGap);
}
/**
 * Tests to see if the given edge is within the bounds of the given rectangle.
 *
 * @param {Rectangle} rect
 * @param {Rectangle} bounds
 * @param {RectangleEdge} edge
 * @returns {boolean}
 */
function _isEdgeInBounds(rect, bounds, edge) {
    const adjustedRectValue = _getRelativeRectEdgeValue(edge, rect);
    return adjustedRectValue > _getRelativeRectEdgeValue(edge, bounds);
}
/**
 * Attempts to move the rectangle through various sides of the target to find a place to fit.
 * If no fit is found, the original position should be returned.
 *
 * @param {Rectangle} rect
 * @param {Rectangle} target
 * @param {Rectangle} bounding
 * @param {IPositionDirectionalHintData} positionData
 * @param {number} [gap=0]
 * @returns {IElementPosition}
 */
function _flipToFit(rect, target, bounding, positionData, gap = 0) {
    const directions = [RectangleEdge.left, RectangleEdge.right, RectangleEdge.bottom, RectangleEdge.top];
    let currentEstimate = rect;
    let currentEdge = positionData.targetEdge;
    let currentAlignment = positionData.alignmentEdge;
    // Keep switching sides until one is found with enough space. If all sides don't fit then return the unmodified element.
    for (let i = 0; i < 4; i++) {
        if (!_isEdgeInBounds(currentEstimate, bounding, currentEdge)) {
            directions.splice(directions.indexOf(currentEdge), 1);
            if (directions.indexOf(currentEdge * -1) > -1) {
                currentEdge = currentEdge * -1;
            }
            else {
                currentAlignment = currentEdge;
                currentEdge = directions.slice(-1)[0];
            }
            currentEstimate = _estimatePosition(rect, target, { targetEdge: currentEdge, alignmentEdge: currentAlignment }, gap);
        }
        else {
            return {
                elementRectangle: currentEstimate,
                targetEdge: currentEdge,
                alignmentEdge: currentAlignment
            };
        }
    }
    return {
        elementRectangle: rect,
        targetEdge: positionData.targetEdge,
        alignmentEdge: currentAlignment
    };
}
/**
 * Flips only the alignment edge of an element rectangle. This is used instead of nudging the alignment edges into position,
 * when alignTargetEdge is specified.
 * @param elementEstimate
 * @param target
 * @param bounding
 * @param gap
 */
function _flipAlignmentEdge(elementEstimate, target, gap, coverTarget) {
    const { alignmentEdge, targetEdge, elementRectangle } = elementEstimate;
    const oppositeEdge = alignmentEdge * -1;
    const newEstimate = _estimatePosition(elementRectangle, target, { targetEdge: targetEdge, alignmentEdge: oppositeEdge }, gap, coverTarget);
    return {
        elementRectangle: newEstimate,
        targetEdge: targetEdge,
        alignmentEdge: oppositeEdge
    };
}
/**
 * Adjusts a element rectangle to fit within the bounds given. If directionalHintFixed or covertarget is passed in
 * then the element will not flip sides on the target. They will, however, be nudged to fit within the bounds given.
 *
 * @param {Rectangle} element
 * @param {Rectangle} target
 * @param {Rectangle} bounding
 * @param {IPositionDirectionalHintData} positionData
 * @param {number} [gap=0]
 * @param {boolean} [directionalHintFixed]
 * @param {boolean} [coverTarget]
 * @returns {IElementPosition}
 */
function _adjustFitWithinBounds(element, target, bounding, positionData, gap = 0, directionalHintFixed, coverTarget) {
    const { alignmentEdge, alignTargetEdge } = positionData;
    let elementEstimate = {
        elementRectangle: element,
        targetEdge: positionData.targetEdge,
        alignmentEdge: alignmentEdge
    };
    if (!directionalHintFixed && !coverTarget) {
        elementEstimate = _flipToFit(element, target, bounding, positionData, gap);
    }
    const outOfBounds = _getOutOfBoundsEdges(element, bounding);
    if (alignTargetEdge) {
        // The edge opposite to the alignment edge might be out of bounds. Flip alignment to see if we can get it within bounds.
        if (elementEstimate.alignmentEdge && outOfBounds.indexOf(elementEstimate.alignmentEdge * -1) > -1) {
            const flippedElementEstimate = _flipAlignmentEdge(elementEstimate, target, gap, coverTarget);
            if (_isRectangleWithinBounds(flippedElementEstimate.elementRectangle, bounding)) {
                return flippedElementEstimate;
            }
        }
    }
    else {
        for (const direction of outOfBounds) {
            elementEstimate.elementRectangle = _alignEdges(elementEstimate.elementRectangle, bounding, direction);
        }
    }
    return elementEstimate;
}
/**
 * Moves the middle point on an edge to the point given.
 * Only moves in one direction. For instance if a bottom edge is passed in, then
 * the bottom edge will be moved in the x axis to match the point.
 *
 * @param {Rectangle} rect
 * @param {RectangleEdge} edge
 * @param {number} point
 * @returns {Rectangle}
 */
function _centerEdgeToPoint(rect, edge, point) {
    const { positiveEdge } = _getFlankingEdges(edge);
    const elementMiddle = _getCenterValue(rect, edge);
    const distanceToMiddle = elementMiddle - _getEdgeValue(rect, positiveEdge);
    return _moveEdge(rect, positiveEdge, point - distanceToMiddle);
}
/**
 * Moves the element rectangle to be appropriately positioned relative to a given target.
 * Does not flip or adjust the element.
 *
 * @param {Rectangle} elementToPosition
 * @param {Rectangle} target
 * @param {IPositionDirectionalHintData} positionData
 * @param {number} [gap=0]
 * @param {boolean} [coverTarget]
 * @returns {Rectangle}
 */
function _estimatePosition(elementToPosition, target, positionData, gap = 0, coverTarget) {
    let estimatedElementPosition;
    const { alignmentEdge, targetEdge } = positionData;
    const elementEdge = coverTarget ? targetEdge : targetEdge * -1;
    estimatedElementPosition = coverTarget
        ? _alignEdges(elementToPosition, target, targetEdge, gap)
        : _alignOppositeEdges(elementToPosition, target, targetEdge, gap);
    // if no alignment edge is provided it's supposed to be centered.
    if (!alignmentEdge) {
        const targetMiddlePoint = _getCenterValue(target, targetEdge);
        estimatedElementPosition = _centerEdgeToPoint(estimatedElementPosition, elementEdge, targetMiddlePoint);
    }
    else {
        estimatedElementPosition = _alignEdges(estimatedElementPosition, target, alignmentEdge);
    }
    return estimatedElementPosition;
}
/**
 * Returns the non-opposite edges of the target edge.
 * For instance if bottom is passed in then left and right will be returned.
 *
 * @param {RectangleEdge} edge
 * @returns {{ firstEdge: RectangleEdge, secondEdge: RectangleEdge }}
 */
function _getFlankingEdges(edge) {
    if (edge === RectangleEdge.top || edge === RectangleEdge.bottom) {
        return {
            positiveEdge: RectangleEdge.left,
            negativeEdge: RectangleEdge.right
        };
    }
    else {
        return {
            positiveEdge: RectangleEdge.top,
            negativeEdge: RectangleEdge.bottom
        };
    }
}
/**
 * Finalizes the element positon based on the hostElement. Only returns the
 * rectangle values to position such that they are anchored to the target.
 * This helps prevent resizing from looking very strange.
 * For instance, if the target edge is top and aligned with the left side then
 * the bottom and left values are returned so as the callou shrinks it shrinks towards that corner.
 *
 * @param {Rectangle} elementRectangle
 * @param {HTMLElement} hostElement
 * @param {RectangleEdge} targetEdge
 * @param {RectangleEdge} [alignmentEdge]
 * @param {boolean} coverTarget
 * @returns {IPartialIRectangle}
 */
function _finalizeElementPosition(elementRectangle, hostElement, targetEdge, alignmentEdge, coverTarget) {
    const returnValue = {};
    const hostRect = _getRectangleFromElement(hostElement);
    const elementEdge = coverTarget ? targetEdge : targetEdge * -1;
    const elementEdgeString = RectangleEdge[elementEdge];
    const returnEdge = alignmentEdge ? alignmentEdge : _getFlankingEdges(targetEdge).positiveEdge;
    returnValue[elementEdgeString] = _getRelativeEdgeDifference(elementRectangle, hostRect, elementEdge);
    returnValue[RectangleEdge[returnEdge]] = _getRelativeEdgeDifference(elementRectangle, hostRect, returnEdge);
    return returnValue;
}
// Since the beak is rotated 45 degrees the actual height/width is the length of the diagonal.
// We still want to position the beak based on it's midpoint which does not change. It will
// be at (beakwidth / 2, beakwidth / 2)
function _calculateActualBeakWidthInPixels(beakWidth) {
    return Math.sqrt(beakWidth * beakWidth * 2);
}
/**
 * Returns the appropriate IPositionData based on the props altered for RTL.
 * If directionalHintForRTL is passed in that is used if the page is RTL.
 * If a directionalHint is specified and no directionalHintForRTL is available and the page is RTL the hint will be flipped.
 * For instance bottomLeftEdge would become bottomRightEdge.
 * If there is no directionalHint passed in bottomAutoEdge is chosen automatically.
 *
 * @param {IPositionProps} props
 * @returns {IPositionDirectionalHintData}
 */
function _getPositionData(directionalHint = DirectionalHint.bottomAutoEdge, directionalHintForRTL, previousPositions) {
    if (previousPositions) {
        return {
            alignmentEdge: previousPositions.alignmentEdge,
            isAuto: previousPositions.isAuto,
            targetEdge: previousPositions.targetEdge
        };
    }
    const positionInformation = { ...DirectionalDictionary[directionalHint] };
    if (getRTL()) {
        // If alignment edge exists and that alignment edge is -2 or 2, right or left, then flip it.
        if (positionInformation.alignmentEdge && positionInformation.alignmentEdge % 2 === 0) {
            positionInformation.alignmentEdge = positionInformation.alignmentEdge * -1;
        }
        return directionalHintForRTL !== undefined ? DirectionalDictionary[directionalHintForRTL] : positionInformation;
    }
    return positionInformation;
}
/**
 * Get's the alignment data for the given information. This only really matters if the positioning is Auto.
 * If it is auto then the alignmentEdge should be chosen based on the target edge's position relative to
 * the center of the page.
 *
 * @param {IPositionDirectionalHintData} positionData
 * @param {Rectangle} target
 * @param {Rectangle} boundingRect
 * @param {boolean} [coverTarget]
 * @returns {IPositionDirectionalHintData}
 */
function _getAlignmentData(positionData, target, boundingRect, coverTarget, alignTargetEdge) {
    if (positionData.isAuto) {
        positionData.alignmentEdge = getClosestEdge(positionData.targetEdge, target, boundingRect);
    }
    positionData.alignTargetEdge = alignTargetEdge;
    return positionData;
}
function getClosestEdge(targetEdge, target, boundingRect) {
    const targetCenter = _getCenterValue(target, targetEdge);
    const boundingCenter = _getCenterValue(boundingRect, targetEdge);
    const { positiveEdge, negativeEdge } = _getFlankingEdges(targetEdge);
    if (targetCenter <= boundingCenter) {
        return positiveEdge;
    }
    else {
        return negativeEdge;
    }
}
function _positionElementWithinBounds(elementToPosition, target, bounding, positionData, gap, directionalHintFixed, coverTarget) {
    const estimatedElementPosition = _estimatePosition(elementToPosition, target, positionData, gap, coverTarget);
    if (_isRectangleWithinBounds(estimatedElementPosition, bounding)) {
        return {
            elementRectangle: estimatedElementPosition,
            targetEdge: positionData.targetEdge,
            alignmentEdge: positionData.alignmentEdge
        };
    }
    else {
        return _adjustFitWithinBounds(elementToPosition, target, bounding, positionData, gap, directionalHintFixed, coverTarget);
    }
}
function _finalizeBeakPosition(elementPosition, positionedBeak) {
    const targetEdge = elementPosition.targetEdge * -1;
    // The "host" element that we will use to help position the beak.
    const actualElement = new Rectangle$1(0, elementPosition.elementRectangle.width, 0, elementPosition.elementRectangle.height);
    const returnEdge = elementPosition.alignmentEdge ? elementPosition.alignmentEdge : _getFlankingEdges(targetEdge).positiveEdge;
    const returnValue = {};
    returnValue[RectangleEdge[targetEdge]] = _getEdgeValue(positionedBeak, targetEdge);
    returnValue[RectangleEdge[returnEdge]] = _getRelativeEdgeDifference(positionedBeak, actualElement, returnEdge);
    return {
        elementPosition: { ...returnValue },
        closestEdge: getClosestEdge(elementPosition.targetEdge, positionedBeak, actualElement),
        targetEdge: targetEdge
    };
}
function _positionBeak(beakWidth, elementPosition) {
    const target = elementPosition.targetRectangle;
    /**
     * Note about beak positioning: The actual beak width only matters for getting the gap between the callout and
     * target, it does not impact the beak placement within the callout. For example example, if the beakWidth is 8,
     * then the actual beakWidth is sqrroot(8^2 + 8^2) = 11.31x11.31. So the callout will need to be an extra 3 pixels
     * away from its target. While the beak is being positioned in the callout it still acts as though it were 8x8.
     * */
    const { positiveEdge, negativeEdge } = _getFlankingEdges(elementPosition.targetEdge);
    const beakTargetPoint = _getCenterValue(target, elementPosition.targetEdge);
    const elementBounds = new Rectangle$1(beakWidth / 2, elementPosition.elementRectangle.width - beakWidth / 2, beakWidth / 2, elementPosition.elementRectangle.height - beakWidth / 2);
    let beakPositon = new Rectangle$1(0, beakWidth, 0, beakWidth);
    beakPositon = _moveEdge(beakPositon, elementPosition.targetEdge * -1, -beakWidth / 2);
    beakPositon = _centerEdgeToPoint(beakPositon, elementPosition.targetEdge * -1, beakTargetPoint - _getRelativeRectEdgeValue(positiveEdge, elementPosition.elementRectangle));
    if (!_isEdgeInBounds(beakPositon, elementBounds, positiveEdge)) {
        beakPositon = _alignEdges(beakPositon, elementBounds, positiveEdge);
    }
    else if (!_isEdgeInBounds(beakPositon, elementBounds, negativeEdge)) {
        beakPositon = _alignEdges(beakPositon, elementBounds, negativeEdge);
    }
    return beakPositon;
}
function _getRectangleFromElement(element) {
    const clientRect = element.getBoundingClientRect();
    return new Rectangle$1(clientRect.left, clientRect.right, clientRect.top, clientRect.bottom);
}
function _getRectangleFromIRect(rect) {
    return new Rectangle$1(rect.left, rect.right, rect.top, rect.bottom);
}
function _getTargetRect(bounds, target) {
    let targetRectangle;
    if (target) {
        if (target.preventDefault) {
            const ev = target;
            targetRectangle = new Rectangle$1(ev.clientX, ev.clientX, ev.clientY, ev.clientY);
        }
        else if (target.getBoundingClientRect) {
            targetRectangle = _getRectangleFromElement(target);
            // HTMLImgElements can have x and y values. The check for it being a point must go last.
        }
        else {
            const point = target;
            targetRectangle = new Rectangle$1(point.x, point.x, point.y, point.y);
        }
        if (!_isRectangleWithinBounds(targetRectangle, bounds)) {
            const outOfBounds = _getOutOfBoundsEdges(targetRectangle, bounds);
            for (const direction of outOfBounds) {
                targetRectangle[RectangleEdge[direction]] = bounds[RectangleEdge[direction]];
            }
        }
    }
    else {
        targetRectangle = new Rectangle$1(0, 0, 0, 0);
    }
    return targetRectangle;
}
/**
 * If max height is less than zero it returns the bounds height instead.
 */
function _getMaxHeightFromTargetRectangle(targetRectangle, targetEdge, gapSpace, bounds, coverTarget) {
    let maxHeight = 0;
    const directionalHint = DirectionalDictionary[targetEdge];
    // If cover target is set, then the max height should be calculated using the opposite of the target edge since
    // that's the direction that the callout will expand in.
    // For instance, if the directionalhint is bottomLeftEdge then the callout will position so it's bottom edge
    // is aligned with the bottom of the target and expand up towards the top of the screen and the calculated max height
    // is (bottom of target) - (top of screen) - gapSpace.
    const target = coverTarget ? directionalHint.targetEdge * -1 : directionalHint.targetEdge;
    if (target === RectangleEdge.top) {
        maxHeight = _getEdgeValue(targetRectangle, directionalHint.targetEdge) - bounds.top - gapSpace;
    }
    else if (target === RectangleEdge.bottom) {
        maxHeight = bounds.bottom - _getEdgeValue(targetRectangle, directionalHint.targetEdge) - gapSpace;
    }
    else {
        maxHeight = bounds.bottom - targetRectangle.top - gapSpace;
    }
    return maxHeight > 0 ? maxHeight : bounds.height;
}
function _positionElementRelative(props, hostElement, elementToPosition, previousPositions) {
    const gap = props.gapSpace ? props.gapSpace : 0;
    const boundingRect = props.bounds
        ? _getRectangleFromIRect(props.bounds)
        : new Rectangle$1(0, window.innerWidth - getScrollbarWidth(), 0, window.innerHeight);
    const targetRect = _getTargetRect(boundingRect, props.target);
    const positionData = _getAlignmentData(_getPositionData(props.directionalHint, props.directionalHintForRTL, previousPositions), targetRect, boundingRect, props.coverTarget, props.alignTargetEdge);
    const positionedElement = _positionElementWithinBounds(_getRectangleFromElement(elementToPosition), targetRect, boundingRect, positionData, gap, props.directionalHintFixed, props.coverTarget);
    return { ...positionedElement, targetRectangle: targetRect };
}
function _finalizePositionData(positionedElement, hostElement, coverTarget) {
    const finalizedElement = _finalizeElementPosition(positionedElement.elementRectangle, hostElement, positionedElement.targetEdge, positionedElement.alignmentEdge, coverTarget);
    return {
        elementPosition: finalizedElement,
        targetEdge: positionedElement.targetEdge,
        alignmentEdge: positionedElement.alignmentEdge
    };
}
function _positionElement(props, hostElement, elementToPosition, previousPositions) {
    const positionedElement = _positionElementRelative(props, hostElement, elementToPosition, previousPositions);
    return _finalizePositionData(positionedElement, hostElement, props.coverTarget);
}
function _positionCallout(props, hostElement, callout, previousPositions) {
    const beakWidth = props.isBeakVisible ? props.beakWidth || 0 : 0;
    const gap = _calculateActualBeakWidthInPixels(beakWidth) / 2 + (props.gapSpace ? props.gapSpace : 0);
    const positionProps = props;
    positionProps.gapSpace = gap;
    const positionedElement = _positionElementRelative(positionProps, hostElement, callout, previousPositions);
    const beakPositioned = _positionBeak(beakWidth, positionedElement);
    const finalizedBeakPosition = _finalizeBeakPosition(positionedElement, beakPositioned);
    return {
        ..._finalizePositionData(positionedElement, hostElement, props.coverTarget),
        beakPosition: finalizedBeakPosition
    };
}
/* tslint:enable:variable-name */
/**
 * Used to position an element relative to the given positioning props.
 * If positioning has been completed before, previousPositioningData
 * can be passed to ensure that the positioning element repositions based on
 * its previous targets rather than starting with directionalhint.
 *
 * @export
 * @param {IPositionProps} props
 * @param {HTMLElement} hostElement
 * @param {HTMLElement} elementToPosition
 * @param {IPositionedData} previousPositions
 * @returns
 */
function positionElement(props, hostElement, elementToPosition, previousPositions) {
    return _positionElement(props, hostElement, elementToPosition, previousPositions);
}
function positionCallout(props, hostElement, elementToPosition, previousPositions) {
    return _positionCallout(props, hostElement, elementToPosition, previousPositions);
}
/**
 * Get's the maximum height that a rectangle can have in order to fit below or above a target.
 * If the directional hint specifies a left or right edge (i.e. leftCenter) it will limit the height to the topBorder
 * of the target given.
 * If no bounds are provided then the window is treated as the bounds.
 */
function getMaxHeight(target, targetEdge, gapSpace = 0, bounds, coverTarget) {
    const mouseTarget = target;
    const elementTarget = target;
    const pointTarget = target;
    let targetRect;
    const boundingRectangle = bounds
        ? _getRectangleFromIRect(bounds)
        : new Rectangle$1(0, window.innerWidth - getScrollbarWidth(), 0, window.innerHeight);
    if (mouseTarget.stopPropagation) {
        targetRect = new Rectangle$1(mouseTarget.clientX, mouseTarget.clientX, mouseTarget.clientY, mouseTarget.clientY);
    }
    else if (pointTarget.x !== undefined && pointTarget.y !== undefined) {
        targetRect = new Rectangle$1(pointTarget.x, pointTarget.x, pointTarget.y, pointTarget.y);
    }
    else {
        targetRect = _getRectangleFromElement(elementTarget);
    }
    return _getMaxHeightFromTargetRectangle(targetRect, targetEdge, gapSpace, boundingRectangle, coverTarget);
}
/**
 * Returns the opposite edge of the given RectangleEdge.
 */
function getOppositeEdge(edge) {
    return edge * -1;
}

/**
 * This adds accessibility to Dialog and Panel controls
 */
class Popup extends BaseComponent {
    constructor(props) {
        super(props);
        this._root = createRef();
        this._onKeyDown = (ev) => {
            switch (ev.which) {
                case KeyCodes.escape:
                    if (this.props.onDismiss) {
                        this.props.onDismiss(ev);
                        ev.preventDefault();
                        ev.stopPropagation();
                    }
                    break;
            }
        };
        this.state = { needsVerticalScrollBar: false };
    }
    componentWillMount() {
        this._originalFocusedElement = getDocument().activeElement;
    }
    componentDidMount() {
        if (!this._root.current) {
            return;
        }
        this._events.on(this._root.current, 'focus', this._onFocus, true);
        this._events.on(this._root.current, 'blur', this._onBlur, true);
        if (doesElementContainFocus(this._root.current)) {
            this._containsFocus = true;
        }
        this._updateScrollBarAsync();
    }
    componentDidUpdate() {
        this._updateScrollBarAsync();
    }
    componentWillUnmount() {
        if (this.props.shouldRestoreFocus &&
            this._originalFocusedElement &&
            this._containsFocus &&
            this._originalFocusedElement !== window) {
            // This slight delay is required so that we can unwind the stack, let react try to mess with focus, and then
            // apply the correct focus. Without the setTimeout, we end up focusing the correct thing, and then React wants
            // to reset the focus back to the thing it thinks should have been focused.
            if (this._originalFocusedElement) {
                this._originalFocusedElement.focus();
            }
        }
    }
    render() {
        const { role, className, ariaLabel, ariaLabelledBy, ariaDescribedBy, style } = this.props;
        return (createElement("div", Object.assign({ ref: this._root }, getNativeProps(this.props, divProperties), { className: className, role: role, "aria-label": ariaLabel, "aria-labelledby": ariaLabelledBy, "aria-describedby": ariaDescribedBy, onKeyDown: this._onKeyDown, style: { overflowY: this.state.needsVerticalScrollBar ? 'scroll' : undefined, ...style } }), this.props.children));
    }
    _updateScrollBarAsync() {
        this._async.requestAnimationFrame(() => {
            this._getScrollBar();
        });
    }
    _getScrollBar() {
        // If overflowY is overriden, don't waste time calculating whether the scrollbar is necessary.
        if (this.props.style && this.props.style.overflowY) {
            return;
        }
        let needsVerticalScrollBar = false;
        if (this._root && this._root.current && this._root.current.firstElementChild) {
            // ClientHeight returns the client height of an element rounded to an
            // integer. On some browsers at different zoom levels this rounding
            // can generate different results for the root container and child even
            // though they are the same height. This causes us to show a scroll bar
            // when not needed. Ideally we would use BoundingClientRect().height
            // instead however seems that the API is 90% slower than using ClientHeight.
            // Therefore instead we will calculate the difference between heights and
            // allow for a 1px difference to still be considered ok and not show the
            // scroll bar.
            const rootHeight = this._root.current.clientHeight;
            const firstChildHeight = this._root.current.firstElementChild.clientHeight;
            if (rootHeight > 0 && firstChildHeight > rootHeight) {
                needsVerticalScrollBar = firstChildHeight - rootHeight > 1;
            }
        }
        if (this.state.needsVerticalScrollBar !== needsVerticalScrollBar) {
            this.setState({
                needsVerticalScrollBar: needsVerticalScrollBar
            });
        }
    }
    _onFocus() {
        this._containsFocus = true;
    }
    _onBlur(ev) {
        if (this._root.current && this._root.current.contains(ev.relatedTarget)) {
            this._containsFocus = false;
        }
    }
}
Popup.defaultProps = {
    shouldRestoreFocus: true
};

const ANIMATIONS = {
    [RectangleEdge.top]: AnimationClassNames.slideUpIn10,
    [RectangleEdge.bottom]: AnimationClassNames.slideDownIn10,
    [RectangleEdge.left]: AnimationClassNames.slideLeftIn10,
    [RectangleEdge.right]: AnimationClassNames.slideRightIn10
};
const getClassNames$1 = classNamesFunction();
const BORDER_WIDTH = 1;
const BEAK_ORIGIN_POSITION = { top: 0, left: 0 };
// Microsoft Edge will overwrite inline styles if there is an animation pertaining to that style.
// To help ensure that edge will respect the offscreen style opacity
// filter needs to be added as an additional way to set opacity.
const OFF_SCREEN_STYLE = { opacity: 0, filter: 'opacity(0)' };
class CalloutContentBase extends BaseComponent {
    constructor(props) {
        super(props);
        this._hostElement = createRef();
        this._calloutElement = createRef();
        this._hasListeners = false;
        this.dismiss = (ev) => {
            const { onDismiss } = this.props;
            if (onDismiss) {
                onDismiss(ev);
            }
        };
        this._setInitialFocus = () => {
            if (this.props.setInitialFocus && !this._didSetInitialFocus && this.state.positions && this._calloutElement.current) {
                this._didSetInitialFocus = true;
                this._async.requestAnimationFrame(() => focusFirstChild(this._calloutElement.current));
            }
        };
        this._onComponentDidMount = () => {
            this._addListeners();
            if (this.props.onLayerMounted) {
                this.props.onLayerMounted();
            }
            this._updateAsyncPosition();
            this._setHeightOffsetEveryFrame();
        };
        this._didSetInitialFocus = false;
        this.state = {
            positions: undefined,
            slideDirectionalClassName: undefined,
            // @TODO it looks like this is not even being used anymore.
            calloutElementRect: undefined,
            heightOffset: 0
        };
        this._positionAttempts = 0;
    }
    componentDidUpdate() {
        this._setInitialFocus();
        if (!this.props.hidden) {
            if (!this._hasListeners) {
                this._addListeners();
            }
            this._updateAsyncPosition();
        }
        else {
            if (this._hasListeners) {
                this._removeListeners();
            }
        }
    }
    componentWillMount() {
        this._setTargetWindowAndElement(this._getTarget());
    }
    componentWillUpdate(newProps) {
        // If the target element changed, find the new one. If we are tracking target with class name, always find element because we
        // do not know if fabric has rendered a new element and disposed the old element.
        const newTarget = this._getTarget(newProps);
        const oldTarget = this._getTarget();
        if (newTarget !== oldTarget || typeof newTarget === 'string' || newTarget instanceof String) {
            this._maxHeight = undefined;
            this._setTargetWindowAndElement(newTarget);
        }
        if (newProps.gapSpace !== this.props.gapSpace || this.props.beakWidth !== newProps.beakWidth) {
            this._maxHeight = undefined;
        }
        if (newProps.finalHeight !== this.props.finalHeight) {
            this._setHeightOffsetEveryFrame();
        }
        // if the callout becomes hidden, then remove any positions that were placed on it.
        if (newProps.hidden && newProps.hidden !== this.props.hidden) {
            this.setState({
                positions: undefined
            });
        }
    }
    componentDidMount() {
        if (!this.props.hidden) {
            this._onComponentDidMount();
        }
    }
    render() {
        // If there is no target window then we are likely in server side rendering and we should not render anything.
        if (!this._targetWindow) {
            return null;
        }
        let { target } = this.props;
        const { styles, style, role, ariaLabel, ariaDescribedBy, ariaLabelledBy, className, isBeakVisible, children, beakWidth, calloutWidth, calloutMaxWidth, finalHeight, hideOverflow = !!finalHeight, backgroundColor, calloutMaxHeight, onScroll } = this.props;
        target = this._getTarget();
        const { positions } = this.state;
        const getContentMaxHeight = this._getMaxHeight() ? this._getMaxHeight() + this.state.heightOffset : undefined;
        const contentMaxHeight = calloutMaxHeight && getContentMaxHeight && calloutMaxHeight < getContentMaxHeight ? calloutMaxHeight : getContentMaxHeight;
        const overflowYHidden = hideOverflow;
        const beakVisible = isBeakVisible && !!target;
        this._classNames = getClassNames$1(styles, {
            theme: this.props.theme,
            className,
            overflowYHidden: overflowYHidden,
            calloutWidth,
            positions,
            beakWidth,
            backgroundColor,
            calloutMaxWidth
        });
        const overflowStyle = {
            ...style,
            maxHeight: contentMaxHeight,
            ...(overflowYHidden && { overflowY: 'hidden' })
        };
        const visibilityStyle = this.props.hidden ? { visibility: 'hidden' } : undefined;
        // React.CSSProperties does not understand IRawStyle, so the inline animations will need to be cast as any for now.
        const content = (createElement("div", { ref: this._hostElement, className: this._classNames.container, style: visibilityStyle },
            createElement("div", Object.assign({}, getNativeProps(this.props, divProperties), { className: css(this._classNames.root, positions && positions.targetEdge && ANIMATIONS[positions.targetEdge]), style: positions ? positions.elementPosition : OFF_SCREEN_STYLE, tabIndex: -1, 
                // See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/button#Clicking_and_focus
                ref: this._calloutElement }),
                beakVisible && createElement("div", { className: this._classNames.beak, style: this._getBeakPosition() }),
                beakVisible && createElement("div", { className: this._classNames.beakCurtain }),
                !this.props.hidden && (createElement(Popup, { role: role, ariaLabel: ariaLabel, ariaDescribedBy: ariaDescribedBy, ariaLabelledBy: ariaLabelledBy, className: this._classNames.calloutMain, onDismiss: this.dismiss, onScroll: onScroll, shouldRestoreFocus: true, style: overflowStyle }, children)))));
        return content;
    }
    _dismissOnScroll(ev) {
        const { preventDismissOnScroll } = this.props;
        if (this.state.positions && !preventDismissOnScroll) {
            this._dismissOnLostFocus(ev);
        }
    }
    _dismissOnLostFocus(ev) {
        const target = ev.target;
        const clickedOutsideCallout = this._hostElement.current && !elementContains(this._hostElement.current, target);
        const { preventDismissOnLostFocus } = this.props;
        if (!preventDismissOnLostFocus &&
            ((!this._target && clickedOutsideCallout) ||
                (ev.target !== this._targetWindow &&
                    clickedOutsideCallout &&
                    (this._target.stopPropagation ||
                        (!this._target || (target !== this._target && !elementContains(this._target, target))))))) {
            this.dismiss(ev);
        }
    }
    _addListeners() {
        // This is added so the callout will dismiss when the window is scrolled
        // but not when something inside the callout is scrolled. The delay seems
        // to be required to avoid React firing an async focus event in IE from
        // the target changing focus quickly prior to rendering the callout.
        this._async.setTimeout(() => {
            this._events.on(this._targetWindow, 'scroll', this._dismissOnScroll, true);
            this._events.on(this._targetWindow, 'resize', this.dismiss, true);
            this._events.on(this._targetWindow.document.documentElement, 'focus', this._dismissOnLostFocus, true);
            this._events.on(this._targetWindow.document.documentElement, 'click', this._dismissOnLostFocus, true);
            this._hasListeners = true;
        }, 0);
    }
    _removeListeners() {
        this._events.off(this._targetWindow, 'scroll', this._dismissOnScroll, true);
        this._events.off(this._targetWindow, 'resize', this.dismiss, true);
        this._events.off(this._targetWindow.document.documentElement, 'focus', this._dismissOnLostFocus, true);
        this._events.off(this._targetWindow.document.documentElement, 'click', this._dismissOnLostFocus, true);
        this._hasListeners = false;
    }
    _updateAsyncPosition() {
        this._async.requestAnimationFrame(() => this._updatePosition());
    }
    _getBeakPosition() {
        const { positions } = this.state;
        const beakPostionStyle = {
            ...(positions && positions.beakPosition ? positions.beakPosition.elementPosition : null)
        };
        if (!beakPostionStyle.top && !beakPostionStyle.bottom && !beakPostionStyle.left && !beakPostionStyle.right) {
            beakPostionStyle.left = BEAK_ORIGIN_POSITION.left;
            beakPostionStyle.top = BEAK_ORIGIN_POSITION.top;
        }
        return beakPostionStyle;
    }
    _updatePosition() {
        // Try to update the target, page might have changed
        this._setTargetWindowAndElement(this._getTarget());
        const { positions } = this.state;
        const hostElement = this._hostElement.current;
        const calloutElement = this._calloutElement.current;
        // If we expect a target element to position against, we need to wait until `this._target` is resolved. Otherwise
        // we can try to position.
        const expectsTarget = !!this.props.target;
        if (hostElement && calloutElement && (!expectsTarget || this._target)) {
            let currentProps;
            currentProps = assign(currentProps, this.props);
            currentProps.bounds = this._getBounds();
            currentProps.target = this._target;
            const newPositions = positionCallout(currentProps, hostElement, calloutElement, positions);
            // Set the new position only when the positions are not exists or one of the new callout positions are different.
            // The position should not change if the position is within 2 decimal places.
            if ((!positions && newPositions) ||
                (positions && newPositions && !this._arePositionsEqual(positions, newPositions) && this._positionAttempts < 5)) {
                // We should not reposition the callout more than a few times, if it is then the content is likely resizing
                // and we should stop trying to reposition to prevent a stack overflow.
                this._positionAttempts++;
                this.setState({
                    positions: newPositions
                });
            }
            else if (this._positionAttempts > 0) {
                // Only call the onPositioned callback if the callout has been re-positioned at least once.
                this._positionAttempts = 0;
                if (this.props.onPositioned) {
                    this.props.onPositioned(this.state.positions);
                }
            }
        }
    }
    _getBounds() {
        if (!this._bounds) {
            let currentBounds = this.props.bounds;
            if (!currentBounds) {
                currentBounds = {
                    top: 0 + this.props.minPagePadding,
                    left: 0 + this.props.minPagePadding,
                    right: this._targetWindow.innerWidth - this.props.minPagePadding,
                    bottom: this._targetWindow.innerHeight - this.props.minPagePadding,
                    width: this._targetWindow.innerWidth - this.props.minPagePadding * 2,
                    height: this._targetWindow.innerHeight - this.props.minPagePadding * 2
                };
            }
            this._bounds = currentBounds;
        }
        return this._bounds;
    }
    // Max height should remain as synchronous as possible, which is why it is not done using set state.
    // It needs to be synchronous since it will impact the ultimate position of the callout.
    _getMaxHeight() {
        if (!this._maxHeight) {
            if (this.props.directionalHintFixed && this._target) {
                const beakWidth = this.props.isBeakVisible ? this.props.beakWidth : 0;
                const gapSpace = this.props.gapSpace ? this.props.gapSpace : 0;
                // Since the callout cannot measure it's border size it must be taken into account here. Otherwise it will
                // overlap with the target.
                const totalGap = gapSpace + beakWidth + BORDER_WIDTH * 2;
                this._async.requestAnimationFrame(() => {
                    if (this._target) {
                        this._maxHeight = getMaxHeight(this._target, this.props.directionalHint, totalGap, this._getBounds(), this.props.coverTarget);
                        this.forceUpdate();
                    }
                });
            }
            else {
                this._maxHeight = this._getBounds().height - BORDER_WIDTH * 2;
            }
        }
        return this._maxHeight;
    }
    _arePositionsEqual(positions, newPosition) {
        return (this._comparePositions(positions.elementPosition, newPosition.elementPosition) &&
            this._comparePositions(positions.beakPosition.elementPosition, newPosition.beakPosition.elementPosition));
    }
    _comparePositions(oldPositions, newPositions) {
        for (const key in newPositions) {
            // This needs to be checked here and below because there is a linting error if for in does not immediately have an if statement
            if (newPositions.hasOwnProperty(key)) {
                const oldPositionEdge = oldPositions[key];
                const newPositionEdge = newPositions[key];
                if (oldPositionEdge !== undefined && newPositionEdge !== undefined) {
                    if (oldPositionEdge.toFixed(2) !== newPositionEdge.toFixed(2)) {
                        return false;
                    }
                }
                else {
                    return false;
                }
            }
        }
        return true;
    }
    _setTargetWindowAndElement(target) {
        if (target) {
            if (typeof target === 'string') {
                const currentDoc = getDocument();
                this._target = currentDoc ? currentDoc.querySelector(target) : null;
                this._targetWindow = getWindow();
            }
            else if (target.stopPropagation) {
                this._targetWindow = getWindow(target.toElement);
                this._target = target;
            }
            else if (target.getBoundingClientRect) {
                const targetElement = target;
                this._targetWindow = getWindow(targetElement);
                this._target = target;
                // HTMLImgElements can have x and y values. The check for it being a point must go last.
            }
            else {
                this._targetWindow = getWindow();
                this._target = target;
            }
        }
        else {
            this._targetWindow = getWindow();
        }
    }
    _setHeightOffsetEveryFrame() {
        if (this._calloutElement.current && this.props.finalHeight) {
            this._setHeightOffsetTimer = this._async.requestAnimationFrame(() => {
                const calloutMainElem = this._calloutElement.current && this._calloutElement.current.lastChild;
                if (!calloutMainElem) {
                    return;
                }
                const cardScrollHeight = calloutMainElem.scrollHeight;
                const cardCurrHeight = calloutMainElem.offsetHeight;
                const scrollDiff = cardScrollHeight - cardCurrHeight;
                this.setState({
                    heightOffset: this.state.heightOffset + scrollDiff
                });
                if (calloutMainElem.offsetHeight < this.props.finalHeight) {
                    this._setHeightOffsetEveryFrame();
                }
                else {
                    this._async.cancelAnimationFrame(this._setHeightOffsetTimer);
                }
            });
        }
    }
    _getTarget(props = this.props) {
        const { target } = props;
        return target;
    }
}
CalloutContentBase.defaultProps = {
    preventDismissOnLostFocus: false,
    preventDismissOnScroll: false,
    isBeakVisible: true,
    beakWidth: 16,
    gapSpace: 0,
    minPagePadding: 8,
    directionalHint: DirectionalHint.bottomAutoEdge
};

function getBeakStyle(beakWidth) {
    return {
        height: beakWidth,
        width: beakWidth
    };
}
const GlobalClassNames = {
    container: 'ms-Callout-container',
    root: 'ms-Callout',
    beak: 'ms-Callout-beak',
    beakCurtain: 'ms-Callout-beakCurtain',
    calloutMain: 'ms-Callout-main'
};
const getStyles$1 = (props) => {
    const { theme, className, overflowYHidden, calloutWidth, beakWidth, backgroundColor, calloutMaxWidth } = props;
    const classNames = getGlobalClassNames(GlobalClassNames, theme);
    const { palette } = theme;
    return {
        container: [
            classNames.container,
            {
                position: 'relative'
            }
        ],
        root: [
            classNames.root,
            theme.fonts.medium,
            {
                position: 'absolute',
                boxSizing: 'border-box',
                borderWidth: 1,
                borderStyle: 'solid',
                borderColor: palette.neutralLight,
                boxShadow: '0 0 5px 0px rgba(0,0,0,0.4)',
                selectors: {
                    [HighContrastSelector]: {
                        borderWidth: 1,
                        borderStyle: 'solid',
                        borderColor: 'WindowText'
                    }
                }
            },
            focusClear(),
            className,
            !!calloutWidth && { width: calloutWidth },
            !!calloutMaxWidth && { maxWidth: calloutMaxWidth }
        ],
        beak: [
            classNames.beak,
            {
                position: 'absolute',
                backgroundColor: palette.white,
                boxShadow: 'inherit',
                border: 'inherit',
                boxSizing: 'border-box',
                transform: 'rotate(45deg)'
            },
            getBeakStyle(beakWidth),
            backgroundColor && {
                backgroundColor: backgroundColor
            }
        ],
        beakCurtain: [
            classNames.beakCurtain,
            {
                position: 'absolute',
                top: 0,
                right: 0,
                bottom: 0,
                left: 0,
                backgroundColor: palette.white
            }
        ],
        calloutMain: [
            classNames.calloutMain,
            {
                backgroundColor: palette.white,
                overflowX: 'hidden',
                overflowY: 'auto',
                position: 'relative'
            },
            overflowYHidden && {
                overflowY: 'hidden'
            },
            backgroundColor && {
                backgroundColor: backgroundColor
            }
        ]
    };
};

const CalloutContent = styled(CalloutContentBase, getStyles$1, undefined, { scope: 'CalloutContent' });

const inheritFont = { fontFamily: 'inherit' };
const GlobalClassNames$1 = {
    root: 'ms-Fabric'
};
const getStyles$2 = (props) => {
    const { theme, className, isFocusVisible } = props;
    const classNames = getGlobalClassNames(GlobalClassNames$1, theme);
    return {
        root: [
            classNames.root,
            isFocusVisible && 'is-focusVisible',
            theme.fonts.medium,
            {
                color: theme.palette.neutralPrimary,
                selectors: {
                    '& button': inheritFont,
                    '& input': inheritFont,
                    '& textarea': inheritFont,
                    ':global(button)': {
                        overflow: 'visible',
                        margin: 0
                    }
                }
            },
            className
        ]
    };
};

const getClassNames$2 = classNamesFunction();
class FabricBase extends BaseComponent {
    constructor(props) {
        super(props);
        this._rootElement = createRef();
        this._onMouseDown = (ev) => {
            this.setState({ isFocusVisible: false });
        };
        this._onKeyDown = (ev) => {
            if (isDirectionalKeyCode(ev.which)) {
                this.setState({ isFocusVisible: true });
            }
        };
        this.state = { isFocusVisible: false };
    }
    render() {
        const classNames = getClassNames$2(getStyles$2, {
            ...this.props,
            ...this.state
        });
        const divProps = getNativeProps(this.props, divProperties);
        return createElement("div", Object.assign({}, divProps, { className: classNames.root, ref: this._rootElement }));
    }
    componentDidMount() {
        const win = getWindow(this._rootElement.current);
        if (win) {
            this._events.on(win, 'mousedown', this._onMouseDown, true);
            this._events.on(win, 'keydown', this._onKeyDown, true);
        }
    }
}

const Fabric = styled(FabricBase, getStyles$2, undefined, {
    scope: 'Fabric'
});

const _layersByHostId = {};
let _defaultHostSelector;
/**
 * Register a layer for a given host id
 * @param hostId Id of the layer host
 * @param layer Layer instance
 */
function registerLayer(hostId, layer) {
    if (!_layersByHostId[hostId]) {
        _layersByHostId[hostId] = [];
    }
    _layersByHostId[hostId].push(layer);
}
/**
 * Unregister a layer for a given host id
 * @param hostId Id of the layer host
 * @param layer Layer instance
 */
function unregisterLayer(hostId, layer) {
    if (_layersByHostId[hostId]) {
        const idx = _layersByHostId[hostId].indexOf(layer);
        if (idx >= 0) {
            _layersByHostId[hostId].splice(idx, 1);
            if (_layersByHostId[hostId].length === 0) {
                delete _layersByHostId[hostId];
            }
        }
    }
}
/**
 * Used for notifying applicable Layers that a host is available/unavailable and to re-evaluate Layers that
 * care about the specific host.
 */
function notifyHostChanged(id) {
    if (_layersByHostId[id]) {
        _layersByHostId[id].forEach(layer => layer.forceUpdate());
    }
}
/**
 * Get the default target selector when determining a host
 */
function getDefaultTarget() {
    return _defaultHostSelector;
}

const getClassNames$3 = classNamesFunction();
let LayerBase = class LayerBase extends BaseComponent {
    constructor(props) {
        super(props);
        this._rootElement = createRef$1();
        /**
         * rootElement wrapper for setting virtual parent as soon as root element ref is available.
         */
        this._handleRootElementRef = (ref) => {
            this._rootElement(ref);
            if (ref) {
                // TODO: Calling _setVirtualParent in this ref wrapper SHOULD allow us to remove
                //    other calls to _setVirtualParent throughout this class. However,
                //    as this is an immediate fix for a P0 issue the existing _setVirtualParent
                //    calls are left for now to minimize potential regression.
                this._setVirtualParent();
            }
        };
        /**
         * Helper to stop events from bubbling up out of Layer.
         */
        this._filterEvent = (ev) => {
            // We should just be able to check ev.bubble here and only stop events that are bubbling up. However, even though mouseenter and
            //    mouseleave do NOT bubble up, they are showing up as bubbling. Therefore we stop events based on event name rather than ev.bubble.
            if (ev.eventPhase === Event.BUBBLING_PHASE && ev.type !== 'mouseenter' && ev.type !== 'mouseleave') {
                ev.stopPropagation();
            }
        };
        this.state = {
            hasMounted: false
        };
        this._warnDeprecations({
            onLayerMounted: 'onLayerDidMount'
        });
        if (this.props.hostId) {
            registerLayer(this.props.hostId, this);
        }
    }
    componentWillMount() {
        this._layerElement = this._getLayerElement();
    }
    componentWillUpdate() {
        if (!this._layerElement) {
            this._layerElement = this._getLayerElement();
        }
    }
    componentDidMount() {
        // We can safely set state immediately because the ref wrapper will make sure the virtual
        //    parent has been set before componentDidMount is called.
        this.setState({ hasMounted: true });
        this._setVirtualParent();
        const { onLayerDidMount, onLayerMounted } = this.props;
        if (onLayerMounted) {
            onLayerMounted();
        }
        if (onLayerDidMount) {
            onLayerDidMount();
        }
    }
    componentWillUnmount() {
        this._removeLayerElement();
        const { onLayerWillUnmount, hostId } = this.props;
        if (onLayerWillUnmount) {
            onLayerWillUnmount();
        }
        if (hostId) {
            unregisterLayer(hostId, this);
        }
    }
    componentDidUpdate() {
        this._setVirtualParent();
    }
    render() {
        const classNames = this._getClassNames();
        const { eventBubblingEnabled } = this.props;
        const { hasMounted } = this.state;
        return (createElement("span", { className: "ms-layer", ref: this._handleRootElementRef }, this._layerElement &&
            hasMounted &&
            createPortal(eventBubblingEnabled ? (createElement(Fabric, { className: classNames.content }, this.props.children)) : (createElement(Fabric, { className: classNames.content, onClick: this._filterEvent, onContextMenu: this._filterEvent, onDoubleClick: this._filterEvent, onDrag: this._filterEvent, onDragEnd: this._filterEvent, onDragEnter: this._filterEvent, onDragExit: this._filterEvent, onDragLeave: this._filterEvent, onDragOver: this._filterEvent, onDragStart: this._filterEvent, onDrop: this._filterEvent, onMouseDown: this._filterEvent, onMouseEnter: this._filterEvent, onMouseLeave: this._filterEvent, onMouseMove: this._filterEvent, onMouseOver: this._filterEvent, onMouseOut: this._filterEvent, onMouseUp: this._filterEvent, onKeyDown: this._filterEvent, onKeyPress: this._filterEvent, onKeyUp: this._filterEvent, onFocus: this._filterEvent, onBlur: this._filterEvent, onChange: this._filterEvent, onInput: this._filterEvent, onInvalid: this._filterEvent, onSubmit: this._filterEvent }, this.props.children)), this._layerElement)));
    }
    _getClassNames() {
        const { className, styles, theme } = this.props;
        const classNames = getClassNames$3(styles, {
            theme: theme,
            className,
            isNotHost: !this.props.hostId
        });
        return classNames;
    }
    _setVirtualParent() {
        if (this._rootElement && this._rootElement.current && this._layerElement) {
            setVirtualParent(this._layerElement, this._rootElement.current);
        }
    }
    _getLayerElement() {
        const host = this._getHost();
        const classNames = this._getClassNames();
        if (host !== this._host) {
            this._removeLayerElement();
        }
        if (host) {
            this._host = host;
            if (!this._layerElement) {
                const doc = getDocument();
                if (!doc) {
                    return;
                }
                this._layerElement = doc.createElement('div');
                this._layerElement.className = classNames.root;
                setPortalAttribute(this._layerElement);
                host.appendChild(this._layerElement);
            }
        }
        return this._layerElement;
    }
    _removeLayerElement() {
        if (this._layerElement) {
            this.props.onLayerWillUnmount();
            const parentNode = this._layerElement.parentNode;
            if (parentNode) {
                parentNode.removeChild(this._layerElement);
            }
            this._layerElement = undefined;
        }
    }
    _getHost() {
        const { hostId } = this.props;
        const doc = getDocument();
        if (!doc) {
            return undefined;
        }
        if (hostId) {
            return doc.getElementById(hostId);
        }
        else {
            const defaultHostSelector = getDefaultTarget();
            return defaultHostSelector ? doc.querySelector(defaultHostSelector) : doc.body;
        }
    }
};
LayerBase.defaultProps = {
    onLayerDidMount: () => undefined,
    onLayerWillUnmount: () => undefined
};
LayerBase = __decorate([
    customizable('Layer', ['theme', 'hostId'])
], LayerBase);

const GlobalClassNames$2 = {
    root: 'ms-Layer',
    rootNoHost: 'ms-Layer--fixed',
    content: 'ms-Layer-content'
};
const getStyles$3 = (props) => {
    const { className, isNotHost, theme } = props;
    const classNames = getGlobalClassNames(GlobalClassNames$2, theme);
    return {
        root: [
            classNames.root,
            theme.fonts.medium,
            isNotHost && [
                classNames.rootNoHost,
                {
                    position: 'fixed',
                    zIndex: ZIndexes.Layer,
                    top: 0,
                    left: 0,
                    width: '100vw',
                    height: '100vh',
                    visibility: 'hidden'
                }
            ],
            className
        ],
        content: [
            classNames.content,
            {
                visibility: 'visible'
            }
        ]
    };
};

const Layer = styled(LayerBase, getStyles$3, undefined, {
    scope: 'Layer',
    fields: ['hostId', 'theme', 'styles']
});

class LayerHost extends BaseComponent {
    shouldComponentUpdate() {
        return false;
    }
    componentDidMount() {
        notifyHostChanged(this.props.id);
    }
    componentWillUnmount() {
        notifyHostChanged(this.props.id);
    }
    render() {
        return createElement("div", Object.assign({}, this.props, { className: css('ms-LayerHost', this.props.className) }));
    }
}

class Callout extends BaseComponent {
    constructor(props) {
        super(props);
    }
    render() {
        const { layerProps, ...rest } = this.props;
        const content = createElement(CalloutContent, Object.assign({}, rest));
        return this.props.doNotLayer ? content : createElement(Layer, Object.assign({}, layerProps), content);
    }
}

class FocusTrapZone extends BaseComponent {
    constructor() {
        super(...arguments);
        this._root = createRef();
        this._onFocusCapture = (ev) => {
            if (this.props.onFocusCapture) {
                this.props.onFocusCapture(ev);
            }
            if (ev.target !== ev.currentTarget) {
                // every time focus changes within the trap zone, remember the focused element so that
                // it can be restored if focus leaves the pane and returns via keystroke (i.e. via a call to this.focus(true))
                this._previouslyFocusedElementInTrapZone = ev.target;
            }
        };
        this._onKeyboardHandler = (ev) => {
            if (this.props.onKeyDown) {
                this.props.onKeyDown(ev);
            }
            // If the default has been prevented, do not process keyboard events.
            if (ev.isDefaultPrevented()) {
                return;
            }
            if (ev.which !== KeyCodes.tab) {
                return;
            }
            if (!this._root.current) {
                return;
            }
            const _firstTabbableChild = getFirstTabbable(this._root.current, this._root.current.firstChild, true);
            const _lastTabbableChild = getLastTabbable(this._root.current, this._root.current.lastChild, true);
            if (ev.shiftKey && _firstTabbableChild === ev.target) {
                focusAsync(_lastTabbableChild);
                ev.preventDefault();
                ev.stopPropagation();
            }
            else if (!ev.shiftKey && _lastTabbableChild === ev.target) {
                focusAsync(_firstTabbableChild);
                ev.preventDefault();
                ev.stopPropagation();
            }
        };
    }
    componentDidMount() {
        this._bringFocusIntoZone();
        this._updateEventHandlers(this.props);
    }
    componentWillReceiveProps(nextProps) {
        const { elementToFocusOnDismiss } = nextProps;
        if (elementToFocusOnDismiss && this._previouslyFocusedElementOutsideTrapZone !== elementToFocusOnDismiss) {
            this._previouslyFocusedElementOutsideTrapZone = elementToFocusOnDismiss;
        }
        this._updateEventHandlers(nextProps);
    }
    componentDidUpdate(prevProps) {
        const prevForceFocusInsideTrap = prevProps.forceFocusInsideTrap !== undefined ? prevProps.forceFocusInsideTrap : true;
        const newForceFocusInsideTrap = this.props.forceFocusInsideTrap !== undefined ? this.props.forceFocusInsideTrap : true;
        if (!prevForceFocusInsideTrap && newForceFocusInsideTrap) {
            // Transition from forceFocusInsideTrap disabled to enabled. Emulate what happens when a FocusTrapZone gets mounted
            this._bringFocusIntoZone();
        }
        else if (prevForceFocusInsideTrap && !newForceFocusInsideTrap) {
            // Transition from forceFocusInsideTrap enabled to disabled. Emulate what happens when a FocusTrapZone gets unmounted
            this._returnFocusToInitiator();
        }
    }
    componentWillUnmount() {
        this._events.dispose();
        this._returnFocusToInitiator();
    }
    render() {
        const { className, ariaLabelledBy } = this.props;
        const divProps = getNativeProps(this.props, divProperties);
        return (createElement("div", Object.assign({}, divProps, { className: className, ref: this._root, "aria-labelledby": ariaLabelledBy, onKeyDown: this._onKeyboardHandler, onFocusCapture: this._onFocusCapture }), this.props.children));
    }
    focus() {
        const { focusPreviouslyFocusedInnerElement, firstFocusableSelector } = this.props;
        if (focusPreviouslyFocusedInnerElement &&
            this._previouslyFocusedElementInTrapZone &&
            elementContains(this._root.current, this._previouslyFocusedElementInTrapZone)) {
            // focus on the last item that had focus in the zone before we left the zone
            focusAsync(this._previouslyFocusedElementInTrapZone);
            return;
        }
        const focusSelector = typeof firstFocusableSelector === 'string' ? firstFocusableSelector : firstFocusableSelector && firstFocusableSelector();
        let _firstFocusableChild;
        if (this._root.current) {
            if (focusSelector) {
                _firstFocusableChild = this._root.current.querySelector('.' + focusSelector);
            }
            else {
                _firstFocusableChild = getNextElement(this._root.current, this._root.current.firstChild, true, false, false, true);
            }
        }
        if (_firstFocusableChild) {
            focusAsync(_firstFocusableChild);
        }
    }
    _bringFocusIntoZone() {
        const { elementToFocusOnDismiss, disableFirstFocus = false } = this.props;
        FocusTrapZone._focusStack.push(this);
        this._previouslyFocusedElementOutsideTrapZone = elementToFocusOnDismiss
            ? elementToFocusOnDismiss
            : document.activeElement;
        if (!elementContains(this._root.current, this._previouslyFocusedElementOutsideTrapZone) && !disableFirstFocus) {
            this.focus();
        }
    }
    _returnFocusToInitiator() {
        const { ignoreExternalFocusing } = this.props;
        FocusTrapZone._focusStack = FocusTrapZone._focusStack.filter((value) => {
            return this !== value;
        });
        const activeElement = document.activeElement;
        if (!ignoreExternalFocusing &&
            this._previouslyFocusedElementOutsideTrapZone &&
            typeof this._previouslyFocusedElementOutsideTrapZone.focus === 'function' &&
            (elementContains(this._root.current, activeElement) || activeElement === document.body)) {
            focusAsync(this._previouslyFocusedElementOutsideTrapZone);
        }
    }
    _updateEventHandlers(newProps) {
        const { isClickableOutsideFocusTrap = false, forceFocusInsideTrap = true } = newProps;
        if (forceFocusInsideTrap && !this._hasFocusHandler) {
            this._events.on(window, 'focus', this._forceFocusInTrap, true);
        }
        else if (!forceFocusInsideTrap && this._hasFocusHandler) {
            this._events.off(window, 'focus', this._forceFocusInTrap, true);
        }
        this._hasFocusHandler = forceFocusInsideTrap;
        if (!isClickableOutsideFocusTrap && !this._hasClickHandler) {
            this._events.on(window, 'click', this._forceClickInTrap, true);
        }
        else if (isClickableOutsideFocusTrap && this._hasClickHandler) {
            this._events.off(window, 'click', this._forceClickInTrap, true);
        }
        this._hasClickHandler = !isClickableOutsideFocusTrap;
    }
    _forceFocusInTrap(ev) {
        if (FocusTrapZone._focusStack.length && this === FocusTrapZone._focusStack[FocusTrapZone._focusStack.length - 1]) {
            const focusedElement = document.activeElement;
            if (!elementContains(this._root.current, focusedElement)) {
                this.focus();
                ev.preventDefault();
                ev.stopPropagation();
            }
        }
    }
    _forceClickInTrap(ev) {
        if (FocusTrapZone._focusStack.length && this === FocusTrapZone._focusStack[FocusTrapZone._focusStack.length - 1]) {
            const clickedElement = ev.target;
            if (clickedElement && !elementContains(this._root.current, clickedElement)) {
                this.focus();
                ev.preventDefault();
                ev.stopPropagation();
            }
        }
    }
}
FocusTrapZone._focusStack = [];

/**
 * A special Callout that uses FocusTrapZone to trap focus
 * @param props - Props for the component
 */
const FocusTrapCallout = (props) => {
    return (createElement(Callout, Object.assign({}, props),
        createElement(FocusTrapZone, Object.assign({}, props.focusTrapProps), props.children)));
};

const getClassNames$4 = classNamesFunction();
class TooltipBase extends BaseComponent {
    constructor() {
        super(...arguments);
        this._onRenderContent = (props) => {
            return createElement("p", { className: this._classNames.subText }, props.content);
        };
    }
    render() {
        const { className, calloutProps, delay, directionalHint, directionalHintForRTL, styles, id, maxWidth, onRenderContent = this._onRenderContent, targetElement, theme } = this.props;
        this._classNames = getClassNames$4(styles, {
            theme: theme,
            className: className || (calloutProps && calloutProps.className),
            delay: delay,
            maxWidth: maxWidth
        });
        return (createElement(Callout, Object.assign({ target: targetElement, directionalHint: directionalHint, directionalHintForRTL: directionalHintForRTL }, calloutProps, getNativeProps(this.props, divProperties, ['id']), { className: this._classNames.root }),
            createElement("div", { className: this._classNames.content, id: id, role: "tooltip", onMouseEnter: this.props.onMouseEnter, onMouseLeave: this.props.onMouseLeave }, onRenderContent(this.props, this._onRenderContent))));
    }
}
// Specify default props values
TooltipBase.defaultProps = {
    directionalHint: DirectionalHint.topCenter,
    delay: TooltipDelay.medium,
    maxWidth: '364px',
    calloutProps: {
        isBeakVisible: true,
        beakWidth: 16,
        gapSpace: 0,
        setInitialFocus: true,
        doNotLayer: false
    }
};

const getStyles$4 = (props) => {
    const { className, delay, maxWidth, theme } = props;
    const { palette, fonts } = theme;
    return {
        root: [
            'ms-Tooltip',
            theme.fonts.medium,
            AnimationClassNames.fadeIn200,
            {
                background: palette.white,
                padding: '8px',
                animationDelay: '300ms',
                maxWidth: maxWidth
            },
            delay === TooltipDelay.zero && {
                animationDelay: '0s'
            },
            delay === TooltipDelay.long && {
                animationDelay: '500ms'
            },
            className
        ],
        content: [
            'ms-Tooltip-content',
            fonts.small,
            palette.neutralPrimary,
            {
                wordWrap: 'break-word',
                overflowWrap: 'break-word'
            }
        ],
        subText: [
            'ms-Tooltip-subtext',
            {
                margin: 0
            }
        ]
    };
};

const Tooltip = styled(TooltipBase, getStyles$4, undefined, {
    scope: 'Tooltip'
});

var TooltipOverflowMode;
(function (TooltipOverflowMode) {
    /** Only show tooltip if parent DOM element is overflowing */
    TooltipOverflowMode[TooltipOverflowMode["Parent"] = 0] = "Parent";
    /** Only show tooltip if tooltip host's content is overflowing */
    TooltipOverflowMode[TooltipOverflowMode["Self"] = 1] = "Self";
})(TooltipOverflowMode || (TooltipOverflowMode = {}));

const getClassNames$5 = classNamesFunction();
class TooltipHostBase extends BaseComponent {
    // Constructor
    constructor(props) {
        super(props);
        // The wrapping div that gets the hover events
        this._tooltipHost = createRef$1();
        // The ID of the setTimeout that will eventually close the tooltip if the
        // the tooltip isn't hovered over.
        this._closingTimer = -1;
        this.show = () => {
            this._toggleTooltip(true);
        };
        this.dismiss = () => {
            this._hideTooltip();
        };
        // Show Tooltip
        this._onTooltipMouseEnter = (ev) => {
            const { overflowMode } = this.props;
            if (TooltipHostBase._currentVisibleTooltip && TooltipHostBase._currentVisibleTooltip !== this) {
                TooltipHostBase._currentVisibleTooltip.dismiss();
            }
            TooltipHostBase._currentVisibleTooltip = this;
            if (overflowMode !== undefined) {
                const overflowElement = this._getTargetElement();
                if (overflowElement && !hasOverflow(overflowElement)) {
                    return;
                }
            }
            if (ev.target && portalContainsElement(ev.target, this._getTargetElement())) {
                // Do not show tooltip when target is inside a portal relative to TooltipHost.
                return;
            }
            this._toggleTooltip(true);
            this._clearDismissTimer();
        };
        // Hide Tooltip
        this._onTooltipMouseLeave = (ev) => {
            if (this.props.closeDelay) {
                this._clearDismissTimer();
                this._closingTimer = this._async.setTimeout(() => {
                    this._toggleTooltip(false);
                }, this.props.closeDelay);
            }
            else {
                this._toggleTooltip(false);
            }
            if (TooltipHostBase._currentVisibleTooltip === this) {
                TooltipHostBase._currentVisibleTooltip = undefined;
            }
        };
        this._clearDismissTimer = () => {
            this._async.clearTimeout(this._closingTimer);
        };
        // Hide Tooltip
        this._hideTooltip = () => {
            this._toggleTooltip(false);
        };
        this.state = {
            isTooltipVisible: false
        };
    }
    // Render
    render() {
        const { calloutProps, children, content, delay, directionalHint, directionalHintForRTL, hostClassName: className, id, setAriaDescribedBy = true, tooltipProps, styles, theme } = this.props;
        this._classNames = getClassNames$5(styles, {
            theme: theme,
            className
        });
        const { isTooltipVisible } = this.state;
        const tooltipId = id || getId('tooltip');
        const isContentPresent = !!(content || (tooltipProps && tooltipProps.onRenderContent && tooltipProps.onRenderContent()));
        const showTooltip = isTooltipVisible && isContentPresent;
        const ariaDescribedBy = setAriaDescribedBy && isTooltipVisible && isContentPresent ? tooltipId : undefined;
        return (createElement("div", Object.assign({ className: this._classNames.root, ref: this._tooltipHost }, { onFocusCapture: this._onTooltipMouseEnter }, { onBlurCapture: this._hideTooltip }, { onMouseEnter: this._onTooltipMouseEnter, onMouseLeave: this._onTooltipMouseLeave, "aria-describedby": ariaDescribedBy }),
            children,
            showTooltip && (createElement(Tooltip, Object.assign({ id: tooltipId, delay: delay, content: content, targetElement: this._getTargetElement(), directionalHint: directionalHint, directionalHintForRTL: directionalHintForRTL, calloutProps: assign({}, calloutProps, {
                    onMouseEnter: this._onTooltipMouseEnter,
                    onMouseLeave: this._onTooltipMouseLeave
                }), onMouseEnter: this._onTooltipMouseEnter, onMouseLeave: this._onTooltipMouseLeave }, getNativeProps(this.props, divProperties), tooltipProps)))));
    }
    componentWillUnmount() {
        if (TooltipHostBase._currentVisibleTooltip && TooltipHostBase._currentVisibleTooltip === this) {
            TooltipHostBase._currentVisibleTooltip = undefined;
        }
    }
    _getTargetElement() {
        if (!this._tooltipHost.current) {
            return undefined;
        }
        const { overflowMode } = this.props;
        // Select target element based on overflow mode. For parent mode, you want to position the tooltip relative
        // to the parent element, otherwise it might look off.
        if (overflowMode !== undefined) {
            switch (overflowMode) {
                case TooltipOverflowMode.Parent:
                    return this._tooltipHost.current.parentElement;
                case TooltipOverflowMode.Self:
                    return this._tooltipHost.current;
            }
        }
        return this._tooltipHost.current;
    }
    _toggleTooltip(isTooltipVisible) {
        if (this.state.isTooltipVisible !== isTooltipVisible) {
            this.setState({ isTooltipVisible }, () => this.props.onTooltipToggle && this.props.onTooltipToggle(this.state.isTooltipVisible));
        }
    }
}
TooltipHostBase.defaultProps = {
    delay: TooltipDelay.medium
};

const GlobalClassNames$3 = {
    root: 'ms-TooltipHost'
};
const getStyles$5 = (props) => {
    const { className, theme } = props;
    const classNames = getGlobalClassNames(GlobalClassNames$3, theme);
    return {
        root: [
            classNames.root,
            {
                display: 'inline'
            },
            className
        ]
    };
};

const TooltipHost = styled(TooltipHostBase, getStyles$5, undefined, {
    scope: 'TooltipHost'
});

// Please keep alphabetized
var IconType;
(function (IconType) {
    /**
     * Render using the fabric icon font.
     */
    IconType[IconType["default"] = 0] = "default";
    /**
     * Render using an image, where imageProps would be used.
     */
    IconType[IconType["image"] = 1] = "image";
    /**
     * Deprecated, use `default`.
     * @deprecated Use `default`.
     */
    IconType[IconType["Default"] = 100000] = "Default";
    /**
     * Deprecated, use `image`.
     * @deprecated Use `image`.
     */
    IconType[IconType["Image"] = 100001] = "Image";
})(IconType || (IconType = {}));

/**
 * The possible methods that can be used to fit the image.
 */
var ImageFit;
(function (ImageFit) {
    /**
     * The image is not scaled. The image is centered and cropped within the content box.
     */
    ImageFit[ImageFit["center"] = 0] = "center";
    /**
     * The image is scaled to maintain its aspect ratio while being fully contained within the frame. The image will
     * be centered horizontally and vertically within the frame. The space in the top and bottom or in the sides of
     * the frame will be empty depending on the difference in aspect ratio between the image and the frame.
     */
    ImageFit[ImageFit["contain"] = 1] = "contain";
    /**
     * The image is scaled to maintain its aspect ratio while filling the frame. Portions of the image will be cropped from
     * the top and bottom, or from the sides, depending on the difference in aspect ratio between the image and the frame.
     */
    ImageFit[ImageFit["cover"] = 2] = "cover";
    /**
     * Neither the image nor the frame are scaled. If their sizes do not match, the image will either be cropped or the
     * frame will have empty space.
     */
    ImageFit[ImageFit["none"] = 3] = "none";
    /**
     * The image will be centered horizontally and vertically within the frame and maintains its aspect ratio. It will
     * behave as ImageFit.center if the image's natural height or width is less than the Image frame's height or width,
     * but if both natural height and width are larger than the frame it will behave as ImageFit.cover.
     */
    ImageFit[ImageFit["centerCover"] = 4] = "centerCover";
})(ImageFit || (ImageFit = {}));
/**
 * The cover style to be used on the image
 */
var ImageCoverStyle;
(function (ImageCoverStyle) {
    /**
     * The image will be shown at 100% height of container and the width will be scaled accordingly
     */
    ImageCoverStyle[ImageCoverStyle["landscape"] = 0] = "landscape";
    /**
     * The image will be shown at 100% width of container and the height will be scaled accordingly
     */
    ImageCoverStyle[ImageCoverStyle["portrait"] = 1] = "portrait";
})(ImageCoverStyle || (ImageCoverStyle = {}));
var ImageLoadState;
(function (ImageLoadState) {
    /**
     * The image has not yet been loaded, and there is no error yet.
     */
    ImageLoadState[ImageLoadState["notLoaded"] = 0] = "notLoaded";
    /**
     * The image has been loaded successfully.
     */
    ImageLoadState[ImageLoadState["loaded"] = 1] = "loaded";
    /**
     * An error has been encountered while loading the image.
     */
    ImageLoadState[ImageLoadState["error"] = 2] = "error";
    /**
     * Deprecated at v1.3.6, to replace the src in case of errors, use `onLoadingStateChange` instead
     * and rerender the Image with a difference src.
     * @deprecated Use `onLoadingStateChange` instead
     * and rerender the Image with a difference src.
     */
    ImageLoadState[ImageLoadState["errorLoaded"] = 3] = "errorLoaded";
})(ImageLoadState || (ImageLoadState = {}));

const getClassNames$6 = classNamesFunction();
const KEY_PREFIX = 'fabricImage';
class ImageBase extends BaseComponent {
    constructor(props) {
        super(props);
        // Make an initial assumption about the image layout until we can
        // check the rendered element. The value here only takes effect when
        // shouldStartVisible is true.
        this._coverStyle = ImageCoverStyle.portrait;
        this._imageElement = createRef();
        this._frameElement = createRef();
        this._onImageLoaded = (ev) => {
            const { src, onLoad } = this.props;
            if (onLoad) {
                onLoad(ev);
            }
            this._computeCoverStyle(this.props);
            if (src) {
                this.setState({
                    loadState: ImageLoadState.loaded
                });
            }
        };
        this._onImageError = (ev) => {
            if (this.props.onError) {
                this.props.onError(ev);
            }
            this.setState({
                loadState: ImageLoadState.error
            });
        };
        this.state = {
            loadState: ImageLoadState.notLoaded
        };
    }
    componentWillReceiveProps(nextProps) {
        if (nextProps.src !== this.props.src) {
            this.setState({
                loadState: ImageLoadState.notLoaded
            });
        }
        else if (this.state.loadState === ImageLoadState.loaded) {
            this._computeCoverStyle(nextProps);
        }
    }
    componentDidUpdate(prevProps, prevState) {
        this._checkImageLoaded();
        if (this.props.onLoadingStateChange && prevState.loadState !== this.state.loadState) {
            this.props.onLoadingStateChange(this.state.loadState);
        }
    }
    render() {
        const imageProps = getNativeProps(this.props, imageProperties, ['width', 'height']);
        const { src, alt, width, height, shouldFadeIn, shouldStartVisible, className, imageFit, role, maximizeFrame, styles, theme } = this.props;
        const { loadState } = this.state;
        const coverStyle = this.props.coverStyle !== undefined ? this.props.coverStyle : this._coverStyle;
        const classNames = getClassNames$6(styles, {
            theme: theme,
            className,
            width,
            height,
            maximizeFrame,
            shouldFadeIn,
            shouldStartVisible,
            isLoaded: loadState === ImageLoadState.loaded || (loadState === ImageLoadState.notLoaded && this.props.shouldStartVisible),
            isLandscape: coverStyle === ImageCoverStyle.landscape,
            isCenter: imageFit === ImageFit.center,
            isCenterCover: imageFit === ImageFit.centerCover,
            isContain: imageFit === ImageFit.contain,
            isCover: imageFit === ImageFit.cover,
            isNone: imageFit === ImageFit.none,
            isError: loadState === ImageLoadState.error,
            isNotImageFit: imageFit === undefined
        });
        // If image dimensions aren't specified, the natural size of the image is used.
        return (createElement("div", { className: classNames.root, style: { width: width, height: height }, ref: this._frameElement },
            createElement("img", Object.assign({}, imageProps, { onLoad: this._onImageLoaded, onError: this._onImageError, key: KEY_PREFIX + this.props.src || '', className: classNames.image, ref: this._imageElement, src: src, alt: alt, role: role }))));
    }
    _checkImageLoaded() {
        const { src } = this.props;
        const { loadState } = this.state;
        if (loadState === ImageLoadState.notLoaded) {
            // testing if naturalWidth and naturalHeight are greater than zero is better than checking
            // .complete, because .complete will also be set to true if the image breaks. However,
            // for some browsers, SVG images do not have a naturalWidth or naturalHeight, so fall back
            // to checking .complete for these images.
            const isLoaded = this._imageElement.current
                ? (src && (this._imageElement.current.naturalWidth > 0 && this._imageElement.current.naturalHeight > 0)) ||
                    (this._imageElement.current.complete && ImageBase._svgRegex.test(src))
                : false;
            if (isLoaded) {
                this._computeCoverStyle(this.props);
                this.setState({
                    loadState: ImageLoadState.loaded
                });
            }
        }
    }
    _computeCoverStyle(props) {
        const { imageFit, width, height } = props;
        // Do not compute cover style if it was already specified in props
        if ((imageFit === ImageFit.cover || imageFit === ImageFit.contain || imageFit === ImageFit.centerCover) &&
            this.props.coverStyle === undefined &&
            this._imageElement.current &&
            this._frameElement.current) {
            // Determine the desired ratio using the width and height props.
            // If those props aren't available, measure measure the frame.
            let desiredRatio;
            if (!!width && !!height && imageFit !== ImageFit.centerCover) {
                desiredRatio = width / height;
            }
            else {
                desiredRatio = this._frameElement.current.clientWidth / this._frameElement.current.clientHeight;
            }
            // Examine the source image to determine its original ratio.
            const naturalRatio = this._imageElement.current.naturalWidth / this._imageElement.current.naturalHeight;
            // Should we crop from the top or the sides?
            if (naturalRatio > desiredRatio) {
                this._coverStyle = ImageCoverStyle.landscape;
            }
            else {
                this._coverStyle = ImageCoverStyle.portrait;
            }
        }
    }
}
ImageBase.defaultProps = {
    shouldFadeIn: true
};
ImageBase._svgRegex = /\.svg$/i;

const GlobalClassNames$4 = {
    root: 'ms-Image',
    rootMaximizeFrame: 'ms-Image--maximizeFrame',
    image: 'ms-Image-image',
    imageCenter: 'ms-Image-image--center',
    imageContain: 'ms-Image-image--contain',
    imageCover: 'ms-Image-image--cover',
    imageCenterCover: 'ms-Image-image--centerCover',
    imageNone: 'ms-Image-image--none',
    imageLandscape: 'ms-Image-image--landscape',
    imagePortrait: 'ms-Image-image--portrait'
};
const getStyles$6 = (props) => {
    const { className, width, height, maximizeFrame, isLoaded, shouldFadeIn, shouldStartVisible, isLandscape, isCenter, isContain, isCover, isCenterCover, isNone, isError, isNotImageFit, theme } = props;
    const classNames = getGlobalClassNames(GlobalClassNames$4, theme);
    const ImageFitStyles = {
        position: 'absolute',
        left: '50% /* @noflip */',
        top: '50%',
        transform: 'translate(-50%,-50%)' // @todo test RTL renders transform: translate(50%,-50%);
    };
    return {
        root: [
            classNames.root,
            theme.fonts.medium,
            {
                overflow: 'hidden'
            },
            maximizeFrame && [
                classNames.rootMaximizeFrame,
                {
                    height: '100%',
                    width: '100%'
                }
            ],
            (isCenter || isContain || isCover || isCenterCover) && {
                position: 'relative'
            },
            className
        ],
        image: [
            classNames.image,
            {
                display: 'block',
                opacity: 0
            },
            isLoaded && [
                'is-loaded',
                {
                    opacity: 1
                }
            ],
            isCenter && [classNames.imageCenter, ImageFitStyles],
            isContain && [
                classNames.imageContain,
                isLandscape && {
                    width: '100%',
                    height: 'auto'
                },
                !isLandscape && {
                    width: 'auto',
                    height: '100%'
                },
                ImageFitStyles
            ],
            isCover && [
                classNames.imageCover,
                isLandscape && {
                    width: 'auto',
                    height: '100%'
                },
                !isLandscape && {
                    width: '100%',
                    height: 'auto'
                },
                ImageFitStyles
            ],
            isCenterCover && [
                classNames.imageCenterCover,
                isLandscape && {
                    maxHeight: '100%'
                },
                !isLandscape && {
                    maxWidth: '100%'
                },
                ImageFitStyles
            ],
            isNone && [
                classNames.imageNone,
                {
                    width: 'auto',
                    height: 'auto'
                }
            ],
            isNotImageFit && [
                !!width &&
                    !height && {
                    height: 'auto',
                    width: '100%'
                },
                !width &&
                    !!height && {
                    height: '100%',
                    width: 'auto'
                },
                !!width &&
                    !!height && {
                    height: '100%',
                    width: '100%'
                }
            ],
            isLoaded && shouldFadeIn && !shouldStartVisible && AnimationClassNames.fadeIn400,
            isLandscape && classNames.imageLandscape,
            !isLandscape && classNames.imagePortrait,
            !isLoaded && 'is-notLoaded',
            shouldFadeIn && 'is-fadeIn',
            isError && 'is-error'
        ]
    };
};

const Image = styled(ImageBase, getStyles$6, undefined, {
    scope: 'Image'
});

/* tslint:disable */
const getClassNames$7 = classNamesFunction();
class IconBase extends BaseComponent {
    constructor(props) {
        super(props);
        this.onImageLoadingStateChange = (state) => {
            if (this.props.imageProps && this.props.imageProps.onLoadingStateChange) {
                this.props.imageProps.onLoadingStateChange(state);
            }
            if (state === ImageLoadState.error) {
                this.setState({ imageLoadError: true });
            }
        };
        this.state = {
            imageLoadError: false
        };
    }
    render() {
        const { ariaLabel, className, styles, iconName, imageErrorAs } = this.props;
        const isPlaceholder = typeof iconName === 'string' && iconName.length === 0;
        const isImage = this.props.iconType === IconType.image || this.props.iconType === IconType.Image;
        const { iconClassName, children } = this._getIconContent(iconName);
        const classNames = getClassNames$7(styles, {
            className,
            iconClassName,
            isImage,
            isPlaceholder
        });
        const containerProps = ariaLabel
            ? {
                'aria-label': ariaLabel
            }
            : {
                role: 'presentation',
                'aria-hidden': true
            };
        const RootType = isImage ? 'div' : 'i';
        const nativeProps = getNativeProps(this.props, htmlElementProperties);
        const { imageLoadError } = this.state;
        const imageProps = { ...this.props.imageProps, onLoadingStateChange: this.onImageLoadingStateChange };
        const ImageType = (imageLoadError && imageErrorAs) || Image;
        return (createElement(RootType, Object.assign({ "data-icon-name": iconName }, nativeProps, containerProps, { className: classNames.root }), isImage ? createElement(ImageType, Object.assign({}, imageProps)) : children));
    }
    _getIconContent(name) {
        const iconDefinition = getIcon(name) || {
            subset: {
                className: undefined
            },
            code: undefined
        };
        return {
            children: iconDefinition.code,
            iconClassName: iconDefinition.subset.className
        };
    }
}

const getStyles$7 = (props) => {
    const { className, iconClassName, isPlaceholder, isImage, styles } = props;
    return {
        root: [
            isImage && 'ms-Icon-imageContainer',
            isPlaceholder && 'ms-Icon-placeHolder',
            {
                display: 'inline-block'
            },
            isPlaceholder && {
                width: '1em'
            },
            isImage && {
                overflow: 'hidden'
            },
            iconClassName,
            className,
            styles && styles.root,
            styles && styles.imageContainer
        ]
    };
};

/**
 * Icons are used for rendering an individual's avatar, presence and details.
 * They are used within the PeoplePicker components.
 */
const Icon = styled(IconBase, getStyles$7, undefined, { scope: 'Icon' });

var PersonaSize;
(function (PersonaSize) {
    /**
     * tiny size has been deprecated in favor of standardized numeric sizing. Use `size10` instead.
     * @deprecated Use `size10` instead.
     */
    PersonaSize[PersonaSize["tiny"] = 0] = "tiny";
    /**
     *
     * extraExtraSmall size has been deprecated in favor of standardized numeric sizing. Use `size24` instead.
     * @deprecated Use `size24` instead.
     */
    PersonaSize[PersonaSize["extraExtraSmall"] = 1] = "extraExtraSmall";
    /**
     * extraSmall size has been deprecated in favor of standardized numeric sizing. Use `size32` instead.
     * @deprecated Use `size32` instead.
     */
    PersonaSize[PersonaSize["extraSmall"] = 2] = "extraSmall";
    /**
     * small size has been deprecated in favor of standardized numeric sizing. Use `size40` instead.
     * @deprecated Use `size40` instead.
     */
    PersonaSize[PersonaSize["small"] = 3] = "small";
    /**
     * regular size has been deprecated in favor of standardized numeric sizing. Use `size48` instead.
     * @deprecated Use `size48` instead.
     */
    PersonaSize[PersonaSize["regular"] = 4] = "regular";
    /**
     * large size has been deprecated in favor of standardized numeric sizing. Use `size72` instead.
     * @deprecated Use `size72` instead.
     */
    PersonaSize[PersonaSize["large"] = 5] = "large";
    /**
     * extraLarge size has been deprecated in favor of standardized numeric sizing. Use `size100` instead.
     * @deprecated Use `size100` instead.
     */
    PersonaSize[PersonaSize["extraLarge"] = 6] = "extraLarge";
    PersonaSize[PersonaSize["size28"] = 7] = "size28";
    PersonaSize[PersonaSize["size16"] = 8] = "size16";
    PersonaSize[PersonaSize["size10"] = 9] = "size10";
    PersonaSize[PersonaSize["size24"] = 10] = "size24";
    PersonaSize[PersonaSize["size32"] = 11] = "size32";
    PersonaSize[PersonaSize["size40"] = 12] = "size40";
    PersonaSize[PersonaSize["size48"] = 13] = "size48";
    PersonaSize[PersonaSize["size72"] = 14] = "size72";
    PersonaSize[PersonaSize["size100"] = 15] = "size100";
})(PersonaSize || (PersonaSize = {}));
var PersonaPresence;
(function (PersonaPresence) {
    PersonaPresence[PersonaPresence["none"] = 0] = "none";
    PersonaPresence[PersonaPresence["offline"] = 1] = "offline";
    PersonaPresence[PersonaPresence["online"] = 2] = "online";
    PersonaPresence[PersonaPresence["away"] = 3] = "away";
    PersonaPresence[PersonaPresence["dnd"] = 4] = "dnd";
    PersonaPresence[PersonaPresence["blocked"] = 5] = "blocked";
    PersonaPresence[PersonaPresence["busy"] = 6] = "busy";
})(PersonaPresence || (PersonaPresence = {}));
var PersonaInitialsColor;
(function (PersonaInitialsColor) {
    PersonaInitialsColor[PersonaInitialsColor["lightBlue"] = 0] = "lightBlue";
    PersonaInitialsColor[PersonaInitialsColor["blue"] = 1] = "blue";
    PersonaInitialsColor[PersonaInitialsColor["darkBlue"] = 2] = "darkBlue";
    PersonaInitialsColor[PersonaInitialsColor["teal"] = 3] = "teal";
    PersonaInitialsColor[PersonaInitialsColor["lightGreen"] = 4] = "lightGreen";
    PersonaInitialsColor[PersonaInitialsColor["green"] = 5] = "green";
    PersonaInitialsColor[PersonaInitialsColor["darkGreen"] = 6] = "darkGreen";
    PersonaInitialsColor[PersonaInitialsColor["lightPink"] = 7] = "lightPink";
    PersonaInitialsColor[PersonaInitialsColor["pink"] = 8] = "pink";
    PersonaInitialsColor[PersonaInitialsColor["magenta"] = 9] = "magenta";
    PersonaInitialsColor[PersonaInitialsColor["purple"] = 10] = "purple";
    /**
     * Black is a color that can result in offensive persona coins with some initials combinations, so it can only be set with overrides
     */
    PersonaInitialsColor[PersonaInitialsColor["black"] = 11] = "black";
    PersonaInitialsColor[PersonaInitialsColor["orange"] = 12] = "orange";
    /**
     * Red is a color that often has a special meaning, so it is considered a reserved color and can only be set with overrides
     */
    PersonaInitialsColor[PersonaInitialsColor["red"] = 13] = "red";
    PersonaInitialsColor[PersonaInitialsColor["darkRed"] = 14] = "darkRed";
    /**
     * Transparent is not intended to be used with typical initials due to accessibility issues.
     * Its primary use is for overflow buttons, so it is considered a reserved color and can only be set with overrides.
     */
    PersonaInitialsColor[PersonaInitialsColor["transparent"] = 15] = "transparent";
    PersonaInitialsColor[PersonaInitialsColor["violet"] = 16] = "violet";
})(PersonaInitialsColor || (PersonaInitialsColor = {}));

// Persona Sizes
var personaSize;
(function (personaSize) {
    personaSize.size10 = '20px';
    personaSize.size16 = '16px';
    personaSize.size24 = '24px';
    personaSize.size28 = '28px';
    personaSize.size32 = '32px';
    personaSize.size40 = '40px';
    personaSize.size48 = '48px';
    personaSize.size72 = '72px';
    personaSize.size100 = '100px';
})(personaSize || (personaSize = {}));
// Persona Presence Sizes
var personaPresenceSize;
(function (personaPresenceSize) {
    personaPresenceSize.size6 = '6px';
    personaPresenceSize.size8 = '8px';
    personaPresenceSize.size12 = '12px';
    personaPresenceSize.size20 = '20px';
    personaPresenceSize.size28 = '28px';
    personaPresenceSize.border = '2px';
})(personaPresenceSize || (personaPresenceSize = {}));
const sizeBoolean = (size) => ({
    isSize10: size === PersonaSize.size10 || size === PersonaSize.tiny,
    isSize16: size === PersonaSize.size16,
    isSize24: size === PersonaSize.size24 || size === PersonaSize.extraExtraSmall,
    isSize28: size === PersonaSize.size28 || size === PersonaSize.extraSmall,
    isSize32: size === PersonaSize.size32,
    isSize40: size === PersonaSize.size40 || size === PersonaSize.small,
    isSize48: size === PersonaSize.size48 || size === PersonaSize.regular,
    isSize72: size === PersonaSize.size72 || size === PersonaSize.large,
    isSize100: size === PersonaSize.size100 || size === PersonaSize.extraLarge
});
const sizeToPixels = {
    [PersonaSize.tiny]: 10,
    [PersonaSize.extraExtraSmall]: 24,
    [PersonaSize.extraSmall]: 28,
    [PersonaSize.small]: 40,
    [PersonaSize.regular]: 48,
    [PersonaSize.large]: 72,
    [PersonaSize.extraLarge]: 100,
    [PersonaSize.size10]: 10,
    [PersonaSize.size16]: 16,
    [PersonaSize.size24]: 24,
    [PersonaSize.size28]: 28,
    [PersonaSize.size32]: 32,
    [PersonaSize.size40]: 40,
    [PersonaSize.size48]: 48,
    [PersonaSize.size72]: 72,
    [PersonaSize.size100]: 100
};
const presenceBoolean = (presence) => ({
    isAvailable: presence === PersonaPresence.online,
    isAway: presence === PersonaPresence.away,
    isBlocked: presence === PersonaPresence.blocked,
    isBusy: presence === PersonaPresence.busy,
    isDoNotDisturb: presence === PersonaPresence.dnd,
    isOffline: presence === PersonaPresence.offline
});

const coinSizeFontScaleFactor = 6;
const coinSizePresenceScaleFactor = 3;
const presenceMaxSize = 40;
const presenceFontMaxSize = 20;
const getClassNames$8 = classNamesFunction();
/**
 * PersonaPresence with no default styles.
 * [Use the `getStyles` API to add your own styles.](https://github.com/OfficeDev/office-ui-fabric-react/wiki/Styling)
 */
class PersonaPresenceBase extends BaseComponent {
    constructor(props) {
        super(props);
        this._onRenderIcon = (className, style) => (createElement(Icon, { className: className, iconName: this._determineIcon(), style: style }));
        this._determineIcon = () => {
            const { presence } = this.props;
            if (presence !== PersonaPresence.none) {
                let userPresence = PersonaPresence[presence];
                switch (userPresence) {
                    case 'online':
                        userPresence = 'SkypeCheck';
                        break;
                    case 'away':
                        userPresence = 'SkypeClock';
                        break;
                    case 'dnd':
                        userPresence = 'SkypeMinus';
                        break;
                    default:
                        userPresence = '';
                }
                return userPresence;
            }
        };
    }
    render() {
        const { coinSize, styles, // Use getStyles from props.
        presence, theme } = this.props;
        const size = sizeBoolean(this.props.size);
        // Render Presence Icon if Persona is above size 32.
        const renderIcon = !(size.isSize10 || size.isSize16 || size.isSize24 || size.isSize28 || size.isSize32) && (coinSize ? coinSize > 32 : true);
        const presenceHeightWidth = coinSize
            ? coinSize / coinSizePresenceScaleFactor < presenceMaxSize
                ? coinSize / coinSizePresenceScaleFactor + 'px'
                : presenceMaxSize + 'px'
            : '';
        const presenceFontSize = coinSize
            ? coinSize / coinSizeFontScaleFactor < presenceFontMaxSize
                ? coinSize / coinSizeFontScaleFactor + 'px'
                : presenceFontMaxSize + 'px'
            : '';
        const coinSizeWithPresenceIconStyle = coinSize ? { fontSize: presenceFontSize, lineHeight: presenceHeightWidth } : undefined;
        const coinSizeWithPresenceStyle = coinSize ? { width: presenceHeightWidth, height: presenceHeightWidth } : undefined;
        // Use getStyles from props, or fall back to getStyles from styles file.
        const classNames = getClassNames$8(styles, {
            theme: theme,
            presence,
            size: this.props.size
        });
        if (presence === PersonaPresence.none) {
            return null;
        }
        return (createElement("div", { className: classNames.presence, style: coinSizeWithPresenceStyle }, renderIcon && this._onRenderIcon(classNames.presenceIcon, coinSizeWithPresenceIconStyle)));
    }
}

const GlobalClassNames$5 = {
    presence: 'ms-Persona-presence',
    presenceIcon: 'ms-Persona-presenceIcon'
};
const getStyles$8 = (props) => {
    const { theme } = props;
    const { semanticColors } = theme;
    const classNames = getGlobalClassNames(GlobalClassNames$5, theme);
    const size = sizeBoolean(props.size);
    const presence = presenceBoolean(props.presence);
    // Presence colors
    const presenceColorAvailable = '#7FBA00';
    const presenceColorAway = '#FCD116';
    const presenceColorBusy = '#D93B3B';
    const presenceColorDnd = '#E81123';
    const presenceColorOffline = '#93ABBD';
    return {
        presence: [
            classNames.presence,
            {
                position: 'absolute',
                height: personaPresenceSize.size12,
                width: personaPresenceSize.size12,
                borderRadius: '50%',
                top: 'auto',
                right: `-${personaPresenceSize.border}`,
                bottom: `-${personaPresenceSize.border}`,
                border: `${personaPresenceSize.border} solid ${semanticColors.bodyBackground}`,
                textAlign: 'center',
                boxSizing: 'content-box',
                backgroundClip: 'content-box',
                MsHighContrastAdjust: 'none',
                selectors: {
                    [HighContrastSelector]: {
                        borderColor: 'Window',
                        backgroundColor: 'WindowText'
                    }
                }
            },
            size.isSize10 && {
                right: 'auto',
                top: '7px',
                left: 0,
                border: 0,
                selectors: {
                    [HighContrastSelector]: {
                        top: '9px',
                        border: '1px solid WindowText'
                    }
                }
            },
            (size.isSize10 || size.isSize24 || size.isSize28 || size.isSize32) && {
                height: personaPresenceSize.size8,
                width: personaPresenceSize.size8
            },
            size.isSize16 && {
                height: personaPresenceSize.size6,
                width: personaPresenceSize.size6,
                borderWidth: '1.5px'
            },
            size.isSize72 && {
                height: personaPresenceSize.size20,
                width: personaPresenceSize.size20
            },
            size.isSize100 && {
                height: personaPresenceSize.size28,
                width: personaPresenceSize.size28
            },
            presence.isAvailable && {
                backgroundColor: presenceColorAvailable,
                selectors: {
                    [HighContrastSelector]: {
                        backgroundColor: 'Highlight'
                    }
                }
            },
            presence.isAway && {
                backgroundColor: presenceColorAway
            },
            presence.isBlocked && [
                {
                    backgroundColor: semanticColors.bodyBackground,
                    selectors: {
                        ':before': {
                            content: '""',
                            width: '100%',
                            height: '100%',
                            position: 'absolute',
                            top: 0,
                            left: 0,
                            border: `${personaPresenceSize.border} solid ${presenceColorBusy}`,
                            borderRadius: '50%',
                            boxSizing: 'border-box'
                        },
                        // Only show :after at larger sizes
                        ':after': size.isSize40 || size.isSize48 || size.isSize72 || size.isSize100
                            ? {
                                content: '""',
                                width: '100%',
                                height: personaPresenceSize.border,
                                backgroundColor: presenceColorBusy,
                                transform: 'translateY(-50%) rotate(-45deg)',
                                position: 'absolute',
                                top: '50%',
                                left: 0
                            }
                            : undefined,
                        [HighContrastSelector]: {
                            backgroundColor: 'WindowText',
                            selectors: {
                                ':before': {
                                    width: `calc(100% - ${personaPresenceSize.border})`,
                                    height: `calc(100% - ${personaPresenceSize.border})`,
                                    top: parseFloat(personaPresenceSize.border) / 2 + 'px',
                                    left: parseFloat(personaPresenceSize.border) / 2 + 'px',
                                    borderColor: 'Window'
                                },
                                ':after': {
                                    width: `calc(100% - ${parseFloat(personaPresenceSize.border) * 2}px)`,
                                    left: personaPresenceSize.border,
                                    backgroundColor: 'Window'
                                }
                            }
                        }
                    }
                }
            ],
            presence.isBusy && {
                backgroundColor: presenceColorBusy
            },
            presence.isDoNotDisturb && {
                backgroundColor: presenceColorDnd
            },
            presence.isOffline && {
                backgroundColor: presenceColorOffline
            }
        ],
        presenceIcon: [
            classNames.presenceIcon,
            {
                color: semanticColors.bodyBackground,
                fontSize: '6px',
                lineHeight: personaPresenceSize.size12,
                verticalAlign: 'top',
                selectors: {
                    [HighContrastSelector]: {
                        color: 'Window'
                    }
                }
            },
            size.isSize72 && {
                fontSize: FontSizes.small,
                lineHeight: personaPresenceSize.size20
            },
            size.isSize100 && {
                fontSize: FontSizes.medium,
                lineHeight: personaPresenceSize.size28
            },
            presence.isAway && {
                position: 'relative',
                left: '1px'
            }
        ]
    };
};

/**
 * PersonaPresence is used to render an individual's presence.
 */
const PersonaPresence$1 = styled(PersonaPresenceBase, getStyles$8, undefined, { scope: 'PersonaPresence' });

/**
 * These colors are considered reserved colors and can only be set with overrides:
 * - Red is a color that often has a special meaning.
 * - Transparent is not intended to be used with typical initials due to accessibility issues,
 *   its primary use is for Facepile overflow buttons.
 */
const COLOR_SWATCHES_LOOKUP = [
    PersonaInitialsColor.lightGreen,
    PersonaInitialsColor.lightBlue,
    PersonaInitialsColor.lightPink,
    PersonaInitialsColor.green,
    PersonaInitialsColor.darkGreen,
    PersonaInitialsColor.pink,
    PersonaInitialsColor.magenta,
    PersonaInitialsColor.purple,
    PersonaInitialsColor.violet,
    PersonaInitialsColor.teal,
    PersonaInitialsColor.blue,
    PersonaInitialsColor.darkBlue,
    PersonaInitialsColor.orange,
    PersonaInitialsColor.darkRed
];
const COLOR_SWATCHES_NUM_ENTRIES = COLOR_SWATCHES_LOOKUP.length;
function getInitialsColorFromName(displayName) {
    let color = PersonaInitialsColor.blue;
    if (!displayName) {
        return color;
    }
    let hashCode = 0;
    for (let iLen = displayName.length - 1; iLen >= 0; iLen--) {
        const ch = displayName.charCodeAt(iLen);
        const shift = iLen % 8;
        // tslint:disable-next-line:no-bitwise
        hashCode ^= (ch << shift) + (ch >> (8 - shift));
    }
    color = COLOR_SWATCHES_LOOKUP[hashCode % COLOR_SWATCHES_NUM_ENTRIES];
    return color;
}
function personaInitialsColorToHexCode(personaInitialsColor) {
    switch (personaInitialsColor) {
        case PersonaInitialsColor.lightBlue:
            return '#6BA5E7';
        case PersonaInitialsColor.blue:
            return '#2D89EF';
        case PersonaInitialsColor.darkBlue:
            return '#2B5797';
        case PersonaInitialsColor.teal:
            return '#00ABA9';
        case PersonaInitialsColor.lightGreen:
            return '#99B433';
        case PersonaInitialsColor.green:
            return '#00A300';
        case PersonaInitialsColor.darkGreen:
            return '#1E7145';
        case PersonaInitialsColor.lightPink:
            return '#E773BD';
        case PersonaInitialsColor.pink:
            return '#FF0097';
        case PersonaInitialsColor.magenta:
            return '#7E3878';
        case PersonaInitialsColor.purple:
            return '#603CBA';
        case PersonaInitialsColor.black:
            return '#1D1D1D';
        case PersonaInitialsColor.orange:
            return '#DA532C';
        case PersonaInitialsColor.red:
            return '#EE1111';
        case PersonaInitialsColor.darkRed:
            return '#B91D47';
        case PersonaInitialsColor.transparent:
            return 'transparent';
        case PersonaInitialsColor.violet:
            return '#5E4B8B';
    }
}
function initialsColorPropToColorCode(props) {
    const { primaryText, text } = props;
    let { initialsColor } = props;
    let initialsColorCode;
    if (typeof initialsColor === 'string') {
        initialsColorCode = initialsColor;
    }
    else {
        initialsColor = initialsColor !== undefined ? initialsColor : getInitialsColorFromName(text || primaryText);
        initialsColorCode = personaInitialsColorToHexCode(initialsColor);
    }
    return initialsColorCode;
}

const getClassNames$9 = classNamesFunction();
/**
 * PersonaCoin with no default styles.
 * [Use the `getStyles` API to add your own styles.](https://github.com/OfficeDev/office-ui-fabric-react/wiki/Styling)
 */
class PersonaCoinBase extends BaseComponent {
    constructor(props) {
        super(props);
        this._onRenderCoin = (props) => {
            const { coinSize, styles, imageUrl, imageAlt, imageShouldFadeIn, imageShouldStartVisible, theme, showUnknownPersonaCoin } = this.props;
            // Render the Image component only if an image URL is provided
            if (!imageUrl) {
                return null;
            }
            const size = this.props.size;
            const classNames = getClassNames$9(styles, {
                theme: theme,
                size,
                showUnknownPersonaCoin
            });
            const dimension = coinSize || sizeToPixels[size];
            return (createElement(Image, { className: classNames.image, imageFit: ImageFit.cover, src: imageUrl, width: dimension, height: dimension, alt: imageAlt, shouldFadeIn: imageShouldFadeIn, shouldStartVisible: imageShouldStartVisible, onLoadingStateChange: this._onPhotoLoadingStateChange }));
        };
        this._onRenderInitials = (props) => {
            let { imageInitials } = props;
            const { allowPhoneInitials, showUnknownPersonaCoin } = props;
            if (showUnknownPersonaCoin) {
                return createElement(Icon, { iconName: "Help" });
            }
            const isRTL = getRTL();
            imageInitials = imageInitials || getInitials(this._getText(), isRTL, allowPhoneInitials);
            return imageInitials !== '' ? createElement("span", null, imageInitials) : createElement(Icon, { iconName: "Contact" });
        };
        this._onPhotoLoadingStateChange = (loadState) => {
            this.setState({
                isImageLoaded: loadState === ImageLoadState.loaded,
                isImageError: loadState === ImageLoadState.error
            });
            this.props.onPhotoLoadingStateChange && this.props.onPhotoLoadingStateChange(loadState);
        };
        this._warnDeprecations({ primaryText: 'text' });
        this.state = {
            isImageLoaded: false,
            isImageError: false
        };
    }
    componentWillReceiveProps(nextProps) {
        if (nextProps.imageUrl !== this.props.imageUrl) {
            this.setState({
                isImageLoaded: false,
                isImageError: false
            });
        }
    }
    render() {
        const { className, coinProps, showUnknownPersonaCoin, coinSize, styles, imageUrl, onRenderCoin = this._onRenderCoin, onRenderInitials = this._onRenderInitials, presence, showInitialsUntilImageLoads, theme } = this.props;
        const size = this.props.size;
        const divProps = getNativeProps(this.props, divProperties);
        const divCoinProps = getNativeProps(coinProps || {}, divProperties);
        const coinSizeStyle = coinSize ? { width: coinSize, height: coinSize } : undefined;
        const hideImage = showUnknownPersonaCoin;
        const personaPresenceProps = {
            coinSize,
            presence,
            size,
            theme
        };
        // Use getStyles from props, or fall back to getStyles from styles file.
        const classNames = getClassNames$9(styles, {
            theme: theme,
            className: coinProps && coinProps.className ? coinProps.className : className,
            size,
            coinSize,
            showUnknownPersonaCoin
        });
        const shouldRenderInitials = Boolean(!this.state.isImageLoaded && ((showInitialsUntilImageLoads && imageUrl) || !imageUrl || this.state.isImageError || hideImage));
        return (createElement("div", Object.assign({}, divProps, { className: classNames.coin }),
            size !== PersonaSize.size10 && size !== PersonaSize.tiny ? (createElement("div", Object.assign({}, divCoinProps, { className: classNames.imageArea, style: coinSizeStyle }),
                shouldRenderInitials && (createElement("div", { className: mergeStyles(classNames.initials, !showUnknownPersonaCoin && { backgroundColor: initialsColorPropToColorCode(this.props) }), style: coinSizeStyle, "aria-hidden": "true" }, onRenderInitials(this.props, this._onRenderInitials))),
                !hideImage && onRenderCoin(this.props, this._onRenderCoin),
                createElement(PersonaPresence$1, Object.assign({}, personaPresenceProps)))) : // Otherwise, render just PersonaPresence.
                this.props.presence ? (createElement(PersonaPresence$1, Object.assign({}, personaPresenceProps))) : (
                // Just render Contact Icon if there isn't a Presence prop.
                createElement(Icon, { iconName: "Contact", className: classNames.size10WithoutPresenceIcon })),
            this.props.children));
    }
    /**
     * Deprecation helper for getting text.
     */
    _getText() {
        return this.props.text || this.props.primaryText || '';
    }
}
PersonaCoinBase.defaultProps = {
    size: PersonaSize.size48,
    presence: PersonaPresence.none,
    imageAlt: ''
};

const GlobalClassNames$6 = {
    coin: 'ms-Persona-coin',
    imageArea: 'ms-Persona-imageArea',
    image: 'ms-Persona-image',
    initials: 'ms-Persona-initials',
    size10: 'ms-Persona--size10',
    size16: 'ms-Persona--size16',
    size24: 'ms-Persona--size24',
    size28: 'ms-Persona--size28',
    size32: 'ms-Persona--size32',
    size40: 'ms-Persona--size40',
    size48: 'ms-Persona--size48',
    size72: 'ms-Persona--size72',
    size100: 'ms-Persona--size100'
};
const getStyles$9 = (props) => {
    const { className, theme, coinSize } = props;
    const { palette } = theme;
    const size = sizeBoolean(props.size);
    const classNames = getGlobalClassNames(GlobalClassNames$6, theme);
    // Static colors used when displaying 'unknown persona' coin
    const unknownPersonaBackgroundColor = palette.neutralLight;
    const unknownPersonaFontColor = palette.redDark;
    const dimension = coinSize || (props.size && sizeToPixels[props.size]) || 48;
    return {
        coin: [
            classNames.coin,
            theme.fonts.medium,
            size.isSize10 && classNames.size10,
            size.isSize16 && classNames.size16,
            size.isSize24 && classNames.size24,
            size.isSize28 && classNames.size28,
            size.isSize32 && classNames.size32,
            size.isSize40 && classNames.size40,
            size.isSize48 && classNames.size48,
            size.isSize72 && classNames.size72,
            size.isSize100 && classNames.size100,
            className
        ],
        size10WithoutPresenceIcon: {
            fontSize: '10px',
            position: 'absolute',
            top: '5px',
            right: 'auto',
            left: 0
        },
        imageArea: [
            classNames.imageArea,
            {
                position: 'relative',
                textAlign: 'center',
                flex: '0 0 auto',
                height: dimension,
                width: dimension
            },
            dimension <= 10 && {
                overflow: 'visible',
                background: 'transparent',
                height: 0,
                width: 0
            }
        ],
        image: [
            classNames.image,
            {
                marginRight: '10px',
                position: 'absolute',
                top: 0,
                left: 0,
                width: '100%',
                height: '100%',
                border: 0,
                borderRadius: '50%',
                perspective: '1px'
            },
            dimension <= 10 && {
                overflow: 'visible',
                background: 'transparent',
                height: 0,
                width: 0
            },
            dimension > 10 && {
                height: dimension,
                width: dimension
            }
        ],
        initials: [
            classNames.initials,
            {
                borderRadius: '50%',
                color: props.showUnknownPersonaCoin ? unknownPersonaFontColor : palette.white,
                fontSize: FontSizes.large,
                fontWeight: FontWeights.regular,
                lineHeight: dimension === 48 ? 46 : dimension,
                height: dimension,
                selectors: {
                    [HighContrastSelector]: {
                        border: '1px solid WindowText',
                        MsHighContrastAdjust: 'none',
                        color: 'WindowText',
                        boxSizing: 'border-box',
                        backgroundColor: 'Window !important'
                    }
                }
            },
            props.showUnknownPersonaCoin && {
                backgroundColor: unknownPersonaBackgroundColor
            },
            dimension < 32 && {
                fontSize: FontSizes.xSmall
            },
            dimension >= 32 &&
                dimension < 48 && {
                fontSize: FontSizes.medium
            },
            dimension >= 72 &&
                dimension < 100 && {
                fontSize: FontSizes.xxLarge
            },
            dimension >= 100 && {
                fontSize: FontSizes.superLarge
            }
        ]
    };
};

/**
 * PersonaCoin is used to render an individual's avatar and presence.
 */
const PersonaCoin = styled(PersonaCoinBase, getStyles$9, undefined, {
    scope: 'PersonaCoin'
});

const getClassNames$a = classNamesFunction();
/**
 * Persona with no default styles.
 * [Use the `styles` API to add your own styles.](https://github.com/OfficeDev/office-ui-fabric-react/wiki/Styling)
 */
class PersonaBase extends BaseComponent {
    constructor(props) {
        super(props);
        this._warnDeprecations({ primaryText: 'text' });
    }
    render() {
        // wrapping default render behavior based on various this.props properties
        const _onRenderPrimaryText = this._onRenderText(this._getText()), _onRenderSecondaryText = this._onRenderText(this.props.secondaryText), _onRenderTertiaryText = this._onRenderText(this.props.tertiaryText), _onRenderOptionalText = this._onRenderText(this.props.optionalText);
        const { hidePersonaDetails, onRenderOptionalText = _onRenderOptionalText, onRenderPrimaryText = _onRenderPrimaryText, onRenderSecondaryText = _onRenderSecondaryText, onRenderTertiaryText = _onRenderTertiaryText } = this.props;
        const size = this.props.size;
        // These properties are to be explicitly passed into PersonaCoin because they are the only props directly used
        const { allowPhoneInitials, className, coinProps, showUnknownPersonaCoin, coinSize, styles, imageAlt, imageInitials, imageShouldFadeIn, imageShouldStartVisible, imageUrl, initialsColor, onPhotoLoadingStateChange, onRenderCoin, onRenderInitials, presence, showInitialsUntilImageLoads, showSecondaryText, theme } = this.props;
        const personaCoinProps = {
            allowPhoneInitials,
            showUnknownPersonaCoin,
            coinSize,
            imageAlt,
            imageInitials,
            imageShouldFadeIn,
            imageShouldStartVisible,
            imageUrl,
            initialsColor,
            onPhotoLoadingStateChange,
            onRenderCoin,
            onRenderInitials,
            presence,
            showInitialsUntilImageLoads,
            size,
            text: this._getText(),
            ...coinProps
        };
        const classNames = getClassNames$a(styles, {
            theme: theme,
            className,
            showSecondaryText,
            presence,
            size
        });
        const divProps = getNativeProps(this.props, divProperties);
        const personaDetails = (createElement("div", { className: classNames.details },
            this._renderElement(classNames.primaryText, onRenderPrimaryText, _onRenderPrimaryText),
            this._renderElement(classNames.secondaryText, onRenderSecondaryText, _onRenderSecondaryText),
            this._renderElement(classNames.tertiaryText, onRenderTertiaryText, _onRenderTertiaryText),
            this._renderElement(classNames.optionalText, onRenderOptionalText, _onRenderOptionalText),
            this.props.children));
        return (createElement("div", Object.assign({}, divProps, { className: classNames.root, style: coinSize ? { height: coinSize, minWidth: coinSize } : undefined }),
            createElement(PersonaCoin, Object.assign({}, personaCoinProps)),
            (!hidePersonaDetails || (size === PersonaSize.size10 || size === PersonaSize.tiny)) && personaDetails));
    }
    /**
     * Renders various types of Text (primaryText, secondaryText, etc)
     * based on the classNames passed
     * @param classNames
     * @param renderFunction
     * @param defaultRenderFunction
     */
    _renderElement(classNames, renderFunction, defaultRenderFunction) {
        return createElement("div", { className: classNames }, renderFunction && renderFunction(this.props, defaultRenderFunction));
    }
    /**
     * Deprecation helper for getting text.
     */
    _getText() {
        return this.props.text || this.props.primaryText || '';
    }
    /**
     * using closure to wrap the default render behavior
     * to make it independent of the type of text passed
     * @param text
     */
    _onRenderText(text) {
        // return default render behaviour for valid text or undefined
        return text
            ? () => {
                // default onRender behaviour
                return (createElement(TooltipHost, { content: text, overflowMode: TooltipOverflowMode.Parent, directionalHint: DirectionalHint.topLeftEdge }, text));
            }
            : undefined;
    }
}
PersonaBase.defaultProps = {
    size: PersonaSize.size48,
    presence: PersonaPresence.none,
    imageAlt: ''
};

const GlobalClassNames$7 = {
    root: 'ms-Persona',
    size10: 'ms-Persona--size10',
    size16: 'ms-Persona--size16',
    size24: 'ms-Persona--size24',
    size28: 'ms-Persona--size28',
    size32: 'ms-Persona--size32',
    size40: 'ms-Persona--size40',
    size48: 'ms-Persona--size48',
    size72: 'ms-Persona--size72',
    size100: 'ms-Persona--size100',
    available: 'ms-Persona--online',
    away: 'ms-Persona--away',
    blocked: 'ms-Persona--blocked',
    busy: 'ms-Persona--busy',
    doNotDisturb: 'ms-Persona--donotdisturb',
    offline: 'ms-Persona--offline',
    details: 'ms-Persona-details',
    primaryText: 'ms-Persona-primaryText',
    secondaryText: 'ms-Persona-secondaryText',
    tertiaryText: 'ms-Persona-tertiaryText',
    optionalText: 'ms-Persona-optionalText',
    textContent: 'ms-Persona-textContent'
};
const getStyles$a = (props) => {
    const { className, showSecondaryText, theme } = props;
    const { palette } = theme;
    const classNames = getGlobalClassNames(GlobalClassNames$7, theme);
    const size = sizeBoolean(props.size);
    const presence = presenceBoolean(props.presence);
    const showSecondaryTextDefaultHeight = '16px';
    const sharedTextStyles = {
        color: palette.neutralSecondary,
        fontWeight: FontWeights.regular,
        fontSize: FontSizes.small
    };
    return {
        root: [
            classNames.root,
            theme.fonts.medium,
            normalize,
            {
                color: palette.neutralPrimary,
                fontSize: FontSizes.medium,
                fontWeight: FontWeights.regular,
                position: 'relative',
                height: personaSize.size48,
                minWidth: personaSize.size48,
                display: 'flex',
                alignItems: 'center',
                selectors: {
                    '.contextualHost': {
                        display: 'none'
                    },
                    ':hover': {
                        selectors: {
                            $primaryText: {
                                color: palette.neutralDark
                            }
                        }
                    }
                }
            },
            size.isSize10 && [
                classNames.size10,
                {
                    height: personaSize.size10,
                    minWidth: personaSize.size10
                }
            ],
            size.isSize16 && [
                classNames.size16,
                {
                    height: personaSize.size16,
                    minWidth: personaSize.size16
                }
            ],
            size.isSize24 && [
                classNames.size24,
                {
                    height: personaSize.size24,
                    minWidth: personaSize.size24
                }
            ],
            size.isSize24 &&
                showSecondaryText && {
                height: '36px'
            },
            size.isSize28 && [
                classNames.size28,
                {
                    height: personaSize.size28,
                    minWidth: personaSize.size28
                }
            ],
            size.isSize28 &&
                showSecondaryText && {
                height: '32px'
            },
            size.isSize32 && [
                classNames.size32,
                {
                    height: personaSize.size32,
                    minWidth: personaSize.size32
                }
            ],
            size.isSize40 && [
                classNames.size40,
                {
                    height: personaSize.size40,
                    minWidth: personaSize.size40
                }
            ],
            size.isSize48 && classNames.size48,
            size.isSize72 && [
                classNames.size72,
                {
                    height: personaSize.size72,
                    minWidth: personaSize.size72
                }
            ],
            size.isSize100 && [
                classNames.size100,
                {
                    height: personaSize.size100,
                    minWidth: personaSize.size100
                }
            ],
            /**
             * Modifiers: presence
             */
            presence.isAvailable && classNames.available,
            presence.isAway && classNames.away,
            presence.isBlocked && classNames.blocked,
            presence.isBusy && classNames.busy,
            presence.isDoNotDisturb && classNames.doNotDisturb,
            presence.isOffline && classNames.offline,
            className
        ],
        details: [
            classNames.details,
            {
                padding: '0 24px 0 16px',
                minWidth: 0,
                width: '100%',
                textAlign: 'left',
                display: 'flex',
                flexDirection: 'column',
                justifyContent: 'space-around'
            },
            size.isSize10 && {
                paddingLeft: '17px'
            },
            (size.isSize24 || size.isSize28) && {
                padding: '0 12px'
            }
        ],
        primaryText: [
            classNames.primaryText,
            noWrap,
            {
                color: palette.neutralPrimary,
                fontWeight: FontWeights.regular,
                fontSize: FontSizes.large
            },
            showSecondaryText && {
                height: showSecondaryTextDefaultHeight,
                lineHeight: showSecondaryTextDefaultHeight,
                overflowX: 'hidden'
            },
            size.isSize10 && {
                fontSize: FontSizes.small,
                lineHeight: personaSize.size10
            },
            (size.isSize16 || size.isSize24 || size.isSize28 || size.isSize32 || size.isSize40) && {
                fontSize: FontSizes.medium
            },
            size.isSize16 && {
                lineHeight: personaSize.size28
            },
            (size.isSize24 || size.isSize28 || size.isSize32 || size.isSize40) &&
                showSecondaryText && {
                height: '18px'
            },
            size.isSize72 && {
                fontSize: FontSizes.xLarge
            },
            size.isSize100 && {
                fontSize: FontSizes.xLarge,
                fontWeight: FontWeights.semilight
            }
        ],
        secondaryText: [
            classNames.secondaryText,
            noWrap,
            sharedTextStyles,
            (size.isSize10 || size.isSize16 || size.isSize24 || size.isSize28 || size.isSize32) && {
                display: 'none'
            },
            size.isSize24 &&
                showSecondaryText && {
                height: '18px'
            },
            (size.isSize72 || size.isSize100) && {
                fontSize: FontSizes.medium
            },
            showSecondaryText && {
                display: 'block',
                height: showSecondaryTextDefaultHeight,
                lineHeight: showSecondaryTextDefaultHeight,
                overflowX: 'hidden'
            }
        ],
        tertiaryText: [
            classNames.tertiaryText,
            noWrap,
            sharedTextStyles,
            {
                display: 'none'
            },
            (size.isSize72 || size.isSize100) && {
                display: 'block'
            }
        ],
        optionalText: [
            classNames.optionalText,
            noWrap,
            sharedTextStyles,
            {
                display: 'none'
            },
            size.isSize100 && {
                display: 'block'
            }
        ],
        textContent: [classNames.textContent, noWrap]
    };
};

/**
 * Personas are used for rendering an individual's avatar, presence and details.
 * They are used within the PeoplePicker components.
 */
const Persona = styled(PersonaBase, getStyles$a, undefined, {
    scope: 'Persona'
});

class ActivityItem extends BaseComponent {
    constructor(props) {
        super(props);
        this._onRenderIcon = (props) => {
            if (props.activityPersonas) {
                return this._onRenderPersonaArray(props);
            }
            else {
                return this.props.activityIcon;
            }
        };
        this._onRenderActivityDescription = (props) => {
            const classNames = this._getClassNames(props);
            const activityDescription = props.activityDescription || props.activityDescriptionText;
            if (activityDescription) {
                return createElement("span", { className: classNames.activityText }, activityDescription);
            }
            return null;
        };
        this._onRenderComments = (props) => {
            const classNames = this._getClassNames(props);
            const comments = props.comments || props.commentText;
            if (!props.isCompact && comments) {
                return createElement("div", { className: classNames.commentText }, comments);
            }
            return null;
        };
        this._onRenderTimeStamp = (props) => {
            const classNames = this._getClassNames(props);
            if (!props.isCompact && props.timeStamp) {
                return createElement("div", { className: classNames.timeStamp }, props.timeStamp);
            }
            return null;
        };
        // If activityPersonas is an array of persona props, build the persona cluster element.
        this._onRenderPersonaArray = (props) => {
            const classNames = this._getClassNames(props);
            let personaElement = null;
            const activityPersonas = props.activityPersonas;
            if (activityPersonas[0].imageUrl || activityPersonas[0].imageInitials) {
                const personaList = [];
                const showSize16Personas = activityPersonas.length > 1 || props.isCompact;
                const personaLimit = props.isCompact ? 3 : 4;
                let style = undefined;
                if (props.isCompact) {
                    style = {
                        display: 'inline-block',
                        width: '10px',
                        minWidth: '10px',
                        overflow: 'visible'
                    };
                }
                activityPersonas
                    .filter((person, index) => index < personaLimit)
                    .forEach((person, index) => {
                    personaList.push(createElement(PersonaCoin, Object.assign({}, person, { 
                        // tslint:disable-next-line:no-string-literal
                        key: person['key'] ? person['key'] : index, className: classNames.activityPersona, size: showSize16Personas ? PersonaSize.size16 : PersonaSize.size32, style: style })));
                });
                personaElement = createElement("div", { className: classNames.personaContainer }, personaList);
            }
            return personaElement;
        };
    }
    render() {
        const { onRenderIcon = this._onRenderIcon, onRenderActivityDescription = this._onRenderActivityDescription, onRenderComments = this._onRenderComments, onRenderTimeStamp = this._onRenderTimeStamp, animateBeaconSignal, isCompact } = this.props;
        const classNames = this._getClassNames(this.props);
        return (createElement("div", { className: classNames.root, style: this.props.style },
            (this.props.activityPersonas || this.props.activityIcon || this.props.onRenderIcon) && (createElement("div", { className: classNames.activityTypeIcon },
                animateBeaconSignal && isCompact && createElement("div", { className: classNames.pulsingBeacon }),
                onRenderIcon(this.props))),
            createElement("div", { className: classNames.activityContent },
                onRenderActivityDescription(this.props, this._onRenderActivityDescription),
                onRenderComments(this.props, this._onRenderComments),
                onRenderTimeStamp(this.props, this._onRenderTimeStamp))));
    }
    _getClassNames(props) {
        return getClassNames(getStyles(undefined, props.styles, props.animateBeaconSignal, props.beaconColorOne, props.beaconColorTwo, props.isCompact), props.className, props.activityPersonas, props.isCompact);
    }
}

const SELECTION_FORWARD = 'forward';
const SELECTION_BACKWARD = 'backward';
class Autofill extends BaseComponent {
    constructor(props) {
        super(props);
        this._inputElement = createRef();
        this._autoFillEnabled = true;
        // Composition events are used when the character/text requires several keystrokes to be completed.
        // Some examples of this are mobile text input and langauges like Japanese or Arabic.
        // Find out more at https://developer.mozilla.org/en-US/docs/Web/Events/compositionstart
        this._onCompositionStart = (ev) => {
            this._autoFillEnabled = false;
        };
        // Composition events are used when the character/text requires several keystrokes to be completed.
        // Some examples of this are mobile text input and langauges like Japanese or Arabic.
        // Find out more at https://developer.mozilla.org/en-US/docs/Web/Events/compositionstart
        this._onCompositionEnd = (ev) => {
            const inputValue = this._getCurrentInputValue();
            this._tryEnableAutofill(inputValue, this.value, false, true);
            // Korean characters typing issue has been addressed in React 16.5
            // TODO: revert back below lines when we upgrade to React 16.5
            // Find out at https://github.com/facebook/react/pull/12563/commits/06524c6c542c571705c0fd7df61ac48f3d5ce244
            const isKorean = ev.nativeEvent.locale === 'ko';
            // Due to timing, this needs to be async, otherwise no text will be selected.
            this._async.setTimeout(() => {
                const updatedInputValue = isKorean ? this.value : inputValue;
                this._updateValue(updatedInputValue);
            }, 0);
        };
        this._onClick = () => {
            if (this._value && this._value !== '' && this._autoFillEnabled) {
                this._autoFillEnabled = false;
            }
        };
        this._onKeyDown = (ev) => {
            if (this.props.onKeyDown) {
                this.props.onKeyDown(ev);
            }
            // If the event is actively being composed, then don't alert autofill.
            // Right now typing does not have isComposing, once that has been fixed any should be removed.
            if (!ev.nativeEvent.isComposing) {
                switch (ev.which) {
                    case KeyCodes.backspace:
                        this._autoFillEnabled = false;
                        break;
                    case KeyCodes.left:
                    case KeyCodes.right:
                        if (this._autoFillEnabled) {
                            this._value = this.state.displayValue;
                            this._autoFillEnabled = false;
                        }
                        break;
                    default:
                        if (!this._autoFillEnabled) {
                            if (this.props.enableAutofillOnKeyPress.indexOf(ev.which) !== -1) {
                                this._autoFillEnabled = true;
                            }
                        }
                        break;
                }
            }
        };
        this._onInputChanged = (ev) => {
            const value = this._getCurrentInputValue(ev);
            // Right now typing does not have isComposing, once that has been fixed any should be removed.
            this._tryEnableAutofill(value, this._value, ev.nativeEvent.isComposing);
            this._updateValue(value);
        };
        this._onChanged = () => {
            // Swallow this event, we don't care about it
            // We must provide it because React PropTypes marks it as required, but onInput serves the correct purpose
            return;
        };
        /**
         * Updates the current input value as well as getting a new display value.
         * @param newValue The new value from the input
         */
        this._updateValue = (newValue) => {
            // Only proceed if the value is nonempty and is different from the old value
            // This is to work around the fact that, in IE 11, inputs with a placeholder fire an onInput event on focus
            if (!newValue && newValue === this._value) {
                return;
            }
            this._value = this.props.onInputChange ? this.props.onInputChange(newValue) : newValue;
            this.setState({
                displayValue: this._getDisplayValue(this._value, this.props.suggestedDisplayValue)
            }, () => this._notifyInputChange(this._value));
        };
        this._value = props.defaultVisibleValue || '';
        this.state = {
            displayValue: props.defaultVisibleValue || ''
        };
    }
    get cursorLocation() {
        if (this._inputElement.current) {
            const inputElement = this._inputElement.current;
            if (inputElement.selectionDirection !== SELECTION_FORWARD) {
                return inputElement.selectionEnd;
            }
            else {
                return inputElement.selectionStart;
            }
        }
        else {
            return -1;
        }
    }
    get isValueSelected() {
        return Boolean(this.inputElement && this.inputElement.selectionStart !== this.inputElement.selectionEnd);
    }
    get value() {
        return this._value;
    }
    get selectionStart() {
        return this._inputElement.current ? this._inputElement.current.selectionStart : -1;
    }
    get selectionEnd() {
        return this._inputElement.current ? this._inputElement.current.selectionEnd : -1;
    }
    get inputElement() {
        return this._inputElement.current;
    }
    componentWillReceiveProps(nextProps) {
        let newValue;
        if (this.props.updateValueInWillReceiveProps) {
            newValue = this.props.updateValueInWillReceiveProps();
        }
        newValue = this._getDisplayValue(newValue ? newValue : this._value, nextProps.suggestedDisplayValue);
        if (typeof newValue === 'string') {
            this.setState({ displayValue: newValue });
        }
    }
    componentDidUpdate() {
        const value = this._value;
        const { suggestedDisplayValue, shouldSelectFullInputValueInComponentDidUpdate, preventValueSelection } = this.props;
        let differenceIndex = 0;
        if (preventValueSelection) {
            return;
        }
        if (this._autoFillEnabled && value && suggestedDisplayValue && this._doesTextStartWith(suggestedDisplayValue, value)) {
            let shouldSelectFullRange = false;
            if (shouldSelectFullInputValueInComponentDidUpdate) {
                shouldSelectFullRange = shouldSelectFullInputValueInComponentDidUpdate();
            }
            if (shouldSelectFullRange && this._inputElement.current) {
                this._inputElement.current.setSelectionRange(0, suggestedDisplayValue.length, SELECTION_BACKWARD);
            }
            else {
                while (differenceIndex < value.length &&
                    value[differenceIndex].toLocaleLowerCase() === suggestedDisplayValue[differenceIndex].toLocaleLowerCase()) {
                    differenceIndex++;
                }
                if (differenceIndex > 0 && this._inputElement.current) {
                    this._inputElement.current.setSelectionRange(differenceIndex, suggestedDisplayValue.length, SELECTION_BACKWARD);
                }
            }
        }
    }
    render() {
        const { displayValue } = this.state;
        const nativeProps = getNativeProps(this.props, inputProperties);
        return (createElement("input", Object.assign({}, nativeProps, { ref: this._inputElement, value: displayValue, autoCapitalize: 'off', autoComplete: 'off', onCompositionStart: this._onCompositionStart, onCompositionEnd: this._onCompositionEnd, onChange: this._onChanged, onInput: this._onInputChanged, onKeyDown: this._onKeyDown, onClick: this.props.onClick ? this.props.onClick : this._onClick, "data-lpignore": true })));
    }
    focus() {
        this._inputElement.current && this._inputElement.current.focus();
    }
    clear() {
        this._autoFillEnabled = true;
        this._updateValue('');
        this._inputElement.current && this._inputElement.current.setSelectionRange(0, 0);
    }
    _getCurrentInputValue(ev) {
        if (ev && ev.target && ev.target.value) {
            return ev.target.value;
        }
        else if (this.inputElement && this.inputElement.value) {
            return this.inputElement.value;
        }
        else {
            return '';
        }
    }
    /**
     * Attempts to enable autofill. Whether or not autofill is enabled depends on the input value,
     * whether or not any text is selected, and only if the new input value is longer than the old input value.
     * Autofill should never be set to true if the value is composing. Once compositionEnd is called, then
     * it should be completed.
     * See https://developer.mozilla.org/en-US/docs/Web/API/CompositionEvent for more information on composition.
     * @param newValue
     * @param oldValue
     * @param isComposing if true then the text is actively being composed and it has not completed.
     * @param isComposed if the text is a composed text value.
     */
    _tryEnableAutofill(newValue, oldValue, isComposing, isComposed) {
        if (!isComposing &&
            newValue &&
            this._inputElement.current &&
            this._inputElement.current.selectionStart === newValue.length &&
            !this._autoFillEnabled &&
            (newValue.length > oldValue.length || isComposed)) {
            this._autoFillEnabled = true;
        }
    }
    _notifyInputChange(newValue) {
        if (this.props.onInputValueChange) {
            this.props.onInputValueChange(newValue);
        }
    }
    /**
     * Returns a string that should be used as the display value.
     * It evaluates this based on whether or not the suggested value starts with the input value
     * and whether or not autofill is enabled.
     * @param inputValue the value that the input currently has.
     * @param suggestedDisplayValue the possible full value
     */
    _getDisplayValue(inputValue, suggestedDisplayValue) {
        let displayValue = inputValue;
        if (suggestedDisplayValue && inputValue && this._doesTextStartWith(suggestedDisplayValue, displayValue) && this._autoFillEnabled) {
            displayValue = suggestedDisplayValue;
        }
        return displayValue;
    }
    _doesTextStartWith(text, startWith) {
        if (!text || !startWith) {
            return false;
        }
        return text.toLocaleLowerCase().indexOf(startWith.toLocaleLowerCase()) === 0;
    }
}
Autofill.defaultProps = {
    enableAutofillOnKeyPress: [KeyCodes.down, KeyCodes.up]
};
/**
 *  @deprecated do not use.
 */
class BaseAutoFill extends Autofill {
}

const FocusZoneTabbableElements = {
    /** Tabbing is not allowed */
    none: 0,
    /** All tabbing action is allowed */
    all: 1,
    /** Tabbing is allowed only on input elements */
    inputOnly: 2
};
var FocusZoneDirection;
(function (FocusZoneDirection) {
    /** Only react to up/down arrows. */
    FocusZoneDirection[FocusZoneDirection["vertical"] = 0] = "vertical";
    /** Only react to left/right arrows. */
    FocusZoneDirection[FocusZoneDirection["horizontal"] = 1] = "horizontal";
    /** React to all arrows. */
    FocusZoneDirection[FocusZoneDirection["bidirectional"] = 2] = "bidirectional";
})(FocusZoneDirection || (FocusZoneDirection = {}));

const IS_FOCUSABLE_ATTRIBUTE$1 = 'data-is-focusable';
const IS_ENTER_DISABLED_ATTRIBUTE = 'data-disable-click-on-enter';
const FOCUSZONE_ID_ATTRIBUTE$1 = 'data-focuszone-id';
const TABINDEX = 'tabindex';
const NO_VERTICAL_WRAP = 'data-no-vertical-wrap';
const NO_HORIZONTAL_WRAP = 'data-no-horizontal-wrap';
const LARGE_DISTANCE_FROM_CENTER = 999999999;
const LARGE_NEGATIVE_DISTANCE_FROM_CENTER = -999999999;
const _allInstances = {};
const ALLOWED_INPUT_TYPES = ['text', 'number', 'password', 'email', 'tel', 'url', 'search'];
const ALLOW_VIRTUAL_ELEMENTS = false;
class FocusZone extends BaseComponent {
    constructor(props) {
        super(props);
        this._root = createRef();
        this._onFocus = (ev) => {
            const { onActiveElementChanged, doNotAllowFocusEventToPropagate, onFocusNotification } = this.props;
            if (onFocusNotification) {
                onFocusNotification();
            }
            if (this._isImmediateDescendantOfZone(ev.target)) {
                this._activeElement = ev.target;
                this._setFocusAlignment(this._activeElement);
            }
            else {
                let parentElement = ev.target;
                while (parentElement && parentElement !== this._root.current) {
                    if (isElementTabbable(parentElement) && this._isImmediateDescendantOfZone(parentElement)) {
                        this._activeElement = parentElement;
                        break;
                    }
                    parentElement = getParent(parentElement, ALLOW_VIRTUAL_ELEMENTS);
                }
            }
            if (onActiveElementChanged) {
                onActiveElementChanged(this._activeElement, ev);
            }
            if (doNotAllowFocusEventToPropagate) {
                ev.stopPropagation();
            }
        };
        this._onMouseDown = (ev) => {
            const { disabled } = this.props;
            if (disabled) {
                return;
            }
            let target = ev.target;
            const path = [];
            while (target && target !== this._root.current) {
                path.push(target);
                target = getParent(target, ALLOW_VIRTUAL_ELEMENTS);
            }
            while (path.length) {
                target = path.pop();
                if (target && isElementTabbable(target)) {
                    this._setActiveElement(target, true);
                }
                if (isElementFocusZone(target)) {
                    // Stop here since the focus zone will take care of its own children.
                    break;
                }
            }
        };
        /**
         * Handle the keystrokes.
         */
        this._onKeyDown = (ev) => {
            const { direction, disabled, isInnerZoneKeystroke } = this.props;
            if (disabled) {
                return;
            }
            if (this.props.onKeyDown) {
                this.props.onKeyDown(ev);
            }
            // If the default has been prevented, do not process keyboard events.
            if (ev.isDefaultPrevented()) {
                return;
            }
            if (document.activeElement === this._root.current && this._isInnerZone) {
                // If this element has focus, it is being controlled by a parent.
                // Ignore the keystroke.
                return;
            }
            if (isInnerZoneKeystroke && isInnerZoneKeystroke(ev) && this._isImmediateDescendantOfZone(ev.target)) {
                // Try to focus
                const innerZone = this._getFirstInnerZone();
                if (innerZone) {
                    if (!innerZone.focus(true)) {
                        return;
                    }
                }
                else if (isElementFocusSubZone(ev.target)) {
                    if (!this.focusElement(getNextElement(ev.target, ev.target.firstChild, true))) {
                        return;
                    }
                }
                else {
                    return;
                }
            }
            else if (ev.altKey) {
                return;
            }
            else {
                switch (ev.which) {
                    case KeyCodes.space:
                        if (this._tryInvokeClickForFocusable(ev.target)) {
                            break;
                        }
                        return;
                    case KeyCodes.left:
                        if (direction !== FocusZoneDirection.vertical && this._moveFocusLeft()) {
                            break;
                        }
                        return;
                    case KeyCodes.right:
                        if (direction !== FocusZoneDirection.vertical && this._moveFocusRight()) {
                            break;
                        }
                        return;
                    case KeyCodes.up:
                        if (direction !== FocusZoneDirection.horizontal && this._moveFocusUp()) {
                            break;
                        }
                        return;
                    case KeyCodes.down:
                        if (direction !== FocusZoneDirection.horizontal && this._moveFocusDown()) {
                            break;
                        }
                        return;
                    case KeyCodes.tab:
                        if (this.props.allowTabKey ||
                            this.props.handleTabKey === FocusZoneTabbableElements.all ||
                            (this.props.handleTabKey === FocusZoneTabbableElements.inputOnly && this._isElementInput(ev.target))) {
                            let focusChanged = false;
                            this._processingTabKey = true;
                            if (direction === FocusZoneDirection.vertical ||
                                !this._shouldWrapFocus(this._activeElement, NO_HORIZONTAL_WRAP)) {
                                focusChanged = ev.shiftKey ? this._moveFocusUp() : this._moveFocusDown();
                            }
                            else if (direction === FocusZoneDirection.horizontal || direction === FocusZoneDirection.bidirectional) {
                                const tabWithDirection = getRTL() ? !ev.shiftKey : ev.shiftKey;
                                focusChanged = tabWithDirection ? this._moveFocusLeft() : this._moveFocusRight();
                            }
                            this._processingTabKey = false;
                            if (focusChanged) {
                                break;
                            }
                        }
                        return;
                    case KeyCodes.home:
                        if (this._isElementInput(ev.target) && !this._shouldInputLoseFocus(ev.target, false)) {
                            return false;
                        }
                        const firstChild = this._root.current && this._root.current.firstChild;
                        if (this._root.current && firstChild && this.focusElement(getNextElement(this._root.current, firstChild, true))) {
                            break;
                        }
                        return;
                    case KeyCodes.end:
                        if (this._isElementInput(ev.target) && !this._shouldInputLoseFocus(ev.target, true)) {
                            return false;
                        }
                        const lastChild = this._root.current && this._root.current.lastChild;
                        if (this._root.current && this.focusElement(getPreviousElement(this._root.current, lastChild, true, true, true))) {
                            break;
                        }
                        return;
                    case KeyCodes.enter:
                        if (this._tryInvokeClickForFocusable(ev.target)) {
                            break;
                        }
                        return;
                    default:
                        return;
                }
            }
            ev.preventDefault();
            ev.stopPropagation();
        };
        this._warnDeprecations({
            rootProps: undefined,
            allowTabKey: 'handleTabKey'
        });
        this._id = getId('FocusZone');
        this._focusAlignment = {
            left: 0,
            top: 0
        };
        this._processingTabKey = false;
    }
    componentDidMount() {
        _allInstances[this._id] = this;
        if (this._root.current) {
            const windowElement = this._root.current.ownerDocument.defaultView;
            let parentElement = getParent(this._root.current, ALLOW_VIRTUAL_ELEMENTS);
            while (parentElement && parentElement !== document.body && parentElement.nodeType === 1) {
                if (isElementFocusZone(parentElement)) {
                    this._isInnerZone = true;
                    break;
                }
                parentElement = getParent(parentElement, ALLOW_VIRTUAL_ELEMENTS);
            }
            if (!this._isInnerZone) {
                this._events.on(windowElement, 'keydown', this._onKeyDownCapture, true);
            }
            // Assign initial tab indexes so that we can set initial focus as appropriate.
            this._updateTabIndexes();
            if (this.props.defaultActiveElement) {
                this._activeElement = getDocument().querySelector(this.props.defaultActiveElement);
                this.focus();
            }
        }
    }
    componentWillUnmount() {
        delete _allInstances[this._id];
    }
    render() {
        const { rootProps, ariaDescribedBy, ariaLabelledBy, className } = this.props;
        const divProps = getNativeProps(this.props, htmlElementProperties);
        const Tag = this.props.elementType || 'div';
        //@ts-ignore
        return (createElement(Tag, Object.assign({ role: "presentation" }, divProps, rootProps, { className: css('ms-FocusZone', className), ref: this._root, "data-focuszone-id": this._id, "aria-labelledby": ariaLabelledBy, "aria-describedby": ariaDescribedBy, onKeyDown: this._onKeyDown, onFocus: this._onFocus, onMouseDownCapture: this._onMouseDown }), this.props.children));
    }
    /**
     * Sets focus to the first tabbable item in the zone.
     * @param forceIntoFirstElement - If true, focus will be forced into the first element, even
     * if focus is already in the focus zone.
     * @returns True if focus could be set to an active element, false if no operation was taken.
     */
    focus(forceIntoFirstElement = false) {
        if (this._root.current) {
            if (!forceIntoFirstElement && this._root.current.getAttribute(IS_FOCUSABLE_ATTRIBUTE$1) === 'true' && this._isInnerZone) {
                const ownerZoneElement = this._getOwnerZone(this._root.current);
                if (ownerZoneElement !== this._root.current) {
                    const ownerZone = _allInstances[ownerZoneElement.getAttribute(FOCUSZONE_ID_ATTRIBUTE$1)];
                    return !!ownerZone && ownerZone.focusElement(this._root.current);
                }
                return false;
            }
            else if (!forceIntoFirstElement &&
                this._activeElement &&
                elementContains(this._root.current, this._activeElement) &&
                isElementTabbable(this._activeElement)) {
                this._activeElement.focus();
                return true;
            }
            else {
                const firstChild = this._root.current.firstChild;
                return this.focusElement(getNextElement(this._root.current, firstChild, true));
            }
        }
        return false;
    }
    /**
     * Sets focus to a specific child element within the zone. This can be used in conjunction with
     * onBeforeFocus to created delayed focus scenarios (like animate the scroll position to the correct
     * location and then focus.)
     * @param element - The child element within the zone to focus.
     * @returns True if focus could be set to an active element, false if no operation was taken.
     */
    focusElement(element) {
        const { onBeforeFocus } = this.props;
        if (onBeforeFocus && !onBeforeFocus(element)) {
            return false;
        }
        if (element) {
            this._setActiveElement(element);
            if (this._activeElement) {
                this._activeElement.focus();
            }
            return true;
        }
        return false;
    }
    /**
     * Handle global tab presses so that we can patch tabindexes on the fly.
     */
    _onKeyDownCapture(ev) {
        if (ev.which === KeyCodes.tab) {
            this._updateTabIndexes();
        }
    }
    _setActiveElement(element, forceAlignemnt) {
        const previousActiveElement = this._activeElement;
        this._activeElement = element;
        if (previousActiveElement) {
            if (isElementFocusZone(previousActiveElement)) {
                this._updateTabIndexes(previousActiveElement);
            }
            previousActiveElement.tabIndex = -1;
        }
        if (this._activeElement) {
            if (!this._focusAlignment || forceAlignemnt) {
                this._setFocusAlignment(element, true, true);
            }
            this._activeElement.tabIndex = 0;
        }
    }
    /**
     * Walk up the dom try to find a focusable element.
     */
    _tryInvokeClickForFocusable(target) {
        if (target === this._root.current) {
            return false;
        }
        do {
            if (target.tagName === 'BUTTON' || target.tagName === 'A' || target.tagName === 'INPUT' || target.tagName === 'TEXTAREA') {
                return false;
            }
            if (this._isImmediateDescendantOfZone(target) &&
                target.getAttribute(IS_FOCUSABLE_ATTRIBUTE$1) === 'true' &&
                target.getAttribute(IS_ENTER_DISABLED_ATTRIBUTE) !== 'true') {
                EventGroup.raise(target, 'click', null, true);
                return true;
            }
            target = getParent(target, ALLOW_VIRTUAL_ELEMENTS);
        } while (target !== this._root.current);
        return false;
    }
    /**
     * Traverse to find first child zone.
     */
    _getFirstInnerZone(rootElement) {
        rootElement = rootElement || this._activeElement || this._root.current;
        if (!rootElement) {
            return null;
        }
        if (isElementFocusZone(rootElement)) {
            return _allInstances[rootElement.getAttribute(FOCUSZONE_ID_ATTRIBUTE$1)];
        }
        let child = rootElement.firstElementChild;
        while (child) {
            if (isElementFocusZone(child)) {
                return _allInstances[child.getAttribute(FOCUSZONE_ID_ATTRIBUTE$1)];
            }
            const match = this._getFirstInnerZone(child);
            if (match) {
                return match;
            }
            child = child.nextElementSibling;
        }
        return null;
    }
    _moveFocus(isForward, getDistanceFromCenter, ev, useDefaultWrap = true) {
        let element = this._activeElement;
        let candidateDistance = -1;
        let candidateElement = undefined;
        let changedFocus = false;
        const isBidirectional = this.props.direction === FocusZoneDirection.bidirectional;
        if (!element || !this._root.current) {
            return false;
        }
        if (this._isElementInput(element)) {
            if (!this._shouldInputLoseFocus(element, isForward)) {
                return false;
            }
        }
        const activeRect = isBidirectional ? element.getBoundingClientRect() : null;
        do {
            element = (isForward ? getNextElement(this._root.current, element) : getPreviousElement(this._root.current, element));
            if (isBidirectional) {
                if (element) {
                    const targetRect = element.getBoundingClientRect();
                    const elementDistance = getDistanceFromCenter(activeRect, targetRect);
                    if (elementDistance === -1 && candidateDistance === -1) {
                        candidateElement = element;
                        break;
                    }
                    if (elementDistance > -1 && (candidateDistance === -1 || elementDistance < candidateDistance)) {
                        candidateDistance = elementDistance;
                        candidateElement = element;
                    }
                    if (candidateDistance >= 0 && elementDistance < 0) {
                        break;
                    }
                }
            }
            else {
                candidateElement = element;
                break;
            }
        } while (element);
        // Focus the closest candidate
        if (candidateElement && candidateElement !== this._activeElement) {
            changedFocus = true;
            this.focusElement(candidateElement);
        }
        else if (this.props.isCircularNavigation && useDefaultWrap) {
            if (isForward) {
                return this.focusElement(getNextElement(this._root.current, this._root.current.firstElementChild, true));
            }
            else {
                return this.focusElement(getPreviousElement(this._root.current, this._root.current.lastElementChild, true, true, true));
            }
        }
        return changedFocus;
    }
    _moveFocusDown() {
        let targetTop = -1;
        const leftAlignment = this._focusAlignment.left;
        if (this._moveFocus(true, (activeRect, targetRect) => {
            let distance = -1;
            // ClientRect values can be floats that differ by very small fractions of a decimal.
            // If the difference between top and bottom are within a pixel then we should treat
            // them as equivalent by using Math.floor. For instance 5.2222 and 5.222221 should be equivalent,
            // but without Math.Floor they will be handled incorrectly.
            const targetRectTop = Math.floor(targetRect.top);
            const activeRectBottom = Math.floor(activeRect.bottom);
            if (targetRectTop < activeRectBottom) {
                if (!this._shouldWrapFocus(this._activeElement, NO_VERTICAL_WRAP)) {
                    return LARGE_NEGATIVE_DISTANCE_FROM_CENTER;
                }
                return LARGE_DISTANCE_FROM_CENTER;
            }
            if ((targetTop === -1 && targetRectTop >= activeRectBottom) || targetRectTop === targetTop) {
                targetTop = targetRectTop;
                if (leftAlignment >= targetRect.left && leftAlignment <= targetRect.left + targetRect.width) {
                    distance = 0;
                }
                else {
                    distance = Math.abs(targetRect.left + targetRect.width / 2 - leftAlignment);
                }
            }
            return distance;
        })) {
            this._setFocusAlignment(this._activeElement, false, true);
            return true;
        }
        return false;
    }
    _moveFocusUp() {
        let targetTop = -1;
        const leftAlignment = this._focusAlignment.left;
        if (this._moveFocus(false, (activeRect, targetRect) => {
            let distance = -1;
            // ClientRect values can be floats that differ by very small fractions of a decimal.
            // If the difference between top and bottom are within a pixel then we should treat
            // them as equivalent by using Math.floor. For instance 5.2222 and 5.222221 should be equivalent,
            // but without Math.Floor they will be handled incorrectly.
            const targetRectBottom = Math.floor(targetRect.bottom);
            const targetRectTop = Math.floor(targetRect.top);
            const activeRectTop = Math.floor(activeRect.top);
            if (targetRectBottom > activeRectTop) {
                if (!this._shouldWrapFocus(this._activeElement, NO_VERTICAL_WRAP)) {
                    return LARGE_NEGATIVE_DISTANCE_FROM_CENTER;
                }
                return LARGE_DISTANCE_FROM_CENTER;
            }
            if ((targetTop === -1 && targetRectBottom <= activeRectTop) || targetRectTop === targetTop) {
                targetTop = targetRectTop;
                if (leftAlignment >= targetRect.left && leftAlignment <= targetRect.left + targetRect.width) {
                    distance = 0;
                }
                else {
                    distance = Math.abs(targetRect.left + targetRect.width / 2 - leftAlignment);
                }
            }
            return distance;
        })) {
            this._setFocusAlignment(this._activeElement, false, true);
            return true;
        }
        return false;
    }
    _moveFocusLeft() {
        const shouldWrap = this._shouldWrapFocus(this._activeElement, NO_HORIZONTAL_WRAP);
        if (this._moveFocus(getRTL(), (activeRect, targetRect) => {
            let distance = -1;
            let topBottomComparison;
            if (getRTL()) {
                // When in RTL, this comparison should be the same as the one in _moveFocusRight for LTR.
                // Going left at a leftmost rectangle will go down a line instead of up a line like in LTR.
                // This is important, because we want to be comparing the top of the target rect
                // with the bottom of the active rect.
                topBottomComparison = targetRect.top.toFixed(3) < activeRect.bottom.toFixed(3);
            }
            else {
                topBottomComparison = targetRect.bottom.toFixed(3) > activeRect.top.toFixed(3);
            }
            if (topBottomComparison && targetRect.right <= activeRect.right && this.props.direction !== FocusZoneDirection.vertical) {
                distance = activeRect.right - targetRect.right;
            }
            else {
                if (!shouldWrap) {
                    distance = LARGE_NEGATIVE_DISTANCE_FROM_CENTER;
                }
            }
            return distance;
        }, undefined /*ev*/, shouldWrap)) {
            this._setFocusAlignment(this._activeElement, true, false);
            return true;
        }
        return false;
    }
    _moveFocusRight() {
        const shouldWrap = this._shouldWrapFocus(this._activeElement, NO_HORIZONTAL_WRAP);
        if (this._moveFocus(!getRTL(), (activeRect, targetRect) => {
            let distance = -1;
            let topBottomComparison;
            if (getRTL()) {
                // When in RTL, this comparison should be the same as the one in _moveFocusLeft for LTR.
                // Going right at a rightmost rectangle will go up a line instead of down a line like in LTR.
                // This is important, because we want to be comparing the bottom of the target rect
                // with the top of the active rect.
                topBottomComparison = targetRect.bottom.toFixed(3) > activeRect.top.toFixed(3);
            }
            else {
                topBottomComparison = targetRect.top.toFixed(3) < activeRect.bottom.toFixed(3);
            }
            if (topBottomComparison && targetRect.left >= activeRect.left && this.props.direction !== FocusZoneDirection.vertical) {
                distance = targetRect.left - activeRect.left;
            }
            else if (!shouldWrap) {
                distance = LARGE_NEGATIVE_DISTANCE_FROM_CENTER;
            }
            return distance;
        }, undefined /*ev*/, shouldWrap)) {
            this._setFocusAlignment(this._activeElement, true, false);
            return true;
        }
        return false;
    }
    _setFocusAlignment(element, isHorizontal, isVertical) {
        if (this.props.direction === FocusZoneDirection.bidirectional && (!this._focusAlignment || isHorizontal || isVertical)) {
            const rect = element.getBoundingClientRect();
            const left = rect.left + rect.width / 2;
            const top = rect.top + rect.height / 2;
            if (!this._focusAlignment) {
                this._focusAlignment = { left, top };
            }
            if (isHorizontal) {
                this._focusAlignment.left = left;
            }
            if (isVertical) {
                this._focusAlignment.top = top;
            }
        }
    }
    _isImmediateDescendantOfZone(element) {
        return this._getOwnerZone(element) === this._root.current;
    }
    _getOwnerZone(element) {
        let parentElement = getParent(element, ALLOW_VIRTUAL_ELEMENTS);
        while (parentElement && parentElement !== this._root.current && parentElement !== document.body) {
            if (isElementFocusZone(parentElement)) {
                return parentElement;
            }
            parentElement = getParent(parentElement, ALLOW_VIRTUAL_ELEMENTS);
        }
        return this._root.current;
    }
    _updateTabIndexes(element) {
        if (!element && this._root.current) {
            this._defaultFocusElement = null;
            element = this._root.current;
            if (this._activeElement && !elementContains(element, this._activeElement)) {
                this._activeElement = null;
            }
        }
        // If active element changes state to disabled, set it to null.
        // Otherwise, we lose keyboard accessibility to other elements in focus zone.
        if (this._activeElement && !isElementTabbable(this._activeElement)) {
            this._activeElement = null;
        }
        const childNodes = element && element.children;
        for (let childIndex = 0; childNodes && childIndex < childNodes.length; childIndex++) {
            const child = childNodes[childIndex];
            if (!isElementFocusZone(child)) {
                // If the item is explicitly set to not be focusable then TABINDEX needs to be set to -1.
                if (child.getAttribute && child.getAttribute(IS_FOCUSABLE_ATTRIBUTE$1) === 'false') {
                    child.setAttribute(TABINDEX, '-1');
                }
                if (isElementTabbable(child)) {
                    if (this.props.disabled) {
                        child.setAttribute(TABINDEX, '-1');
                    }
                    else if (!this._isInnerZone && ((!this._activeElement && !this._defaultFocusElement) || this._activeElement === child)) {
                        this._defaultFocusElement = child;
                        if (child.getAttribute(TABINDEX) !== '0') {
                            child.setAttribute(TABINDEX, '0');
                        }
                    }
                    else if (child.getAttribute(TABINDEX) !== '-1') {
                        child.setAttribute(TABINDEX, '-1');
                    }
                }
                else if (child.tagName === 'svg' && child.getAttribute('focusable') !== 'false') {
                    // Disgusting IE hack. Sad face.
                    child.setAttribute('focusable', 'false');
                }
            }
            else if (child.getAttribute(IS_FOCUSABLE_ATTRIBUTE$1) === 'true') {
                if (!this._isInnerZone && ((!this._activeElement && !this._defaultFocusElement) || this._activeElement === child)) {
                    this._defaultFocusElement = child;
                    if (child.getAttribute(TABINDEX) !== '0') {
                        child.setAttribute(TABINDEX, '0');
                    }
                }
                else if (child.getAttribute(TABINDEX) !== '-1') {
                    child.setAttribute(TABINDEX, '-1');
                }
            }
            this._updateTabIndexes(child);
        }
    }
    _isElementInput(element) {
        if (element && element.tagName && (element.tagName.toLowerCase() === 'input' || element.tagName.toLowerCase() === 'textarea')) {
            return true;
        }
        return false;
    }
    _shouldInputLoseFocus(element, isForward) {
        // If a tab was used, we want to focus on the next element.
        if (!this._processingTabKey && element && element.type && ALLOWED_INPUT_TYPES.indexOf(element.type.toLowerCase()) > -1) {
            const selectionStart = element.selectionStart;
            const selectionEnd = element.selectionEnd;
            const isRangeSelected = selectionStart !== selectionEnd;
            const inputValue = element.value;
            // We shouldn't lose focus in the following cases:
            // 1. There is range selected.
            // 2. When selection start is larger than 0 and it is backward.
            // 3. when selection start is not the end of length and it is forward.
            // 4. We press any of the arrow keys when our handleTabKey isn't none or undefined (only losing focus if we hit tab)
            // and if shouldInputLoseFocusOnArrowKey is defined, if scenario prefers to not loose the focus which is determined by calling the
            // callback shouldInputLoseFocusOnArrowKey
            if (isRangeSelected ||
                (selectionStart > 0 && !isForward) ||
                (selectionStart !== inputValue.length && isForward) ||
                (!!this.props.handleTabKey && !(this.props.shouldInputLoseFocusOnArrowKey && this.props.shouldInputLoseFocusOnArrowKey(element)))) {
                return false;
            }
        }
        return true;
    }
    _shouldWrapFocus(element, noWrapDataAttribute) {
        return !!this.props.checkForNoWrap ? shouldWrapFocus(element, noWrapDataAttribute) : true;
    }
}
FocusZone.defaultProps = {
    isCircularNavigation: false,
    direction: FocusZoneDirection.bidirectional
};

const KTP_PREFIX = 'ktp';
const KTP_SEPARATOR = '-';
const DATAKTP_TARGET = 'data-ktp-target';
const DATAKTP_EXECUTE_TARGET = 'data-ktp-execute-target';
const KTP_LAYER_ID = 'ktp-layer-id';
const KTP_ARIA_SEPARATOR = ', ';
// Events
var KeytipEvents;
(function (KeytipEvents) {
    KeytipEvents.KEYTIP_ADDED = 'keytipAdded';
    KeytipEvents.KEYTIP_REMOVED = 'keytipRemoved';
    KeytipEvents.KEYTIP_UPDATED = 'keytipUpdated';
    KeytipEvents.PERSISTED_KEYTIP_ADDED = 'persistedKeytipAdded';
    KeytipEvents.PERSISTED_KEYTIP_REMOVED = 'persistedKeytipRemoved';
    KeytipEvents.PERSISTED_KEYTIP_EXECUTE = 'persistedKeytipExecute';
    KeytipEvents.ENTER_KEYTIP_MODE = 'enterKeytipMode';
    KeytipEvents.EXIT_KEYTIP_MODE = 'exitKeytipMode';
})(KeytipEvents || (KeytipEvents = {}));

/**
 * This class is responsible for handling registering, updating, and unregistering of keytips
 */
class KeytipManager {
    constructor() {
        this.keytips = [];
        this.persistedKeytips = [];
        // This is (and should be) updated and kept in sync
        // with the inKeytipMode in KeytipLayer.
        this.inKeytipMode = false;
        // Boolean that gets checked before entering keytip mode by the KeytipLayer
        // Used for an override in special cases (e.g. Disable entering keytip mode when a modal is shown)
        this.shouldEnterKeytipMode = true;
    }
    /**
     * Static function to get singleton KeytipManager instance
     *
     * @returns {KeytipManager} Singleton KeytipManager instance
     */
    static getInstance() {
        return this._instance;
    }
    /**
     * Registers a keytip
     *
     * @param keytipProps - Keytip to register
     * @param persisted - T/F if this keytip should be persisted, default is false
     * @returns {string} Unique ID for this keytip
     */
    register(keytipProps, persisted = false) {
        let props = keytipProps;
        if (!persisted) {
            // Add the overflowSetSequence if necessary
            props = this.addParentOverflow(keytipProps);
        }
        // Create a unique keytip
        const uniqueKeytip = this._getUniqueKtp(props);
        // Add to array
        persisted ? this.persistedKeytips.push(uniqueKeytip) : this.keytips.push(uniqueKeytip);
        const event = persisted ? KeytipEvents.PERSISTED_KEYTIP_ADDED : KeytipEvents.KEYTIP_ADDED;
        EventGroup.raise(this, event, {
            keytip: props,
            uniqueID: uniqueKeytip.uniqueID
        });
        return uniqueKeytip.uniqueID;
    }
    /**
     * Update a keytip
     *
     * @param keytipProps - Keytip to update
     * @param uniqueID - Unique ID of this keytip
     */
    update(keytipProps, uniqueID) {
        const newKeytipProps = this.addParentOverflow(keytipProps);
        const uniqueKeytip = this._getUniqueKtp(newKeytipProps, uniqueID);
        const keytipIndex = findIndex(this.keytips, (ktp) => {
            return ktp.uniqueID === uniqueID;
        });
        if (keytipIndex >= 0) {
            // Update everything except 'visible'
            uniqueKeytip.keytip.visible = this.keytips[keytipIndex].keytip.visible;
            // Update keytip in this.keytips
            this.keytips = replaceElement(this.keytips, uniqueKeytip, keytipIndex);
            // Raise event
            EventGroup.raise(this, KeytipEvents.KEYTIP_UPDATED, {
                keytip: uniqueKeytip.keytip,
                uniqueID: uniqueKeytip.uniqueID
            });
        }
    }
    /**
     * Unregisters a keytip
     *
     * @param keytipToRemove - IKeytipProps of the keytip to remove
     * @param uniqueID - Unique ID of this keytip
     * @param persisted - T/F if this keytip should be persisted, default is false
     */
    unregister(keytipToRemove, uniqueID, persisted = false) {
        if (persisted) {
            // Remove keytip from this.persistedKeytips
            this.persistedKeytips = this.persistedKeytips.filter((uniqueKtp) => {
                return uniqueKtp.uniqueID !== uniqueID;
            });
        }
        else {
            // Remove keytip from this.keytips
            this.keytips = this.keytips.filter((uniqueKtp) => {
                return uniqueKtp.uniqueID !== uniqueID;
            });
        }
        const event = persisted ? KeytipEvents.PERSISTED_KEYTIP_REMOVED : KeytipEvents.KEYTIP_REMOVED;
        EventGroup.raise(this, event, {
            keytip: keytipToRemove,
            uniqueID: uniqueID
        });
    }
    /**
     * Manual call to enter keytip mode
     */
    enterKeytipMode() {
        EventGroup.raise(this, KeytipEvents.ENTER_KEYTIP_MODE);
    }
    /**
     * Manual call to exit keytip mode
     */
    exitKeytipMode() {
        EventGroup.raise(this, KeytipEvents.EXIT_KEYTIP_MODE);
    }
    /**
     * Gets all IKeytipProps from this.keytips
     *
     * @returns {IKeytipProps[]} All keytips stored in the manager
     */
    getKeytips() {
        return this.keytips.map((uniqueKeytip) => {
            return uniqueKeytip.keytip;
        });
    }
    /**
     * Adds the overflowSetSequence to the keytipProps if its parent keytip also has it
     *
     * @param keytipProps - Keytip props to add overflowSetSequence to if necessary
     * @returns {IKeytipProps} - Modified keytip props, if needed to be modified
     */
    addParentOverflow(keytipProps) {
        const fullSequence = [...keytipProps.keySequences];
        fullSequence.pop();
        if (fullSequence.length !== 0) {
            const parentKeytip = find(this.getKeytips(), (keytip) => {
                return arraysEqual(fullSequence, keytip.keySequences);
            });
            if (parentKeytip && parentKeytip.overflowSetSequence) {
                return {
                    ...keytipProps,
                    overflowSetSequence: parentKeytip.overflowSetSequence
                };
            }
        }
        return keytipProps;
    }
    /**
     * Public function to bind for overflow items that have a submenu
     *
     * @param overflowButtonSequences
     * @param keytipSequences
     */
    menuExecute(overflowButtonSequences, keytipSequences) {
        EventGroup.raise(this, KeytipEvents.PERSISTED_KEYTIP_EXECUTE, {
            overflowButtonSequences,
            keytipSequences
        });
    }
    /**
     * Creates an IUniqueKeytip object
     *
     * @param keytipProps - IKeytipProps
     * @param uniqueID - Unique ID, will default to the next unique ID if not passed
     * @returns {IUniqueKeytip} IUniqueKeytip object
     */
    _getUniqueKtp(keytipProps, uniqueID = getId()) {
        return { keytip: { ...keytipProps }, uniqueID };
    }
}
KeytipManager._instance = new KeytipManager();

/**
 * Converts a whole set of KeySequences into one keytip ID, which will be the ID for the last keytip sequence specified
 * keySequences should not include the initial keytip 'start' sequence.
 *
 * @param keySequences - Full path of IKeySequences for one keytip.
 * @returns {string} String to use for the keytip ID.
 */
function sequencesToID(keySequences) {
    return keySequences.reduce((prevValue, keySequence) => {
        return prevValue + KTP_SEPARATOR + keySequence.split('').join(KTP_SEPARATOR);
    }, KTP_PREFIX);
}
/**
 * Merges an overflow sequence with a key sequence.
 *
 * @param keySequences - Full sequence for one keytip.
 * @param overflowKeySequences - Full overflow keytip sequence.
 * @returns {string[]} Sequence that will be used by the keytip when in the overflow.
 */
function mergeOverflows(keySequences, overflowKeySequences) {
    const overflowSequenceLen = overflowKeySequences.length;
    const overflowSequence = [...overflowKeySequences].pop();
    const newKeySequences = [...keySequences];
    return addElementAtIndex(newKeySequences, overflowSequenceLen - 1, overflowSequence);
}
/**
 * Constructs the data-ktp-target attribute selector from a full key sequence.
 *
 * @param keySequences - Full string[] for a Keytip.
 * @returns {string} String selector to use to query for the keytip target.
 */
function ktpTargetFromSequences(keySequences) {
    return '[' + DATAKTP_TARGET + '="' + sequencesToID(keySequences) + '"]';
}
/**
 * Constructs the data-ktp-execute-target attribute selector from a keytip ID.
 *
 * @param keytipId - ID of the Keytip.
 * @returns {string} String selector to use to query for the keytip execute target.
 */
function ktpTargetFromId(keytipId) {
    return '[' + DATAKTP_EXECUTE_TARGET + '="' + keytipId + '"]';
}
/**
 * Gets the aria-describedby value to put on the component with this keytip.
 *
 * @param keySequences - KeySequences of the keytip.
 * @returns {string} The aria-describedby value to set on the component with this keytip.
 */
function getAriaDescribedBy(keySequences) {
    const describedby = ' ' + KTP_LAYER_ID;
    if (!keySequences.length) {
        // Return just the layer ID
        return describedby;
    }
    return describedby + ' ' + sequencesToID(keySequences);
}

/**
 * A small element to help the target component correctly read out its aria-describedby for its Keytip
 */
class KeytipData extends BaseComponent {
    constructor() {
        super(...arguments);
        this._keytipManager = KeytipManager.getInstance();
    }
    componentDidMount() {
        // Register Keytip in KeytipManager
        if (this.props.keytipProps) {
            this._uniqueId = this._keytipManager.register(this._getKtpProps());
        }
    }
    componentWillUnmount() {
        // Unregister Keytip in KeytipManager
        this.props.keytipProps && this._keytipManager.unregister(this._getKtpProps(), this._uniqueId);
    }
    componentDidUpdate() {
        // Update Keytip in KeytipManager
        this.props.keytipProps && this._keytipManager.update(this._getKtpProps(), this._uniqueId);
    }
    render() {
        const { children, keytipProps, ariaDescribedBy } = this.props;
        let nativeKeytipProps = {};
        if (keytipProps) {
            nativeKeytipProps = this._getKtpAttrs(keytipProps, ariaDescribedBy);
        }
        return children(nativeKeytipProps);
    }
    _getKtpProps() {
        return {
            disabled: this.props.disabled,
            ...this.props.keytipProps
        };
    }
    /**
     * Gets the aria- and data- attributes to attach to the component
     * @param keytipProps
     * @param describedByPrepend
     */
    _getKtpAttrs(keytipProps, describedByPrepend) {
        if (keytipProps) {
            // Add the parent overflow sequence if necessary
            const newKeytipProps = this._keytipManager.addParentOverflow(keytipProps);
            // Construct aria-describedby and data-ktp-id attributes and return
            const ariaDescribedBy = getAriaDescribedBy(newKeytipProps.keySequences);
            let keySequences = [...newKeytipProps.keySequences];
            if (newKeytipProps.overflowSetSequence) {
                keySequences = mergeOverflows(keySequences, newKeytipProps.overflowSetSequence);
            }
            const ktpId = sequencesToID(keySequences);
            return {
                'aria-describedby': mergeAriaAttributeValues(describedByPrepend, ariaDescribedBy),
                'data-ktp-target': ktpId,
                'data-ktp-execute-target': ktpId
            };
        }
        return undefined;
    }
}

const getClassNames$b = classNamesFunction();
class LinkBase extends BaseComponent {
    constructor() {
        super(...arguments);
        this._link = createRef();
        this._onClick = (ev) => {
            const { onClick, disabled } = this.props;
            if (disabled) {
                ev.preventDefault();
            }
            else if (onClick) {
                onClick(ev);
            }
        };
    }
    render() {
        const { disabled, children, className, href, theme, styles, keytipProps } = this.props;
        const classNames = getClassNames$b(styles, {
            className,
            isButton: !href,
            isDisabled: disabled,
            theme: theme
        });
        const RootType = this._getRootType(this.props);
        return (createElement(KeytipData, { keytipProps: keytipProps, ariaDescribedBy: this.props['aria-describedby'], disabled: disabled }, (keytipAttributes) => (createElement(RootType, Object.assign({}, keytipAttributes, this._removeInvalidPropsForRootType(RootType, this.props), { className: classNames.root, onClick: this._onClick, ref: this._link, "aria-disabled": disabled }), children))));
    }
    focus() {
        const { current } = this._link;
        if (current && current.focus) {
            current.focus();
        }
    }
    _removeInvalidPropsForRootType(RootType, props) {
        // Deconstruct the props so we remove props like `as`, `theme` and `styles`
        // as those will always be removed. We also take some props that are optional
        // based on the RootType.
        const { children, as, disabled, target, href, theme, getStyles, styles, componentRef, ...restProps } = props;
        // RootType will be a string if we're dealing with an html component
        if (typeof RootType === 'string') {
            // Remove the disabled prop for anchor elements
            if (RootType === 'a') {
                return {
                    target,
                    href,
                    ...restProps
                };
            }
            // Remove the target and href props for non anchor elements
            return { ...restProps, disabled };
        }
        // Retain all props except 'as' for ReactComponents
        return { target, href, disabled, ...restProps };
    }
    _getRootType(props) {
        if (props.as) {
            return props.as;
        }
        if (props.href) {
            return 'a';
        }
        return 'button';
    }
}

const GlobalClassNames$8 = {
    root: 'ms-Link'
};
const getStyles$b = (props) => {
    const { className, isButton, isDisabled, theme } = props;
    const { semanticColors } = theme;
    const classNames = getGlobalClassNames(GlobalClassNames$8, theme);
    return {
        root: [
            classNames.root,
            theme.fonts.medium,
            {
                color: semanticColors.link,
                outline: 'none',
                fontSize: 'inherit',
                fontWeight: 'inherit',
                selectors: {
                    [`.${IsFocusVisibleClassName} &:focus`]: {
                        // Can't use getFocusStyle because it doesn't support wrapping links
                        // https://github.com/OfficeDev/office-ui-fabric-react/issues/4883#issuecomment-406743543
                        outline: `1px solid ${theme.palette.neutralSecondary}`
                    }
                }
            },
            isButton && {
                background: 'none',
                backgroundColor: 'transparent',
                border: 'none',
                cursor: 'pointer',
                display: 'inline',
                margin: 0,
                overflow: 'inherit',
                padding: 0,
                textAlign: 'left',
                textOverflow: 'inherit',
                userSelect: 'text',
                borderBottom: '1px solid transparent',
                selectors: {
                    [HighContrastSelectorBlack]: {
                        color: '#FFFF00'
                    },
                    [HighContrastSelectorWhite]: {
                        color: '#00009F'
                    },
                    '@media screen and (-ms-high-contrast: active), (-ms-high-contrast: none)': {
                        // For IE high contrast mode
                        borderBottom: 'none'
                    }
                }
            },
            !isButton && {
                textDecoration: 'none'
            },
            isDisabled && [
                'is-disabled',
                {
                    color: semanticColors.disabledText,
                    cursor: 'default'
                },
                {
                    selectors: {
                        '&:link, &:visited': {
                            pointerEvents: 'none'
                        }
                    }
                }
            ],
            !isDisabled && {
                selectors: {
                    '&:active, &:hover, &:active:hover': {
                        color: semanticColors.linkHovered,
                        selectors: {
                            [HighContrastSelector]: {
                                textDecoration: 'underline'
                            }
                        }
                    },
                    '&:focus': {
                        color: semanticColors.link
                    }
                }
            },
            classNames.root,
            className
        ]
    };
};

const Link = styled(LinkBase, getStyles$b, undefined, {
    scope: 'Link'
});

var ContextualMenuItemType;
(function (ContextualMenuItemType) {
    ContextualMenuItemType[ContextualMenuItemType["Normal"] = 0] = "Normal";
    ContextualMenuItemType[ContextualMenuItemType["Divider"] = 1] = "Divider";
    ContextualMenuItemType[ContextualMenuItemType["Header"] = 2] = "Header";
    ContextualMenuItemType[ContextualMenuItemType["Section"] = 3] = "Section";
})(ContextualMenuItemType || (ContextualMenuItemType = {}));

/**
 * Determines the effective checked state of a menu item.
 *
 * @param item {IContextualMenuItem} to get the check state of.
 * @returns {true} if the item is checked.
 * @returns {false} if the item is unchecked.
 * @returns {null} if the item is not checkable.
 */
function getIsChecked(item) {
    if (item.canCheck) {
        return !!(item.isChecked || item.checked);
    }
    if (typeof item.isChecked === 'boolean') {
        return item.isChecked;
    }
    if (typeof item.checked === 'boolean') {
        return item.checked;
    }
    // Item is not checkable.
    return null;
}
function hasSubmenu(item) {
    return !!(item.subMenuProps || item.items);
}
function isItemDisabled(item) {
    return !!(item.isDisabled || item.disabled);
}

class BaseDecorator extends BaseComponent {
    constructor(props) {
        super(props);
        // tslint:disable-next-line:typedef
        this._skipComponentRefResolution = true;
        this._updateComposedComponentRef = this._updateComposedComponentRef.bind(this);
    }
    /**
     * Updates the ref to the component composed by the decorator, which will also take care of hoisting
     * (and unhoisting as appropriate) methods from said component.
     *
     * Pass this method as the argument to the 'ref' property of the composed component.
     */
    _updateComposedComponentRef(composedComponentInstance) {
        this._composedComponentInstance = composedComponentInstance;
        if (composedComponentInstance) {
            this._hoisted = hoistMethods(this, composedComponentInstance);
        }
        else if (this._hoisted) {
            unhoistMethods(this, this._hoisted);
        }
    }
}

var ResponsiveMode;
(function (ResponsiveMode) {
    ResponsiveMode[ResponsiveMode["small"] = 0] = "small";
    ResponsiveMode[ResponsiveMode["medium"] = 1] = "medium";
    ResponsiveMode[ResponsiveMode["large"] = 2] = "large";
    ResponsiveMode[ResponsiveMode["xLarge"] = 3] = "xLarge";
    ResponsiveMode[ResponsiveMode["xxLarge"] = 4] = "xxLarge";
    ResponsiveMode[ResponsiveMode["xxxLarge"] = 5] = "xxxLarge";
})(ResponsiveMode || (ResponsiveMode = {}));
const RESPONSIVE_MAX_CONSTRAINT = [479, 639, 1023, 1365, 1919, 99999999];
let _defaultMode;
function withResponsiveMode(ComposedComponent) {
    const resultClass = class WithResponsiveMode extends BaseDecorator {
        constructor(props) {
            super(props);
            this._updateComposedComponentRef = this._updateComposedComponentRef.bind(this);
            this.state = {
                responsiveMode: this._getResponsiveMode()
            };
        }
        componentDidMount() {
            this._events.on(window, 'resize', () => {
                const responsiveMode = this._getResponsiveMode();
                if (responsiveMode !== this.state.responsiveMode) {
                    this.setState({
                        responsiveMode: responsiveMode
                    });
                }
            });
        }
        componentWillUnmount() {
            this._events.dispose();
        }
        render() {
            const { responsiveMode } = this.state;
            return createElement(ComposedComponent, Object.assign({ ref: this._updateComposedComponentRef, responsiveMode: responsiveMode }, this.props));
        }
        _getResponsiveMode() {
            let responsiveMode = ResponsiveMode.small;
            const win = getWindow();
            if (typeof win !== 'undefined') {
                try {
                    while (win.innerWidth > RESPONSIVE_MAX_CONSTRAINT[responsiveMode]) {
                        responsiveMode++;
                    }
                }
                catch (e) {
                    // Return a best effort result in cases where we're in the browser but it throws on getting innerWidth.
                    responsiveMode = ResponsiveMode.large;
                }
            }
            else {
                if (_defaultMode !== undefined) {
                    responsiveMode = _defaultMode;
                }
                else {
                    throw new Error('Content was rendered in a server environment without providing a default responsive mode. ' +
                        'Call setResponsiveMode to define what the responsive mode is.');
                }
            }
            return responsiveMode;
        }
    };
    return hoistStatics(ComposedComponent, resultClass);
}

const renderItemIcon = (props) => {
    const { item, hasIcons, classNames } = props;
    const { iconProps } = item;
    if (!hasIcons) {
        return null;
    }
    if (item.onRenderIcon) {
        return item.onRenderIcon(props);
    }
    return createElement(Icon, Object.assign({}, iconProps, { className: classNames.icon }));
};
const renderCheckMarkIcon = ({ onCheckmarkClick, item, classNames }) => {
    const isItemChecked = getIsChecked(item);
    if (onCheckmarkClick) {
        // Ensures that the item is passed as the first argument to the checkmark click callback.
        const onClick = (e) => onCheckmarkClick(item, e);
        return createElement(Icon, { iconName: isItemChecked ? 'CheckMark' : '', className: classNames.checkmarkIcon, onClick: onClick });
    }
    return null;
};
const renderItemName = ({ item, classNames }) => {
    if (item.text || item.name) {
        return createElement("span", { className: classNames.label }, item.text || item.name);
    }
    return null;
};
const renderSecondaryText = ({ item, classNames }) => {
    if (item.secondaryText) {
        return createElement("span", { className: classNames.secondaryText }, item.secondaryText);
    }
    return null;
};
const renderSubMenuIcon = ({ item, classNames }) => {
    if (hasSubmenu(item)) {
        return createElement(Icon, Object.assign({ iconName: getRTL() ? 'ChevronLeft' : 'ChevronRight' }, item.submenuIconProps, { className: classNames.subMenuIcon }));
    }
    return null;
};
class ContextualMenuItemBase extends BaseComponent {
    constructor() {
        super(...arguments);
        this.openSubMenu = () => {
            const { item, openSubMenu, getSubmenuTarget } = this.props;
            if (getSubmenuTarget) {
                const submenuTarget = getSubmenuTarget();
                if (hasSubmenu(item) && openSubMenu && submenuTarget) {
                    openSubMenu(item, submenuTarget);
                }
            }
        };
        this.dismissSubMenu = () => {
            const { item, dismissSubMenu } = this.props;
            if (hasSubmenu(item) && dismissSubMenu) {
                dismissSubMenu();
            }
        };
        this.dismissMenu = (dismissAll) => {
            const { dismissMenu } = this.props;
            if (dismissMenu) {
                dismissMenu(undefined /* ev */, dismissAll);
            }
        };
    }
    render() {
        const { item, classNames } = this.props;
        return (createElement("div", { className: item.split ? classNames.linkContentMenu : classNames.linkContent },
            renderCheckMarkIcon(this.props),
            renderItemIcon(this.props),
            renderItemName(this.props),
            renderSecondaryText(this.props),
            renderSubMenuIcon(this.props)));
    }
}

const getDividerClassNames = memoizeFunction((theme) => {
    return mergeStyleSets({
        wrapper: {
            display: 'inline-flex',
            height: '100%',
            alignItems: 'center'
        },
        divider: {
            width: 1,
            height: '100%',
            backgroundColor: theme.palette.neutralTertiaryAlt
        }
    });
});

const CONTEXTUAL_MENU_ITEM_HEIGHT = '32px';
const MediumScreenSelector = getScreenSelector(0, ScreenWidthMaxMedium);
const getItemHighContrastStyles = memoizeFunction(() => {
    return {
        selectors: {
            [HighContrastSelector]: {
                backgroundColor: 'Highlight',
                borderColor: 'Highlight',
                color: 'HighlightText',
                MsHighContrastAdjust: 'none'
            }
        }
    };
});
const getMenuItemStyles = memoizeFunction((theme) => {
    const { semanticColors, fonts } = theme;
    const ContextualMenuItemBackgroundHoverColor = semanticColors.menuItemBackgroundHovered;
    const ContextualMenuItemBackgroundSelectedColor = semanticColors.menuItemBackgroundChecked;
    const ContextualMenuItemDividerColor = semanticColors.bodyDivider;
    const menuItemStyles = {
        item: [
            fonts.medium,
            {
                color: semanticColors.bodyText,
                position: 'relative',
                boxSizing: 'border-box'
            }
        ],
        divider: {
            display: 'block',
            height: '1px',
            backgroundColor: ContextualMenuItemDividerColor,
            position: 'relative'
        },
        root: [
            getFocusStyle(theme),
            fonts.medium,
            {
                color: semanticColors.bodyText,
                backgroundColor: 'transparent',
                border: 'none',
                width: '100%',
                height: CONTEXTUAL_MENU_ITEM_HEIGHT,
                lineHeight: CONTEXTUAL_MENU_ITEM_HEIGHT,
                display: 'block',
                cursor: 'pointer',
                padding: '0px 8px 0 4px',
                textAlign: 'left'
            }
        ],
        rootDisabled: {
            color: semanticColors.disabledBodyText,
            cursor: 'default',
            pointerEvents: 'none',
            selectors: {
                [HighContrastSelector]: {
                    color: 'GrayText',
                    opacity: 1
                }
            }
        },
        rootHovered: {
            backgroundColor: ContextualMenuItemBackgroundHoverColor,
            ...getItemHighContrastStyles()
        },
        rootFocused: {
            backgroundColor: ContextualMenuItemBackgroundHoverColor,
            ...getItemHighContrastStyles()
        },
        rootChecked: {
            ...getItemHighContrastStyles()
        },
        rootPressed: {
            backgroundColor: ContextualMenuItemBackgroundSelectedColor,
            ...getItemHighContrastStyles()
        },
        rootExpanded: {
            backgroundColor: ContextualMenuItemBackgroundSelectedColor,
            color: semanticColors.bodyTextChecked,
            ...getItemHighContrastStyles()
        },
        linkContent: {
            whiteSpace: 'nowrap',
            height: 'inherit',
            display: 'flex',
            alignItems: 'center',
            maxWidth: '100%'
        },
        anchorLink: {
            padding: '0px 8px 0 4px',
            textRendering: 'auto',
            color: 'inherit',
            letterSpacing: 'normal',
            wordSpacing: 'normal',
            textTransform: 'none',
            textIndent: '0px',
            textShadow: 'none',
            textDecoration: 'none',
            boxSizing: 'border-box'
        },
        label: {
            margin: '0 4px',
            verticalAlign: 'middle',
            display: 'inline-block',
            flexGrow: '1',
            textOverflow: 'ellipsis',
            overflow: 'hidden',
            whiteSpace: 'nowrap'
        },
        secondaryText: {
            color: theme.palette.neutralSecondary,
            paddingLeft: '20px',
            textAlign: 'right'
        },
        icon: {
            display: 'inline-block',
            minHeight: '1px',
            maxHeight: CONTEXTUAL_MENU_ITEM_HEIGHT,
            width: '14px',
            margin: '0 4px',
            verticalAlign: 'middle',
            flexShrink: '0'
        },
        iconColor: {
            color: semanticColors.menuIcon,
            selectors: {
                [HighContrastSelector]: {
                    color: 'inherit'
                },
                ['$root:hover &']: {
                    selectors: {
                        [HighContrastSelector]: {
                            color: 'HighlightText'
                        }
                    }
                },
                ['$root:focus &']: {
                    selectors: {
                        [HighContrastSelector]: {
                            color: 'HighlightText'
                        }
                    }
                }
            }
        },
        iconDisabled: {
            color: semanticColors.disabledBodyText
        },
        checkmarkIcon: {
            color: semanticColors.bodySubtext,
            selectors: {
                [HighContrastSelector]: {
                    color: 'HighlightText'
                }
            }
        },
        subMenuIcon: {
            height: CONTEXTUAL_MENU_ITEM_HEIGHT,
            lineHeight: CONTEXTUAL_MENU_ITEM_HEIGHT,
            textAlign: 'center',
            display: 'inline-block',
            verticalAlign: 'middle',
            flexShrink: '0',
            fontSize: FontSizes.small,
            selectors: {
                [MediumScreenSelector]: {
                    fontSize: FontSizes.icon // 16px
                }
            }
        },
        splitButtonFlexContainer: [
            getFocusStyle(theme),
            {
                display: 'flex',
                height: CONTEXTUAL_MENU_ITEM_HEIGHT,
                flexWrap: 'nowrap',
                justifyContent: 'center',
                alignItems: 'center'
            }
        ]
    };
    return concatStyleSets(menuItemStyles);
});

const MediumScreenSelector$1 = getScreenSelector(0, ScreenWidthMaxMedium);
const getSplitButtonVerticalDividerClassNames = memoizeFunction((theme) => {
    return mergeStyleSets(getDividerClassNames(theme), {
        wrapper: {
            position: 'absolute',
            right: 28,
            selectors: {
                [MediumScreenSelector$1]: {
                    right: 32 // fontSize of the icon increased from 12px to 16px
                }
            }
        },
        divider: {
            height: 16,
            width: 1
        }
    });
});
const GlobalClassNames$9 = {
    item: 'ms-ContextualMenu-item',
    divider: 'ms-ContextualMenu-divider',
    root: 'ms-ContextualMenu-link',
    isChecked: 'is-checked',
    isExpanded: 'is-expanded',
    isDisabled: 'is-disabled',
    linkContent: 'ms-ContextualMenu-linkContent',
    linkContentMenu: 'ms-ContextualMenu-linkContent',
    icon: 'ms-ContextualMenu-icon',
    iconColor: 'ms-ContextualMenu-iconColor',
    checkmarkIcon: 'ms-ContextualMenu-checkmarkIcon',
    subMenuIcon: 'ms-ContextualMenu-submenuIcon',
    label: 'ms-ContextualMenu-itemText',
    secondaryText: 'ms-ContextualMenu-secondaryText'
};
/**
 * @deprecated To be removed in 7.0.
 * @internal
 * This is a package-internal method that has been depended on.
 * It is being kept in this form for backwards compatibility.
 * It should be cleaned up in 7.0.
 *
 * TODO: Audit perf. impact of and potentially remove memoizeFunction.
 * https://github.com/OfficeDev/office-ui-fabric-react/issues/5534
 */
const getItemClassNames = memoizeFunction((theme, disabled, expanded, checked, isAnchorLink, knownIcon, itemClassName, dividerClassName, iconClassName, subMenuClassName, primaryDisabled, className) => {
    const styles = getMenuItemStyles(theme);
    const classNames = getGlobalClassNames(GlobalClassNames$9, theme);
    return mergeStyleSets({
        item: [classNames.item, styles.item, itemClassName],
        divider: [classNames.divider, styles.divider, dividerClassName],
        root: [
            classNames.root,
            styles.root,
            checked && [classNames.isChecked, styles.rootChecked],
            isAnchorLink && styles.anchorLink,
            expanded && [classNames.isExpanded, styles.rootExpanded],
            disabled && [classNames.isDisabled, styles.rootDisabled],
            !disabled &&
                !expanded && [
                {
                    selectors: {
                        ':hover': styles.rootHovered,
                        ':active': styles.rootPressed,
                        [`.${IsFocusVisibleClassName} &:focus, .${IsFocusVisibleClassName} &:focus:hover`]: styles.rootFocused,
                        [`.${IsFocusVisibleClassName} &:hover`]: { background: 'inherit;' }
                    }
                }
            ],
            className
        ],
        splitPrimary: [
            styles.root,
            checked && ['is-checked', styles.rootChecked],
            (disabled || primaryDisabled) && ['is-disabled', styles.rootDisabled],
            !(disabled || primaryDisabled) &&
                !checked && [
                {
                    selectors: {
                        ':hover': styles.rootHovered,
                        ':hover ~ $splitMenu': styles.rootHovered,
                        ':active': styles.rootPressed,
                        [`.${IsFocusVisibleClassName} &:focus, .${IsFocusVisibleClassName} &:focus:hover`]: styles.rootFocused,
                        [`.${IsFocusVisibleClassName} &:hover`]: { background: 'inherit;' }
                    }
                }
            ]
        ],
        splitMenu: [
            styles.root,
            {
                flexBasis: '0',
                padding: '0 8px'
            },
            expanded && ['is-expanded', styles.rootExpanded],
            disabled && ['is-disabled', styles.rootDisabled],
            !disabled &&
                !expanded && [
                {
                    selectors: {
                        ':hover': styles.rootHovered,
                        ':active': styles.rootPressed,
                        [`.${IsFocusVisibleClassName} &:focus, .${IsFocusVisibleClassName} &:focus:hover`]: styles.rootFocused,
                        [`.${IsFocusVisibleClassName} &:hover`]: { background: 'inherit;' }
                    }
                }
            ]
        ],
        anchorLink: styles.anchorLink,
        linkContent: [classNames.linkContent, styles.linkContent],
        linkContentMenu: [
            classNames.linkContentMenu,
            styles.linkContent,
            {
                justifyContent: 'center'
            }
        ],
        icon: [
            classNames.icon,
            knownIcon && styles.iconColor,
            styles.icon,
            iconClassName,
            disabled && [classNames.isDisabled, styles.iconDisabled]
        ],
        iconColor: styles.iconColor,
        checkmarkIcon: [classNames.checkmarkIcon, knownIcon && styles.checkmarkIcon, styles.icon, iconClassName],
        subMenuIcon: [classNames.subMenuIcon, styles.subMenuIcon, subMenuClassName],
        label: [classNames.label, styles.label],
        secondaryText: [classNames.secondaryText, styles.secondaryText],
        splitContainer: [
            styles.splitButtonFlexContainer,
            !disabled &&
                !checked && [
                {
                    selectors: {
                        [`.${IsFocusVisibleClassName} &:focus, .${IsFocusVisibleClassName} &:focus:hover`]: styles.rootFocused
                    }
                }
            ]
        ]
    });
});
/**
 * Wrapper function for generating ContextualMenuItem classNames which adheres to
 * the getStyles API, but invokes memoized className generator function with
 * primitive values.
 *
 * @param props the ContextualMenuItem style props used to generate its styles.
 */
const getItemStyles = (props) => {
    const { theme, disabled, expanded, checked, isAnchorLink, knownIcon, itemClassName, dividerClassName, iconClassName, subMenuClassName, primaryDisabled, className } = props;
    return getItemClassNames(theme, disabled, expanded, checked, isAnchorLink, knownIcon, itemClassName, dividerClassName, iconClassName, subMenuClassName, primaryDisabled, className);
};

/**
 * ContextualMenuItem description
 */
const ContextualMenuItem = styled(ContextualMenuItemBase, getItemStyles, undefined, { scope: 'ContextualMenuItem' });

class ContextualMenuItemWrapper extends BaseComponent {
    constructor() {
        super(...arguments);
        this._onItemMouseEnter = (ev) => {
            const { item, onItemMouseEnter } = this.props;
            if (onItemMouseEnter) {
                onItemMouseEnter(item, ev, ev.currentTarget);
            }
        };
        this._onItemClick = (ev) => {
            const { item, onItemClickBase } = this.props;
            if (onItemClickBase) {
                onItemClickBase(item, ev, ev.currentTarget);
            }
        };
        this._onItemMouseLeave = (ev) => {
            const { item, onItemMouseLeave } = this.props;
            if (onItemMouseLeave) {
                onItemMouseLeave(item, ev);
            }
        };
        this._onItemKeyDown = (ev) => {
            const { item, onItemKeyDown } = this.props;
            if (onItemKeyDown) {
                onItemKeyDown(item, ev);
            }
        };
        this._onItemMouseMove = (ev) => {
            const { item, onItemMouseMove } = this.props;
            if (onItemMouseMove) {
                onItemMouseMove(item, ev, ev.currentTarget);
            }
        };
        this._getSubMenuId = (item) => {
            const { getSubMenuId } = this.props;
            if (getSubMenuId) {
                return getSubMenuId(item);
            }
        };
        this._getSubmenuTarget = () => {
            return undefined;
        };
    }
}

class ContextualMenuAnchor extends ContextualMenuItemWrapper {
    constructor() {
        super(...arguments);
        this._anchor = createRef();
        this._getSubmenuTarget = () => {
            return this._anchor.current ? this._anchor.current : undefined;
        };
        this._onItemClick = (ev) => {
            const { item, onItemClick } = this.props;
            if (onItemClick) {
                onItemClick(item, ev);
            }
        };
    }
    render() {
        const { item, classNames, index, focusableElementIndex, totalItemCount, hasCheckmarks, hasIcons, contextualMenuItemAs: ChildrenRenderer = ContextualMenuItem, expandedMenuItemKey, onItemClick, openSubMenu, dismissSubMenu, dismissMenu } = this.props;
        let anchorRel = item.rel;
        if (item.target && item.target.toLowerCase() === '_blank') {
            anchorRel = anchorRel ? anchorRel : 'nofollow noopener noreferrer'; // Safe default to prevent tabjacking
        }
        const subMenuId = this._getSubMenuId(item);
        const itemHasSubmenu = hasSubmenu(item);
        const nativeProps = getNativeProps(item, anchorProperties);
        const disabled = isItemDisabled(item);
        const { itemProps } = item;
        return (createElement("div", null,
            createElement(KeytipData, { keytipProps: item.keytipProps, ariaDescribedBy: nativeProps['aria-describedby'], disabled: disabled }, (keytipAttributes) => (createElement("a", Object.assign({}, nativeProps, keytipAttributes, { ref: this._anchor, href: item.href, target: item.target, rel: anchorRel, className: classNames.root, role: "menuitem", "aria-owns": item.key === expandedMenuItemKey ? subMenuId : undefined, "aria-haspopup": itemHasSubmenu || undefined, "aria-expanded": itemHasSubmenu ? item.key === expandedMenuItemKey : undefined, "aria-posinset": focusableElementIndex + 1, "aria-setsize": totalItemCount, "aria-disabled": isItemDisabled(item), style: item.style, onClick: this._onItemClick, onMouseEnter: this._onItemMouseEnter, onMouseLeave: this._onItemMouseLeave, onMouseMove: this._onItemMouseMove, onKeyDown: itemHasSubmenu ? this._onItemKeyDown : null }),
                createElement(ChildrenRenderer, Object.assign({ componentRef: item.componentRef, item: item, classNames: classNames, index: index, onCheckmarkClick: hasCheckmarks && onItemClick ? onItemClick : undefined, hasIcons: hasIcons, openSubMenu: openSubMenu, dismissSubMenu: dismissSubMenu, dismissMenu: dismissMenu, getSubmenuTarget: this._getSubmenuTarget }, itemProps)))))));
    }
}

class ContextualMenuButton extends ContextualMenuItemWrapper {
    constructor() {
        super(...arguments);
        this._btn = createRef();
        this._getSubmenuTarget = () => {
            return this._btn.current ? this._btn.current : undefined;
        };
    }
    render() {
        const { item, classNames, index, focusableElementIndex, totalItemCount, hasCheckmarks, hasIcons, contextualMenuItemAs: ChildrenRenderer = ContextualMenuItem, expandedMenuItemKey, onItemMouseDown, onItemClick, openSubMenu, dismissSubMenu, dismissMenu } = this.props;
        const subMenuId = this._getSubMenuId(item);
        const isChecked = getIsChecked(item);
        const canCheck = isChecked !== null;
        const defaultRole = canCheck ? 'menuitemcheckbox' : 'menuitem';
        const itemHasSubmenu = hasSubmenu(item);
        const { itemProps, ariaLabel } = item;
        const buttonNativeProperties = getNativeProps(item, buttonProperties);
        // Do not add the disabled attribute to the button so that it is focusable
        delete buttonNativeProperties.disabled;
        const itemButtonProperties = {
            className: classNames.root,
            onClick: this._onItemClick,
            onKeyDown: itemHasSubmenu ? this._onItemKeyDown : null,
            onMouseEnter: this._onItemMouseEnter,
            onMouseLeave: this._onItemMouseLeave,
            onMouseDown: (ev) => (onItemMouseDown ? onItemMouseDown(item, ev) : undefined),
            onMouseMove: this._onItemMouseMove,
            href: item.href,
            title: item.title,
            'aria-label': ariaLabel,
            'aria-haspopup': itemHasSubmenu || undefined,
            'aria-owns': item.key === expandedMenuItemKey ? subMenuId : undefined,
            'aria-expanded': itemHasSubmenu ? item.key === expandedMenuItemKey : undefined,
            'aria-checked': canCheck ? !!isChecked : undefined,
            'aria-posinset': focusableElementIndex + 1,
            'aria-setsize': totalItemCount,
            'aria-disabled': isItemDisabled(item),
            role: item.role || defaultRole,
            style: item.style
        };
        let { keytipProps } = item;
        if (keytipProps && itemHasSubmenu) {
            keytipProps = {
                ...keytipProps,
                hasMenu: true
            };
        }
        return (createElement(KeytipData, { keytipProps: keytipProps, ariaDescribedBy: buttonNativeProperties['aria-describedby'], disabled: isItemDisabled(item) }, (keytipAttributes) => (createElement("button", Object.assign({ ref: this._btn }, buttonNativeProperties, itemButtonProperties, keytipAttributes),
            createElement(ChildrenRenderer, Object.assign({ componentRef: item.componentRef, item: item, classNames: classNames, index: index, onCheckmarkClick: hasCheckmarks && onItemClick ? onItemClick : undefined, hasIcons: hasIcons, openSubMenu: openSubMenu, dismissSubMenu: dismissSubMenu, dismissMenu: dismissMenu, getSubmenuTarget: this._getSubmenuTarget }, itemProps))))));
    }
}

const VerticalDivider = (props) => {
    const theme = getTheme();
    const classNames = props.getClassNames ? props.getClassNames(theme) : getDividerClassNames(theme);
    return (createElement("span", { className: classNames.wrapper },
        createElement("span", { className: classNames.divider })));
};

const TouchIdleDelay = 500; /* ms */
class ContextualMenuSplitButton extends ContextualMenuItemWrapper {
    constructor() {
        super(...arguments);
        this._onItemKeyDown = (ev) => {
            const { item, onItemKeyDown } = this.props;
            if (ev.which === KeyCodes.enter) {
                this._executeItemClick(ev);
                ev.preventDefault();
                ev.stopPropagation();
            }
            else if (onItemKeyDown) {
                onItemKeyDown(item, ev);
            }
        };
        this._getSubmenuTarget = () => {
            return this._splitButton;
        };
        this._onItemMouseEnterPrimary = (ev) => {
            const { item, onItemMouseEnter } = this.props;
            if (onItemMouseEnter) {
                onItemMouseEnter({ ...item, subMenuProps: undefined, items: undefined }, ev, this._splitButton);
            }
        };
        this._onItemMouseEnterIcon = (ev) => {
            const { item, onItemMouseEnter } = this.props;
            if (onItemMouseEnter) {
                onItemMouseEnter(item, ev, this._splitButton);
            }
        };
        this._onItemMouseMovePrimary = (ev) => {
            const { item, onItemMouseMove } = this.props;
            if (onItemMouseMove) {
                onItemMouseMove({ ...item, subMenuProps: undefined, items: undefined }, ev, this._splitButton);
            }
        };
        this._onItemMouseMoveIcon = (ev) => {
            const { item, onItemMouseMove } = this.props;
            if (onItemMouseMove) {
                onItemMouseMove(item, ev, this._splitButton);
            }
        };
        this._onIconItemClick = (ev) => {
            const { item, onItemClickBase } = this.props;
            if (onItemClickBase) {
                onItemClickBase(item, ev, (this._splitButton ? this._splitButton : ev.currentTarget));
            }
        };
        this._executeItemClick = (ev) => {
            const { item, executeItemClick, onItemClick } = this.props;
            if (item.disabled || item.isDisabled) {
                return;
            }
            if (this._processingTouch && onItemClick) {
                return onItemClick(item, ev);
            }
            if (executeItemClick) {
                executeItemClick(item, ev);
            }
        };
        this._onTouchStart = (ev) => {
            if (this._splitButton && !('onpointerdown' in this._splitButton)) {
                this._handleTouchAndPointerEvent(ev);
            }
        };
        this._onPointerDown = (ev) => {
            if (ev.pointerType === 'touch') {
                this._handleTouchAndPointerEvent(ev);
                ev.preventDefault();
                ev.stopImmediatePropagation();
            }
        };
    }
    componentDidMount() {
        if (this._splitButton && 'onpointerdown' in this._splitButton) {
            this._events.on(this._splitButton, 'pointerdown', this._onPointerDown, true);
        }
    }
    render() {
        const { item, classNames, index, focusableElementIndex, totalItemCount, hasCheckmarks, hasIcons, onItemMouseLeave, expandedMenuItemKey } = this.props;
        const itemHasSubmenu = hasSubmenu(item);
        let { keytipProps } = item;
        if (keytipProps) {
            keytipProps = {
                ...keytipProps,
                hasMenu: true
            };
        }
        return (createElement(KeytipData, { keytipProps: keytipProps, disabled: isItemDisabled(item) }, (keytipAttributes) => (createElement("div", { "data-ktp-target": keytipAttributes['data-ktp-target'], ref: (splitButton) => (this._splitButton = splitButton), role: 'menuitem', "aria-label": item.ariaLabel, className: classNames.splitContainer, "aria-disabled": isItemDisabled(item), "aria-expanded": itemHasSubmenu ? item.key === expandedMenuItemKey : undefined, "aria-haspopup": true, "aria-describedby": mergeAriaAttributeValues(item.ariaDescription, keytipAttributes['aria-describedby']), "aria-checked": item.isChecked || item.checked, "aria-posinset": focusableElementIndex + 1, "aria-setsize": totalItemCount, onMouseEnter: this._onItemMouseEnterPrimary, onMouseLeave: onItemMouseLeave ? onItemMouseLeave.bind(this, { ...item, subMenuProps: null, items: null }) : undefined, onMouseMove: this._onItemMouseMovePrimary, onKeyDown: this._onItemKeyDown, onClick: this._executeItemClick, onTouchStart: this._onTouchStart, tabIndex: 0, "data-is-focusable": true, "aria-roledescription": item['aria-roledescription'] },
            this._renderSplitPrimaryButton(item, classNames, index, hasCheckmarks, hasIcons),
            this._renderSplitDivider(item),
            this._renderSplitIconButton(item, classNames, index, keytipAttributes)))));
    }
    _renderSplitPrimaryButton(item, classNames, index, hasCheckmarks, hasIcons) {
        const { contextualMenuItemAs: ChildrenRenderer = ContextualMenuItem, onItemClick } = this.props;
        const itemProps = {
            key: item.key,
            disabled: isItemDisabled(item) || item.primaryDisabled,
            name: item.name,
            text: item.text || item.name,
            className: classNames.splitPrimary,
            canCheck: item.canCheck,
            isChecked: item.isChecked,
            checked: item.checked,
            iconProps: item.iconProps,
            'data-is-focusable': false,
            'aria-hidden': true
        };
        const { itemProps: itemComponentProps } = item;
        return (createElement("button", Object.assign({}, getNativeProps(itemProps, buttonProperties)),
            createElement(ChildrenRenderer, Object.assign({ "data-is-focusable": false, item: itemProps, classNames: classNames, index: index, onCheckmarkClick: hasCheckmarks && onItemClick ? onItemClick : undefined, hasIcons: hasIcons }, itemComponentProps))));
    }
    _renderSplitDivider(item) {
        const getDividerClassNames = item.getSplitButtonVerticalDividerClassNames || getSplitButtonVerticalDividerClassNames;
        return createElement(VerticalDivider, { getClassNames: getDividerClassNames });
    }
    _renderSplitIconButton(item, classNames, index, keytipAttributes) {
        const { contextualMenuItemAs: ChildrenRenderer = ContextualMenuItem, onItemMouseLeave, onItemMouseDown, openSubMenu, dismissSubMenu, dismissMenu } = this.props;
        const itemProps = {
            onClick: this._onIconItemClick,
            disabled: isItemDisabled(item),
            className: classNames.splitMenu,
            subMenuProps: item.subMenuProps,
            submenuIconProps: item.submenuIconProps,
            split: true,
            key: item.key
        };
        const buttonProps = assign({}, getNativeProps(itemProps, buttonProperties), {
            onMouseEnter: this._onItemMouseEnterIcon,
            onMouseLeave: onItemMouseLeave ? onItemMouseLeave.bind(this, item) : undefined,
            onMouseDown: (ev) => (onItemMouseDown ? onItemMouseDown(item, ev) : undefined),
            onMouseMove: this._onItemMouseMoveIcon,
            'data-is-focusable': false,
            'data-ktp-execute-target': keytipAttributes['data-ktp-execute-target'],
            'aria-hidden': true
        });
        const { itemProps: itemComponentProps } = item;
        return (createElement("button", Object.assign({}, buttonProps),
            createElement(ChildrenRenderer, Object.assign({ componentRef: item.componentRef, item: itemProps, classNames: classNames, index: index, hasIcons: false, openSubMenu: openSubMenu, dismissSubMenu: dismissSubMenu, dismissMenu: dismissMenu, getSubmenuTarget: this._getSubmenuTarget }, itemComponentProps))));
    }
    _handleTouchAndPointerEvent(ev) {
        const { onTap } = this.props;
        if (onTap) {
            onTap(ev);
        }
        // If we already have an existing timeout from a previous touch/pointer event
        // cancel that timeout so we can set a new one.
        if (this._lastTouchTimeoutId) {
            this._async.clearTimeout(this._lastTouchTimeoutId);
            this._lastTouchTimeoutId = undefined;
        }
        this._processingTouch = true;
        this._lastTouchTimeoutId = this._async.setTimeout(() => {
            this._processingTouch = false;
            this._lastTouchTimeoutId = undefined;
        }, TouchIdleDelay);
    }
}

const getClassNames$c = classNamesFunction();
const getContextualMenuItemClassNames = classNamesFunction();
function getSubmenuItems(item) {
    return item.subMenuProps ? item.subMenuProps.items : item.items;
}
/**
 * Returns true if a list of menu items can contain a checkbox
 */
function canAnyMenuItemsCheck(items) {
    return items.some(item => {
        if (item.canCheck) {
            return true;
        }
        // If the item is a section, check if any of the items in the section can check.
        if (item.sectionProps && item.sectionProps.items.some(submenuItem => submenuItem.canCheck === true)) {
            return true;
        }
        return false;
    });
}
const NavigationIdleDelay = 250 /* ms */;
let ContextualMenuBase = class ContextualMenuBase extends BaseComponent {
    constructor(props) {
        super(props);
        this._mounted = false;
        this.dismiss = (ev, dismissAll) => {
            const { onDismiss } = this.props;
            if (onDismiss) {
                onDismiss(ev, dismissAll);
            }
        };
        this._onRenderMenuList = (menuListProps, defaultRender) => {
            let indexCorrection = 0;
            return (createElement("ul", { className: this._classNames.list, onKeyDown: this._onKeyDown, onKeyUp: this._onKeyUp }, menuListProps.items.map((item, index) => {
                const menuItem = this._renderMenuItem(item, index, indexCorrection, menuListProps.totalItemCount, menuListProps.hasCheckmarks, menuListProps.hasIcons);
                if (item.itemType !== ContextualMenuItemType.Divider && item.itemType !== ContextualMenuItemType.Header) {
                    const indexIncrease = item.customOnRenderListLength ? item.customOnRenderListLength : 1;
                    indexCorrection += indexIncrease;
                }
                return menuItem;
            })));
        };
        this._onKeyDown = (ev) => {
            // Take note if we are processing an alt (option) or meta (command) keydown.
            // See comment in _shouldHandleKeyUp for reasoning.
            this._lastKeyDownWasAltOrMeta = this._isAltOrMeta(ev);
            // On Mac, pressing escape dismisses all levels of native context menus
            const dismissAllMenus = ev.which === KeyCodes.escape && (isMac() || isIOS());
            return this._keyHandler(ev, this._shouldHandleKeyDown, dismissAllMenus);
        };
        this._shouldHandleKeyDown = (ev) => {
            return ev.which === KeyCodes.escape || this._shouldCloseSubMenu(ev) || (ev.which === KeyCodes.up && (ev.altKey || ev.metaKey));
        };
        this._onMenuFocusCapture = (ev) => {
            if (this.props.delayUpdateFocusOnHover) {
                this._shouldUpdateFocusOnMouseEvent = true;
            }
        };
        this._onKeyUp = (ev) => {
            return this._keyHandler(ev, this._shouldHandleKeyUp, true /* dismissAllMenus */);
        };
        /**
         * We close the menu on key up only if ALL of the following are true:
         * - Most recent key down was alt or meta (command)
         * - The alt/meta key down was NOT followed by some other key (such as down/up arrow to
         *   expand/collapse the menu)
         * - We're not on a Mac (or iOS)
         *
         * This is because on Windows, pressing alt moves focus to the application menu bar or similar,
         * closing any open context menus. There is not a similar behavior on Macs.
         */
        this._shouldHandleKeyUp = (ev) => {
            const keyPressIsAltOrMetaAlone = this._lastKeyDownWasAltOrMeta && this._isAltOrMeta(ev);
            this._lastKeyDownWasAltOrMeta = false;
            return !!keyPressIsAltOrMetaAlone && !(isIOS() || isMac());
        };
        /**
         * Calls `shouldHandleKey` to determine whether the keyboard event should be handled;
         * if so, stops event propagation and dismisses menu(s).
         * @param ev The keyboard event.
         * @param shouldHandleKey Returns whether we should handle this keyboard event.
         * @param dismissAllMenus If true, dismiss all menus. Otherwise, dismiss only the current menu.
         * Only does anything if `shouldHandleKey` returns true.
         * @returns Whether the event was handled.
         */
        this._keyHandler = (ev, shouldHandleKey, dismissAllMenus) => {
            let handled = false;
            if (shouldHandleKey(ev)) {
                this._isFocusingPreviousElement = true;
                ev.preventDefault();
                ev.stopPropagation();
                this.dismiss(ev, dismissAllMenus);
                handled = true;
            }
            return handled;
        };
        /**
         * Checks if the submenu should be closed
         */
        this._shouldCloseSubMenu = (ev) => {
            const submenuCloseKey = getRTL() ? KeyCodes.right : KeyCodes.left;
            if (ev.which !== submenuCloseKey || !this.props.isSubMenu) {
                return false;
            }
            return (this._adjustedFocusZoneProps.direction === FocusZoneDirection.vertical ||
                (!!this._adjustedFocusZoneProps.checkForNoWrap && !shouldWrapFocus(ev.target, 'data-no-horizontal-wrap')));
        };
        this._onMenuKeyDown = (ev) => {
            // Mark as handled if onKeyDown returns true (for handling collapse cases)
            // or if we are attempting to expand a submenu
            const handled = this._onKeyDown(ev);
            if (handled || !this._host) {
                return;
            }
            // If we have a modifier key being pressed, we do not want to move focus.
            // Otherwise, handle up and down keys.
            const hasModifier = !!(ev.altKey || ev.metaKey);
            const isUp = ev.which === KeyCodes.up;
            const isDown = ev.which === KeyCodes.down;
            if (!hasModifier && (isUp || isDown)) {
                const elementToFocus = isUp
                    ? getLastFocusable(this._host, this._host.lastChild, true)
                    : getFirstFocusable(this._host, this._host.firstChild, true);
                if (elementToFocus) {
                    elementToFocus.focus();
                    ev.preventDefault();
                    ev.stopPropagation();
                }
            }
        };
        /**
         * Scroll handler for the callout to make sure the mouse events
         * for updating focus are not interacting during scroll
         */
        this._onScroll = () => {
            if (!this._isScrollIdle && this._scrollIdleTimeoutId !== undefined) {
                this._async.clearTimeout(this._scrollIdleTimeoutId);
                this._scrollIdleTimeoutId = undefined;
            }
            else {
                this._isScrollIdle = false;
            }
            this._scrollIdleTimeoutId = this._async.setTimeout(() => {
                this._isScrollIdle = true;
            }, NavigationIdleDelay);
        };
        this._onItemMouseEnterBase = (item, ev, target) => {
            if (this._shouldIgnoreMouseEvent()) {
                return;
            }
            this._updateFocusOnMouseEvent(item, ev, target);
        };
        this._onItemMouseMoveBase = (item, ev, target) => {
            const targetElement = ev.currentTarget;
            // Always do this check to make sure we record
            // a mouseMove if needed (even if we are timed out)
            if (this._shouldUpdateFocusOnMouseEvent) {
                this._gotMouseMove = true;
            }
            else {
                return;
            }
            if (!this._isScrollIdle ||
                this._enterTimerId !== undefined ||
                targetElement === this._targetWindow.document.activeElement) {
                return;
            }
            this._updateFocusOnMouseEvent(item, ev, target);
        };
        this._onMouseItemLeave = (item, ev) => {
            if (this._shouldIgnoreMouseEvent()) {
                return;
            }
            if (this._enterTimerId !== undefined) {
                this._async.clearTimeout(this._enterTimerId);
                this._enterTimerId = undefined;
            }
            if (this.state.expandedMenuItemKey !== undefined) {
                return;
            }
            /**
             * IE11 focus() method forces parents to scroll to top of element.
             * Edge and IE expose a setActive() function for focusable divs that
             * sets the page focus but does not scroll the parent element.
             */
            if (this._host.setActive) {
                try {
                    this._host.setActive();
                }
                catch (e) {
                    /* no-op */
                }
            }
            else {
                this._host.focus();
            }
        };
        this._onItemMouseDown = (item, ev) => {
            if (item.onMouseDown) {
                item.onMouseDown(item, ev);
            }
        };
        this._onItemClick = (item, ev) => {
            this._onItemClickBase(item, ev, ev.currentTarget);
        };
        this._onItemClickBase = (item, ev, target) => {
            const items = getSubmenuItems(item);
            // Cancel a async menu item hover timeout action from being taken and instead
            // just trigger the click event instead.
            this._cancelSubMenuTimer();
            if (!hasSubmenu(item) && (!items || !items.length)) {
                // This is an item without a menu. Click it.
                this._executeItemClick(item, ev);
            }
            else {
                if (item.key !== this.state.expandedMenuItemKey) {
                    // This has a collapsed sub menu. Expand it.
                    this.setState({
                        // When Edge + Narrator are used together (regardless of if the button is in a form or not), pressing
                        // "Enter" fires this method and not _onMenuKeyDown. Checking ev.nativeEvent.detail differentiates
                        // between a real click event and a keypress event.
                        expandedByMouseClick: ev.nativeEvent.detail !== 0
                    });
                    this._onItemSubMenuExpand(item, target);
                }
            }
            ev.stopPropagation();
            ev.preventDefault();
        };
        this._onAnchorClick = (item, ev) => {
            this._executeItemClick(item, ev);
            ev.stopPropagation();
        };
        this._executeItemClick = (item, ev) => {
            if (item.disabled || item.isDisabled) {
                return;
            }
            let dismiss = false;
            if (item.onClick) {
                dismiss = !!item.onClick(ev, item);
            }
            else if (this.props.onItemClick) {
                dismiss = !!this.props.onItemClick(ev, item);
            }
            (dismiss || !ev.defaultPrevented) && this.dismiss(ev, true);
        };
        this._onItemKeyDown = (item, ev) => {
            const openKey = getRTL() ? KeyCodes.left : KeyCodes.right;
            if (!item.disabled &&
                (ev.which === openKey || ev.which === KeyCodes.enter || (ev.which === KeyCodes.down && (ev.altKey || ev.metaKey)))) {
                this.setState({
                    expandedByMouseClick: false
                });
                this._onItemSubMenuExpand(item, ev.currentTarget);
                ev.preventDefault();
            }
        };
        // Cancel a async menu item hover timeout action from being taken and instead
        // do new upcoming behavior
        this._cancelSubMenuTimer = () => {
            if (this._enterTimerId !== undefined) {
                this._async.clearTimeout(this._enterTimerId);
                this._enterTimerId = undefined;
            }
        };
        this._onItemSubMenuExpand = (item, target) => {
            if (this.state.expandedMenuItemKey !== item.key) {
                if (this.state.expandedMenuItemKey) {
                    this._onSubMenuDismiss();
                }
                // Focus the target to ensure when we close it, we're focusing on the correct element.
                target.focus();
                this.setState({
                    expandedMenuItemKey: item.key,
                    submenuTarget: target
                });
            }
        };
        /**
         * This function is called ASYNCHRONOUSLY, and so there is a chance it is called
         * after the component is unmounted. The _mounted property is added to prevent
         * from calling setState() after unmount. Do NOT copy this pattern in synchronous
         * code.
         */
        this._onSubMenuDismiss = (ev, dismissAll) => {
            if (dismissAll) {
                this.dismiss(ev, dismissAll);
            }
            else if (this._mounted) {
                this.setState({
                    dismissedMenuItemKey: this.state.expandedMenuItemKey,
                    expandedMenuItemKey: undefined,
                    submenuTarget: undefined
                });
            }
        };
        this._getSubMenuId = (item) => {
            let { subMenuId } = this.state;
            if (item.subMenuProps && item.subMenuProps.id) {
                subMenuId = item.subMenuProps.id;
            }
            return subMenuId;
        };
        this._onPointerAndTouchEvent = (ev) => {
            this._cancelSubMenuTimer();
        };
        this.state = {
            contextualMenuItems: undefined,
            subMenuId: getId('ContextualMenu')
        };
        this._warnDeprecations({
            getMenuClassNames: 'styles'
        });
        this._isFocusingPreviousElement = false;
        this._isScrollIdle = true;
        this._shouldUpdateFocusOnMouseEvent = !this.props.delayUpdateFocusOnHover;
        this._gotMouseMove = false;
    }
    componentWillUpdate(newProps) {
        if (newProps.target !== this.props.target) {
            const newTarget = newProps.target;
            this._setTargetWindowAndElement(newTarget);
        }
        if (newProps.hidden !== this.props.hidden) {
            if (newProps.hidden) {
                this._onMenuClosed();
            }
            else {
                this._onMenuOpened();
                this._previousActiveElement = this._targetWindow ? this._targetWindow.document.activeElement : null;
            }
        }
        if (newProps.delayUpdateFocusOnHover !== this.props.delayUpdateFocusOnHover) {
            // update shouldUpdateFocusOnMouseEvent to follow what was passed in
            this._shouldUpdateFocusOnMouseEvent = !newProps.delayUpdateFocusOnHover;
            // If shouldUpdateFocusOnMouseEvent is false, we need to reset gotMouseMove to false
            this._gotMouseMove = this._shouldUpdateFocusOnMouseEvent && this._gotMouseMove;
        }
    }
    // Invoked once, both on the client and server, immediately before the initial rendering occurs.
    componentWillMount() {
        const target = this.props.target;
        this._setTargetWindowAndElement(target);
        if (!this.props.hidden) {
            this._previousActiveElement = this._targetWindow ? this._targetWindow.document.activeElement : null;
        }
    }
    // Invoked once, only on the client (not on the server), immediately after the initial rendering occurs.
    componentDidMount() {
        if (!this.props.hidden) {
            this._onMenuOpened();
        }
        this._mounted = true;
    }
    // Invoked immediately before a component is unmounted from the DOM.
    componentWillUnmount() {
        if (this._isFocusingPreviousElement && this._previousActiveElement) {
            // This slight delay is required so that we can unwind the stack, const react try to mess with focus, and then
            // apply the correct focus. Without the setTimeout, we end up focusing the correct thing, and then React wants
            // to reset the focus back to the thing it thinks should have been focused.
            // Note: Cannot be replaced by this._async.setTimout because those will be removed by the time this is called.
            setTimeout(() => {
                this._previousActiveElement && this._previousActiveElement.focus();
            }, 0);
        }
        if (this.props.onMenuDismissed) {
            this.props.onMenuDismissed(this.props);
        }
        this._events.dispose();
        this._async.dispose();
        this._mounted = false;
    }
    render() {
        let { isBeakVisible } = this.props;
        const { items, labelElementId, id, className, beakWidth, directionalHint, directionalHintForRTL, alignTargetEdge, gapSpace, coverTarget, ariaLabel, doNotLayer, target, bounds, useTargetWidth, useTargetAsMinWidth, directionalHintFixed, shouldFocusOnMount, shouldFocusOnContainer, title, styles, theme, calloutProps, onRenderSubMenu = this._onRenderSubMenu, onRenderMenuList = this._onRenderMenuList, focusZoneProps, getMenuClassNames } = this.props;
        this._classNames = getMenuClassNames
            ? getMenuClassNames(theme, className)
            : getClassNames$c(styles, {
                theme: theme,
                className: className
            });
        const hasIcons = itemsHaveIcons(items);
        function itemsHaveIcons(contextualMenuItems) {
            for (const item of contextualMenuItems) {
                if (!!item.iconProps) {
                    return true;
                }
                if (item.itemType === ContextualMenuItemType.Section && item.sectionProps && itemsHaveIcons(item.sectionProps.items)) {
                    return true;
                }
            }
            return false;
        }
        this._adjustedFocusZoneProps = { ...focusZoneProps, direction: this._getFocusZoneDirection() };
        const hasCheckmarks = canAnyMenuItemsCheck(items);
        const submenuProps = this.state.expandedMenuItemKey ? this._getSubmenuProps() : null;
        isBeakVisible = isBeakVisible === undefined ? this.props.responsiveMode <= ResponsiveMode.medium : isBeakVisible;
        /**
         * When useTargetWidth is true, get the width of the target element and apply it for the context menu container
         */
        let contextMenuStyle;
        const targetAsHtmlElement = this._target;
        if ((useTargetWidth || useTargetAsMinWidth) && targetAsHtmlElement && targetAsHtmlElement.offsetWidth) {
            const targetBoundingRect = targetAsHtmlElement.getBoundingClientRect();
            const targetWidth = targetBoundingRect.width - 2 /* Accounts for 1px border */;
            if (useTargetWidth) {
                contextMenuStyle = {
                    width: targetWidth
                };
            }
            else if (useTargetAsMinWidth) {
                contextMenuStyle = {
                    minWidth: targetWidth
                };
            }
        }
        // The menu should only return if items were provided, if no items were provided then it should not appear.
        if (items && items.length > 0) {
            let totalItemCount = 0;
            for (const item of items) {
                if (item.itemType !== ContextualMenuItemType.Divider && item.itemType !== ContextualMenuItemType.Header) {
                    const itemCount = item.customOnRenderListLength ? item.customOnRenderListLength : 1;
                    totalItemCount += itemCount;
                }
            }
            const calloutStyles = !getMenuClassNames && this._classNames.subComponentStyles
                ? this._classNames.subComponentStyles.callout
                : undefined;
            return (createElement(Callout, Object.assign({ styles: calloutStyles }, calloutProps, { target: target, isBeakVisible: isBeakVisible, beakWidth: beakWidth, directionalHint: directionalHint, directionalHintForRTL: directionalHintForRTL, gapSpace: gapSpace, coverTarget: coverTarget, doNotLayer: doNotLayer, className: css('ms-ContextualMenu-Callout', calloutProps ? calloutProps.className : undefined), setInitialFocus: shouldFocusOnMount, onDismiss: this.props.onDismiss, onScroll: this._onScroll, bounds: bounds, directionalHintFixed: directionalHintFixed, alignTargetEdge: alignTargetEdge, hidden: this.props.hidden }),
                createElement("div", { role: 'menu', "aria-label": ariaLabel, "aria-labelledby": labelElementId, style: contextMenuStyle, ref: (host) => (this._host = host), id: id, className: this._classNames.container, tabIndex: shouldFocusOnContainer ? 0 : -1, onKeyDown: this._onMenuKeyDown, onKeyUp: this._onKeyUp, onFocusCapture: this._onMenuFocusCapture },
                    title && createElement("div", { className: this._classNames.title },
                        " ",
                        title,
                        " "),
                    items && items.length ? (createElement(FocusZone, Object.assign({}, this._adjustedFocusZoneProps, { className: this._classNames.root, isCircularNavigation: true, handleTabKey: FocusZoneTabbableElements.all }), onRenderMenuList({
                        items,
                        totalItemCount,
                        hasCheckmarks,
                        hasIcons
                    }, this._onRenderMenuList))) : null,
                    submenuProps && onRenderSubMenu(submenuProps, this._onRenderSubMenu))));
        }
        else {
            return null;
        }
    }
    _onMenuOpened() {
        this._events.on(this._targetWindow, 'resize', this.dismiss);
        this._shouldUpdateFocusOnMouseEvent = !this.props.delayUpdateFocusOnHover;
        this._gotMouseMove = false;
        this.props.onMenuOpened && this.props.onMenuOpened(this.props);
    }
    _onMenuClosed() {
        this._events.off(this._targetWindow, 'resize', this.dismiss);
        this._previousActiveElement &&
            this._async.setTimeout(() => {
                this._previousActiveElement && this._previousActiveElement.focus();
            }, 0);
        this._shouldUpdateFocusOnMouseEvent = !this.props.delayUpdateFocusOnHover;
    }
    /**
     * Gets the focusZoneDirection by using the arrowDirection if specified,
     * the direction specificed in the focusZoneProps, or defaults to FocusZoneDirection.vertical
     */
    _getFocusZoneDirection() {
        const { focusZoneProps } = this.props;
        return focusZoneProps && focusZoneProps.direction !== undefined ? focusZoneProps.direction : FocusZoneDirection.vertical;
    }
    _onRenderSubMenu(subMenuProps) {
        return createElement(ContextualMenu, Object.assign({}, subMenuProps));
    }
    _renderMenuItem(item, index, focusableElementIndex, totalItemCount, hasCheckmarks, hasIcons) {
        const renderedItems = [];
        const iconProps = item.iconProps || { iconName: 'None' };
        const { getItemClassNames: getItemClassNames$$1, itemProps } = item;
        const styles = itemProps ? itemProps.styles : undefined;
        // We only send a dividerClassName when the item to be rendered is a divider. For all other cases, the default divider style is used.
        const dividerClassName = item.itemType === ContextualMenuItemType.Divider ? item.className : undefined;
        const subMenuIconClassName = item.submenuIconProps ? item.submenuIconProps.className : '';
        let itemClassNames;
        // IContextualMenuItem#getItemClassNames for backwards compatibility
        // otherwise uses mergeStyles for class names.
        if (getItemClassNames$$1) {
            itemClassNames = getItemClassNames$$1(this.props.theme, isItemDisabled(item), this.state.expandedMenuItemKey === item.key, !!getIsChecked(item), !!item.href, iconProps.iconName !== 'None', item.className, dividerClassName, iconProps.className, subMenuIconClassName, item.primaryDisabled);
        }
        else {
            const itemStyleProps = {
                theme: this.props.theme,
                disabled: isItemDisabled(item),
                expanded: this.state.expandedMenuItemKey === item.key,
                checked: !!getIsChecked(item),
                isAnchorLink: !!item.href,
                knownIcon: iconProps.iconName !== 'None',
                itemClassName: item.className,
                dividerClassName,
                iconClassName: iconProps.className,
                subMenuClassName: subMenuIconClassName,
                primaryDisabled: item.primaryDisabled
            };
            const menuItemStyles = this._classNames.subComponentStyles
                ? this._classNames.subComponentStyles.menuItem
                : undefined;
            // We need to generate default styles then override if styles are provided
            // since the ContextualMenu currently handles item classNames.
            itemClassNames = mergeStyleSets(getContextualMenuItemClassNames(getItemStyles, itemStyleProps), getContextualMenuItemClassNames(menuItemStyles, itemStyleProps), getContextualMenuItemClassNames(styles, itemStyleProps));
        }
        if (item.text === '-' || item.name === '-') {
            item.itemType = ContextualMenuItemType.Divider;
        }
        switch (item.itemType) {
            case ContextualMenuItemType.Divider:
                renderedItems.push(this._renderSeparator(index, itemClassNames));
                break;
            case ContextualMenuItemType.Header:
                renderedItems.push(this._renderSeparator(index, itemClassNames));
                const headerItem = this._renderHeaderMenuItem(item, itemClassNames, index, hasCheckmarks, hasIcons);
                renderedItems.push(this._renderListItem(headerItem, item.key || index, itemClassNames, item.title));
                break;
            case ContextualMenuItemType.Section:
                renderedItems.push(this._renderSectionItem(item, itemClassNames, index, hasCheckmarks, hasIcons));
                break;
            default:
                const menuItem = this._renderNormalItem(item, itemClassNames, index, focusableElementIndex, totalItemCount, hasCheckmarks, hasIcons);
                renderedItems.push(this._renderListItem(menuItem, item.key || index, itemClassNames, item.title));
                break;
        }
        return renderedItems;
    }
    _renderSectionItem(item, menuClassNames, index, hasCheckmarks, hasIcons) {
        const section = item.sectionProps;
        if (!section) {
            return;
        }
        let headerItem;
        if (section.title) {
            const headerContextualMenuItem = {
                key: `section-${section.title}-title`,
                itemType: ContextualMenuItemType.Header,
                text: section.title
            };
            headerItem = this._renderHeaderMenuItem(headerContextualMenuItem, menuClassNames, index, hasCheckmarks, hasIcons);
        }
        if (section.items && section.items.length > 0) {
            return (createElement("li", { role: "presentation", key: section.key },
                createElement("div", { role: "group" },
                    createElement("ul", { className: this._classNames.list },
                        section.topDivider && this._renderSeparator(index, menuClassNames, true, true),
                        headerItem && this._renderListItem(headerItem, item.key || index, menuClassNames, item.title),
                        section.items.map((contextualMenuItem, itemsIndex) => this._renderMenuItem(contextualMenuItem, itemsIndex, itemsIndex, section.items.length, hasCheckmarks, hasIcons)),
                        section.bottomDivider && this._renderSeparator(index, menuClassNames, false, true)))));
        }
    }
    _renderListItem(content, key, classNames, title) {
        return (createElement("li", { role: "presentation", title: title, key: key, className: classNames.item }, content));
    }
    _renderSeparator(index, classNames, top, fromSection) {
        if (fromSection || index > 0) {
            return (createElement("li", { role: "separator", key: 'separator-' + index + (top === undefined ? '' : top ? '-top' : '-bottom'), className: classNames.divider, "aria-hidden": "true" }));
        }
        return null;
    }
    _renderNormalItem(item, classNames, index, focusableElementIndex, totalItemCount, hasCheckmarks, hasIcons) {
        if (item.onRender) {
            return item.onRender({ 'aria-posinset': focusableElementIndex + 1, 'aria-setsize': totalItemCount, ...item }, this.dismiss);
        }
        if (item.href) {
            return this._renderAnchorMenuItem(item, classNames, index, focusableElementIndex, totalItemCount, hasCheckmarks, hasIcons);
        }
        if (item.split && hasSubmenu(item)) {
            return this._renderSplitButton(item, classNames, index, focusableElementIndex, totalItemCount, hasCheckmarks, hasIcons);
        }
        return this._renderButtonItem(item, classNames, index, focusableElementIndex, totalItemCount, hasCheckmarks, hasIcons);
    }
    _renderHeaderMenuItem(item, classNames, index, hasCheckmarks, hasIcons) {
        const { contextualMenuItemAs: ChildrenRenderer = ContextualMenuItem } = this.props;
        const { itemProps } = item;
        return (createElement("div", { className: this._classNames.header, style: item.style },
            createElement(ChildrenRenderer, Object.assign({ item: item, classNames: classNames, index: index, onCheckmarkClick: hasCheckmarks ? this._onItemClick : undefined, hasIcons: hasIcons }, itemProps))));
    }
    _renderAnchorMenuItem(item, classNames, index, focusableElementIndex, totalItemCount, hasCheckmarks, hasIcons) {
        const { contextualMenuItemAs } = this.props;
        const { expandedMenuItemKey } = this.state;
        return (createElement(ContextualMenuAnchor, { item: item, classNames: classNames, index: index, focusableElementIndex: focusableElementIndex, totalItemCount: totalItemCount, hasCheckmarks: hasCheckmarks, hasIcons: hasIcons, contextualMenuItemAs: contextualMenuItemAs, onItemMouseEnter: this._onItemMouseEnterBase, onItemMouseLeave: this._onMouseItemLeave, onItemMouseMove: this._onItemMouseMoveBase, onItemMouseDown: this._onItemMouseDown, executeItemClick: this._executeItemClick, onItemClick: this._onAnchorClick, onItemKeyDown: this._onItemKeyDown, getSubMenuId: this._getSubMenuId, expandedMenuItemKey: expandedMenuItemKey, openSubMenu: this._onItemSubMenuExpand, dismissSubMenu: this._onSubMenuDismiss, dismissMenu: this.dismiss }));
    }
    _renderButtonItem(item, classNames, index, focusableElementIndex, totalItemCount, hasCheckmarks, hasIcons) {
        const { contextualMenuItemAs } = this.props;
        const { expandedMenuItemKey } = this.state;
        return (createElement(ContextualMenuButton, { item: item, classNames: classNames, index: index, focusableElementIndex: focusableElementIndex, totalItemCount: totalItemCount, hasCheckmarks: hasCheckmarks, hasIcons: hasIcons, contextualMenuItemAs: contextualMenuItemAs, onItemMouseEnter: this._onItemMouseEnterBase, onItemMouseLeave: this._onMouseItemLeave, onItemMouseMove: this._onItemMouseMoveBase, onItemMouseDown: this._onItemMouseDown, executeItemClick: this._executeItemClick, onItemClick: this._onItemClick, onItemClickBase: this._onItemClickBase, onItemKeyDown: this._onItemKeyDown, getSubMenuId: this._getSubMenuId, expandedMenuItemKey: expandedMenuItemKey, openSubMenu: this._onItemSubMenuExpand, dismissSubMenu: this._onSubMenuDismiss, dismissMenu: this.dismiss }));
    }
    _renderSplitButton(item, classNames, index, focusableElementIndex, totalItemCount, hasCheckmarks, hasIcons) {
        const { contextualMenuItemAs } = this.props;
        const { expandedMenuItemKey } = this.state;
        return (createElement(ContextualMenuSplitButton, { item: item, classNames: classNames, index: index, focusableElementIndex: focusableElementIndex, totalItemCount: totalItemCount, hasCheckmarks: hasCheckmarks, hasIcons: hasIcons, contextualMenuItemAs: contextualMenuItemAs, onItemMouseEnter: this._onItemMouseEnterBase, onItemMouseLeave: this._onMouseItemLeave, onItemMouseMove: this._onItemMouseMoveBase, onItemMouseDown: this._onItemMouseDown, executeItemClick: this._executeItemClick, onItemClick: this._onItemClick, onItemClickBase: this._onItemClickBase, onItemKeyDown: this._onItemKeyDown, openSubMenu: this._onItemSubMenuExpand, dismissSubMenu: this._onSubMenuDismiss, dismissMenu: this.dismiss, expandedMenuItemKey: expandedMenuItemKey, onTap: this._onPointerAndTouchEvent }));
    }
    /**
     * Returns true if the key for the event is alt (Mac option) or meta (Mac command).
     */
    _isAltOrMeta(ev) {
        return ev.which === KeyCodes.alt || ev.key === 'Meta';
    }
    _shouldIgnoreMouseEvent() {
        return !this._isScrollIdle || !this._gotMouseMove;
    }
    /**
     * Handles updating focus when mouseEnter or mouseMove fire.
     * As part of updating focus, This function will also update
     * the expand/collapse state accordingly.
     */
    _updateFocusOnMouseEvent(item, ev, target) {
        const targetElement = target ? target : ev.currentTarget;
        const { subMenuHoverDelay: timeoutDuration = NavigationIdleDelay } = this.props;
        if (item.key === this.state.expandedMenuItemKey) {
            return;
        }
        if (this._enterTimerId !== undefined) {
            this._async.clearTimeout(this._enterTimerId);
            this._enterTimerId = undefined;
        }
        // If the menu is not expanded we can update focus without any delay
        if (this.state.expandedMenuItemKey === undefined) {
            targetElement.focus();
        }
        // Delay updating expanding/dismissing the submenu
        // and only set focus if we have not already done so
        if (hasSubmenu(item)) {
            ev.stopPropagation();
            this._enterTimerId = this._async.setTimeout(() => {
                targetElement.focus();
                this.setState({
                    expandedByMouseClick: true
                });
                this._onItemSubMenuExpand(item, targetElement);
                this._enterTimerId = undefined;
            }, timeoutDuration);
        }
        else {
            this._enterTimerId = this._async.setTimeout(() => {
                this._onSubMenuDismiss(ev);
                targetElement.focus();
                this._enterTimerId = undefined;
            }, timeoutDuration);
        }
    }
    _getSubmenuProps() {
        const { submenuTarget, expandedMenuItemKey } = this.state;
        const item = this._findItemByKey(expandedMenuItemKey);
        let submenuProps = null;
        if (item) {
            submenuProps = {
                items: getSubmenuItems(item),
                target: submenuTarget,
                onDismiss: this._onSubMenuDismiss,
                isSubMenu: true,
                id: this.state.subMenuId,
                shouldFocusOnMount: true,
                shouldFocusOnContainer: this.state.expandedByMouseClick,
                directionalHint: getRTL() ? DirectionalHint.leftTopEdge : DirectionalHint.rightTopEdge,
                className: this.props.className,
                gapSpace: 0,
                isBeakVisible: false
            };
            if (item.subMenuProps) {
                assign(submenuProps, item.subMenuProps);
            }
        }
        return submenuProps;
    }
    _findItemByKey(key) {
        const { items } = this.props;
        return this._findItemByKeyFromItems(key, items);
    }
    /**
     * Returns the item that mathes a given key if any.
     * @param key The key of the item to match
     * @param items The items to look for the key
     */
    _findItemByKeyFromItems(key, items) {
        for (const item of items) {
            if (item.itemType === ContextualMenuItemType.Section && item.sectionProps) {
                const match = this._findItemByKeyFromItems(key, item.sectionProps.items);
                if (match) {
                    return match;
                }
            }
            else if (item.key && item.key === key) {
                return item;
            }
        }
    }
    _setTargetWindowAndElement(target) {
        if (target) {
            if (typeof target === 'string') {
                const currentDoc = getDocument();
                this._target = currentDoc ? currentDoc.querySelector(target) : null;
                this._targetWindow = getWindow();
            }
            else if (target.stopPropagation) {
                this._targetWindow = getWindow(target.toElement);
                this._target = target;
            }
            else if (target.x !== undefined && target.y !== undefined) {
                this._targetWindow = getWindow();
                this._target = target;
            }
            else {
                const targetElement = target;
                this._targetWindow = getWindow(targetElement);
                this._target = target;
            }
        }
        else {
            this._targetWindow = getWindow();
        }
    }
};
// The default ContextualMenu properties have no items and beak, the default submenu direction is right and top.
ContextualMenuBase.defaultProps = {
    items: [],
    shouldFocusOnMount: true,
    gapSpace: 0,
    directionalHint: DirectionalHint.bottomAutoEdge,
    beakWidth: 16
};
ContextualMenuBase = __decorate([
    withResponsiveMode
], ContextualMenuBase);

const GlobalClassNames$a = {
    root: 'ms-ContextualMenu',
    container: 'ms-ContextualMenu-container',
    list: 'ms-ContextualMenu-list',
    header: 'ms-ContextualMenu-header',
    title: 'ms-ContextualMenu-title',
    isopen: 'is-open'
};
const getStyles$c = (props) => {
    const { className, theme } = props;
    const classNames = getGlobalClassNames(GlobalClassNames$a, theme);
    const { palette, fonts, semanticColors } = theme;
    return {
        root: [
            theme.fonts.medium,
            classNames.root,
            classNames.isopen,
            {
                backgroundColor: semanticColors.bodyBackground,
                minWidth: '180px'
            },
            className
        ],
        container: [
            classNames.container,
            {
                selectors: {
                    ':focus': { outline: 0 }
                }
            }
        ],
        list: [
            classNames.list,
            classNames.isopen,
            {
                listStyleType: 'none',
                margin: '0',
                padding: '0'
            }
        ],
        header: [
            classNames.header,
            fonts.small,
            {
                fontWeight: FontWeights.semibold,
                color: semanticColors.menuHeader,
                background: 'none',
                backgroundColor: 'transparent',
                border: 'none',
                height: CONTEXTUAL_MENU_ITEM_HEIGHT,
                lineHeight: CONTEXTUAL_MENU_ITEM_HEIGHT,
                cursor: 'default',
                padding: '0px 6px',
                userSelect: 'none',
                textAlign: 'left'
            }
        ],
        title: [
            classNames.title,
            {
                fontSize: '16px',
                paddingRight: '14px',
                paddingLeft: '14px',
                paddingBottom: '5px',
                paddingTop: '5px',
                backgroundColor: palette.neutralLight
            }
        ],
        subComponentStyles: { callout: {}, menuItem: {} }
    };
};

/**
 * ContextualMenu description
 */
const ContextualMenu = styled(ContextualMenuBase, getStyles$c, undefined, { scope: 'ContextualMenu' });

const GlobalClassNames$b = {
    msButton: 'ms-Button',
    msButtonIcon: 'ms-Button-icon',
    msButtonMenuIcon: 'ms-Button-menuIcon',
    msButtonLabel: 'ms-Button-label',
    msButtonDescription: 'ms-Button-description',
    msButtonScreenReaderText: 'ms-Button-screenReaderText',
    msButtonFlexContainer: 'ms-Button-flexContainer',
    msButtonTextContainer: 'ms-Button-textContainer'
};
const getBaseButtonClassNames = memoizeFunction((theme, styles, className, variantClassName, iconClassName, menuIconClassName, disabled, checked, expanded, isSplit) => {
    const classNames = getGlobalClassNames(GlobalClassNames$b, theme);
    const isExpanded = expanded && !isSplit;
    return mergeStyleSets({
        root: [
            classNames.msButton,
            styles.root,
            variantClassName,
            checked && ['is-checked', styles.rootChecked],
            isExpanded && [
                'is-expanded',
                styles.rootExpanded,
                {
                    selectors: {
                        [`:hover .${classNames.msButtonIcon}`]: styles.iconExpandedHovered,
                        // menuIcon falls back to rootExpandedHovered to support original behavior
                        [`:hover .${classNames.msButtonMenuIcon}`]: styles.menuIconExpandedHovered || styles.rootExpandedHovered,
                        ':hover': styles.rootExpandedHovered
                    }
                }
            ],
            disabled && ['is-disabled', styles.rootDisabled],
            !disabled &&
                !isExpanded &&
                !checked && {
                selectors: {
                    ':hover': styles.rootHovered,
                    [`:hover .${classNames.msButtonLabel}`]: styles.labelHovered,
                    [`:hover .${classNames.msButtonIcon}`]: styles.iconHovered,
                    [`:hover .${classNames.msButtonDescription}`]: styles.descriptionHovered,
                    [`:hover .${classNames.msButtonMenuIcon}`]: styles.menuIconHovered,
                    ':focus': styles.rootFocused,
                    ':active': styles.rootPressed,
                    [`:active .${classNames.msButtonIcon}`]: styles.iconPressed,
                    [`:active .${classNames.msButtonDescription}`]: styles.descriptionPressed,
                    [`:active .${classNames.msButtonMenuIcon}`]: styles.menuIconPressed
                }
            },
            disabled && checked && [styles.rootCheckedDisabled],
            !disabled &&
                checked && {
                selectors: {
                    ':hover': styles.rootCheckedHovered,
                    ':active': styles.rootCheckedPressed
                }
            },
            className
        ],
        flexContainer: [classNames.msButtonFlexContainer, styles.flexContainer],
        textContainer: [classNames.msButtonTextContainer, styles.textContainer],
        icon: [
            classNames.msButtonIcon,
            iconClassName,
            styles.icon,
            isExpanded && styles.iconExpanded,
            checked && styles.iconChecked,
            disabled && styles.iconDisabled
        ],
        label: [classNames.msButtonLabel, styles.label, checked && styles.labelChecked, disabled && styles.labelDisabled],
        menuIcon: [
            classNames.msButtonMenuIcon,
            menuIconClassName,
            styles.menuIcon,
            checked && styles.menuIconChecked,
            disabled && styles.menuIconDisabled,
            !disabled &&
                !isExpanded &&
                !checked && {
                selectors: {
                    ':hover': styles.menuIconHovered,
                    ':active': styles.menuIconPressed
                }
            },
            isExpanded && ['is-expanded', styles.menuIconExpanded]
        ],
        description: [
            classNames.msButtonDescription,
            styles.description,
            checked && styles.descriptionChecked,
            disabled && styles.descriptionDisabled
        ],
        screenReaderText: [classNames.msButtonScreenReaderText, styles.screenReaderText]
    });
});

const getClassNames$d = memoizeFunction((styles, disabled, expanded, checked) => {
    return {
        root: mergeStyles(styles.splitButtonMenuButton, expanded && [styles.splitButtonMenuButtonExpanded], disabled && [styles.splitButtonMenuButtonDisabled], checked && !disabled && [styles.splitButtonMenuButtonChecked]),
        splitButtonContainer: mergeStyles(styles.splitButtonContainer, checked &&
            !disabled && [
            styles.splitButtonContainerChecked,
            {
                selectors: {
                    ':hover': styles.splitButtonContainerCheckedHovered
                }
            }
        ], !disabled &&
            !checked && [
            {
                selectors: {
                    ':hover': styles.splitButtonContainerHovered,
                    ':focus': styles.splitButtonContainerFocused
                }
            }
        ], disabled && styles.splitButtonContainerDisabled),
        icon: mergeStyles(styles.splitButtonMenuIcon, disabled && styles.splitButtonMenuIconDisabled),
        flexContainer: mergeStyles(styles.splitButtonFlexContainer),
        divider: mergeStyles(styles.splitButtonDivider)
    };
});

const TouchIdleDelay$1 = 500; /* ms */
class BaseButton extends BaseComponent {
    constructor(props, rootClassName) {
        super(props);
        this._buttonElement = createRef();
        this._splitButtonContainer = createRef();
        this._onRenderIcon = (buttonProps, defaultRender) => {
            const { iconProps } = this.props;
            if (iconProps) {
                const { className, ...rest } = iconProps;
                return createElement(Icon, Object.assign({ className: css(this._classNames.icon, className) }, rest));
            }
            return null;
        };
        this._onRenderTextContents = () => {
            const { text, children, secondaryText = this.props.description, onRenderText = this._onRenderText, onRenderDescription = this._onRenderDescription } = this.props;
            if (text || typeof children === 'string' || secondaryText) {
                return (createElement("div", { className: this._classNames.textContainer },
                    onRenderText(this.props, this._onRenderText),
                    onRenderDescription(this.props, this._onRenderDescription)));
            }
            return [onRenderText(this.props, this._onRenderText), onRenderDescription(this.props, this._onRenderDescription)];
        };
        this._onRenderText = () => {
            let { text } = this.props;
            const { children } = this.props;
            // For backwards compat, we should continue to take in the text content from children.
            if (text === undefined && typeof children === 'string') {
                text = children;
            }
            if (this._hasText()) {
                return (createElement("div", { key: this._labelId, className: this._classNames.label, id: this._labelId }, text));
            }
            return null;
        };
        this._onRenderChildren = () => {
            const { children } = this.props;
            // If children is just a string, either it or the text will be rendered via onRenderLabel
            // If children is another component, it will be rendered after text
            if (typeof children === 'string') {
                return null;
            }
            return children;
        };
        this._onRenderDescription = (props) => {
            const { secondaryText = this.props.description } = props;
            // ms-Button-description is only shown when the button type is compound.
            // In other cases it will not be displayed.
            return secondaryText ? (createElement("div", { key: this._descriptionId, className: this._classNames.description, id: this._descriptionId }, secondaryText)) : null;
        };
        this._onRenderAriaDescription = () => {
            const { ariaDescription } = this.props;
            // If ariaDescription is given, descriptionId will be assigned to ariaDescriptionSpan,
            // otherwise it will be assigned to descriptionSpan.
            return ariaDescription ? (createElement("span", { className: this._classNames.screenReaderText, id: this._ariaDescriptionId }, ariaDescription)) : null;
        };
        this._onRenderMenuIcon = (props) => {
            const { menuIconProps } = this.props;
            return createElement(Icon, Object.assign({ iconName: "ChevronDown" }, menuIconProps, { className: this._classNames.menuIcon }));
        };
        this._onRenderMenu = (menuProps) => {
            const { onDismiss = this._dismissMenu } = menuProps;
            const MenuType = this.props.menuAs || ContextualMenu;
            // the accessible menu label (accessible name) has a relationship to the button.
            // If the menu props do not specify an explicit value for aria-label or aria-labelledBy,
            // AND the button has text, we'll set the menu aria-labelledBy to the text element id.
            if (!menuProps.ariaLabel && !menuProps.labelElementId && this._hasText()) {
                menuProps = { ...menuProps, labelElementId: this._labelId };
            }
            //@ts-ignore
            return (createElement(MenuType, Object.assign({ id: this._labelId + '-menu', directionalHint: DirectionalHint.bottomLeftEdge }, menuProps, { shouldFocusOnContainer: this.state.menuProps ? this.state.menuProps.shouldFocusOnContainer : undefined, shouldFocusOnMount: this.state.menuProps ? this.state.menuProps.shouldFocusOnMount : undefined, className: css('ms-BaseButton-menuhost', menuProps.className), target: this._isSplitButton ? this._splitButtonContainer.current : this._buttonElement.current, onDismiss: onDismiss })));
        };
        this._dismissMenu = () => {
            let menuProps = null;
            if (this.props.persistMenu && this.state.menuProps) {
                menuProps = this.state.menuProps;
                menuProps.hidden = true;
            }
            this.setState({ menuProps: menuProps });
        };
        this._openMenu = (shouldFocusOnContainer, shouldFocusOnMount = true) => {
            if (this.props.menuProps) {
                const menuProps = { ...this.props.menuProps, shouldFocusOnContainer, shouldFocusOnMount };
                if (this.props.persistMenu) {
                    menuProps.hidden = false;
                }
                this.setState({ menuProps: menuProps });
            }
        };
        this._onToggleMenu = (shouldFocusOnContainer) => {
            const currentMenuProps = this.state.menuProps;
            let shouldFocusOnMount = true;
            if (this.props.menuProps && this.props.menuProps.shouldFocusOnMount === false) {
                shouldFocusOnMount = false;
            }
            if (this.props.persistMenu) {
                currentMenuProps && currentMenuProps.hidden ? this._openMenu(shouldFocusOnContainer, shouldFocusOnMount) : this._dismissMenu();
            }
            else {
                currentMenuProps ? this._dismissMenu() : this._openMenu(shouldFocusOnContainer, shouldFocusOnMount);
            }
        };
        this._onSplitContainerFocusCapture = (ev) => {
            const container = this._splitButtonContainer.current;
            // If the target is coming from the portal we do not need to set focus on the container.
            if (!container || (ev.target && portalContainsElement(ev.target, container))) {
                return;
            }
            // We should never be able to focus the individual buttons in a split button. Focus
            // should always remain on the container.
            container.focus();
        };
        this._onSplitButtonPrimaryClick = (ev) => {
            if (this._isExpanded) {
                this._dismissMenu();
            }
            if (!this._processingTouch && this.props.onClick) {
                this.props.onClick(ev);
            }
            else if (this._processingTouch) {
                this._onMenuClick(ev);
            }
        };
        this._onKeyDown = (ev) => {
            // explicity cancelling event so click won't fire after this
            if (this.props.disabled && (ev.which === KeyCodes.enter || ev.which === KeyCodes.space)) {
                ev.preventDefault();
                ev.stopPropagation();
            }
            else if (!this.props.disabled) {
                if (this.props.menuProps) {
                    this._onMenuKeyDown(ev);
                }
                else if (this.props.onKeyDown !== undefined) {
                    this.props.onKeyDown(ev); // not cancelling event because it's not disabled
                }
            }
        };
        this._onKeyUp = (ev) => {
            if (!this.props.disabled && this.props.onKeyUp !== undefined) {
                this.props.onKeyUp(ev); // not cancelling event because it's not disabled
            }
        };
        this._onKeyPress = (ev) => {
            if (!this.props.disabled && this.props.onKeyPress !== undefined) {
                this.props.onKeyPress(ev); // not cancelling event because it's not disabled
            }
        };
        this._onMouseUp = (ev) => {
            if (!this.props.disabled && this.props.onMouseUp !== undefined) {
                this.props.onMouseUp(ev); // not cancelling event because it's not disabled
            }
        };
        this._onMouseDown = (ev) => {
            if (!this.props.disabled && this.props.onMouseDown !== undefined) {
                this.props.onMouseDown(ev); // not cancelling event because it's not disabled
            }
        };
        this._onClick = (ev) => {
            if (!this.props.disabled) {
                if (this.props.menuProps) {
                    this._onMenuClick(ev);
                }
                else if (this.props.onClick !== undefined) {
                    this.props.onClick(ev); // not cancelling event because it's not disabled
                }
            }
        };
        this._onSplitButtonContainerKeyDown = (ev) => {
            if (ev.which === KeyCodes.enter) {
                if (this._buttonElement.current) {
                    this._buttonElement.current.click();
                    ev.preventDefault();
                    ev.stopPropagation();
                }
            }
            else {
                this._onMenuKeyDown(ev);
            }
        };
        this._onMenuKeyDown = (ev) => {
            if (this.props.disabled) {
                return;
            }
            if (this.props.onKeyDown) {
                this.props.onKeyDown(ev);
            }
            if (!ev.defaultPrevented && this._isValidMenuOpenKey(ev)) {
                const { onMenuClick } = this.props;
                if (onMenuClick) {
                    onMenuClick(ev, this);
                }
                this._onToggleMenu(false);
                ev.preventDefault();
                ev.stopPropagation();
            }
        };
        this._onTouchStart = () => {
            if (this._isSplitButton && this._splitButtonContainer.current && !('onpointerdown' in this._splitButtonContainer.current)) {
                this._handleTouchAndPointerEvent();
            }
        };
        this._onMenuClick = (ev) => {
            const { onMenuClick } = this.props;
            if (onMenuClick) {
                onMenuClick(ev, this);
            }
            if (!ev.defaultPrevented) {
                // When Edge + Narrator are used together (regardless of if the button is in a form or not), pressing
                // "Enter" fires this method and not _onMenuKeyDown. Checking ev.nativeEvent.detail differentiates
                // between a real click event and a keypress event.
                const shouldFocusOnContainer = ev.nativeEvent.detail !== 0;
                this._onToggleMenu(shouldFocusOnContainer);
                ev.preventDefault();
                ev.stopPropagation();
            }
        };
        this._warnConditionallyRequiredProps(['menuProps', 'onClick'], 'split', this.props.split);
        this._warnDeprecations({
            rootProps: undefined,
            description: 'secondaryText',
            toggled: 'checked'
        });
        this._labelId = getId();
        this._descriptionId = getId();
        this._ariaDescriptionId = getId();
        let menuProps = null;
        if (props.persistMenu && props.menuProps) {
            menuProps = props.menuProps;
            menuProps.hidden = true;
        }
        this.state = {
            menuProps: menuProps
        };
    }
    get _isSplitButton() {
        return !!this.props.menuProps && !!this.props.onClick && this.props.split === true;
    }
    get _isExpanded() {
        if (this.props.persistMenu) {
            return !this.state.menuProps.hidden;
        }
        return !!this.state.menuProps;
    }
    render() {
        const { ariaDescription, ariaLabel, ariaHidden, className, disabled, allowDisabledFocus, primaryDisabled, secondaryText = this.props.description, href, iconProps, menuIconProps, styles, checked, variantClassName, theme, toggle, getClassNames: getClassNames$$1 } = this.props;
        const { menuProps } = this.state;
        // Button is disabled if the whole button (in case of splitbutton is disabled) or if the primary action is disabled
        const isPrimaryButtonDisabled = disabled || primaryDisabled;
        this._classNames = getClassNames$$1
            ? getClassNames$$1(theme, className, variantClassName, iconProps && iconProps.className, menuIconProps && menuIconProps.className, isPrimaryButtonDisabled, checked, !!menuProps, this.props.split, !!allowDisabledFocus)
            : getBaseButtonClassNames(theme, styles, className, variantClassName, iconProps && iconProps.className, menuIconProps && menuIconProps.className, isPrimaryButtonDisabled, checked, !!menuProps, this.props.split);
        const { _ariaDescriptionId, _labelId, _descriptionId } = this;
        // Anchor tag cannot be disabled hence in disabled state rendering
        // anchor button as normal button
        const renderAsAnchor = !isPrimaryButtonDisabled && !!href;
        const tag = renderAsAnchor ? 'a' : 'button';
        const nativeProps = getNativeProps(assign(renderAsAnchor ? {} : { type: 'button' }, this.props.rootProps, this.props), renderAsAnchor ? anchorProperties : buttonProperties, [
            'disabled' // let disabled buttons be focused and styled as disabled.
        ]);
        // Check for ariaLabel passed in via Button props, and fall back to aria-label passed in via native props
        const resolvedAriaLabel = ariaLabel || nativeProps['aria-label'];
        // Check for ariaDescription, secondaryText or aria-describedby in the native props to determine source of aria-describedby
        // otherwise default to undefined so property does not appear in output.
        let ariaDescribedBy = undefined;
        if (ariaDescription) {
            ariaDescribedBy = _ariaDescriptionId;
        }
        else if (secondaryText) {
            ariaDescribedBy = _descriptionId;
        }
        else if (nativeProps['aria-describedby']) {
            ariaDescribedBy = nativeProps['aria-describedby'];
        }
        // If an explicit ariaLabel is given, use that as the label and we're done.
        // If an explicit aria-labelledby is given, use that and we're done.
        // If any kind of description is given (which will end up as an aria-describedby attribute),
        // set the labelledby element. Otherwise, the button is labeled implicitly by the descendent
        // text on the button (if it exists). Never set both aria-label and aria-labelledby.
        let ariaLabelledBy = undefined;
        if (!resolvedAriaLabel) {
            if (nativeProps['aria-labelledby']) {
                ariaLabelledBy = nativeProps['aria-labelledby'];
            }
            else if (ariaDescribedBy) {
                ariaLabelledBy = this._hasText() ? _labelId : undefined;
            }
        }
        const dataIsFocusable = this.props['data-is-focusable'] === false || (disabled && !allowDisabledFocus) || this._isSplitButton ? false : true;
        const buttonProps = assign(nativeProps, {
            className: this._classNames.root,
            ref: this._buttonElement,
            disabled: isPrimaryButtonDisabled && !allowDisabledFocus,
            onKeyDown: this._onKeyDown,
            onKeyPress: this._onKeyPress,
            onKeyUp: this._onKeyUp,
            onMouseDown: this._onMouseDown,
            onMouseUp: this._onMouseUp,
            onClick: this._onClick,
            'aria-label': resolvedAriaLabel,
            'aria-labelledby': ariaLabelledBy,
            'aria-describedby': ariaDescribedBy,
            'aria-disabled': isPrimaryButtonDisabled,
            'data-is-focusable': dataIsFocusable,
            'aria-pressed': toggle ? !!checked : undefined // aria-pressed attribute should only be present for toggle buttons
        });
        if (ariaHidden) {
            buttonProps['aria-hidden'] = true;
        }
        if (this._isSplitButton) {
            return this._onRenderSplitButtonContent(tag, buttonProps);
        }
        else if (this.props.menuProps) {
            assign(buttonProps, {
                'aria-expanded': this._isExpanded,
                'aria-owns': this.state.menuProps ? this._labelId + '-menu' : null,
                'aria-haspopup': true
            });
        }
        return this._onRenderContent(tag, buttonProps);
    }
    componentDidMount() {
        // For split buttons, touching anywhere in the button should drop the dropdown, which should contain the primary action.
        // This gives more hit target space for touch environments. We're setting the onpointerdown here, because React
        // does not support Pointer events yet.
        if (this._isSplitButton && this._splitButtonContainer.current && 'onpointerdown' in this._splitButtonContainer.current) {
            this._events.on(this._splitButtonContainer.current, 'pointerdown', this._onPointerDown, true);
        }
    }
    componentDidUpdate(prevProps, prevState) {
        // If Button's menu was closed, run onAfterMenuDismiss
        if (this.props.onAfterMenuDismiss && prevState.menuProps && !this.state.menuProps) {
            this.props.onAfterMenuDismiss();
        }
    }
    focus() {
        if (this._isSplitButton && this._splitButtonContainer.current) {
            this._splitButtonContainer.current.focus();
        }
        else if (this._buttonElement.current) {
            this._buttonElement.current.focus();
        }
    }
    dismissMenu() {
        this._dismissMenu();
    }
    openMenu(shouldFocusOnContainer, shouldFocusOnMount) {
        this._openMenu(shouldFocusOnContainer, shouldFocusOnMount);
    }
    _onRenderContent(tag, buttonProps) {
        const props = this.props;
        const Tag = tag;
        const { menuIconProps, menuProps, onRenderIcon = this._onRenderIcon, onRenderAriaDescription = this._onRenderAriaDescription, onRenderChildren = this._onRenderChildren, onRenderMenu = this._onRenderMenu, onRenderMenuIcon = this._onRenderMenuIcon, disabled } = props;
        let { keytipProps } = props;
        if (keytipProps && menuProps) {
            keytipProps = {
                ...keytipProps,
                hasMenu: true
            };
        }
        const Content = (
        // If we're making a split button, we won't put the keytip here
        createElement(KeytipData, { keytipProps: !this._isSplitButton ? keytipProps : undefined, ariaDescribedBy: buttonProps['aria-describedby'], disabled: disabled }, (keytipAttributes) => (createElement(Tag, Object.assign({}, buttonProps, keytipAttributes),
            createElement("div", { className: this._classNames.flexContainer },
                onRenderIcon(props, this._onRenderIcon),
                this._onRenderTextContents(),
                onRenderAriaDescription(props, this._onRenderAriaDescription),
                onRenderChildren(props, this._onRenderChildren),
                !this._isSplitButton &&
                    (menuProps || menuIconProps || this.props.onRenderMenuIcon) &&
                    onRenderMenuIcon(this.props, this._onRenderMenuIcon),
                this.state.menuProps && !this.state.menuProps.doNotLayer && onRenderMenu(menuProps, this._onRenderMenu))))));
        if (menuProps && menuProps.doNotLayer) {
            return (createElement("div", { style: { display: 'inline-block' } },
                Content,
                this.state.menuProps && onRenderMenu(menuProps, this._onRenderMenu)));
        }
        return Content;
    }
    _hasText() {
        // _onRenderTextContents and _onRenderText do not perform the same checks. Below is parity with what _onRenderText used to have
        // before the refactor that introduced this function. _onRenderTextContents does not require props.text to be undefined in order
        // for props.children to be used as a fallback. Purely a code maintainability/reuse issue, but logged as Issue #4979
        return this.props.text !== null && (this.props.text !== undefined || typeof this.props.children === 'string');
    }
    _onRenderSplitButtonContent(tag, buttonProps) {
        const { styles = {}, disabled, allowDisabledFocus, checked, getSplitButtonClassNames, primaryDisabled, menuProps, toggle } = this.props;
        let { keytipProps } = this.props;
        const classNames = getSplitButtonClassNames
            ? getSplitButtonClassNames(!!disabled, !!this.state.menuProps, !!checked, !!allowDisabledFocus)
            : styles && getClassNames$d(styles, !!disabled, !!this.state.menuProps, !!checked);
        assign(buttonProps, {
            onClick: undefined,
            tabIndex: -1,
            'data-is-focusable': false
        });
        const ariaDescribedBy = buttonProps.ariaDescription;
        if (keytipProps && menuProps) {
            keytipProps = {
                ...keytipProps,
                hasMenu: true
            };
        }
        const containerProps = getNativeProps(buttonProps, [], ['disabled']);
        return (createElement(KeytipData, { keytipProps: keytipProps, disabled: disabled }, (keytipAttributes) => (createElement("div", Object.assign({}, containerProps, { "data-ktp-target": keytipAttributes['data-ktp-target'], role: 'button', "aria-disabled": disabled, "aria-haspopup": true, "aria-expanded": this._isExpanded, "aria-pressed": toggle ? !!checked : undefined, "aria-describedby": mergeAriaAttributeValues(ariaDescribedBy, keytipAttributes['aria-describedby']), className: classNames && classNames.splitButtonContainer, onKeyDown: this._onSplitButtonContainerKeyDown, onTouchStart: this._onTouchStart, ref: this._splitButtonContainer, "data-is-focusable": true, onClick: !disabled && !primaryDisabled ? this._onSplitButtonPrimaryClick : undefined, tabIndex: !disabled || allowDisabledFocus ? 0 : undefined, "aria-roledescription": buttonProps['aria-roledescription'], onFocusCapture: this._onSplitContainerFocusCapture }),
            createElement("span", { style: { display: 'flex' } },
                this._onRenderContent(tag, buttonProps),
                this._onRenderSplitButtonMenuButton(classNames, keytipAttributes),
                this._onRenderSplitButtonDivider(classNames))))));
    }
    _onRenderSplitButtonDivider(classNames) {
        if (classNames && classNames.divider) {
            return createElement("span", { className: classNames.divider });
        }
        return null;
    }
    _onRenderSplitButtonMenuButton(classNames, keytipAttributes) {
        const { allowDisabledFocus, checked, disabled } = this.props;
        let menuIconProps = this.props.menuIconProps;
        const { splitButtonAriaLabel } = this.props;
        if (menuIconProps === undefined) {
            menuIconProps = {
                iconName: 'ChevronDown'
            };
        }
        const splitButtonProps = {
            styles: classNames,
            checked: checked,
            disabled: disabled,
            allowDisabledFocus: allowDisabledFocus,
            onClick: this._onMenuClick,
            menuProps: undefined,
            iconProps: { ...menuIconProps, className: this._classNames.menuIcon },
            ariaLabel: splitButtonAriaLabel,
            'aria-haspopup': true,
            'aria-expanded': this._isExpanded,
            'data-is-focusable': false
        };
        // Add data-ktp-execute-target to the split button if the keytip is defined
        return (createElement(BaseButton, Object.assign({}, splitButtonProps, { "data-ktp-execute-target": keytipAttributes['data-ktp-execute-target'], onMouseDown: this._onMouseDown, tabIndex: -1 })));
    }
    _onPointerDown(ev) {
        if (ev.pointerType === 'touch') {
            this._handleTouchAndPointerEvent();
            ev.preventDefault();
            ev.stopImmediatePropagation();
        }
    }
    _handleTouchAndPointerEvent() {
        // If we already have an existing timeeout from a previous touch and pointer event
        // cancel that timeout so we can set a nwe one.
        if (this._lastTouchTimeoutId !== undefined) {
            this._async.clearTimeout(this._lastTouchTimeoutId);
            this._lastTouchTimeoutId = undefined;
        }
        this._processingTouch = true;
        this._lastTouchTimeoutId = this._async.setTimeout(() => {
            this._processingTouch = false;
            this._lastTouchTimeoutId = undefined;
        }, TouchIdleDelay$1);
    }
    /**
     * Returns if the user hits a valid keyboard key to open the menu
     * @param ev - the keyboard event
     * @returns True if user clicks on custom trigger key if enabled or alt + down arrow if not. False otherwise.
     */
    _isValidMenuOpenKey(ev) {
        if (this.props.menuTriggerKeyCode) {
            return ev.which === this.props.menuTriggerKeyCode;
        }
        else if (this.props.menuProps) {
            return ev.which === KeyCodes.down && (ev.altKey || ev.metaKey);
        }
        // Note: When enter is pressed, we will let the event continue to propagate
        // to trigger the onClick event on the button
        return false;
    }
}
BaseButton.defaultProps = {
    baseClassName: 'ms-Button',
    styles: {},
    split: false
};

var ElementType;
(function (ElementType) {
    /** <button> element. */
    ElementType[ElementType["button"] = 0] = "button";
    /** <a> element. */
    ElementType[ElementType["anchor"] = 1] = "anchor";
})(ElementType || (ElementType = {}));
var ButtonType;
(function (ButtonType) {
    ButtonType[ButtonType["normal"] = 0] = "normal";
    ButtonType[ButtonType["primary"] = 1] = "primary";
    ButtonType[ButtonType["hero"] = 2] = "hero";
    ButtonType[ButtonType["compound"] = 3] = "compound";
    ButtonType[ButtonType["command"] = 4] = "command";
    ButtonType[ButtonType["icon"] = 5] = "icon";
    ButtonType[ButtonType["default"] = 6] = "default";
})(ButtonType || (ButtonType = {}));

const noOutline = {
    outline: 0
};
const iconStyle = {
    fontSize: FontSizes.icon,
    margin: '0 4px',
    height: '16px',
    lineHeight: '16px',
    textAlign: 'center',
    verticalAlign: 'middle',
    flexShrink: 0
};
/**
 * Gets the base button styles. Note: because it is a base class to be used with the `mergeRules`
 * helper, it should have values for all class names in the interface. This let `mergeRules` optimize
 * mixing class names together.
 */
const getStyles$d = memoizeFunction((theme) => {
    const { semanticColors } = theme;
    const border = semanticColors.buttonBorder;
    const disabledBackground = semanticColors.disabledBackground;
    const disabledText = semanticColors.disabledText;
    const buttonHighContrastFocus = {
        left: -2,
        top: -2,
        bottom: -2,
        right: -2,
        border: 'none',
        outlineColor: 'ButtonText'
    };
    return {
        root: [
            getFocusStyle(theme, -1, 'relative', buttonHighContrastFocus),
            theme.fonts.medium,
            {
                boxSizing: 'border-box',
                border: '1px solid ' + border,
                userSelect: 'none',
                display: 'inline-block',
                textDecoration: 'none',
                textAlign: 'center',
                cursor: 'pointer',
                verticalAlign: 'top',
                padding: '0 16px',
                borderRadius: 0,
                selectors: {
                    // IE11 workaround for preventing shift of child elements of a button when active.
                    ':active > *': {
                        position: 'relative',
                        left: 0,
                        top: 0
                    }
                }
            }
        ],
        rootDisabled: [
            getFocusStyle(theme, -1, 'relative', buttonHighContrastFocus),
            {
                backgroundColor: disabledBackground,
                color: disabledText,
                cursor: 'default',
                pointerEvents: 'none',
                selectors: {
                    ':hover': noOutline,
                    ':focus': noOutline,
                    [HighContrastSelector]: {
                        color: 'grayText',
                        bordercolor: 'grayText'
                    }
                }
            }
        ],
        iconDisabled: {
            color: disabledText
        },
        menuIconDisabled: {
            color: disabledText
        },
        flexContainer: {
            display: 'flex',
            height: '100%',
            flexWrap: 'nowrap',
            justifyContent: 'center',
            alignItems: 'center'
        },
        textContainer: {
            flexGrow: 1
        },
        icon: iconStyle,
        menuIcon: [
            iconStyle,
            {
                fontSize: FontSizes.small
            }
        ],
        label: {
            margin: '0 4px',
            lineHeight: '100%'
        },
        screenReaderText: hiddenContentStyle
    };
});

const getStyles$e = memoizeFunction((theme, customStyles) => {
    const buttonHighContrastFocus = {
        left: -2,
        top: -2,
        bottom: -2,
        right: -2,
        border: 'none'
    };
    const splitButtonStyles = {
        splitButtonContainer: [
            getFocusStyle(theme, 0, 'relative', buttonHighContrastFocus),
            {
                display: 'inline-flex'
            }
        ],
        splitButtonContainerFocused: {
            outline: 'none!important'
        },
        splitButtonMenuButton: {
            padding: 6,
            height: 'auto',
            boxSizing: 'border-box',
            border: 0,
            borderRadius: 0,
            outline: 'transparent',
            userSelect: 'none',
            display: 'inline-block',
            textDecoration: 'none',
            textAlign: 'center',
            cursor: 'pointer',
            verticalAlign: 'top',
            width: 32,
            marginLeft: -1
        },
        splitButtonDivider: {
            position: 'absolute',
            width: 1,
            right: 31,
            top: 8,
            bottom: 8
        },
        splitButtonMenuButtonDisabled: {
            pointerEvents: 'none',
            selectors: {
                ':hover': {
                    cursor: 'default'
                }
            }
        },
        splitButtonFlexContainer: {
            display: 'flex',
            height: '100%',
            flexWrap: 'nowrap',
            justifyContent: 'center',
            alignItems: 'center'
        },
        splitButtonContainerDisabled: {
            outline: 'none',
            border: 'none'
        }
    };
    return concatStyleSets(splitButtonStyles, customStyles);
});

function standardStyles(theme) {
    const s = theme.semanticColors;
    const buttonBackground = s.buttonBackground;
    const buttonBackgroundChecked = s.buttonBackgroundChecked;
    const buttonBackgroundHovered = s.buttonBackgroundHovered;
    const buttonText = s.buttonText;
    const buttonTextHovered = s.buttonTextHovered;
    const buttonTextChecked = s.buttonTextChecked;
    const buttonTextCheckedHovered = s.buttonTextCheckedHovered;
    return {
        root: {
            backgroundColor: buttonBackground,
            color: buttonText
        },
        rootHovered: {
            backgroundColor: buttonBackgroundHovered,
            color: buttonTextHovered,
            selectors: {
                [HighContrastSelector]: {
                    borderColor: 'Highlight',
                    color: 'Highlight'
                }
            }
        },
        rootPressed: {
            backgroundColor: buttonBackgroundChecked,
            color: buttonTextChecked
        },
        rootExpanded: {
            backgroundColor: buttonBackgroundChecked,
            color: buttonTextChecked
        },
        rootChecked: {
            backgroundColor: buttonBackgroundChecked,
            color: buttonTextChecked
        },
        rootCheckedHovered: {
            backgroundColor: theme.palette.neutralLight,
            color: buttonTextCheckedHovered
        },
        // Split button styles
        splitButtonContainer: {
            selectors: {
                [HighContrastSelector]: {
                    border: 'none'
                }
            }
        },
        splitButtonMenuButton: {
            color: theme.palette.white,
            backgroundColor: theme.palette.neutralLighter,
            selectors: {
                ':hover': {
                    backgroundColor: theme.palette.neutralLight,
                    selectors: {
                        [HighContrastSelector]: {
                            color: 'Highlight'
                        }
                    }
                }
            }
        },
        splitButtonMenuButtonDisabled: {
            backgroundColor: theme.palette.neutralLighter,
            selectors: {
                ':hover': {
                    backgroundColor: theme.palette.neutralLighter
                }
            }
        },
        splitButtonDivider: {
            backgroundColor: theme.palette.neutralTertiaryAlt
        },
        splitButtonMenuButtonChecked: {
            backgroundColor: theme.palette.themePrimary
        },
        splitButtonMenuButtonExpanded: {
            backgroundColor: theme.palette.neutralLight
        },
        splitButtonMenuIcon: {
            color: theme.palette.neutralPrimary
        },
        splitButtonMenuIconDisabled: {
            color: theme.palette.neutralTertiary
        }
    };
}
function primaryStyles(theme) {
    return {
        root: {
            backgroundColor: theme.palette.themePrimary,
            color: theme.palette.white,
            selectors: {
                [HighContrastSelector]: {
                    color: 'Window',
                    backgroundColor: 'WindowText',
                    MsHighContrastAdjust: 'none'
                }
            }
        },
        rootHovered: {
            backgroundColor: theme.palette.themeDarkAlt,
            color: theme.palette.white,
            selectors: {
                [HighContrastSelector]: {
                    color: 'Window',
                    backgroundColor: 'Highlight'
                }
            }
        },
        rootPressed: {
            backgroundColor: theme.palette.themeDark,
            color: theme.palette.white,
            selectors: {
                [HighContrastSelector]: {
                    color: 'Window',
                    backgroundColor: 'WindowText',
                    MsHighContrastAdjust: 'none'
                }
            }
        },
        rootExpanded: {
            backgroundColor: theme.palette.themeDark,
            color: theme.palette.white
        },
        rootChecked: {
            backgroundColor: theme.palette.themeDark,
            color: theme.palette.white
        },
        rootCheckedHovered: {
            backgroundColor: theme.palette.themePrimary,
            color: theme.palette.white
        },
        rootDisabled: {
            selectors: {
                [HighContrastSelector]: {
                    color: 'GrayText',
                    borderColor: 'GrayText',
                    backgroundColor: 'Window'
                }
            }
        },
        // Split button styles
        splitButtonContainer: {
            selectors: {
                [HighContrastSelector]: {
                    border: 'none'
                }
            }
        },
        splitButtonDivider: {
            backgroundColor: theme.palette.themeLighter
        },
        splitButtonMenuButton: {
            backgroundColor: theme.palette.themePrimary,
            color: theme.palette.white,
            selectors: {
                ':hover': {
                    backgroundColor: theme.palette.themeDark,
                    selectors: {
                        [HighContrastSelector]: {
                            color: 'Highlight'
                        }
                    }
                }
            }
        },
        splitButtonMenuButtonDisabled: {
            backgroundColor: theme.palette.neutralLighter,
            selectors: {
                ':hover': {
                    backgroundColor: theme.palette.neutralLighter
                }
            }
        },
        splitButtonMenuButtonChecked: {
            backgroundColor: theme.palette.themeDark
        },
        splitButtonMenuButtonExpanded: {
            backgroundColor: theme.palette.themeDark
        },
        splitButtonMenuIcon: {
            color: theme.palette.white
        },
        splitButtonMenuIconDisabled: {
            color: theme.palette.neutralTertiary
        }
    };
}

const DEFAULT_BUTTON_HEIGHT = '32px';
const DEFAULT_BUTTON_MINWIDTH = '80px';
const getStyles$f = memoizeFunction((theme, customStyles, primary) => {
    const baseButtonStyles = getStyles$d(theme);
    const splitButtonStyles = getStyles$e(theme);
    const defaultButtonStyles = {
        root: {
            minWidth: DEFAULT_BUTTON_MINWIDTH,
            height: DEFAULT_BUTTON_HEIGHT
        },
        label: {
            fontWeight: FontWeights.semibold
        }
    };
    return concatStyleSets(baseButtonStyles, defaultButtonStyles, primary ? primaryStyles(theme) : standardStyles(theme), splitButtonStyles, customStyles);
});

let DefaultButton = class DefaultButton extends BaseComponent {
    constructor() {
        super(...arguments);
        /**
         * Tell BaseComponent to bypass resolution of componentRef.
         */
        this._skipComponentRefResolution = true;
    }
    render() {
        const { primary = false, styles, theme } = this.props;
        return (createElement(BaseButton, Object.assign({}, this.props, { variantClassName: primary ? 'ms-Button--primary' : 'ms-Button--default', styles: getStyles$f(theme, styles, primary), onRenderDescription: nullRender })));
    }
};
DefaultButton = __decorate([
    customizable('DefaultButton', ['theme', 'styles'], true)
], DefaultButton);

const DEFAULT_BUTTON_HEIGHT$1 = '40px';
const DEFAULT_PADDING = '0 4px';
const getStyles$g = memoizeFunction((theme, customStyles) => {
    const baseButtonStyles = getStyles$d(theme);
    const actionButtonStyles = {
        root: {
            padding: DEFAULT_PADDING,
            height: DEFAULT_BUTTON_HEIGHT$1,
            color: theme.palette.neutralPrimary,
            backgroundColor: 'transparent',
            border: 'none'
        },
        rootHovered: {
            color: theme.palette.themePrimary,
            selectors: {
                [HighContrastSelector]: {
                    borderColor: 'Highlight',
                    color: 'Highlight'
                }
            }
        },
        iconHovered: {
            color: theme.palette.themePrimary
        },
        rootPressed: {
            color: theme.palette.black
        },
        rootExpanded: {
            color: theme.palette.themePrimary
        },
        iconPressed: {
            color: theme.palette.themeDarker
        },
        rootDisabled: {
            color: theme.palette.neutralTertiary,
            backgroundColor: 'transparent'
        },
        rootChecked: {
            color: theme.palette.black
        },
        iconChecked: {
            color: theme.palette.themeDarker
        },
        flexContainer: {
            justifyContent: 'flex-start'
        },
        icon: {
            color: theme.palette.themeDarkAlt
        },
        iconDisabled: {
            color: 'inherit'
        },
        menuIcon: {
            color: theme.palette.neutralSecondary
        },
        textContainer: {
            flexGrow: 0
        }
    };
    return concatStyleSets(baseButtonStyles, actionButtonStyles, customStyles);
});

let ActionButton = class ActionButton extends BaseComponent {
    constructor() {
        super(...arguments);
        /**
         * Tell BaseComponent to bypass resolution of componentRef.
         */
        this._skipComponentRefResolution = true;
    }
    render() {
        const { styles, theme } = this.props;
        return (createElement(BaseButton, Object.assign({}, this.props, { variantClassName: "ms-Button--action ms-Button--command", styles: getStyles$g(theme, styles), onRenderDescription: nullRender })));
    }
};
ActionButton = __decorate([
    customizable('ActionButton', ['theme', 'styles'], true)
], ActionButton);

const getStyles$h = memoizeFunction((theme, customStyles, primary) => {
    const baseButtonStyles = getStyles$d(theme);
    const splitButtonStyles = getStyles$e(theme);
    const compoundButtonStyles = {
        root: {
            maxWidth: '280px',
            minHeight: '72px',
            height: 'auto',
            padding: '20px'
        },
        flexContainer: {
            flexDirection: 'row',
            alignItems: 'flex-start',
            minWidth: '100%',
            margin: ''
        },
        textContainer: {
            textAlign: 'left'
        },
        icon: {
            fontSize: '2em',
            lineHeight: '1em',
            height: '1em',
            margin: '0px 8px 0px 0px',
            flexBasis: '1em',
            flexShrink: '0'
        },
        label: {
            margin: '0 0 5px',
            lineHeight: '100%',
            fontWeight: FontWeights.semibold
        },
        description: [
            theme.fonts.small,
            {
                lineHeight: '100%'
            }
        ]
    };
    const standardCompoundTheme = {
        description: {
            color: theme.palette.neutralSecondary
        },
        descriptionHovered: {
            color: theme.palette.neutralDark
        },
        descriptionPressed: {
            color: 'inherit'
        },
        descriptionChecked: {
            color: 'inherit'
        },
        descriptionDisabled: {
            color: 'inherit'
        }
    };
    const primaryCompoundTheme = {
        description: {
            color: theme.palette.white,
            selectors: {
                [HighContrastSelector]: {
                    color: 'Window',
                    backgroundColor: 'WindowText',
                    MsHighContrastAdjust: 'none'
                }
            }
        },
        descriptionHovered: {
            color: theme.palette.white,
            selectors: {
                [HighContrastSelector]: {
                    color: 'Window',
                    backgroundColor: 'Highlight',
                    MsHighContrastAdjust: 'none'
                }
            }
        },
        descriptionPressed: {
            color: 'inherit'
        },
        descriptionChecked: {
            color: 'inherit'
        },
        descriptionDisabled: {
            color: 'inherit',
            selectors: {
                [HighContrastSelector]: {
                    color: 'inherit'
                }
            }
        }
    };
    return concatStyleSets(baseButtonStyles, compoundButtonStyles, primary ? primaryStyles(theme) : standardStyles(theme), primary ? primaryCompoundTheme : standardCompoundTheme, splitButtonStyles, customStyles);
});

let CompoundButton = class CompoundButton extends BaseComponent {
    constructor() {
        super(...arguments);
        /**
         * Tell BaseComponent to bypass resolution of componentRef.
         */
        this._skipComponentRefResolution = true;
    }
    render() {
        const { primary = false, styles, theme } = this.props;
        return (createElement(BaseButton, Object.assign({}, this.props, { variantClassName: primary ? 'ms-Button--compoundPrimary' : 'ms-Button--compound', styles: getStyles$h(theme, styles, primary) })));
    }
};
CompoundButton = __decorate([
    customizable('CompoundButton', ['theme', 'styles'], true)
], CompoundButton);

const getStyles$i = memoizeFunction((theme, customStyles) => {
    const baseButtonStyles = getStyles$d(theme);
    const splitButtonStyles = getStyles$e(theme);
    const { palette, semanticColors } = theme;
    const iconButtonStyles = {
        root: {
            padding: '0 4px',
            width: '32px',
            height: '32px',
            backgroundColor: 'transparent',
            border: 'none',
            color: semanticColors.actionLink
        },
        rootHovered: {
            color: semanticColors.actionLinkHovered,
            selectors: {
                [HighContrastSelector]: {
                    borderColor: 'Highlight',
                    color: 'Highlight'
                }
            }
        },
        rootPressed: {
            color: palette.themePrimary
        },
        rootExpanded: {
            color: palette.themePrimary
        },
        rootChecked: {
            backgroundColor: semanticColors.buttonBackgroundChecked
        },
        rootCheckedHovered: {
            backgroundColor: semanticColors.buttonBackgroundHovered
        },
        rootDisabled: {
            color: semanticColors.disabledText
        }
    };
    return concatStyleSets(baseButtonStyles, iconButtonStyles, splitButtonStyles, customStyles);
});

let IconButton = class IconButton extends BaseComponent {
    constructor() {
        super(...arguments);
        /**
         * Tell BaseComponent to bypass resolution of componentRef.
         */
        this._skipComponentRefResolution = true;
    }
    render() {
        const { styles, theme } = this.props;
        return (createElement(BaseButton, Object.assign({}, this.props, { variantClassName: "ms-Button--icon", styles: getStyles$i(theme, styles), onRenderText: nullRender, onRenderDescription: nullRender })));
    }
};
IconButton = __decorate([
    customizable('IconButton', ['theme', 'styles'], true)
], IconButton);

let PrimaryButton = class PrimaryButton extends BaseComponent {
    constructor() {
        super(...arguments);
        /**
         * Set this BaseComponent._skipComponentRefResolution to true, bypassing resolution of componentRef.
         */
        this._skipComponentRefResolution = true;
    }
    render() {
        return createElement(DefaultButton, Object.assign({}, this.props, { primary: true, onRenderDescription: nullRender }));
    }
};
PrimaryButton = __decorate([
    customizable('PrimaryButton', ['theme', 'styles'], true)
], PrimaryButton);

/**
 * This class is deprecated. Use the individual *Button components instead.
 * @deprecated Use the individual *Button components instead.
 */
class Button extends BaseComponent {
    constructor(props) {
        super(props);
        /**
         * Set this BaseComponent._skipComponentRefResolution to true, bypassing resolution of componentRef.
         */
        this._skipComponentRefResolution = true;
        warn(`The Button component has been deprecated. Use specific variants instead. ` +
            `(PrimaryButton, DefaultButton, IconButton, ActionButton, etc.)`);
    }
    render() {
        const props = this.props;
        switch (props.buttonType) {
            case ButtonType.command:
                return createElement(ActionButton, Object.assign({}, props));
            case ButtonType.compound:
                return createElement(CompoundButton, Object.assign({}, props));
            case ButtonType.icon:
                return createElement(IconButton, Object.assign({}, props));
            case ButtonType.primary:
                return createElement(PrimaryButton, Object.assign({}, props));
            default:
                return createElement(DefaultButton, Object.assign({}, props));
        }
    }
}

const getStyles$j = memoizeFunction((theme, customStyles, focusInset, focusColor) => {
    const baseButtonStyles = getStyles$d(theme);
    const baseSplitButtonStyles = getStyles$e(theme);
    const commandButtonHighContrastFocus = {
        left: 4,
        top: 4,
        bottom: 4,
        right: 4,
        border: 'none'
    };
    const commandButtonStyles = {
        root: [
            getFocusStyle(theme, -1, 'relative', commandButtonHighContrastFocus),
            theme.fonts.medium,
            {
                minWidth: '40px',
                backgroundColor: theme.palette.neutralLighter,
                color: theme.palette.neutralPrimary,
                padding: '0 4px',
                selectors: {
                    [HighContrastSelector]: {
                        border: 'none'
                    }
                }
            }
        ],
        rootHovered: {
            backgroundColor: theme.palette.neutralLight,
            color: theme.palette.neutralDark,
            selectors: {
                [HighContrastSelector]: {
                    color: 'Highlight'
                }
            }
        },
        rootPressed: {
            backgroundColor: theme.palette.neutralQuaternaryAlt,
            color: theme.palette.black
        },
        rootChecked: {
            backgroundColor: theme.palette.neutralQuaternaryAlt,
            color: theme.palette.black
        },
        rootExpanded: {
            backgroundColor: theme.palette.neutralQuaternaryAlt,
            color: theme.palette.black
        },
        rootCheckedHovered: {
            backgroundColor: theme.palette.neutralQuaternary,
            color: theme.palette.black
        },
        // Split button styles
        splitButtonContainer: {
            selectors: {
                [HighContrastSelector]: {
                    border: 'none'
                }
            }
        },
        splitButtonDivider: {
            backgroundColor: theme.palette.neutralTertiaryAlt,
            marginTop: 4,
            marginBottom: 4
        },
        splitButtonMenuButton: {
            backgroundColor: theme.palette.neutralLighter,
            color: theme.palette.neutralPrimary,
            selectors: {
                ':hover': {
                    backgroundColor: theme.palette.neutralLight,
                    color: theme.palette.neutralDark,
                    selectors: {
                        [HighContrastSelector]: {
                            color: 'Highlight'
                        }
                    }
                }
            }
        },
        splitButtonMenuButtonDisabled: {
            backgroundColor: theme.palette.neutralLighter,
            selectors: {
                ':hover': {
                    backgroundColor: theme.palette.neutralLighter
                }
            }
        },
        splitButtonMenuButtonChecked: {
            backgroundColor: theme.palette.neutralQuaternaryAlt,
            color: theme.palette.black,
            selectors: {
                ':hover': {
                    backgroundColor: theme.palette.neutralQuaternaryAlt
                }
            }
        },
        splitButtonMenuButtonExpanded: {
            backgroundColor: theme.palette.neutralQuaternaryAlt,
            color: theme.palette.black,
            selectors: {
                ':hover': {
                    backgroundColor: theme.palette.neutralQuaternaryAlt
                }
            }
        },
        splitButtonMenuIcon: {
            color: theme.palette.neutralPrimary
        },
        splitButtonMenuIconDisabled: {
            color: theme.palette.neutralTertiary
        },
        label: {
            fontWeight: 'normal' // theme.fontWeights.semibold,
        },
        icon: {
            color: theme.palette.themeDarkAlt
        },
        menuIcon: {
            color: theme.palette.neutralSecondary
        }
    };
    return concatStyleSets(baseButtonStyles, commandButtonStyles, baseSplitButtonStyles, customStyles);
});

let CommandBarButton = class CommandBarButton extends BaseComponent {
    constructor() {
        super(...arguments);
        /**
         * Tell BaseComponent to bypass resolution of componentRef.
         */
        this._skipComponentRefResolution = true;
    }
    render() {
        const { styles, theme } = this.props;
        return (createElement(BaseButton, Object.assign({}, this.props, { variantClassName: "ms-Button--commandBar", styles: getStyles$j(theme, styles), onRenderDescription: nullRender })));
    }
};
CommandBarButton = __decorate([
    customizable('CommandBarButton', ['theme', 'styles'], true)
], CommandBarButton);

const CommandButton = ActionButton;

const getStyles$k = memoizeFunction((theme, customStyles, focusInset, focusColor) => {
    const baseButtonStyles = getStyles$d(theme);
    const messageBarButtonStyles = {
        root: {
            backgroundColor: theme.palette.neutralQuaternaryAlt,
            color: theme.palette.neutralPrimary
        },
        rootHovered: {
            backgroundColor: theme.palette.neutralTertiaryAlt,
            color: theme.palette.neutralDark
        },
        rootPressed: {
            backgroundColor: theme.palette.neutralTertiary,
            color: theme.palette.neutralDark
        }
    };
    return concatStyleSets(baseButtonStyles, messageBarButtonStyles, customStyles);
});

let MessageBarButton = class MessageBarButton extends BaseComponent {
    render() {
        const { styles, theme } = this.props;
        return createElement(DefaultButton, Object.assign({}, this.props, { styles: getStyles$k(theme, styles), onRenderDescription: nullRender }));
    }
};
MessageBarButton = __decorate([
    customizable('MessageBarButton', ['theme', 'styles'], true)
], MessageBarButton);

const RESIZE_DELAY = 16;
/**
 * Returns a simple object is able to store measurements with a given key.
 */
const getMeasurementCache = () => {
    const measurementsCache = {};
    return {
        /**
         * Checks if the provided data has a cacheKey. If it has a cacheKey and there is a
         * corresponding entry in the measurementsCache, then it will return that value.
         * Returns undefined otherwise.
         */
        getCachedMeasurement: (data) => {
            if (data && data.cacheKey && measurementsCache.hasOwnProperty(data.cacheKey)) {
                return measurementsCache[data.cacheKey];
            }
            return undefined;
        },
        /**
         * Should be called whenever there is a new measurement associated with a given data object.
         * If the data has a cacheKey, store that measurement in the measurementsCache.
         */
        addMeasurementToCache: (data, measurement) => {
            if (data.cacheKey) {
                measurementsCache[data.cacheKey] = measurement;
            }
        }
    };
};
/**
 * Returns a function that is able to compute the next state for the ResizeGroup given the current
 * state and any measurement updates.
 */
const getNextResizeGroupStateProvider = (measurementCache = getMeasurementCache()) => {
    const _measurementCache = measurementCache;
    let _containerWidth;
    /**
     * Gets the width of the data rendered in a hidden div.
     * @param measuredData - The data corresponding to the measurement we wish to take.
     * @param getElementToMeasureWidth - A function that returns the measurement of the rendered data. Only called when the measurement
     * is not in the cache.
     */
    function _getMeasuredWidth(measuredData, getElementToMeasureWidth) {
        const cachedWidth = _measurementCache.getCachedMeasurement(measuredData);
        if (cachedWidth !== undefined) {
            return cachedWidth;
        }
        const measuredWidth = getElementToMeasureWidth();
        _measurementCache.addMeasurementToCache(measuredData, measuredWidth);
        return measuredWidth;
    }
    /**
     * Will get the next IResizeGroupState based on the current data while trying to shrink contents
     * to fit in the container.
     * @param data - The initial data point to start measuring.
     * @param onReduceData - Function that transforms the data into something that should render with less width.
     * @param getElementToMeasureWidth - A function that returns the measurement of the rendered data. Only called when the measurement
     * is not in the cache.
     */
    function _shrinkContentsUntilTheyFit(data, onReduceData, getElementToMeasureWidth) {
        let dataToMeasure = data;
        let measuredWidth = _getMeasuredWidth(data, getElementToMeasureWidth);
        while (measuredWidth > _containerWidth) {
            const nextMeasuredData = onReduceData(dataToMeasure);
            // We don't want to get stuck in an infinite render loop when there are no more
            // scaling steps, so implementations of onReduceData should return undefined when
            // there are no more scaling states to apply.
            if (nextMeasuredData === undefined) {
                return {
                    renderedData: dataToMeasure,
                    resizeDirection: undefined,
                    dataToMeasure: undefined
                };
            }
            measuredWidth = _measurementCache.getCachedMeasurement(nextMeasuredData);
            // If the measurement isn't in the cache, we need to rerender with some data in a hidden div
            if (measuredWidth === undefined) {
                return {
                    dataToMeasure: nextMeasuredData,
                    resizeDirection: 'shrink'
                };
            }
            dataToMeasure = nextMeasuredData;
        }
        return {
            renderedData: dataToMeasure,
            resizeDirection: undefined,
            dataToMeasure: undefined
        };
    }
    /**
     * This function should be called when the state changes in a manner that might allow for more content to fit
     * on the screen, such as the window width growing.
     * @param data - The initial data point to start measuring.
     * @param onGrowData - Function that transforms the data into something that may take up more space when rendering.
     * @param getElementToMeasureWidth - A function that returns the measurement of the rendered data. Only called when the measurement
     * is not in the cache.
     */
    function _growDataUntilItDoesNotFit(data, onGrowData, getElementToMeasureWidth, onReduceData) {
        let dataToMeasure = data;
        let measuredWidth = _getMeasuredWidth(data, getElementToMeasureWidth);
        while (measuredWidth < _containerWidth) {
            const nextMeasuredData = onGrowData(dataToMeasure);
            // We don't want to get stuck in an infinite render loop when there are no more
            // scaling steps, so implementations of onGrowData should return undefined when
            // there are no more scaling states to apply.
            if (nextMeasuredData === undefined) {
                return {
                    renderedData: dataToMeasure,
                    resizeDirection: undefined,
                    dataToMeasure: undefined
                };
            }
            measuredWidth = _measurementCache.getCachedMeasurement(nextMeasuredData);
            // If the measurement isn't in the cache, we need to rerender with some data in a hidden div
            if (measuredWidth === undefined) {
                return {
                    dataToMeasure: nextMeasuredData
                };
            }
            dataToMeasure = nextMeasuredData;
        }
        // Once the loop is done, we should now shrink until the contents fit.
        return {
            resizeDirection: 'shrink',
            ..._shrinkContentsUntilTheyFit(dataToMeasure, onReduceData, getElementToMeasureWidth)
        };
    }
    /**
     * Handles an update to the container width. Should only be called when we knew the previous container width.
     * @param newWidth - The new width of the container.
     * @param fullWidthData - The initial data passed in as a prop to resizeGroup.
     * @param renderedData - The data that was rendered prior to the container size changing.
     * @param onGrowData - Set to true if the Resize group has an onGrowData function.
     */
    function _updateContainerWidth(newWidth, fullWidthData, renderedData, onGrowData) {
        let nextState;
        if (newWidth > _containerWidth) {
            if (onGrowData) {
                nextState = {
                    resizeDirection: 'grow',
                    dataToMeasure: onGrowData(renderedData)
                };
            }
            else {
                nextState = {
                    resizeDirection: 'shrink',
                    dataToMeasure: fullWidthData
                };
            }
        }
        else {
            nextState = {
                resizeDirection: 'shrink',
                dataToMeasure: renderedData
            };
        }
        _containerWidth = newWidth;
        return { ...nextState, measureContainer: false };
    }
    function getNextState(props, currentState, getElementToMeasureWidth, newContainerWidth) {
        // If there is no new container width or data to measure, there is no need for a new state update
        if (newContainerWidth === undefined && currentState.dataToMeasure === undefined) {
            return undefined;
        }
        if (newContainerWidth) {
            // If we know what the last container size was and we rendered data at that width, we can do an optimized render
            if (_containerWidth && currentState.renderedData && !currentState.dataToMeasure) {
                return {
                    ...currentState,
                    ..._updateContainerWidth(newContainerWidth, props.data, currentState.renderedData, props.onGrowData)
                };
            }
            // If we are just setting the container width for the first time, we can't do any optimizations
            _containerWidth = newContainerWidth;
        }
        let nextState = {
            ...currentState,
            measureContainer: false
        };
        if (currentState.dataToMeasure) {
            if (currentState.resizeDirection === 'grow' && props.onGrowData) {
                nextState = {
                    ...nextState,
                    ..._growDataUntilItDoesNotFit(currentState.dataToMeasure, props.onGrowData, getElementToMeasureWidth, props.onReduceData)
                };
            }
            else {
                nextState = {
                    ...nextState,
                    ..._shrinkContentsUntilTheyFit(currentState.dataToMeasure, props.onReduceData, getElementToMeasureWidth)
                };
            }
        }
        return nextState;
    }
    /** Function that determines if we need to render content for measurement based on the measurement cache contents. */
    function shouldRenderDataForMeasurement(dataToMeasure) {
        if (!dataToMeasure || _measurementCache.getCachedMeasurement(dataToMeasure) !== undefined) {
            return false;
        }
        return true;
    }
    function getInitialResizeGroupState(data) {
        return {
            dataToMeasure: { ...data },
            resizeDirection: 'grow',
            measureContainer: true
        };
    }
    return {
        getNextState,
        shouldRenderDataForMeasurement,
        getInitialResizeGroupState
    };
};
// Provides a context property that (if true) tells any child components that
// they are only being used for measurement purposes and will not be visible.
const MeasuredContext = provideContext({
    isMeasured: bool
}, () => {
    return { isMeasured: true };
});
// Styles for the hidden div used for measurement
const hiddenDivStyles = { position: 'fixed', visibility: 'hidden' };
const hiddenParentStyles = { position: 'relative' };
class ResizeGroupBase extends BaseComponent {
    constructor(props) {
        super(props);
        this._nextResizeGroupStateProvider = getNextResizeGroupStateProvider();
        // The root div which is the container inside of which we are trying to fit content.
        this._root = createRef();
        // A div that can be used for the initial measurement so that we can avoid mounting a second instance
        // of the component being measured for the initial render.
        this._initialHiddenDiv = createRef();
        // A hidden div that is used for mounting a new instance of the component for measurement in a hidden
        // div without unmounting the currently visible content.
        this._updateHiddenDiv = createRef();
        // Tracks if any content has been rendered to the user. This enables us to do some performance optimizations
        // for the initial render.
        this._hasRenderedContent = false;
        this.state = this._nextResizeGroupStateProvider.getInitialResizeGroupState(this.props.data);
        this._warnDeprecations({
            styles: 'className'
        });
    }
    render() {
        const { className, onRenderData } = this.props;
        const { dataToMeasure, renderedData } = this.state;
        const divProps = getNativeProps(this.props, divProperties, ['data']);
        const dataNeedsMeasuring = this._nextResizeGroupStateProvider.shouldRenderDataForMeasurement(dataToMeasure);
        const isInitialMeasure = !this._hasRenderedContent && dataNeedsMeasuring;
        // We only ever render the final content to the user. All measurements are done in a hidden div.
        // For the initial render, we want this to be as fast as possible, so we need to make sure that we only mount one version of the
        // component for measurement and the final render. For renders that update what is on screen, we want to make sure that
        // there are no jarring effects such as the screen flashing as we apply scaling steps for meassurement. In the update case,
        // we mount a second version of the component just for measurement purposes and leave the rendered content untouched until we know the
        // next state sto show to the user.
        return (createElement("div", Object.assign({}, divProps, { className: className, ref: this._root }),
            createElement("div", { style: hiddenParentStyles },
                dataNeedsMeasuring && !isInitialMeasure && (createElement("div", { style: hiddenDivStyles, ref: this._updateHiddenDiv },
                    createElement(MeasuredContext, null, onRenderData(dataToMeasure)))),
                createElement("div", { ref: this._initialHiddenDiv, style: isInitialMeasure ? hiddenDivStyles : undefined, "data-automation-id": "visibleContent" }, isInitialMeasure ? onRenderData(dataToMeasure) : renderedData && onRenderData(renderedData)))));
    }
    componentDidMount() {
        this._afterComponentRendered();
        this._events.on(window, 'resize', this._async.debounce(this._onResize, RESIZE_DELAY, { leading: true }));
    }
    componentWillReceiveProps(nextProps) {
        this.setState({
            dataToMeasure: { ...nextProps.data },
            resizeDirection: 'grow',
            measureContainer: true // Receiving new props means the parent might rerender and the root width might change
        });
    }
    componentDidUpdate(prevProps) {
        if (this.state.renderedData) {
            this._hasRenderedContent = true;
            if (this.props.dataDidRender) {
                this.props.dataDidRender(this.state.renderedData);
            }
        }
        this._afterComponentRendered();
    }
    remeasure() {
        if (this._root.current) {
            this.setState({ measureContainer: true });
        }
    }
    _afterComponentRendered() {
        this._async.requestAnimationFrame(() => {
            let containerWidth = undefined;
            if (this.state.measureContainer && this._root.current) {
                containerWidth = this._root.current.getBoundingClientRect().width;
            }
            const nextState = this._nextResizeGroupStateProvider.getNextState(this.props, this.state, () => {
                const refToMeasure = !this._hasRenderedContent ? this._initialHiddenDiv : this._updateHiddenDiv;
                return refToMeasure.current ? refToMeasure.current.scrollWidth : 0;
            }, containerWidth);
            if (nextState) {
                this.setState(nextState);
            }
        });
    }
    _onResize() {
        if (this._root.current) {
            this.setState({ measureContainer: true });
        }
    }
}

const ResizeGroup = ResizeGroupBase;

const getClassNames$e = classNamesFunction();
const OVERFLOW_KEY = 'overflow';
const nullFunction = () => null;
class BreadcrumbBase extends BaseComponent {
    constructor(props) {
        super(props);
        this._focusZone = createRef();
        this._onReduceData = (data) => {
            let { renderedItems, renderedOverflowItems } = data;
            const { overflowIndex } = data.props;
            const movedItem = renderedItems[overflowIndex];
            renderedItems = [...renderedItems];
            renderedItems.splice(overflowIndex, 1);
            renderedOverflowItems = [...renderedOverflowItems, movedItem];
            if (movedItem !== undefined) {
                return { ...data, renderedItems, renderedOverflowItems };
            }
        };
        this._onRenderBreadcrumb = (data) => {
            const { ariaLabel, dividerAs: DividerType = Icon, onRenderItem = this._onRenderItem, overflowAriaLabel, overflowIndex } = data.props;
            const { renderedOverflowItems, renderedItems } = data;
            const contextualItems = renderedOverflowItems.map((item, index) => ({
                name: item.text,
                key: item.key,
                onClick: item.onClick ? this._onBreadcrumbClicked.bind(this, item) : null,
                href: item.href
            }));
            // Find index of last rendered item so the divider icon
            // knows not to render on that item
            const lastItemIndex = renderedItems.length - 1;
            const hasOverflowItems = renderedOverflowItems && renderedOverflowItems.length !== 0;
            const itemElements = renderedItems.map((item, index) => (createElement("li", { className: this._classNames.listItem, key: item.key || String(index) },
                onRenderItem(item, this._onRenderItem),
                (index !== lastItemIndex || (hasOverflowItems && index === overflowIndex - 1)) && (
                //@ts-ignore
                createElement(DividerType, { className: this._classNames.chevron, iconName: getRTL() ? 'ChevronLeft' : 'ChevronRight', item: item })))));
            if (hasOverflowItems) {
                itemElements.splice(overflowIndex, 0, createElement("li", { className: this._classNames.overflow, key: OVERFLOW_KEY },
                    createElement(IconButton, { className: this._classNames.overflowButton, iconProps: { iconName: 'More' }, role: "button", "aria-haspopup": "true", ariaLabel: overflowAriaLabel, onRenderMenuIcon: nullFunction, menuProps: {
                            items: contextualItems,
                            directionalHint: DirectionalHint.bottomLeftEdge
                        } }),
                    overflowIndex !== lastItemIndex + 1 && (
                    //@ts-ignore
                    createElement(DividerType, { className: this._classNames.chevron, iconName: getRTL() ? 'ChevronLeft' : 'ChevronRight', item: renderedOverflowItems[renderedOverflowItems.length - 1] }))));
            }
            return (createElement("div", { className: this._classNames.root, role: "navigation", "aria-label": ariaLabel },
                createElement(FocusZone, { componentRef: this._focusZone, direction: FocusZoneDirection.horizontal },
                    createElement("ol", { className: this._classNames.list }, itemElements))));
        };
        this._onRenderItem = (item) => {
            if (item.onClick || item.href) {
                return (createElement(Link, { className: this._classNames.itemLink, href: item.href, "aria-current": item.isCurrentItem ? 'page' : undefined, onClick: this._onBreadcrumbClicked.bind(this, item) },
                    createElement(TooltipHost, { content: item.text, overflowMode: TooltipOverflowMode.Parent }, item.text)));
            }
            else {
                return (createElement("span", { className: this._classNames.item },
                    createElement(TooltipHost, { content: item.text, overflowMode: TooltipOverflowMode.Parent }, item.text)));
            }
        };
        this._onBreadcrumbClicked = (item, ev) => {
            if (item.onClick) {
                item.onClick(ev, item);
            }
        };
        this._validateProps(props);
    }
    /**
     * Sets focus to the first breadcrumb link.
     */
    focus() {
        if (this._focusZone.current) {
            this._focusZone.current.focus();
        }
    }
    render() {
        const { onReduceData = this._onReduceData, overflowIndex, maxDisplayedItems, items, className, theme, styles } = this.props;
        const renderedItems = [...items];
        const renderedOverflowItems = renderedItems.splice(overflowIndex, renderedItems.length - maxDisplayedItems);
        const breadCrumbData = {
            props: this.props,
            renderedItems,
            renderedOverflowItems
        };
        this._classNames = getClassNames$e(styles, {
            className,
            theme: theme
        });
        return createElement(ResizeGroup, { onRenderData: this._onRenderBreadcrumb, onReduceData: onReduceData, data: breadCrumbData });
    }
    componentWillReceiveProps(nextProps) {
        this._validateProps(nextProps);
    }
    /**
     * Validate incoming props
     * @param props Props to validate
     */
    _validateProps(props) {
        const { maxDisplayedItems, overflowIndex, items } = props;
        if (overflowIndex < 0 ||
            (maxDisplayedItems > 1 && overflowIndex > maxDisplayedItems - 1) ||
            (items.length > 0 && overflowIndex > items.length - 1)) {
            throw new Error('Breadcrumb: overflowIndex out of range');
        }
    }
}
BreadcrumbBase.defaultProps = {
    items: [],
    maxDisplayedItems: 999,
    overflowIndex: 0
};

const SingleLineTextStyle = {
    whiteSpace: 'nowrap',
    textOverflow: 'ellipsis',
    overflow: 'hidden'
};
const MinimumScreenSelector = getScreenSelector(0, ScreenWidthMaxSmall);
const MediumScreenSelector$2 = getScreenSelector(ScreenWidthMinMedium, ScreenWidthMaxMedium);
const getStyles$l = (props) => {
    const { className, theme } = props;
    const overflowButtonFontSize = 16;
    const itemMaxWidth = 160;
    const itemMaxWidthSmall = 116;
    const chevronSmallFontSize = 8;
    return {
        root: [
            'ms-Breadcrumb',
            theme.fonts.medium,
            {
                margin: '23px 0 1px'
            },
            className
        ],
        list: [
            'ms-Breadcrumb-list',
            {
                whiteSpace: 'nowrap',
                padding: 0,
                margin: 0,
                display: 'flex',
                alignItems: 'stretch'
            }
        ],
        listItem: [
            'ms-Breadcrumb-listItem',
            {
                listStyleType: 'none',
                margin: '0',
                padding: '0',
                display: 'flex',
                position: 'relative',
                alignItems: 'center'
            }
        ],
        chevron: [
            'ms-Breadcrumb-chevron',
            {
                color: theme.palette.neutralSecondary,
                fontSize: theme.fonts.small.fontSize,
                selectors: {
                    [HighContrastSelector]: {
                        color: 'WindowText',
                        MsHighContrastAdjust: 'none'
                    },
                    [MediumScreenSelector$2]: {
                        fontSize: chevronSmallFontSize
                    },
                    [MinimumScreenSelector]: {
                        fontSize: chevronSmallFontSize
                    }
                }
            }
        ],
        overflow: [
            'ms-Breadcrumb-overflow',
            {
                position: 'relative',
                display: 'flex',
                alignItems: 'center'
            }
        ],
        overflowButton: [
            'ms-Breadcrumb-overflowButton',
            getFocusStyle(theme),
            SingleLineTextStyle,
            {
                fontSize: overflowButtonFontSize,
                height: '100%',
                cursor: 'pointer',
                selectors: {
                    ':hover': {
                        backgroundColor: theme.palette.neutralLighter
                    },
                    ':active': {
                        backgroundColor: theme.palette.neutralTertiaryAlt,
                        color: theme.semanticColors.bodyText
                    },
                    ':hover:active': {
                        // This seems unnecessary.
                        backgroundColor: theme.palette.neutralQuaternary
                    },
                    [MinimumScreenSelector]: {
                        padding: '4px 6px'
                    },
                    [MediumScreenSelector$2]: {
                        fontSize: theme.fonts.mediumPlus.fontSize
                    }
                }
            }
        ],
        itemLink: [
            'ms-Breadcrumb-itemLink',
            getFocusStyle(theme),
            SingleLineTextStyle,
            theme.fonts.xLarge,
            {
                textDecoration: 'none',
                color: theme.semanticColors.bodyText,
                padding: '0 8px',
                maxWidth: itemMaxWidth,
                selectors: {
                    ':hover': {
                        backgroundColor: theme.semanticColors.menuItemBackgroundHovered,
                        color: 'initial',
                        cursor: 'pointer',
                        selectors: {
                            [HighContrastSelector]: {
                                color: 'Highlight'
                            }
                        }
                    },
                    ':focus': {
                        color: theme.palette.neutralDark
                    },
                    ':active': {
                        backgroundColor: theme.palette.neutralTertiaryAlt,
                        color: theme.palette.neutralPrimary
                    },
                    [MediumScreenSelector$2]: theme.fonts.large,
                    [MinimumScreenSelector]: [
                        theme.fonts.medium,
                        {
                            maxWidth: itemMaxWidthSmall
                        }
                    ]
                }
            }
        ],
        item: [
            'ms-Breadcrumb-item',
            theme.fonts.xLarge,
            {
                color: theme.semanticColors.bodyText,
                padding: '0 8px',
                maxWidth: itemMaxWidth,
                selectors: {
                    ':hover': {
                        cursor: 'default'
                    }
                }
            }
        ]
    };
};

const Breadcrumb = styled(BreadcrumbBase, getStyles$l, undefined, { scope: 'Breadcrumb' });

/**
 * The days of the week
 */
var DayOfWeek;
(function (DayOfWeek) {
    DayOfWeek[DayOfWeek["Sunday"] = 0] = "Sunday";
    DayOfWeek[DayOfWeek["Monday"] = 1] = "Monday";
    DayOfWeek[DayOfWeek["Tuesday"] = 2] = "Tuesday";
    DayOfWeek[DayOfWeek["Wednesday"] = 3] = "Wednesday";
    DayOfWeek[DayOfWeek["Thursday"] = 4] = "Thursday";
    DayOfWeek[DayOfWeek["Friday"] = 5] = "Friday";
    DayOfWeek[DayOfWeek["Saturday"] = 6] = "Saturday";
})(DayOfWeek || (DayOfWeek = {}));
/**
 * The months
 */
var MonthOfYear;
(function (MonthOfYear) {
    MonthOfYear[MonthOfYear["January"] = 0] = "January";
    MonthOfYear[MonthOfYear["February"] = 1] = "February";
    MonthOfYear[MonthOfYear["March"] = 2] = "March";
    MonthOfYear[MonthOfYear["April"] = 3] = "April";
    MonthOfYear[MonthOfYear["May"] = 4] = "May";
    MonthOfYear[MonthOfYear["June"] = 5] = "June";
    MonthOfYear[MonthOfYear["July"] = 6] = "July";
    MonthOfYear[MonthOfYear["August"] = 7] = "August";
    MonthOfYear[MonthOfYear["September"] = 8] = "September";
    MonthOfYear[MonthOfYear["October"] = 9] = "October";
    MonthOfYear[MonthOfYear["November"] = 10] = "November";
    MonthOfYear[MonthOfYear["December"] = 11] = "December";
})(MonthOfYear || (MonthOfYear = {}));
/**
 * First week of the year settings types
 */
var FirstWeekOfYear;
(function (FirstWeekOfYear) {
    FirstWeekOfYear[FirstWeekOfYear["FirstDay"] = 0] = "FirstDay";
    FirstWeekOfYear[FirstWeekOfYear["FirstFullWeek"] = 1] = "FirstFullWeek";
    FirstWeekOfYear[FirstWeekOfYear["FirstFourDayWeek"] = 2] = "FirstFourDayWeek";
})(FirstWeekOfYear || (FirstWeekOfYear = {}));
/**
 * The supported date range types
 */
var DateRangeType;
(function (DateRangeType) {
    DateRangeType[DateRangeType["Day"] = 0] = "Day";
    DateRangeType[DateRangeType["Week"] = 1] = "Week";
    DateRangeType[DateRangeType["Month"] = 2] = "Month";
    DateRangeType[DateRangeType["WorkWeek"] = 3] = "WorkWeek";
})(DateRangeType || (DateRangeType = {}));

/**
 * Common constants and methods
 */
const TimeConstants = {
    MillisecondsInOneDay: 86400000,
    MillisecondsIn1Sec: 1000,
    MillisecondsIn1Min: 60000,
    MillisecondsIn30Mins: 1800000,
    MillisecondsIn1Hour: 3600000,
    MinutesInOneDay: 1440,
    MinutesInOneHour: 60,
    DaysInOneWeek: 7,
    MonthInOneYear: 12
};

/**
 * Returns a date offset from the given date by the specified number of days.
 * @param {Date} date - The origin date
 * @param {number} days - The number of days to offset. 'days' can be negative.
 * @return {Date} A new Date object offset from the origin date by the given number of days
 */
function addDays(date, days) {
    const result = new Date(date.getTime());
    result.setDate(result.getDate() + days);
    return result;
}
/**
 * Returns a date offset from the given date by the specified number of weeks.
 * @param {Date} date - The origin date
 * @param {number} weeks - The number of weeks to offset. 'weeks' can be negative.
 * @return {Date} A new Date object offset from the origin date by the given number of weeks
 */
function addWeeks(date, weeks) {
    return addDays(date, weeks * TimeConstants.DaysInOneWeek);
}
/**
 * Returns a date offset from the given date by the specified number of months.
 * The method tries to preserve the day-of-month; however, if the new month does not have enough days
 * to contain the original day-of-month, we'll use the last day of the new month.
 * @param {Date} date - The origin date
 * @param {number} months - The number of months to offset. 'months' can be negative.
 * @return {Date} A new Date object offset from the origin date by the given number of months
 */
function addMonths(date, months) {
    let result = new Date(date.getTime());
    const newMonth = result.getMonth() + months;
    result.setMonth(newMonth);
    // We want to maintain the same day-of-month, but that may not be possible if the new month doesn't have enough days.
    // Loop until we back up to a day the new month has.
    // (Weird modulo math is due to Javascript's treatment of negative numbers in modulo)
    if (result.getMonth() !== ((newMonth % TimeConstants.MonthInOneYear) + TimeConstants.MonthInOneYear) % TimeConstants.MonthInOneYear) {
        result = addDays(result, -result.getDate());
    }
    return result;
}
/**
 * Returns a date offset from the given date by the specified number of years.
 * The method tries to preserve the day-of-month; however, if the new month does not have enough days
 * to contain the original day-of-month, we'll use the last day of the new month.
 * @param {Date} date - The origin date
 * @param {number} years - The number of years to offset. 'years' can be negative.
 * @return {Date} A new Date object offset from the origin date by the given number of years
 */
function addYears(date, years) {
    let result = new Date(date.getTime());
    result.setFullYear(date.getFullYear() + years);
    // We want to maintain the same day-of-month, but that may not be possible if the new month doesn't have enough days.
    // Loop until we back up to a day the new month has.
    // (Weird modulo math is due to Javascript's treatment of negative numbers in modulo)
    if (result.getMonth() !==
        ((date.getMonth() % TimeConstants.MonthInOneYear) + TimeConstants.MonthInOneYear) % TimeConstants.MonthInOneYear) {
        result = addDays(result, -result.getDate());
    }
    return result;
}
/**
 * Returns a date that is the first day of the month of the provided date.
 * @param {Date} date - The origin date
 * @return {Date} A new Date object with the day set to the first day of the month.
 */
function getMonthStart(date) {
    return new Date(date.getFullYear(), date.getMonth(), 1, 0, 0, 0, 0);
}
/**
 * Returns a date that is the last day of the month of the provided date.
 * @param {Date} date - The origin date
 * @return {Date} A new Date object with the day set to the last day of the month.
 */
function getMonthEnd(date) {
    return new Date(date.getFullYear(), date.getMonth() + 1, 0, 0, 0, 0, 0);
}
/**
 * Returns a date that is the first day of the year of the provided date.
 * @param {Date} date - The origin date
 * @return {Date} A new Date object with the day set to the first day of the year.
 */
function getYearStart(date) {
    return new Date(date.getFullYear(), 0, 1, 0, 0, 0, 0);
}
/**
 * Returns a date that is the last day of the year of the provided date.
 * @param {Date} date - The origin date
 * @return {Date} A new Date object with the day set to the last day of the year.
 */
function getYearEnd(date) {
    return new Date(date.getFullYear() + 1, 0, 0, 0, 0, 0, 0);
}
/**
 * Returns a date that is a copy of the given date, aside from the month changing to the given month.
 *  The method tries to preserve the day-of-month; however, if the new month does not have enough days
 * to contain the original day-of-month, we'll use the last day of the new month.
 * @param {Date} date - The origin date
 * @param {number} month - The 0-based index of the month to set on the date.
 * @return {Date} A new Date object with the given month set.
 */
function setMonth(date, month) {
    return addMonths(date, month - date.getMonth());
}
/**
 * Compares two dates, and returns true if the two dates (not accounting for time-of-day) are equal.
 * @return {boolean} True if the two dates represent the same date (regardless of time-of-day), false otherwise.
 */
function compareDates(date1, date2) {
    if (!date1 && !date2) {
        return true;
    }
    else if (!date1 || !date2) {
        return false;
    }
    else {
        return date1.getFullYear() === date2.getFullYear() && date1.getMonth() === date2.getMonth() && date1.getDate() === date2.getDate();
    }
}
/**
 * Compare the date parts of two dates
 * @param {Date} date1 - The first date to compare
 * @param {Date} date2 - The second date to compare
 * @returns {Number} A negative value if date1 is earlier than date2, 0 if the dates are equal, or a positive value
 * if date1 is later than date2.
 */
function compareDatePart(date1, date2) {
    return getDatePartHashValue(date1) - getDatePartHashValue(date2);
}
/**
 * Gets the date range array including the specified date. The date range array is calculated as the list
 * of dates accounting for the specified first day of the week and date range type.
 * @param {Date} date - The input date
 * @param {DateRangeType} dateRangeType - The desired date range type, i.e., day, week, month, etc.
 * @param {DayOfWeek} firstDayOfWeek - The first day of the week.
 * @param {DayOfWeek[]} workWeekDays - The allowed days in work week. If not provided, assumes all days are allowed.
 * @returns {Date[]} An array of dates representing the date range containing the specified date.
 */
function getDateRangeArray(date, dateRangeType, firstDayOfWeek, workWeekDays) {
    const datesArray = new Array();
    let startDate;
    let endDate = null;
    if (!workWeekDays) {
        workWeekDays = [DayOfWeek.Monday, DayOfWeek.Tuesday, DayOfWeek.Wednesday, DayOfWeek.Thursday, DayOfWeek.Friday];
    }
    switch (dateRangeType) {
        case DateRangeType.Day:
            startDate = getDatePart(date);
            endDate = addDays(startDate, 1);
            break;
        case DateRangeType.Week:
        case DateRangeType.WorkWeek:
            startDate = getStartDateOfWeek(getDatePart(date), firstDayOfWeek);
            endDate = addDays(startDate, TimeConstants.DaysInOneWeek);
            break;
        case DateRangeType.Month:
            startDate = new Date(date.getFullYear(), date.getMonth(), 1);
            endDate = addMonths(startDate, 1);
            break;
        default:
            return assertNever(dateRangeType);
    }
    // Populate the dates array with the dates in range
    let nextDate = startDate;
    do {
        if (dateRangeType !== DateRangeType.WorkWeek) {
            // push all days not in work week view
            datesArray.push(nextDate);
        }
        else if (workWeekDays.includes(nextDate.getDay())) {
            datesArray.push(nextDate);
        }
        nextDate = addDays(nextDate, 1);
    } while (!compareDates(nextDate, endDate));
    return datesArray;
}
/**
 * Checks whether the specified date is in the given date range.
 * @param {Date} date - The origin date
 * @param {Date[]} dateRange - An array of dates to do the lookup on
 * @returns {bool} True if the date matches one of the dates in the specified array, false otherwise.
 */
function isInDateRangeArray(date, dateRange) {
    for (const dateInRange of dateRange) {
        if (compareDates(date, dateInRange)) {
            return true;
        }
    }
    return false;
}
/**
 * Returns the week number for a date.
 * Week numbers are 1 - 52 (53) in a year
 * @param {navigatedDate} Date - A date to find the week number for.
 * @param {firstDayOfWeek} DayOfWeek - The first day of the week (0-6, Sunday = 0)
 * @param {firstWeekOfYear} FirstWeekOfYear - The first week of the year (1-2)
 * @return {weeksArray} The weeks number array for the current month.
 */
function getWeekNumbersInMonth(weeksInMonth, firstDayOfWeek, firstWeekOfYear, navigatedDate) {
    const selectedYear = navigatedDate.getFullYear();
    const selectedMonth = navigatedDate.getMonth();
    let dayOfMonth = 1;
    const fistDayOfMonth = new Date(selectedYear, selectedMonth, dayOfMonth);
    const endOfFirstWeek = dayOfMonth + (firstDayOfWeek + TimeConstants.DaysInOneWeek - 1) - adjustWeekDay(firstDayOfWeek, fistDayOfMonth.getDay());
    let endOfWeekRange = new Date(selectedYear, selectedMonth, endOfFirstWeek);
    dayOfMonth = endOfWeekRange.getDate();
    const weeksArray = [];
    for (let i = 0; i < weeksInMonth; i++) {
        // Get week number for end of week
        weeksArray.push(getWeekNumber(endOfWeekRange, firstDayOfWeek, firstWeekOfYear));
        dayOfMonth += TimeConstants.DaysInOneWeek;
        endOfWeekRange = new Date(selectedYear, selectedMonth, dayOfMonth);
    }
    return weeksArray;
}
/**
 * Returns the week number for a date.
 * Week numbers are 1 - 52 (53) in a year
 * @param {Date} date - A date to find the week number for.
 * @param {DayOfWeek} firstDayOfWeek - The first day of the week (0-6, Sunday = 0)
 * @param {firstWeekOfYear} firstWeekOfYear - The first week of the year (1-2)
 * @return {Number} The week's number in the year.
 */
function getWeekNumber(date, firstDayOfWeek, firstWeekOfYear) {
    // First four-day week of the year - minumum days count
    const fourDayWeek = 4;
    switch (firstWeekOfYear) {
        case FirstWeekOfYear.FirstFullWeek:
            return getWeekOfYearFullDays(date, firstDayOfWeek, TimeConstants.DaysInOneWeek);
        case FirstWeekOfYear.FirstFourDayWeek:
            return getWeekOfYearFullDays(date, firstDayOfWeek, fourDayWeek);
        default:
            return getFirstDayWeekOfYear(date, firstDayOfWeek);
    }
}
/**
 * Gets a new date with the time portion zeroed out, i.e., set to midnight
 * @param {Date} date - The origin date
 * @returns {Date} A new date with the time set to midnight
 */
function getDatePart(date) {
    return new Date(date.getFullYear(), date.getMonth(), date.getDate());
}
/**
 * Gets the date for the first day of the week based on the given date assuming
 * the specified first day of the week.
 * @param {Date} date - The date to find the beginning of the week date for.
 * @return {Date} A new date object representing the first day of the week containing the input date.
 */
function getStartDateOfWeek(date, firstDayOfWeek) {
    let daysOffset = firstDayOfWeek - date.getDay();
    if (daysOffset > 0) {
        // If first day of week is > date, go 1 week back, to ensure resulting date is in the past.
        daysOffset -= TimeConstants.DaysInOneWeek;
    }
    return addDays(date, daysOffset);
}
/**
 * Helper function to assist in date comparisons
 */
function getDatePartHashValue(date) {
    // Generate date hash value created as sum of Date (up to 31 = 5 bits), Month (up to 11 = 4 bits) and Year.
    /* tslint:disable:no-bitwise */
    return date.getDate() + (date.getMonth() << 5) + (date.getFullYear() << 9);
    /* tslint:enable:no-bitwise */
}
/**
 * Helper function for getWeekNumber.
 * Returns week number for a date
 * @param {date} Date - current selected date.
 * @param {firstDayOfWeek} DayOfWeek - The first day of week (0-6, Sunday = 0)
 * @param {numberOfFullDays} number - week settings.
 * @return {Number} The week's number in the year.
 */
function getWeekOfYearFullDays(date, firstDayOfWeek, numberOfFullDays) {
    const dayOfYear = getDayOfYear(date) - 1;
    let num = date.getDay() - (dayOfYear % TimeConstants.DaysInOneWeek);
    const lastDayOfPrevYear = new Date(date.getFullYear() - 1, MonthOfYear.December, 31);
    const daysInYear = getDayOfYear(lastDayOfPrevYear) - 1;
    let num2 = (firstDayOfWeek - num + 2 * TimeConstants.DaysInOneWeek) % TimeConstants.DaysInOneWeek;
    if (num2 !== 0 && num2 >= numberOfFullDays) {
        num2 -= TimeConstants.DaysInOneWeek;
    }
    let num3 = dayOfYear - num2;
    if (num3 < 0) {
        num -= daysInYear % TimeConstants.DaysInOneWeek;
        num2 = (firstDayOfWeek - num + 2 * TimeConstants.DaysInOneWeek) % TimeConstants.DaysInOneWeek;
        if (num2 !== 0 && num2 + 1 >= numberOfFullDays) {
            num2 -= TimeConstants.DaysInOneWeek;
        }
        num3 = daysInYear - num2;
    }
    return Math.floor(num3 / TimeConstants.DaysInOneWeek + 1);
}
/**
 * Helper function for getWeekNumber.
 * Returns week number for a date
 * @param {date} Date - current selected date.
 * @param {firstDayOfWeek} DayOfWeek - The first day of week (0-6, Sunday = 0)
 * @return {Number} The week's number in the year.
 */
function getFirstDayWeekOfYear(date, firstDayOfWeek) {
    const num = getDayOfYear(date) - 1;
    const num2 = date.getDay() - (num % TimeConstants.DaysInOneWeek);
    const num3 = (num2 - firstDayOfWeek + 2 * TimeConstants.DaysInOneWeek) % TimeConstants.DaysInOneWeek;
    return Math.floor((num + num3) / TimeConstants.DaysInOneWeek + 1);
}
/**
 * Helper function for getWeekNumber.
 * Returns adjusted week day number when firstDayOfWeek is other than Sunday
 * For Week Day Number comparison checks
 * @param {firstDayOfWeek} DayOfWeek - The first day of week (0-6, Sunday = 0)
 * @param {dateWeekDay} DayOfWeek - shifts number forward to 1 week in case passed as true
 * @return {DayOfWeek} The day of week adjusted to firstDayOfWeek. E.g. when FirstDyOfWeek is Monday (1), Sunday becomes = 7 (7 > 1).
 */
function adjustWeekDay(firstDayOfWeek, dateWeekDay) {
    return firstDayOfWeek !== DayOfWeek.Sunday && dateWeekDay < firstDayOfWeek ? dateWeekDay + TimeConstants.DaysInOneWeek : dateWeekDay;
}
/**
 * Returns the day number for a date in a year
 * The number of days since January 1st in the particular year.
 * @param {Date} date - A date to find the day number for.
 * @return {Number} The day's number in the year.
 */
function getDayOfYear(date) {
    const month = date.getMonth();
    const year = date.getFullYear();
    let daysUntilDate = 0;
    for (let i = 0; i < month; i++) {
        daysUntilDate += daysInMonth(i + 1, year);
    }
    daysUntilDate += date.getDate();
    return daysUntilDate;
}
/**
 * Returns the number of days in the month
 * @param {number} month - The month number to target (months 1-12).
 * @param {number} year - The year to target.
 * @return {Number} The number of days in the month.
 */
function daysInMonth(month, year) {
    return new Date(year, month, 0).getDate();
}

var styles;
const DAYS_IN_WEEK = 7;
class CalendarDay extends BaseComponent {
    constructor(props) {
        super(props);
        this.days = {};
        this._onKeyDown = (callback, ev) => {
            if (ev.which === KeyCodes.enter || ev.which === KeyCodes.space) {
                callback();
            }
        };
        this._onDayKeyDown = (originalDate, weekIndex, dayIndex) => {
            return (ev) => {
                if (ev.which === KeyCodes.enter) {
                    this._onSelectDate(originalDate);
                }
                else {
                    this._navigateMonthEdge(ev, originalDate, weekIndex, dayIndex);
                }
            };
        };
        this._onDayMouseDown = (originalDate, weekIndex, dayIndex, dateRangeType) => {
            return (ev) => {
                // set the press styling
                if (dateRangeType === DateRangeType.Month) {
                    this._applyFunctionToDayRefs((ref, day) => {
                        if (ref && day.originalDate.getMonth() === originalDate.getMonth() && day.isInBounds) {
                            ref.classList.add(styles.dayPress);
                        }
                    });
                }
                else {
                    // week or work week view
                    this._applyFunctionToDayRefs((ref, day, dayWeekIndex) => {
                        if (ref && dayWeekIndex === weekIndex && day.isInBounds) {
                            ref.classList.add(styles.dayPress);
                            ref.classList.add(styles.dayIsHighlighted);
                        }
                        else if (ref) {
                            ref.classList.remove(styles.dayIsHighlighted);
                        }
                    });
                }
            };
        };
        this._onDayMouseUp = (originalDate, weekIndex, dayIndex, dateRangeType) => {
            return (ev) => {
                // remove press styling
                if (dateRangeType === DateRangeType.Month) {
                    this._applyFunctionToDayRefs((ref, day) => {
                        if (ref && day.originalDate.getMonth() === originalDate.getMonth() && day.isInBounds) {
                            ref.classList.remove(styles.dayPress);
                        }
                    });
                }
                else {
                    // week or work week view
                    this._applyFunctionToDayRefs((ref, day, dayWeekIndex) => {
                        if (ref && dayWeekIndex === weekIndex && day.isInBounds) {
                            ref.classList.remove(styles.dayPress);
                        }
                    });
                }
            };
        };
        this._onDayMouseOver = (originalDate, weekIndex, dayIndex, dateRangeType) => {
            return (ev) => {
                // set the hover styling on every day in the same month
                if (dateRangeType === DateRangeType.Month) {
                    this._applyFunctionToDayRefs((ref, day) => {
                        if (ref && day.originalDate.getMonth() === originalDate.getMonth() && day.isInBounds) {
                            ref.classList.add(styles.dayHover);
                        }
                    });
                }
                else {
                    // week or work week view
                    this._applyFunctionToDayRefs((ref, day, dayWeekIndex) => {
                        if (ref && dayWeekIndex === weekIndex && day.isInBounds) {
                            ref.classList.add(styles.dayHover);
                        }
                    });
                }
            };
        };
        this._onDayMouseLeave = (originalDate, weekIndex, dayIndex, dateRangeType) => {
            return (ev) => {
                // remove the hover and pressed styling
                if (dateRangeType === DateRangeType.Month) {
                    this._applyFunctionToDayRefs((ref, day) => {
                        if (ref && day.originalDate.getMonth() === originalDate.getMonth() && day.isInBounds) {
                            ref.classList.remove(styles.dayHover);
                        }
                    });
                }
                else {
                    // week or work week view
                    this._applyFunctionToDayRefs((ref, day, dayWeekIndex) => {
                        if (ref && dayWeekIndex === weekIndex && day.isInBounds) {
                            ref.classList.remove(styles.dayHover);
                        }
                    });
                }
            };
        };
        this._onTableMouseLeave = (ev) => {
            if (ev.target.contains &&
                ev.relatedTarget &&
                ev.relatedTarget.contains &&
                ev.target.contains(ev.relatedTarget)) {
                return;
            }
            this._applyFunctionToDayRefs((ref, day) => {
                if (ref) {
                    ref.classList.remove(styles.dayHover);
                    ref.classList.remove(styles.dayPress);
                }
            });
        };
        this._onTableMouseUp = (ev) => {
            if (ev.target.contains &&
                ev.relatedTarget &&
                ev.relatedTarget.contains &&
                ev.target.contains(ev.relatedTarget)) {
                return;
            }
            this._applyFunctionToDayRefs((ref, day) => {
                if (ref) {
                    ref.classList.remove(styles.dayPress);
                }
            });
        };
        this._onSelectDate = (selectedDate) => {
            const { onSelectDate, dateRangeType, firstDayOfWeek, navigatedDate, autoNavigateOnSelection, minDate, maxDate, workWeekDays } = this.props;
            let dateRange = getDateRangeArray(selectedDate, dateRangeType, firstDayOfWeek, workWeekDays);
            if (dateRangeType !== DateRangeType.Day) {
                dateRange = this._getBoundedDateRange(dateRange, minDate, maxDate);
            }
            dateRange = dateRange.filter(d => {
                return !this._getIsRestrictedDate(d);
            });
            if (onSelectDate) {
                onSelectDate(selectedDate, dateRange);
            }
            // Navigate to next or previous month if needed
            if (autoNavigateOnSelection && selectedDate.getMonth() !== navigatedDate.getMonth()) {
                const compareResult = compareDatePart(selectedDate, navigatedDate);
                if (compareResult < 0) {
                    this._onSelectPrevMonth();
                }
                else if (compareResult > 0) {
                    this._onSelectNextMonth();
                }
            }
        };
        this._onSelectNextMonth = () => {
            this.props.onNavigateDate(addMonths(this.props.navigatedDate, 1), false);
        };
        this._onSelectPrevMonth = () => {
            this.props.onNavigateDate(addMonths(this.props.navigatedDate, -1), false);
        };
        this._onClose = () => {
            if (this.props.onDismiss) {
                this.props.onDismiss();
            }
        };
        this._onHeaderSelect = () => {
            const { onHeaderSelect } = this.props;
            if (onHeaderSelect) {
                onHeaderSelect(true);
            }
        };
        this._onHeaderKeyDown = (ev) => {
            const { onHeaderSelect } = this.props;
            if (onHeaderSelect && (ev.which === KeyCodes.enter || ev.which === KeyCodes.space)) {
                onHeaderSelect(true);
            }
        };
        this._onPrevMonthKeyDown = (ev) => {
            if (ev.which === KeyCodes.enter) {
                this._onKeyDown(this._onSelectPrevMonth, ev);
            }
        };
        this._onNextMonthKeyDown = (ev) => {
            if (ev.which === KeyCodes.enter) {
                this._onKeyDown(this._onSelectNextMonth, ev);
            }
        };
        this._onCloseButtonKeyDown = (ev) => {
            if (ev.which === KeyCodes.enter) {
                this._onKeyDown(this._onClose, ev);
            }
        };
        this.state = {
            activeDescendantId: getId('DatePickerDay-active'),
            weeks: this._getWeeks(props)
        };
        this._onSelectNextMonth = this._onSelectNextMonth.bind(this);
        this._onSelectPrevMonth = this._onSelectPrevMonth.bind(this);
        this._onClose = this._onClose.bind(this);
    }
    componentWillReceiveProps(nextProps) {
        this.setState({
            weeks: this._getWeeks(nextProps)
        });
    }
    render() {
        const { activeDescendantId, weeks } = this.state;
        const { firstDayOfWeek, strings, navigatedDate, selectedDate, dateRangeType, navigationIcons, showWeekNumbers, firstWeekOfYear, dateTimeFormatter, minDate, maxDate, showCloseButton, allFocusable } = this.props;
        const dayPickerId = getId('DatePickerDay-dayPicker');
        const monthAndYearId = getId('DatePickerDay-monthAndYear');
        const leftNavigationIcon = navigationIcons.leftNavigation;
        const rightNavigationIcon = navigationIcons.rightNavigation;
        const closeNavigationIcon = navigationIcons.closeIcon;
        const weekNumbers = showWeekNumbers ? getWeekNumbersInMonth(weeks.length, firstDayOfWeek, firstWeekOfYear, navigatedDate) : null;
        const selectedDateWeekNumber = showWeekNumbers ? getWeekNumber(selectedDate, firstDayOfWeek, firstWeekOfYear) : undefined;
        // When the month is highlighted get the corner dates so that styles can be added to them
        const weekCorners = this._getWeekCornerStyles(weeks, dateRangeType);
        // determine if previous/next months are in bounds
        const prevMonthInBounds = minDate ? compareDatePart(minDate, getMonthStart(navigatedDate)) < 0 : true;
        const nextMonthInBounds = maxDate ? compareDatePart(getMonthEnd(navigatedDate), maxDate) < 0 : true;
        return (createElement("div", { className: css('ms-DatePicker-dayPicker', styles.dayPicker, showWeekNumbers && 'ms-DatePicker-showWeekNumbers' && (getRTL() ? styles.showWeekNumbersRTL : styles.showWeekNumbers)), id: dayPickerId },
            createElement("div", { className: css('ms-DatePicker-header', styles.header) },
                createElement("div", { "aria-live": "polite", "aria-relevant": "text", "aria-atomic": "true", id: monthAndYearId, className: styles.monthAndYear }, this.props.onHeaderSelect ? (createElement("div", { className: css('ms-DatePicker-monthAndYear js-showMonthPicker', styles.headerToggleView), onClick: this._onHeaderSelect, onKeyDown: this._onHeaderKeyDown, "aria-label": dateTimeFormatter.formatMonthYear(navigatedDate, strings), role: "button", tabIndex: 0 }, dateTimeFormatter.formatMonthYear(navigatedDate, strings))) : (createElement("div", { className: css('ms-DatePicker-monthAndYear', styles.monthAndYear) }, dateTimeFormatter.formatMonthYear(navigatedDate, strings)))),
                createElement("div", { className: css('ms-DatePicker-monthComponents', styles.monthComponents) },
                    createElement("div", { className: css('ms-DatePicker-navContainer', styles.navContainer) },
                        createElement("button", { className: css('ms-DatePicker-prevMonth js-prevMonth', styles.prevMonth, {
                                ['ms-DatePicker-prevMonth--disabled ' + styles.prevMonthIsDisabled]: !prevMonthInBounds
                            }), disabled: !allFocusable && !prevMonthInBounds, "aria-disabled": !prevMonthInBounds, onClick: prevMonthInBounds ? this._onSelectPrevMonth : undefined, onKeyDown: prevMonthInBounds ? this._onPrevMonthKeyDown : undefined, "aria-controls": dayPickerId, "aria-label": strings.prevMonthAriaLabel
                                ? strings.prevMonthAriaLabel + ' ' + strings.months[addMonths(navigatedDate, -1).getMonth()]
                                : undefined, role: "button" },
                            createElement(Icon, { iconName: leftNavigationIcon })),
                        createElement("button", { className: css('ms-DatePicker-nextMonth js-nextMonth', styles.nextMonth, {
                                ['ms-DatePicker-nextMonth--disabled ' + styles.nextMonthIsDisabled]: !nextMonthInBounds
                            }), disabled: !allFocusable && !nextMonthInBounds, "aria-disabled": !nextMonthInBounds, onClick: nextMonthInBounds ? this._onSelectNextMonth : undefined, onKeyDown: nextMonthInBounds ? this._onNextMonthKeyDown : undefined, "aria-controls": dayPickerId, "aria-label": strings.nextMonthAriaLabel
                                ? strings.nextMonthAriaLabel + ' ' + strings.months[addMonths(navigatedDate, 1).getMonth()]
                                : undefined, role: "button" },
                            createElement(Icon, { iconName: rightNavigationIcon })),
                        showCloseButton && (createElement("button", { className: css('ms-DatePicker-closeButton js-closeButton', styles.closeButton), onClick: this._onClose, onKeyDown: this._onCloseButtonKeyDown, "aria-label": strings.closeButtonAriaLabel, role: "button" },
                            createElement(Icon, { iconName: closeNavigationIcon })))))),
            createElement(FocusZone, null,
                createElement("table", { className: css('ms-DatePicker-table', styles.table), "aria-readonly": "true", "aria-multiselectable": "false", "aria-labelledby": monthAndYearId, "aria-activedescendant": activeDescendantId, role: "grid" },
                    createElement("thead", null,
                        createElement("tr", null,
                            showWeekNumbers && createElement("th", { className: css('ms-DatePicker-weekday', styles.weekday) }),
                            strings.shortDays.map((val, index) => (createElement("th", { className: css('ms-DatePicker-weekday', styles.weekday), role: "gridcell", scope: "col", key: index, title: strings.days[(index + firstDayOfWeek) % DAYS_IN_WEEK], "aria-label": strings.days[(index + firstDayOfWeek) % DAYS_IN_WEEK], "data-is-focusable": allFocusable ? true : undefined }, strings.shortDays[(index + firstDayOfWeek) % DAYS_IN_WEEK]))))),
                    createElement("tbody", { onMouseLeave: dateRangeType !== DateRangeType.Day ? this._onTableMouseLeave : undefined, onMouseUp: dateRangeType !== DateRangeType.Day ? this._onTableMouseUp : undefined }, weeks.map((week, weekIndex) => (createElement("tr", { key: weekNumbers ? weekNumbers[weekIndex] : weekIndex },
                        showWeekNumbers && weekNumbers && (createElement("th", { className: css('ms-DatePicker-weekNumbers', 'ms-DatePicker-weekday', styles.weekday, styles.weekNumbers), key: weekIndex, title: weekNumbers && strings.weekNumberFormatString && format(strings.weekNumberFormatString, weekNumbers[weekIndex]), "aria-label": weekNumbers && strings.weekNumberFormatString && format(strings.weekNumberFormatString, weekNumbers[weekIndex]), scope: "row" },
                            createElement("div", { className: css('ms-DatePicker-day', styles.day, {
                                    ['ms-DatePicker-week--highlighted ' + styles.weekIsHighlighted]: selectedDateWeekNumber === weekNumbers[weekIndex]
                                }) },
                                createElement("span", null, weekNumbers[weekIndex])))),
                        week.map((day, dayIndex) => {
                            const isNavigatedDate = compareDates(navigatedDate, day.originalDate);
                            return (createElement("td", { key: day.key, className: css(styles.dayWrapper, 'ms-DatePicker-day', this._getHighlightedCornerStyle(weekCorners, dayIndex, weekIndex), {
                                    ['ms-DatePicker-weekBackground ' + styles.weekBackground]: day.isSelected && (dateRangeType === DateRangeType.Week || dateRangeType === DateRangeType.WorkWeek),
                                    ['ms-DatePicker-dayBackground ' + styles.dayBackground]: dateRangeType === DateRangeType.Day,
                                    ['ms-DatePicker-day--highlighted ' + styles.dayIsHighlighted]: day.isSelected && dateRangeType === DateRangeType.Day,
                                    ['ms-DatePicker-day--infocus ' + styles.dayIsFocused]: day.isInBounds && day.isInMonth,
                                    ['ms-DatePicker-day--outfocus ' + styles.dayIsUnfocused]: day.isInBounds && !day.isInMonth,
                                    [styles.daySelection]: dateRangeType === DateRangeType.Day,
                                    [styles.weekSelection]: dateRangeType === DateRangeType.Week || dateRangeType === DateRangeType.WorkWeek,
                                    [styles.monthSelection]: dateRangeType === DateRangeType.Month
                                }), ref: element => this._setDayCellRef(element, day, isNavigatedDate), onMouseOver: dateRangeType !== DateRangeType.Day && day.isInBounds
                                    ? this._onDayMouseOver(day.originalDate, weekIndex, dayIndex, dateRangeType)
                                    : undefined, onMouseLeave: dateRangeType !== DateRangeType.Day && day.isInBounds
                                    ? this._onDayMouseLeave(day.originalDate, weekIndex, dayIndex, dateRangeType)
                                    : undefined, onMouseDown: dateRangeType !== DateRangeType.Day && day.isInBounds
                                    ? this._onDayMouseDown(day.originalDate, weekIndex, dayIndex, dateRangeType)
                                    : undefined, onMouseUp: dateRangeType !== DateRangeType.Day && day.isInBounds
                                    ? this._onDayMouseUp(day.originalDate, weekIndex, dayIndex, dateRangeType)
                                    : undefined, role: 'gridcell' },
                                createElement("button", { key: day.key + 'button', className: css(styles.day, 'ms-DatePicker-day-button', {
                                        ['ms-DatePicker-day--disabled ' + styles.dayIsDisabled]: !day.isInBounds,
                                        ['ms-DatePicker-day--today ' + styles.dayIsToday]: day.isToday
                                    }), role: 'button', onKeyDown: this._onDayKeyDown(day.originalDate, weekIndex, dayIndex), onClick: day.isInBounds ? day.onSelected : undefined, "aria-label": dateTimeFormatter.formatMonthDayYear(day.originalDate, strings), id: isNavigatedDate ? activeDescendantId : undefined, "aria-selected": day.isInBounds ? day.isSelected : undefined, "data-is-focusable": allFocusable || (day.isInBounds ? true : undefined), ref: element => this._setDayRef(element, day, isNavigatedDate), disabled: !allFocusable && !day.isInBounds, "aria-disabled": !day.isInBounds },
                                    createElement("span", { "aria-hidden": "true" }, dateTimeFormatter.formatDay(day.originalDate)))));
                        })))))))));
    }
    focus() {
        if (this.navigatedDay) {
            this.navigatedDay.tabIndex = 0;
            this.navigatedDay.focus();
        }
    }
    _setDayRef(element, day, isNavigatedDate) {
        if (isNavigatedDate) {
            this.navigatedDay = element;
        }
    }
    _setDayCellRef(element, day, isNavigatedDate) {
        this.days[day.key] = element;
    }
    _getWeekCornerStyles(weeks, dateRangeType) {
        const weekCornersStyled = {};
        switch (dateRangeType) {
            case DateRangeType.Month:
                /* need to handle setting all of the corners on arbitrarily shaped blobs
                      __
                   __|A |
                  |B |C |__
                  |D |E |F |
        
                  in this case, A needs top left rounded, top right rounded
                  B needs top left rounded
                  C doesn't need any rounding
                  D needs bottom left rounded
                  E doesn't need any rounding
                  F needs top right rounding
                */
                // if there's an item above, lose both top corners. Item below, lose both bottom corners, etc.
                weeks.forEach((week, weekIndex) => {
                    week.forEach((day, dayIndex) => {
                        const above = weeks[weekIndex - 1] &&
                            weeks[weekIndex - 1][dayIndex] &&
                            weeks[weekIndex - 1][dayIndex].originalDate.getMonth() === weeks[weekIndex][dayIndex].originalDate.getMonth();
                        const below = weeks[weekIndex + 1] &&
                            weeks[weekIndex + 1][dayIndex] &&
                            weeks[weekIndex + 1][dayIndex].originalDate.getMonth() === weeks[weekIndex][dayIndex].originalDate.getMonth();
                        const left = weeks[weekIndex][dayIndex - 1] &&
                            weeks[weekIndex][dayIndex - 1].originalDate.getMonth() === weeks[weekIndex][dayIndex].originalDate.getMonth();
                        const right = weeks[weekIndex][dayIndex + 1] &&
                            weeks[weekIndex][dayIndex + 1].originalDate.getMonth() === weeks[weekIndex][dayIndex].originalDate.getMonth();
                        const roundedTopLeft = !above && !left;
                        const roundedTopRight = !above && !right;
                        const roundedBottomLeft = !below && !left;
                        const roundedBottomRight = !below && !right;
                        let style = '';
                        if (roundedTopLeft) {
                            style = getRTL() ? style.concat(styles.topRightCornerDate + ' ') : style.concat(styles.topLeftCornerDate + ' ');
                        }
                        if (roundedTopRight) {
                            style = getRTL() ? style.concat(styles.topLeftCornerDate + ' ') : style.concat(styles.topRightCornerDate + ' ');
                        }
                        if (roundedBottomLeft) {
                            style = getRTL() ? style.concat(styles.bottomRightCornerDate + ' ') : style.concat(styles.bottomLeftCornerDate + ' ');
                        }
                        if (roundedBottomRight) {
                            style = getRTL() ? style.concat(styles.bottomLeftCornerDate + ' ') : style.concat(styles.bottomRightCornerDate + ' ');
                        }
                        if (!above) {
                            style = style.concat(styles.topDate + ' ');
                        }
                        if (!below) {
                            style = style.concat(styles.bottomDate + ' ');
                        }
                        if (!right) {
                            style = style.concat(styles.rightDate + ' ');
                        }
                        if (!left) {
                            style = style.concat(styles.leftdate + ' ');
                        }
                        weekCornersStyled[weekIndex + '_' + dayIndex] = style;
                    });
                });
                break;
            case DateRangeType.Week:
            case DateRangeType.WorkWeek:
                weeks.forEach((week, weekIndex) => {
                    const minIndex = findIndex(week, (item) => {
                        return item.isInBounds;
                    });
                    const maxIndex = this._findLastIndex(week, (item) => {
                        return item.isInBounds;
                    });
                    const leftStyle = styles.topLeftCornerDate + ' ' + styles.bottomLeftCornerDate;
                    const rightStyle = styles.topRightCornerDate + ' ' + styles.bottomRightCornerDate;
                    weekCornersStyled[weekIndex + '_' + minIndex] = getRTL() ? rightStyle : leftStyle;
                    weekCornersStyled[weekIndex + '_' + maxIndex] = getRTL() ? leftStyle : rightStyle;
                });
                break;
        }
        return weekCornersStyled;
    }
    _getHighlightedCornerStyle(weekCorners, dayIndex, weekIndex) {
        const cornerStyle = weekCorners[weekIndex + '_' + dayIndex] ? weekCorners[weekIndex + '_' + dayIndex] : '';
        return cornerStyle;
    }
    _navigateMonthEdge(ev, date, weekIndex, dayIndex) {
        const { minDate, maxDate } = this.props;
        let targetDate = undefined;
        if (weekIndex === 0 && ev.which === KeyCodes.up) {
            targetDate = addWeeks(date, -1);
        }
        else if (weekIndex === this.state.weeks.length - 1 && ev.which === KeyCodes.down) {
            targetDate = addWeeks(date, 1);
        }
        else if (dayIndex === 0 && ev.which === getRTLSafeKeyCode(KeyCodes.left)) {
            targetDate = addDays(date, -1);
        }
        else if (dayIndex === DAYS_IN_WEEK - 1 && ev.which === getRTLSafeKeyCode(KeyCodes.right)) {
            targetDate = addDays(date, 1);
        }
        // Don't navigate to out-of-bounds date
        if (targetDate &&
            (minDate ? compareDatePart(minDate, targetDate) < 1 : true) &&
            (maxDate ? compareDatePart(targetDate, maxDate) < 1 : true)) {
            this.props.onNavigateDate(targetDate, true);
            ev.preventDefault();
        }
    }
    _applyFunctionToDayRefs(func) {
        if (this.state.weeks) {
            this.state.weeks.map((week, weekIndex) => {
                week.map(day => {
                    const ref = this.days[day.key];
                    func(ref, day, weekIndex);
                });
            });
        }
    }
    _getWeeks(propsToUse) {
        const { navigatedDate, selectedDate, dateRangeType, firstDayOfWeek, today, minDate, maxDate, showSixWeeksByDefault, workWeekDays } = propsToUse;
        const date = new Date(navigatedDate.getFullYear(), navigatedDate.getMonth(), 1);
        const todaysDate = today || new Date();
        const weeks = [];
        // Cycle the date backwards to get to the first day of the week.
        while (date.getDay() !== firstDayOfWeek) {
            date.setDate(date.getDate() - 1);
        }
        // a flag to indicate whether all days of the week are in the month
        let isAllDaysOfWeekOutOfMonth = false;
        // in work week view we want to select the whole week
        const selectedDateRangeType = dateRangeType === DateRangeType.WorkWeek ? DateRangeType.Week : dateRangeType;
        let selectedDates = getDateRangeArray(selectedDate, selectedDateRangeType, firstDayOfWeek, workWeekDays);
        if (dateRangeType !== DateRangeType.Day) {
            selectedDates = this._getBoundedDateRange(selectedDates, minDate, maxDate);
        }
        let shouldGetWeeks = true;
        for (let weekIndex = 0; shouldGetWeeks; weekIndex++) {
            const week = [];
            isAllDaysOfWeekOutOfMonth = true;
            for (let dayIndex = 0; dayIndex < DAYS_IN_WEEK; dayIndex++) {
                const originalDate = new Date(date.toString());
                const dayInfo = {
                    key: date.toString(),
                    date: date.getDate().toString(),
                    originalDate: originalDate,
                    isInMonth: date.getMonth() === navigatedDate.getMonth(),
                    isToday: compareDates(todaysDate, date),
                    isSelected: isInDateRangeArray(date, selectedDates),
                    onSelected: this._onSelectDate.bind(this, originalDate),
                    isInBounds: (minDate ? compareDatePart(minDate, date) < 1 : true) &&
                        (maxDate ? compareDatePart(date, maxDate) < 1 : true) &&
                        !this._getIsRestrictedDate(date)
                };
                week.push(dayInfo);
                if (dayInfo.isInMonth) {
                    isAllDaysOfWeekOutOfMonth = false;
                }
                date.setDate(date.getDate() + 1);
            }
            // We append the condition of the loop depending upon the showSixWeeksByDefault prop.
            shouldGetWeeks = showSixWeeksByDefault ? !isAllDaysOfWeekOutOfMonth || weekIndex <= 5 : !isAllDaysOfWeekOutOfMonth;
            if (shouldGetWeeks) {
                weeks.push(week);
            }
        }
        return weeks;
    }
    _getIsRestrictedDate(date) {
        const { restrictedDates } = this.props;
        if (!restrictedDates) {
            return false;
        }
        const restrictedDate = restrictedDates.find(rd => {
            return compareDates(rd, date);
        });
        return restrictedDate ? true : false;
    }
    _getBoundedDateRange(dateRange, minDate, maxDate) {
        let boundedDateRange = [...dateRange];
        if (minDate) {
            boundedDateRange = boundedDateRange.filter(date => compareDatePart(date, minDate) >= 0);
        }
        if (maxDate) {
            boundedDateRange = boundedDateRange.filter(date => compareDatePart(date, maxDate) <= 0);
        }
        return boundedDateRange;
    }
    /**
     * Returns the index of the last element in the array where the predicate is true, and -1
     * otherwise
     * @param items Array of items to be iterated over using the predicate
     * @param predicate find calls predicate once for each element of the array, in descending
     * order, until it finds one where predicate returns true if such an element is found.
     */
    _findLastIndex(items, predicate) {
        for (let i = items.length - 1; i >= 0; i--) {
            const item = items[i];
            if (predicate(item)) {
                return i;
            }
        }
        return -1;
    }
}

// import * as stylesImport from './Calendar.scss';
// const styles: any = stylesImport;
let styles$1;
const CELL_COUNT = 12;
const DefaultCalendarYearStrings = {
    prevRangeAriaLabel: undefined,
    nextRangeAriaLabel: undefined
};
const DefaultNavigationIcons = {
    leftNavigation: 'Up',
    rightNavigation: 'Down',
    closeIcon: 'CalculatorMultiply'
};
class CalendarYearGridCell extends Component {
    constructor() {
        super(...arguments);
        this._buttonRef = createRef();
        this._onRenderYear = () => {
            const { year, onRenderYear } = this.props;
            if (onRenderYear) {
                return onRenderYear(year);
            }
            return year;
        };
        this._onClick = () => {
            if (this.props.onSelectYear) {
                this.props.onSelectYear(this.props.year);
            }
        };
        this._onKeyDown = (ev) => {
            if (this.props.onSelectYear && ev.which === KeyCodes.enter) {
                this.props.onSelectYear(this.props.year);
            }
        };
    }
    focus() {
        if (this._buttonRef.current) {
            this._buttonRef.current.focus();
        }
    }
    render() {
        const { year, selected, disabled, onSelectYear } = this.props;
        return (createElement("button", { className: css('ms-DatePicker-yearOption', styles$1.yearOption, {
                ['ms-DatePicker-day--highlighted ' + styles$1.yearIsHighlighted]: selected,
                ['ms-DatePicker-yearOption--disabled ' + styles$1.yearOptionIsDisabled]: disabled
            }), type: "button", role: "gridcell", onClick: !disabled && onSelectYear ? this._onClick : undefined, onKeyDown: !disabled && onSelectYear ? this._onKeyDown : undefined, disabled: disabled, "aria-label": String(year), "aria-selected": selected, ref: this._buttonRef }, this._onRenderYear()));
    }
}
class CalendarYearGrid extends Component {
    constructor() {
        super(...arguments);
        this._selectedCellRef = createRef();
        this._currentCellRef = createRef();
        this._renderCell = (year) => {
            const selected = year === this.props.selectedYear;
            const { minYear, maxYear, onSelectYear } = this.props;
            const disabled = (minYear !== undefined && year < minYear) || (maxYear !== undefined && year > maxYear);
            const current = year === new Date().getFullYear();
            return (createElement(CalendarYearGridCell, { key: year, year: year, selected: selected, current: current, disabled: disabled, onSelectYear: onSelectYear, ref: selected ? this._selectedCellRef : current ? this._currentCellRef : undefined }));
        };
    }
    focus() {
        if (this._selectedCellRef.current) {
            this._selectedCellRef.current.focus();
        }
        else if (this._currentCellRef.current) {
            this._currentCellRef.current.focus();
        }
    }
    render() {
        const { fromYear, toYear } = this.props;
        let year = fromYear;
        const cells = [];
        while (year <= toYear) {
            cells.push(this._renderCell(year));
            year++;
        }
        return (createElement(FocusZone, null,
            createElement("div", { className: css('ms-DatePicker-optionGrid', styles$1.optionGrid), role: "grid" },
                createElement("div", { role: "row" }, cells))));
    }
}
class CalendarYearNavPrev extends Component {
    constructor() {
        super(...arguments);
        this._onSelectPrev = () => {
            if (!this.isDisabled && this.props.onSelectPrev) {
                this.props.onSelectPrev();
            }
        };
        this._onKeyDown = (ev) => {
            if (ev.which === KeyCodes.enter) {
                this._onSelectPrev();
            }
        };
    }
    render() {
        const iconStrings = this.props.navigationIcons || DefaultNavigationIcons;
        const strings = this.props.strings || DefaultCalendarYearStrings;
        const prevRangeAriaLabel = strings.prevRangeAriaLabel || strings.rangeAriaLabel;
        const prevAriaLabel = prevRangeAriaLabel
            ? typeof prevRangeAriaLabel === 'string'
                ? prevRangeAriaLabel
                : prevRangeAriaLabel(this.props)
            : undefined;
        const disabled = this.isDisabled;
        const { onSelectPrev } = this.props;
        return (createElement("button", { className: css('ms-DatePicker-prevDecade', styles$1.prevDecade, {
                ['ms-DatePicker-prevDecade--disabled ' + styles$1.prevDecadeIsDisabled]: disabled
            }), onClick: !disabled && onSelectPrev ? this._onSelectPrev : undefined, onKeyDown: !disabled && onSelectPrev ? this._onKeyDown : undefined, type: "button", tabIndex: 0, "aria-label": prevAriaLabel, disabled: disabled },
            createElement(Icon, { iconName: getRTL() ? iconStrings.rightNavigation : iconStrings.leftNavigation })));
    }
    get isDisabled() {
        const { minYear } = this.props;
        return minYear !== undefined && this.props.fromYear < minYear;
    }
}
class CalendarYearNavNext extends Component {
    constructor() {
        super(...arguments);
        this._onSelectNext = () => {
            if (!this.isDisabled && this.props.onSelectNext) {
                this.props.onSelectNext();
            }
        };
        this._onKeyDown = (ev) => {
            if (ev.which === KeyCodes.enter) {
                this._onSelectNext();
            }
        };
    }
    render() {
        const iconStrings = this.props.navigationIcons || DefaultNavigationIcons;
        const strings = this.props.strings || DefaultCalendarYearStrings;
        const nextRangeAriaLabel = strings.nextRangeAriaLabel || strings.rangeAriaLabel;
        const nextAriaLabel = nextRangeAriaLabel
            ? typeof nextRangeAriaLabel === 'string'
                ? nextRangeAriaLabel
                : nextRangeAriaLabel(this.props)
            : undefined;
        const { onSelectNext } = this.props;
        const disabled = this.isDisabled;
        return (createElement("button", { className: css('ms-DatePicker-nextDecade', styles$1.nextDecade, {
                ['ms-DatePicker-nextDecade--disabled ' + styles$1.nextDecadeIsDisabled]: disabled
            }), onClick: !disabled && onSelectNext ? this._onSelectNext : undefined, onKeyDown: !disabled && onSelectNext ? this._onKeyDown : undefined, type: "button", tabIndex: 0, "aria-label": nextAriaLabel, disabled: this.isDisabled },
            createElement(Icon, { iconName: getRTL() ? iconStrings.leftNavigation : iconStrings.rightNavigation })));
    }
    get isDisabled() {
        const { maxYear } = this.props;
        return maxYear !== undefined && this.props.fromYear + CELL_COUNT > maxYear;
    }
}
class CalendarYearNav extends Component {
    render() {
        return (createElement("div", { className: css('ms-DatePicker-decadeComponents', styles$1.decadeComponents) },
            createElement("div", { className: css('ms-DatePicker-navContainer', styles$1.navContainer) },
                createElement(CalendarYearNavPrev, Object.assign({}, this.props)),
                createElement(CalendarYearNavNext, Object.assign({}, this.props)))));
    }
}
class CalendarYearTitle extends Component {
    constructor() {
        super(...arguments);
        this._onHeaderSelect = () => {
            if (this.props.onHeaderSelect) {
                this.props.onHeaderSelect(true);
            }
        };
        this._onHeaderKeyDown = (ev) => {
            if (this.props.onHeaderSelect && (ev.which === KeyCodes.enter || ev.which === KeyCodes.space)) {
                this.props.onHeaderSelect(true);
            }
        };
        this._onRenderYear = (year) => {
            if (this.props.onRenderYear) {
                return this.props.onRenderYear(year);
            }
            return year;
        };
    }
    render() {
        const { fromYear, toYear, onHeaderSelect } = this.props;
        if (onHeaderSelect) {
            const strings = this.props.strings || DefaultCalendarYearStrings;
            const rangeAriaLabel = strings.rangeAriaLabel;
            const ariaLabel = rangeAriaLabel
                ? typeof rangeAriaLabel === 'string'
                    ? rangeAriaLabel
                    : rangeAriaLabel(this.props)
                : undefined;
            return (createElement("div", { className: css('ms-DatePicker-currentDecade js-showYearPicker', styles$1.currentDecade, styles$1.headerToggleView), onClick: this._onHeaderSelect, onKeyDown: this._onHeaderKeyDown, "aria-label": ariaLabel, role: "button", tabIndex: 0 },
                this._onRenderYear(fromYear),
                " - ",
                this._onRenderYear(toYear)));
        }
        return (createElement("div", { className: css('ms-DatePicker-currentDecade js-showYearPicker', styles$1.currentDecade) },
            this._onRenderYear(fromYear),
            " - ",
            this._onRenderYear(toYear)));
    }
}
class CalendarYearHeader extends Component {
    constructor() {
        super(...arguments);
        this._onRenderTitle = () => {
            if (this.props.onRenderTitle) {
                return this.props.onRenderTitle(this.props);
            }
            return createElement(CalendarYearTitle, Object.assign({}, this.props));
        };
        this._onRenderNav = () => {
            return createElement(CalendarYearNav, Object.assign({}, this.props));
        };
    }
    render() {
        return (createElement("div", { className: css('ms-DatePicker-header', styles$1.header) },
            this._onRenderTitle(),
            this._onRenderNav()));
    }
}
class CalendarYear extends Component {
    constructor() {
        super(...arguments);
        this.state = {
            fromYear: 0 // overwritten by getDerivedStateFromProps
        };
        this._gridRef = createRef();
        this._onNavNext = () => {
            this.setState({ fromYear: this.state.fromYear + CELL_COUNT });
        };
        this._onNavPrev = () => {
            this.setState({ fromYear: this.state.fromYear - CELL_COUNT });
        };
        this._renderHeader = () => {
            return (createElement(CalendarYearHeader, Object.assign({}, this.props, { fromYear: this.state.fromYear, toYear: this.state.fromYear + CELL_COUNT - 1, onSelectPrev: this._onNavPrev, onSelectNext: this._onNavNext })));
        };
        this._renderGrid = () => {
            return (createElement(CalendarYearGrid, Object.assign({}, this.props, { fromYear: this.state.fromYear, toYear: this.state.fromYear + CELL_COUNT - 1, ref: this._gridRef })));
        };
    }
    static getDerivedStateFromProps(nextProps) {
        const { selectedYear, navigatedYear } = nextProps;
        const rangeYear = selectedYear || navigatedYear || new Date().getFullYear();
        const fromYear = Math.floor(rangeYear / 10) * 10;
        return {
            fromYear: fromYear,
            navigatedYear: navigatedYear,
            selectedYear: selectedYear
        };
    }
    focus() {
        if (this._gridRef.current) {
            this._gridRef.current.focus();
        }
    }
    render() {
        return (createElement("div", { className: css('ms-DatePicker-yearPicker', styles$1.yearPicker) },
            this._renderHeader(),
            this._renderGrid()));
    }
}

// import * as stylesImport from './Calendar.scss';
// const styles: any = stylesImport;
let styles$2;
class CalendarMonth extends BaseComponent {
    constructor(props) {
        super(props);
        this._onCalendarYearRef = (ref) => {
            this._calendarYearRef = ref;
        };
        this._onKeyDown = (callback, ev) => {
            if (ev.which === KeyCodes.enter) {
                callback();
            }
        };
        this._onSelectYear = (selectedYear) => {
            this._focusOnUpdate = true;
            const { navigatedDate, onNavigateDate, maxDate, minDate } = this.props;
            const navYear = navigatedDate.getFullYear();
            if (navYear !== selectedYear) {
                let newNavigationDate = new Date(navigatedDate.getTime());
                newNavigationDate.setFullYear(selectedYear);
                // for min and max dates, adjust the new navigation date - perhaps this should be
                // checked on the master navigation date handler (i.e. in Calendar)
                if (maxDate && newNavigationDate > maxDate) {
                    newNavigationDate = setMonth(newNavigationDate, maxDate.getMonth());
                }
                else if (minDate && newNavigationDate < minDate) {
                    newNavigationDate = setMonth(newNavigationDate, minDate.getMonth());
                }
                onNavigateDate(newNavigationDate, true);
            }
            this.setState({ isYearPickerVisible: false });
        };
        this._yearToString = (year) => {
            const { navigatedDate, dateTimeFormatter } = this.props;
            if (dateTimeFormatter) {
                // create a date based on the current nav date
                const yearFormattingDate = new Date(navigatedDate.getTime());
                yearFormattingDate.setFullYear(year);
                return dateTimeFormatter.formatYear(yearFormattingDate);
            }
            return String(year);
        };
        this._yearRangeToString = (yearRange) => {
            return `${this._yearToString(yearRange.fromYear)} - ${this._yearToString(yearRange.toYear)}`;
        };
        this._onRenderYear = (year) => {
            return this._yearToString(year);
        };
        this._onSelectNextYear = () => {
            const { navigatedDate, onNavigateDate } = this.props;
            onNavigateDate(addYears(navigatedDate, 1), false);
        };
        this._onSelectNextYearKeyDown = (ev) => {
            if (ev.which === KeyCodes.enter) {
                this._onKeyDown(this._onSelectNextYear, ev);
            }
        };
        this._onSelectPrevYear = () => {
            const { navigatedDate, onNavigateDate } = this.props;
            onNavigateDate(addYears(navigatedDate, -1), false);
        };
        this._onSelectPrevYearKeyDown = (ev) => {
            if (ev.which === KeyCodes.enter) {
                this._onKeyDown(this._onSelectPrevYear, ev);
            }
        };
        this._onSelectMonthKeyDown = (index) => {
            return (ev) => this._onKeyDown(() => this._onSelectMonth(index), ev);
        };
        this._onSelectMonth = (newMonth) => {
            const { navigatedDate, onNavigateDate, onHeaderSelect } = this.props;
            // If header is clickable the calendars are overlayed, switch back to day picker when month is clicked
            if (onHeaderSelect) {
                onHeaderSelect(true);
            }
            onNavigateDate(setMonth(navigatedDate, newMonth), true);
        };
        this._onHeaderSelect = () => {
            const { onHeaderSelect, yearPickerHidden } = this.props;
            if (!yearPickerHidden) {
                this._focusOnUpdate = true;
                this.setState({ isYearPickerVisible: true });
            }
            else if (onHeaderSelect) {
                onHeaderSelect(true);
            }
        };
        this._onYearPickerHeaderSelect = (focus) => {
            this._focusOnUpdate = focus;
            this.setState({ isYearPickerVisible: false });
        };
        this._onHeaderKeyDown = (ev) => {
            const { onHeaderSelect } = this.props;
            if (onHeaderSelect && (ev.which === KeyCodes.enter || ev.which === KeyCodes.space)) {
                onHeaderSelect(true);
            }
        };
        this._selectMonthCallbacks = [];
        props.strings.shortMonths.map((month, index) => {
            this._selectMonthCallbacks[index] = this._onSelectMonth.bind(this, index);
        });
        this._isCurrentMonth = this._isCurrentMonth.bind(this);
        this._onSelectNextYear = this._onSelectNextYear.bind(this);
        this._onSelectPrevYear = this._onSelectPrevYear.bind(this);
        this._onSelectMonth = this._onSelectMonth.bind(this);
        this.state = { isYearPickerVisible: false };
    }
    componentDidUpdate() {
        if (this._focusOnUpdate) {
            this.focus();
            this._focusOnUpdate = false;
        }
    }
    render() {
        const { navigatedDate, selectedDate, strings, today, highlightCurrentMonth, highlightSelectedMonth, navigationIcons, dateTimeFormatter, minDate, maxDate, yearPickerHidden } = this.props;
        if (this.state.isYearPickerVisible) {
            return (createElement(CalendarYear, { minYear: minDate ? minDate.getFullYear() : undefined, maxYear: maxDate ? maxDate.getFullYear() : undefined, onSelectYear: this._onSelectYear, navigationIcons: navigationIcons, onHeaderSelect: this._onYearPickerHeaderSelect, selectedYear: selectedDate ? selectedDate.getFullYear() : navigatedDate ? navigatedDate.getFullYear() : undefined, onRenderYear: this._onRenderYear, strings: {
                    rangeAriaLabel: this._yearRangeToString
                }, ref: this._onCalendarYearRef }));
        }
        const leftNavigationIcon = navigationIcons.leftNavigation;
        const rightNavigationIcon = navigationIcons.rightNavigation;
        // determine if previous/next years are in bounds
        const isPrevYearInBounds = minDate ? compareDatePart(minDate, getYearStart(navigatedDate)) < 0 : true;
        const isNextYearInBounds = maxDate ? compareDatePart(getYearEnd(navigatedDate), maxDate) < 0 : true;
        return (createElement("div", { className: css('ms-DatePicker-monthPicker', styles$2.monthPicker) },
            createElement("div", { className: css('ms-DatePicker-header', styles$2.header) },
                this.props.onHeaderSelect || !yearPickerHidden ? (createElement("div", { className: css('ms-DatePicker-currentYear js-showYearPicker', styles$2.currentYear, styles$2.headerToggleView), onClick: this._onHeaderSelect, onKeyDown: this._onHeaderKeyDown, "aria-label": dateTimeFormatter.formatYear(navigatedDate), role: "button", tabIndex: 0 }, dateTimeFormatter.formatYear(navigatedDate))) : (createElement("div", { className: css('ms-DatePicker-currentYear js-showYearPicker', styles$2.currentYear) }, dateTimeFormatter.formatYear(navigatedDate))),
                createElement("div", { className: css('ms-DatePicker-yearComponents', styles$2.yearComponents) },
                    createElement("div", { className: css('ms-DatePicker-navContainer', styles$2.navContainer) },
                        createElement("button", { className: css('ms-DatePicker-prevYear js-prevYear', styles$2.prevYear, {
                                ['ms-DatePicker-prevYear--disabled ' + styles$2.prevYearIsDisabled]: !isPrevYearInBounds
                            }), disabled: !isPrevYearInBounds, onClick: isPrevYearInBounds ? this._onSelectPrevYear : undefined, onKeyDown: isPrevYearInBounds ? this._onSelectPrevYearKeyDown : undefined, "aria-label": strings.prevYearAriaLabel
                                ? strings.prevYearAriaLabel + ' ' + dateTimeFormatter.formatYear(addYears(navigatedDate, -1))
                                : undefined, role: "button" },
                            createElement(Icon, { iconName: getRTL() ? rightNavigationIcon : leftNavigationIcon })),
                        createElement("button", { className: css('ms-DatePicker-nextYear js-nextYear', styles$2.nextYear, {
                                ['ms-DatePicker-nextYear--disabled ' + styles$2.nextYearIsDisabled]: !isNextYearInBounds
                            }), disabled: !isNextYearInBounds, onClick: isNextYearInBounds ? this._onSelectNextYear : undefined, onKeyDown: isNextYearInBounds ? this._onSelectNextYearKeyDown : undefined, "aria-label": strings.nextYearAriaLabel
                                ? strings.nextYearAriaLabel + ' ' + dateTimeFormatter.formatYear(addYears(navigatedDate, 1))
                                : undefined, role: "button" },
                            createElement(Icon, { iconName: getRTL() ? leftNavigationIcon : rightNavigationIcon }))))),
            createElement(FocusZone, null,
                createElement("div", { className: css('ms-DatePicker-optionGrid', styles$2.optionGrid), role: "grid", "aria-readonly": "true" },
                    createElement("div", { role: "row" }, strings.shortMonths.map((month, index) => {
                        const indexedMonth = setMonth(navigatedDate, index);
                        const isCurrentMonth = this._isCurrentMonth(index, navigatedDate.getFullYear(), today);
                        const isNavigatedMonth = navigatedDate.getMonth() === index;
                        const isSelectedMonth = selectedDate.getMonth() === index;
                        const isSelectedYear = selectedDate.getFullYear() === navigatedDate.getFullYear();
                        const isInBounds = (minDate ? compareDatePart(minDate, getMonthEnd(indexedMonth)) < 1 : true) &&
                            (maxDate ? compareDatePart(getMonthStart(indexedMonth), maxDate) < 1 : true);
                        return (createElement("button", { role: 'gridcell', className: css('ms-DatePicker-monthOption', styles$2.monthOption, {
                                ['ms-DatePicker-day--today ' + styles$2.monthIsCurrentMonth]: highlightCurrentMonth && isCurrentMonth,
                                ['ms-DatePicker-day--highlighted ' + styles$2.monthIsHighlighted]: (highlightCurrentMonth || highlightSelectedMonth) && isSelectedMonth && isSelectedYear,
                                ['ms-DatePicker-monthOption--disabled ' + styles$2.monthOptionIsDisabled]: !isInBounds
                            }), disabled: !isInBounds, key: index, onClick: isInBounds ? this._selectMonthCallbacks[index] : undefined, onKeyDown: isInBounds ? this._onSelectMonthKeyDown(index) : undefined, "aria-label": dateTimeFormatter.formatMonthYear(indexedMonth, strings), "aria-selected": isCurrentMonth || isNavigatedMonth, "data-is-focusable": isInBounds ? true : undefined, ref: isNavigatedMonth ? 'navigatedMonth' : undefined }, month));
                    }))))));
    }
    focus() {
        if (this._calendarYearRef) {
            this._calendarYearRef.focus();
        }
        else if (this.refs.navigatedMonth) {
            this.refs.navigatedMonth.tabIndex = 0;
            this.refs.navigatedMonth.focus();
        }
    }
    _isCurrentMonth(month, year, today) {
        return today.getFullYear() === year && today.getMonth() === month;
    }
}

//import * as stylesImport from './Calendar.scss';
//const styles: any = stylesImport;
let styles$3;
const leftArrow = 'Up';
const rightArrow = 'Down';
const closeIcon = 'CalculatorMultiply';
const iconStrings = {
    leftNavigation: leftArrow,
    rightNavigation: rightArrow,
    closeIcon: closeIcon
};
const defaultWorkWeekDays = [DayOfWeek.Monday, DayOfWeek.Tuesday, DayOfWeek.Wednesday, DayOfWeek.Thursday, DayOfWeek.Friday];
const dateTimeFormatterCallbacks = {
    formatMonthDayYear: (date, strings) => strings.months[date.getMonth()] + ' ' + date.getDate() + ', ' + date.getFullYear(),
    formatMonthYear: (date, strings) => strings.months[date.getMonth()] + ' ' + date.getFullYear(),
    formatDay: (date) => date.getDate().toString(),
    formatYear: (date) => date.getFullYear().toString()
};
class Calendar extends BaseComponent {
    constructor(props) {
        super(props);
        this._dayPicker = createRef();
        this._monthPicker = createRef();
        this._navigateDayPickerDay = (date) => {
            this.setState({
                navigatedDayDate: date,
                navigatedMonthDate: date
            });
        };
        this._navigateMonthPickerDay = (date) => {
            this.setState({
                navigatedMonthDate: date
            });
        };
        this._onNavigateDayDate = (date, focusOnNavigatedDay) => {
            this._navigateDayPickerDay(date);
            this._focusOnUpdate = focusOnNavigatedDay;
        };
        this._onNavigateMonthDate = (date, focusOnNavigatedDay) => {
            if (!focusOnNavigatedDay) {
                this._navigateMonthPickerDay(date);
                this._focusOnUpdate = focusOnNavigatedDay;
                return;
            }
            const monthPickerOnly = !this.props.showMonthPickerAsOverlay && !this.props.isDayPickerVisible;
            if (monthPickerOnly) {
                this._onSelectDate(date);
            }
            this._navigateDayPickerDay(date);
        };
        this._onSelectDate = (date, selectedDateRangeArray) => {
            const { onSelectDate } = this.props;
            this.setState({
                selectedDate: date
            });
            if (onSelectDate) {
                onSelectDate(date, selectedDateRangeArray);
            }
        };
        this._onHeaderSelect = (focus) => {
            this.setState({
                isDayPickerVisible: !this.state.isDayPickerVisible,
                isMonthPickerVisible: !this.state.isMonthPickerVisible
            });
            if (focus) {
                this._focusOnUpdate = true;
            }
        };
        this._onGotoToday = () => {
            const { dateRangeType, firstDayOfWeek, today, workWeekDays, selectDateOnClick } = this.props;
            if (selectDateOnClick) {
                // When using Defaultprops, TypeScript doesn't know that React is going to inject defaults
                // so we use exclamation mark as a hint to the type checker (see link below)
                // https://decembersoft.com/posts/error-ts2532-optional-react-component-props-in-typescript/
                const dates = getDateRangeArray(today, dateRangeType, firstDayOfWeek, workWeekDays);
                this._onSelectDate(today, dates);
            }
            this._navigateDayPickerDay(today);
        };
        this._onGotoTodayClick = (ev) => {
            this._onGotoToday();
        };
        this._onGotoTodayKeyDown = (ev) => {
            if (ev.which === KeyCodes.enter) {
                ev.preventDefault();
                this._onGotoToday();
            }
        };
        this._onDatePickerPopupKeyDown = (ev) => {
            switch (ev.which) {
                case KeyCodes.enter:
                    ev.preventDefault();
                    break;
                case KeyCodes.backspace:
                    ev.preventDefault();
                    break;
                case KeyCodes.escape:
                    this._handleEscKey(ev);
                    break;
                default:
                    break;
            }
        };
        this._handleEscKey = (ev) => {
            if (this.props.onDismiss) {
                this.props.onDismiss();
            }
        };
        const currentDate = props.value && !isNaN(props.value.getTime()) ? props.value : props.today || new Date();
        this.state = {
            selectedDate: currentDate,
            navigatedDayDate: currentDate,
            navigatedMonthDate: currentDate,
            /** When showMonthPickerAsOverlay is active it overrides isMonthPickerVisible/isDayPickerVisible props
             (These props permanently set the visibility of their respective calendars). */
            isMonthPickerVisible: this.props.showMonthPickerAsOverlay ? false : this.props.isMonthPickerVisible,
            isDayPickerVisible: this.props.showMonthPickerAsOverlay ? true : this.props.isDayPickerVisible
        };
        this._focusOnUpdate = false;
    }
    componentWillReceiveProps(nextProps) {
        const { autoNavigateOnSelection, value, today = new Date() } = nextProps;
        // Make sure auto-navigation is supported for programmatic changes to selected date, i.e.,
        // if selected date is updated via props, we may need to modify the navigated date
        const overrideNavigatedDate = autoNavigateOnSelection && !compareDates(value, this.props.value);
        if (overrideNavigatedDate) {
            this.setState({
                navigatedMonthDate: value,
                navigatedDayDate: value
            });
        }
        this.setState({
            selectedDate: value || today
        });
    }
    componentDidUpdate() {
        if (this._focusOnUpdate) {
            this.focus();
            this._focusOnUpdate = false;
        }
    }
    render() {
        const rootClass = 'ms-DatePicker';
        const { firstDayOfWeek, dateRangeType, strings, showMonthPickerAsOverlay, autoNavigateOnSelection, showGoToToday, highlightCurrentMonth, highlightSelectedMonth, navigationIcons, minDate, maxDate, restrictedDates, className, showCloseButton, allFocusable, yearPickerHidden, today } = this.props;
        const nativeProps = getNativeProps(this.props, divProperties, ['value']);
        const { selectedDate, navigatedDayDate, navigatedMonthDate, isMonthPickerVisible, isDayPickerVisible } = this.state;
        const onHeaderSelect = showMonthPickerAsOverlay ? this._onHeaderSelect : undefined;
        const monthPickerOnly = !showMonthPickerAsOverlay && !isDayPickerVisible;
        const overlayedWithButton = showMonthPickerAsOverlay && showGoToToday;
        let goTodayEnabled = showGoToToday;
        if (goTodayEnabled && navigatedDayDate && navigatedMonthDate && today) {
            goTodayEnabled =
                navigatedDayDate.getFullYear() !== today.getFullYear() ||
                    navigatedDayDate.getMonth() !== today.getMonth() ||
                    navigatedMonthDate.getFullYear() !== today.getFullYear() ||
                    navigatedMonthDate.getMonth() !== today.getMonth();
        }
        return (createElement("div", { className: css(rootClass, styles$3.root, className), role: "application" },
            createElement("div", Object.assign({}, nativeProps, { className: css('ms-DatePicker-picker ms-DatePicker-picker--opened ms-DatePicker-picker--focused', styles$3.picker, styles$3.pickerIsOpened, styles$3.pickerIsFocused, isMonthPickerVisible && 'ms-DatePicker-monthPickerVisible ' + styles$3.monthPickerVisible, isMonthPickerVisible && isDayPickerVisible && 'ms-DatePicker-calendarsInline ' + styles$3.calendarsInline, monthPickerOnly && 'ms-DatePicker-monthPickerOnly ' + styles$3.monthPickerOnly, showMonthPickerAsOverlay && 'ms-DatePicker-monthPickerAsOverlay ' + styles$3.monthPickerAsOverlay) }),
                createElement("div", { className: css('ms-DatePicker-holder ms-slideDownIn10', styles$3.holder, overlayedWithButton && styles$3.holderWithButton), onKeyDown: this._onDatePickerPopupKeyDown },
                    createElement("div", { className: css('ms-DatePicker-frame', styles$3.frame) },
                        createElement("div", { className: css('ms-DatePicker-wrap', styles$3.wrap, showGoToToday && styles$3.goTodaySpacing) },
                            isDayPickerVisible && (createElement(CalendarDay, { selectedDate: selectedDate, navigatedDate: navigatedDayDate, today: this.props.today, onSelectDate: this._onSelectDate, onNavigateDate: this._onNavigateDayDate, onDismiss: this.props.onDismiss, firstDayOfWeek: firstDayOfWeek, dateRangeType: dateRangeType, autoNavigateOnSelection: autoNavigateOnSelection, strings: strings, onHeaderSelect: onHeaderSelect, navigationIcons: navigationIcons, showWeekNumbers: this.props.showWeekNumbers, firstWeekOfYear: this.props.firstWeekOfYear, dateTimeFormatter: this.props.dateTimeFormatter, showSixWeeksByDefault: this.props.showSixWeeksByDefault, minDate: minDate, maxDate: maxDate, restrictedDates: restrictedDates, workWeekDays: this.props.workWeekDays, componentRef: this._dayPicker, showCloseButton: showCloseButton, allFocusable: allFocusable })),
                            isDayPickerVisible && isMonthPickerVisible && createElement("div", { className: styles$3.divider }),
                            isMonthPickerVisible && (createElement(CalendarMonth, { navigatedDate: navigatedMonthDate, selectedDate: navigatedDayDate, strings: strings, onNavigateDate: this._onNavigateMonthDate, today: this.props.today, highlightCurrentMonth: highlightCurrentMonth, highlightSelectedMonth: highlightSelectedMonth, onHeaderSelect: onHeaderSelect, navigationIcons: navigationIcons, dateTimeFormatter: this.props.dateTimeFormatter, minDate: minDate, maxDate: maxDate, componentRef: this._monthPicker, yearPickerHidden: yearPickerHidden || showMonthPickerAsOverlay })),
                            showGoToToday && (createElement("button", { role: "button", className: css('ms-DatePicker-goToday js-goToday', styles$3.goToday, {
                                    [styles$3.goTodayInlineMonth]: isMonthPickerVisible,
                                    [styles$3.goToTodayIsDisabled]: !goTodayEnabled
                                }), onClick: this._onGotoTodayClick, onKeyDown: this._onGotoTodayKeyDown, tabIndex: 0, disabled: !goTodayEnabled }, strings.goToToday))))))));
    }
    focus() {
        if (this.state.isDayPickerVisible && this._dayPicker.current) {
            this._dayPicker.current.focus();
        }
        else if (this.state.isMonthPickerVisible && this._monthPicker.current) {
            this._monthPicker.current.focus();
        }
    }
}
Calendar.defaultProps = {
    onSelectDate: undefined,
    onDismiss: undefined,
    isMonthPickerVisible: true,
    isDayPickerVisible: true,
    showMonthPickerAsOverlay: false,
    value: undefined,
    today: new Date(),
    firstDayOfWeek: DayOfWeek.Sunday,
    dateRangeType: DateRangeType.Day,
    autoNavigateOnSelection: false,
    showGoToToday: true,
    strings: null,
    highlightCurrentMonth: false,
    highlightSelectedMonth: false,
    navigationIcons: iconStrings,
    showWeekNumbers: false,
    firstWeekOfYear: FirstWeekOfYear.FirstDay,
    dateTimeFormatter: dateTimeFormatterCallbacks,
    showSixWeeksByDefault: false,
    workWeekDays: defaultWorkWeekDays,
    showCloseButton: false,
    allFocusable: false
};

const getClassNames$f = classNamesFunction();
class CheckBase extends BaseComponent {
    shouldComponentUpdate(newProps) {
        return this.props.checked !== newProps.checked || this.props.theme !== newProps.theme || this.props.className !== newProps.className;
    }
    render() {
        const { checked, className, theme, styles } = this.props;
        const classNames = getClassNames$f(styles, { theme: theme, className, checked });
        return (createElement("div", { className: classNames.root },
            createElement(Icon, { iconName: "CircleRing", className: classNames.circle }),
            createElement(Icon, { iconName: "StatusCircleCheckmark", className: classNames.check })));
    }
}
CheckBase.defaultProps = {
    checked: false
};

const GlobalClassNames$c = {
    root: 'ms-Check',
    circle: 'ms-Check-circle',
    check: 'ms-Check-check'
};
const getStyles$m = (props) => {
    const { checkBoxHeight = '18px', checked, className, theme } = props;
    const { palette, semanticColors } = theme;
    const isRTL = getRTL();
    const classNames = getGlobalClassNames(GlobalClassNames$c, theme);
    const sharedCircleCheck = {
        fontSize: checkBoxHeight,
        position: 'absolute',
        left: 0,
        top: 0,
        width: checkBoxHeight,
        height: checkBoxHeight,
        textAlign: 'center',
        verticalAlign: 'middle'
    };
    return {
        root: [
            classNames.root,
            theme.fonts.medium,
            {
                // lineHeight currently needs to be a string to output without 'px'
                lineHeight: '1',
                width: checkBoxHeight,
                height: checkBoxHeight,
                verticalAlign: 'top',
                position: 'relative',
                userSelect: 'none',
                selectors: {
                    ':before': {
                        content: '""',
                        position: 'absolute',
                        top: '1px',
                        right: '1px',
                        bottom: '1px',
                        left: '1px',
                        borderRadius: '50%',
                        opacity: 1,
                        background: semanticColors.bodyBackground
                    },
                    /**
                     * TODO: Come back to this once .checkHost has been
                     * converted to mergeStyles
                     */
                    '$checkHost:hover &, $checkHost:focus &, &:hover, &:focus': {
                        opacity: 1
                    }
                }
            },
            checked && [
                'is-checked',
                {
                    selectors: {
                        ':before': {
                            background: palette.themePrimary,
                            opacity: 1,
                            selectors: {
                                [HighContrastSelector]: {
                                    background: 'Window'
                                }
                            }
                        }
                    }
                }
            ],
            className
        ],
        circle: [
            classNames.circle,
            sharedCircleCheck,
            {
                color: palette.neutralTertiaryAlt,
                selectors: {
                    [HighContrastSelector]: {
                        color: 'WindowText'
                    }
                }
            },
            checked && {
                color: palette.white
            }
        ],
        check: [
            classNames.check,
            sharedCircleCheck,
            {
                opacity: 0,
                color: palette.neutralTertiaryAlt,
                fontSize: '16px',
                left: isRTL ? '-0.5px' : '.5px',
                selectors: {
                    ':hover': {
                        opacity: 1
                    },
                    [HighContrastSelector]: {
                        MsHighContrastAdjust: 'none'
                    }
                }
            },
            checked && {
                opacity: 1,
                color: palette.white,
                fontWeight: 900,
                selectors: {
                    [HighContrastSelector]: {
                        border: 'none',
                        color: 'WindowText'
                    }
                }
            }
        ],
        checkHost: [{}]
    };
};

const Check = styled(CheckBase, getStyles$m, undefined, {
    scope: 'Check'
});

const getClassNames$g = classNamesFunction();
class CheckboxBase extends BaseComponent {
    /**
     * Initialize a new instance of the Checkbox
     * @param props - Props for the component
     * @param context - Context or initial state for the base component.
     */
    constructor(props, context) {
        super(props, context);
        this._checkBox = createRef();
        this._onFocus = (ev) => {
            const { inputProps } = this.props;
            if (inputProps && inputProps.onFocus) {
                inputProps.onFocus(ev);
            }
        };
        this._onBlur = (ev) => {
            const { inputProps } = this.props;
            if (inputProps && inputProps.onBlur) {
                inputProps.onBlur(ev);
            }
        };
        this._onChange = (ev) => {
            const { disabled, onChange } = this.props;
            const { isChecked } = this.state;
            if (!disabled) {
                if (onChange) {
                    onChange(ev, !isChecked);
                }
                if (this.props.checked === undefined) {
                    this.setState({ isChecked: !isChecked });
                }
            }
        };
        this._onRenderLabel = (props) => {
            const { label } = props;
            return label ? createElement("span", { className: this._classNames.text }, label) : null;
        };
        this._warnMutuallyExclusive({
            checked: 'defaultChecked'
        });
        this._id = this.props.id || getId('checkbox-');
        this.state = {
            isChecked: !!(props.checked !== undefined ? props.checked : props.defaultChecked)
        };
    }
    componentWillReceiveProps(newProps) {
        if (newProps.checked !== undefined) {
            this.setState({
                isChecked: !!newProps.checked // convert null to false
            });
        }
    }
    /**
     * Render the Checkbox based on passed props
     */
    render() {
        const { checked, className, defaultChecked, disabled, inputProps, name, boxSide, theme, ariaLabel, ariaLabelledBy, ariaDescribedBy, styles, onRenderLabel = this._onRenderLabel, checkmarkIconProps, ariaPositionInSet, ariaSetSize, keytipProps, title } = this.props;
        const isChecked = checked === undefined ? this.state.isChecked : checked;
        const isReversed = boxSide !== 'start' ? true : false;
        this._classNames = getClassNames$g(styles, {
            theme: theme,
            className,
            disabled,
            checked: isChecked,
            reversed: isReversed,
            isUsingCustomLabelRender: onRenderLabel !== this._onRenderLabel
        });
        return (createElement(KeytipData, { keytipProps: keytipProps, disabled: disabled }, (keytipAttributes) => (createElement("div", { className: this._classNames.root },
            createElement("input", Object.assign({ type: "checkbox" }, inputProps, { "data-ktp-execute-target": keytipAttributes['data-ktp-execute-target'] }, checked !== undefined && { checked }, defaultChecked !== undefined && { defaultChecked }, { disabled: disabled, className: this._classNames.input, ref: this._checkBox, name: name, id: this._id, title: title, onChange: this._onChange, onFocus: this._onFocus, onBlur: this._onBlur, "aria-disabled": disabled, "aria-label": ariaLabel, "aria-labelledby": ariaLabelledBy, "aria-describedby": mergeAriaAttributeValues(ariaDescribedBy, keytipAttributes['aria-describedby']), "aria-posinset": ariaPositionInSet, "aria-setsize": ariaSetSize })),
            createElement("label", { className: this._classNames.label, htmlFor: this._id },
                createElement("div", { className: this._classNames.checkbox, "data-ktp-target": keytipAttributes['data-ktp-target'] },
                    createElement(Icon, Object.assign({ iconName: "CheckMark" }, checkmarkIconProps, { className: this._classNames.checkmark }))),
                onRenderLabel(this.props, this._onRenderLabel))))));
    }
    get checked() {
        return this.state.isChecked;
    }
    focus() {
        if (this._checkBox.current) {
            this._checkBox.current.focus();
        }
    }
}
CheckboxBase.defaultProps = {
    boxSide: 'start'
};

const MS_CHECKBOX_LABEL_SIZE = '20px';
const MS_CHECKBOX_TRANSITION_DURATION = '200ms';
const MS_CHECKBOX_TRANSITION_TIMING = 'cubic-bezier(.4, 0, .23, 1)';
const getStyles$n = (props) => {
    const { className, theme, reversed, checked, disabled, isUsingCustomLabelRender } = props;
    const { semanticColors } = theme;
    const checkmarkFontColor = semanticColors.inputForegroundChecked;
    const checkmarkFontColorCheckedDisabled = semanticColors.disabledBackground;
    const checkmarkFontColorHovered = semanticColors.inputBorder;
    const checkboxBorderColor = semanticColors.smallInputBorder;
    const checkboxBorderColorChecked = semanticColors.inputBackgroundChecked;
    const checkboxBorderColorDisabled = semanticColors.disabledBodySubtext;
    const checkboxBorderHoveredColor = semanticColors.inputBorderHovered;
    const checkboxBackgroundChecked = semanticColors.inputBackgroundChecked;
    const checkboxBackgroundCheckedHovered = semanticColors.inputBackgroundCheckedHovered;
    const checkboxBorderColorCheckedHovered = semanticColors.inputBackgroundCheckedHovered;
    const checkboxHoveredTextColor = semanticColors.bodyText;
    const checkboxBackgroundDisabledChecked = semanticColors.disabledBodySubtext;
    const checkboxTextColor = semanticColors.bodyText;
    const checkboxTextColorDisabled = semanticColors.disabledText;
    return {
        root: [
            'ms-Checkbox',
            {
                position: 'relative',
                display: 'flex'
            },
            reversed && 'reversed',
            checked && 'is-checked',
            !disabled && 'is-enabled',
            disabled && 'is-disabled',
            !disabled && [
                !checked && {
                    selectors: {
                        ':hover .ms-Checkbox-checkbox': {
                            borderColor: checkboxBorderHoveredColor,
                            selectors: {
                                [HighContrastSelector]: {
                                    borderColor: 'Highlight'
                                }
                            }
                        },
                        ':focus .ms-Checkbox-checkbox': { borderColor: checkboxBorderHoveredColor },
                        ':hover .ms-Checkbox-checkmark': {
                            color: checkmarkFontColorHovered,
                            opacity: '1',
                            selectors: {
                                [HighContrastSelector]: {
                                    color: 'Highlight'
                                }
                            }
                        }
                    }
                },
                checked && {
                    selectors: {
                        ':hover .ms-Checkbox-checkbox': {
                            background: checkboxBackgroundCheckedHovered,
                            borderColor: checkboxBorderColorCheckedHovered
                        },
                        ':focus .ms-Checkbox-checkbox': {
                            background: checkboxBackgroundCheckedHovered,
                            borderColor: checkboxBorderColorCheckedHovered
                        },
                        [HighContrastSelector]: {
                            selectors: {
                                ':hover .ms-Checkbox-checkbox': {
                                    background: 'Window',
                                    borderColor: 'Highlight'
                                },
                                ':focus .ms-Checkbox-checkbox': {
                                    background: 'Highlight'
                                },
                                ':focus:hover .ms-Checkbox-checkbox': {
                                    background: 'Highlight'
                                },
                                ':focus:hover .ms-Checkbox-checkmark': {
                                    color: 'Window'
                                },
                                ':hover .ms-Checkbox-checkmark': {
                                    color: 'Highlight'
                                }
                            }
                        }
                    }
                },
                {
                    selectors: {
                        ':hover .ms-Checkbox-text': { color: checkboxHoveredTextColor },
                        ':focus .ms-Checkbox-text': { color: checkboxHoveredTextColor }
                    }
                }
            ],
            className
        ],
        input: [
            {
                position: 'absolute',
                background: 'none',
                opacity: 0,
                selectors: {
                    [`.${IsFocusVisibleClassName} &:focus + label::before`]: {
                        outline: '1px solid ' + theme.palette.neutralSecondary,
                        outlineOffset: '2px',
                        selectors: {
                            [HighContrastSelector]: {
                                outline: '1px solid ActiveBorder'
                            }
                        }
                    }
                }
            }
        ],
        label: [
            'ms-Checkbox-label',
            theme.fonts.medium,
            {
                display: 'flex',
                alignItems: isUsingCustomLabelRender ? 'center' : 'flex-start',
                cursor: disabled ? 'default' : 'pointer',
                position: 'relative',
                userSelect: 'none',
                textAlign: 'left'
            },
            reversed && {
                flexDirection: 'row-reverse',
                justifyContent: 'flex-end'
            },
            {
                selectors: {
                    '&::before': {
                        position: 'absolute',
                        left: 0,
                        right: 0,
                        top: 0,
                        bottom: 0,
                        content: '""',
                        pointerEvents: 'none'
                    }
                }
            }
        ],
        checkbox: [
            'ms-Checkbox-checkbox',
            {
                display: 'flex',
                flexShrink: 0,
                alignItems: 'center',
                justifyContent: 'center',
                height: MS_CHECKBOX_LABEL_SIZE,
                width: MS_CHECKBOX_LABEL_SIZE,
                borderWidth: '1px',
                borderStyle: 'solid',
                borderColor: checkboxBorderColor,
                boxSizing: 'border-box',
                transitionProperty: 'background, border, border-color',
                transitionDuration: MS_CHECKBOX_TRANSITION_DURATION,
                transitionTimingFunction: MS_CHECKBOX_TRANSITION_TIMING,
                /* in case the icon is bigger than the box */
                overflow: 'hidden'
            },
            !reversed
                ? // this margin on the checkbox is for backwards compat.
                    // notably it has the effect where a customRender is used, there will be only a 4px margin from checkbox to label.
                    // the label by default would have another 4px margin for a total of 8px margin between checkbox and label.
                    // we don't combine the two (and move it into the text) to not incur a breaking change for everyone using custom render atm.
                    {
                        marginRight: 4
                    }
                : {
                    marginLeft: 4
                },
            !disabled &&
                checked && {
                background: checkboxBackgroundChecked,
                borderColor: checkboxBorderColorChecked,
                selectors: {
                    [HighContrastSelector]: {
                        background: 'Highlight',
                        borderColor: 'Highlight'
                    }
                }
            },
            disabled && {
                borderColor: checkboxBorderColorDisabled,
                selectors: {
                    [HighContrastSelector]: {
                        borderColor: 'InactiveBorder'
                    }
                }
            },
            checked &&
                disabled && {
                background: checkboxBackgroundDisabledChecked,
                borderColor: checkboxBorderColorDisabled
            }
        ],
        checkmark: [
            'ms-Checkbox-checkmark',
            {
                opacity: checked ? '1' : '0',
                color: checked && disabled ? checkmarkFontColorCheckedDisabled : checkmarkFontColor,
                selectors: {
                    [HighContrastSelector]: {
                        color: disabled ? 'InactiveBorder' : 'Window',
                        MsHighContrastAdjust: 'none'
                    }
                }
            }
        ],
        text: [
            'ms-Checkbox-text',
            {
                color: disabled ? checkboxTextColorDisabled : checkboxTextColor,
                fontSize: FontSizes.medium,
                lineHeight: '20px'
            },
            !reversed
                ? {
                    marginLeft: 4
                }
                : {
                    marginRight: 4
                },
            disabled && {
                selectors: {
                    [HighContrastSelector]: {
                        // backwards compat for the color of the text when the checkbox was rendered
                        // using a Button.
                        color: 'InactiveBorder'
                    }
                }
            }
        ]
    };
};

const Checkbox = styled(CheckboxBase, getStyles$n, undefined, { scope: 'Checkbox' });

const getClassNames$h = classNamesFunction();
class LabelBase extends BaseComponent {
    render() {
        const { as: RootType = 'label', children, className, disabled, styles, required, theme } = this.props;
        const classNames = getClassNames$h(styles, {
            className,
            disabled,
            required,
            theme: theme
        });
        //@ts-ignore
        return (createElement(RootType, Object.assign({}, getNativeProps(this.props, divProperties), { className: classNames.root }), children));
    }
}

const getStyles$o = (props) => {
    const { theme, className, disabled, required } = props;
    return {
        root: [
            'ms-Label',
            theme.fonts.medium,
            {
                color: theme.semanticColors.bodyText,
                boxSizing: 'border-box',
                boxShadow: 'none',
                margin: 0,
                display: 'block',
                padding: '5px 0',
                wordWrap: 'break-word',
                overflowWrap: 'break-word'
            },
            disabled && {
                color: theme.semanticColors.disabledBodyText,
                selectors: {
                    [HighContrastSelector]: {
                        color: 'GrayText'
                    }
                }
            },
            required && {
                selectors: {
                    '::after': {
                        content: `' *'`,
                        color: theme.semanticColors.errorText,
                        paddingRight: 12
                    }
                }
            },
            className
        ]
    };
};

const Label = styled(LabelBase, getStyles$o, undefined, {
    scope: 'Label'
});

const getClassNames$i = classNamesFunction();
class ChoiceGroupOptionBase extends BaseComponent {
    constructor(props) {
        super(props);
        this._inputElement = createRef();
        this._onRenderField = (props) => {
            const { onRenderLabel = this._onRenderLabel, id, imageSrc, imageAlt, selectedImageSrc, iconProps } = props;
            const imageSize = props.imageSize ? props.imageSize : { width: 32, height: 32 };
            return (createElement("label", { htmlFor: id, className: this._classNames.field },
                imageSrc && (createElement("div", { className: this._classNames.innerField, style: { height: imageSize.height, width: imageSize.width } },
                    createElement("div", { className: this._classNames.imageWrapper },
                        createElement(Image, { src: imageSrc, alt: imageAlt ? imageAlt : '', width: imageSize.width, height: imageSize.height })),
                    createElement("div", { className: this._classNames.selectedImageWrapper },
                        createElement(Image, { src: selectedImageSrc, alt: imageAlt ? imageAlt : '', width: imageSize.width, height: imageSize.height })))),
                iconProps ? (createElement("div", { className: this._classNames.innerField },
                    createElement("div", { className: this._classNames.iconWrapper },
                        createElement(Icon, Object.assign({}, iconProps))))) : null,
                imageSrc || iconProps ? (createElement("div", { className: this._classNames.labelWrapper, style: { maxWidth: imageSize.width * 2 } }, onRenderLabel(props))) : (onRenderLabel(props))));
        };
        this._onRenderLabel = (props) => {
            return (createElement("span", { id: props.labelId, className: "ms-ChoiceFieldLabel" }, props.text));
        };
    }
    render() {
        const { ariaLabel, focused, required, theme, iconProps, imageSrc, imageSize = { width: 32, height: 32 }, disabled, checked, id, styles, name, onRenderField = this._onRenderField } = this.props;
        this._classNames = getClassNames$i(styles, {
            theme: theme,
            hasIcon: !!iconProps,
            hasImage: !!imageSrc,
            checked,
            disabled,
            imageIsLarge: !!imageSrc && (imageSize.width > 71 || imageSize.height > 71),
            focused
        });
        const { className, ...nativeProps } = getNativeProps(this.props, inputProperties);
        return (createElement("div", { className: this._classNames.root },
            createElement("div", { className: this._classNames.choiceFieldWrapper },
                createElement("input", Object.assign({ "aria-label": ariaLabel ? ariaLabel : undefined, ref: this._inputElement, id: id, className: css(this._classNames.input, className), type: "radio", name: name, disabled: disabled, checked: checked, required: required, onChange: this._onChange.bind(this, this.props), onFocus: this._onFocus.bind(this, this.props), onBlur: this._onBlur.bind(this, this.props) }, nativeProps)),
                onRenderField(this.props, this._onRenderField))));
    }
    _onChange(props, evt) {
        const { onChange } = props;
        if (onChange) {
            onChange(evt, props);
        }
    }
    _onBlur(props, evt) {
        const { onBlur } = props;
        if (onBlur) {
            onBlur(evt, props);
        }
    }
    _onFocus(props, evt) {
        const { onFocus } = props;
        if (onFocus) {
            onFocus(evt, props);
        }
    }
}

const GlobalClassNames$d = {
    root: 'ms-ChoiceField',
    choiceFieldWrapper: 'ms-ChoiceField-wrapper',
    input: 'ms-ChoiceField-input',
    field: 'ms-ChoiceField-field',
    innerField: 'ms-ChoiceField-innerField',
    imageWrapper: 'ms-ChoiceField-imageWrapper',
    iconWrapper: 'ms-ChoiceField-iconWrapper',
    labelWrapper: 'ms-ChoiceField-labelWrapper'
};
const labelWrapperLineHeight = 15;
const iconSize = 32;
const choiceFieldSize = 20;
const choiceFieldTransitionDuration = '200ms';
const choiceFieldTransitionTiming = 'cubic-bezier(.4, 0, .23, 1)';
const radioButtonSpacing = 3;
const radioButtonInnerSize = 5;
function getChoiceGroupFocusStyle(palette, hasIconOrImage) {
    return [
        'is-inFocus',
        {
            selectors: {
                [`.${IsFocusVisibleClassName} &`]: {
                    position: 'relative',
                    outline: 'transparent',
                    selectors: {
                        '::-moz-focus-inner': {
                            border: 0
                        },
                        ':after': {
                            content: '""',
                            top: -2,
                            right: -2,
                            bottom: -2,
                            left: -2,
                            pointerEvents: 'none',
                            border: '1px solid ' + (hasIconOrImage ? palette.neutralSecondary : palette.neutralPrimary),
                            position: 'absolute',
                            selectors: {
                                [HighContrastSelector]: {
                                    borderColor: 'WindowText',
                                    borderWidth: hasIconOrImage ? 1 : 2
                                }
                            }
                        }
                    }
                }
            }
        }
    ];
}
function getImageWrapperStyle(isSelectedImageWrapper, className, checked) {
    return [
        className,
        {
            paddingBottom: 2,
            transitionProperty: 'opacity',
            transitionDuration: choiceFieldTransitionDuration,
            transitionTimingFunction: 'ease',
            selectors: {
                '.ms-Image': {
                    display: 'inline-block',
                    borderStyle: 'none'
                }
            }
        },
        (checked ? !isSelectedImageWrapper : isSelectedImageWrapper) && [
            'is-hidden',
            {
                position: 'absolute',
                left: 0,
                top: 0,
                width: '100%',
                height: '100%',
                overflow: 'hidden',
                opacity: 0
            }
        ]
    ];
}
const getStyles$p = (props) => {
    const { theme, hasIcon, hasImage, checked, disabled, imageIsLarge, focused } = props;
    const { palette, semanticColors } = theme;
    const classNames = getGlobalClassNames(GlobalClassNames$d, theme);
    const fieldHoverOrFocusProperties = {
        selectors: {
            '.ms-ChoiceFieldLabel': {
                color: semanticColors.bodyTextChecked
            },
            ':before': {
                borderColor: checked ? semanticColors.inputBackgroundCheckedHovered : semanticColors.inputBorderHovered
            }
        }
    };
    const enabledFieldWithImageHoverOrFocusProperties = {
        borderColor: checked ? palette.themeDark : palette.neutralTertiaryAlt,
        selectors: {
            ':before': {
                opacity: 1,
                borderColor: checked ? palette.themeDark : semanticColors.inputBorderHovered
            }
        }
    };
    const circleAreaProperties = [
        {
            content: '""',
            display: 'inline-block',
            backgroundColor: semanticColors.bodyBackground,
            borderWidth: 1,
            borderStyle: 'solid',
            borderColor: semanticColors.smallInputBorder,
            width: choiceFieldSize,
            height: choiceFieldSize,
            fontWeight: 'normal',
            position: 'absolute',
            top: 0,
            left: 0,
            boxSizing: 'border-box',
            transitionProperty: 'border-color',
            transitionDuration: choiceFieldTransitionDuration,
            transitionTimingFunction: choiceFieldTransitionTiming,
            borderRadius: '50%'
        },
        disabled && {
            backgroundColor: checked ? semanticColors.bodyBackground : semanticColors.disabledText,
            borderColor: semanticColors.disabledText,
            selectors: {
                [HighContrastSelector]: {
                    color: 'GrayText'
                }
            }
        },
        checked && {
            borderWidth: 1,
            borderStyle: 'solid',
            borderColor: semanticColors.inputBackgroundChecked,
            selectors: {
                [HighContrastSelector]: {
                    borderColor: 'Highlight'
                }
            }
        },
        (hasIcon || hasImage) && {
            top: radioButtonSpacing,
            right: radioButtonSpacing,
            left: 'auto',
            opacity: !disabled && checked ? 1 : 0
        }
    ];
    const dotAreaProperties = [
        {
            content: '""',
            width: 0,
            height: 0,
            borderRadius: '50%',
            position: 'absolute',
            left: choiceFieldSize / 2,
            right: 0,
            transitionProperty: 'border-width',
            transitionDuration: choiceFieldTransitionDuration,
            transitionTimingFunction: choiceFieldTransitionTiming,
            boxSizing: 'border-box'
        },
        checked && {
            borderWidth: 5,
            borderStyle: 'solid',
            borderColor: semanticColors.inputBackgroundChecked,
            left: 5,
            top: 5,
            width: 10,
            height: 10,
            selectors: {
                [HighContrastSelector]: {
                    borderColor: 'Highlight'
                }
            }
        },
        checked &&
            (hasIcon || hasImage) && {
            top: radioButtonSpacing + radioButtonInnerSize,
            right: radioButtonSpacing + radioButtonInnerSize,
            left: 'auto' // To reset the value of 'left' to its default value, so that 'right' works
        }
    ];
    return {
        root: [
            classNames.root,
            theme.fonts.medium,
            {
                display: 'flex',
                alignItems: 'center',
                boxSizing: 'border-box',
                color: semanticColors.bodyText,
                fontSize: FontSizes.medium,
                fontWeight: FontWeights.regular,
                minHeight: 26,
                border: 'none',
                position: 'relative',
                marginTop: 8,
                selectors: {
                    '.ms-ChoiceFieldLabel': {
                        fontSize: FontSizes.medium,
                        display: 'inline-block'
                    }
                }
            },
            !hasIcon &&
                !hasImage && {
                selectors: {
                    '.ms-ChoiceFieldLabel': {
                        paddingLeft: '26px'
                    }
                }
            },
            hasImage && 'ms-ChoiceField--image',
            hasIcon && 'ms-ChoiceField--icon',
            (hasIcon || hasImage) && {
                display: 'inline-flex',
                fontSize: 0,
                margin: '0 4px 4px 0',
                paddingLeft: 0,
                backgroundColor: palette.neutralLighter,
                height: '100%'
            }
        ],
        choiceFieldWrapper: [classNames.choiceFieldWrapper, focused && getChoiceGroupFocusStyle(palette, hasIcon || hasImage)],
        // The hidden input
        input: [
            classNames.input,
            {
                position: 'absolute',
                opacity: 0,
                top: 8
            },
            (hasIcon || hasImage) && {
                top: 0,
                right: 0,
                opacity: 0,
                width: '100%',
                height: '100%',
                margin: 0
            }
        ],
        field: [
            classNames.field,
            {
                display: 'inline-block',
                cursor: 'pointer',
                marginTop: 0,
                position: 'relative',
                verticalAlign: 'top',
                userSelect: 'none',
                minHeight: 20,
                selectors: {
                    ':hover': !disabled && fieldHoverOrFocusProperties,
                    ':focus': !disabled && fieldHoverOrFocusProperties,
                    // The circle
                    ':before': circleAreaProperties,
                    // The dot
                    ':after': dotAreaProperties
                }
            },
            hasIcon && 'ms-ChoiceField--icon',
            hasImage && 'ms-ChoiceField-field--image',
            (hasIcon || hasImage) && {
                boxSizing: 'content-box',
                cursor: 'pointer',
                paddingTop: 22,
                margin: 0,
                textAlign: 'center',
                transitionProperty: 'all',
                transitionDuration: choiceFieldTransitionDuration,
                transitionTimingFunction: 'ease',
                border: '2px solid transparent',
                justifyContent: 'center',
                alignItems: 'center',
                display: 'flex',
                flexDirection: 'column'
            },
            checked && {
                borderColor: palette.themePrimary
            },
            (hasIcon || hasImage) &&
                !disabled && {
                selectors: {
                    ':hover': enabledFieldWithImageHoverOrFocusProperties,
                    ':focus': enabledFieldWithImageHoverOrFocusProperties
                }
            },
            disabled && {
                cursor: 'default',
                selectors: {
                    '.ms-ChoiceFieldLabel': {
                        color: semanticColors.disabledBodyText
                    },
                    [HighContrastSelector]: {
                        color: 'GrayText'
                    }
                }
            }
        ],
        innerField: [
            classNames.innerField,
            (hasIcon || hasImage) && {
                position: 'relative',
                display: 'inline-block',
                paddingLeft: 30,
                paddingRight: 30
            },
            (hasIcon || hasImage) &&
                imageIsLarge && {
                paddingLeft: 24,
                paddingRight: 24
            },
            (hasIcon || hasImage) &&
                disabled && {
                opacity: 0.25,
                selectors: {
                    [HighContrastSelector]: {
                        color: 'GrayText',
                        opacity: 1
                    }
                }
            }
        ],
        imageWrapper: getImageWrapperStyle(false, classNames.imageWrapper, checked),
        selectedImageWrapper: getImageWrapperStyle(true, classNames.imageWrapper, checked),
        iconWrapper: [
            classNames.iconWrapper,
            {
                fontSize: iconSize,
                lineHeight: iconSize,
                height: iconSize
            }
        ],
        labelWrapper: [
            classNames.labelWrapper,
            (hasIcon || hasImage) && {
                display: 'block',
                position: 'relative',
                margin: '4px 8px',
                height: labelWrapperLineHeight * 2,
                lineHeight: labelWrapperLineHeight,
                overflow: 'hidden',
                whiteSpace: 'pre-wrap',
                textOverflow: 'ellipsis',
                fontSize: FontSizes.medium,
                fontWeight: FontWeights.regular
            }
        ]
    };
};

const ChoiceGroupOption = styled(ChoiceGroupOptionBase, getStyles$p, undefined, { scope: 'ChoiceGroupOption' });

const getClassNames$j = classNamesFunction();
class ChoiceGroupBase extends BaseComponent {
    constructor(props) {
        super(props);
        this._inputElement = createRef();
        this.focusedVars = {};
        this.changedVars = {};
        this._onFocus = (key) => this.focusedVars[key]
            ? this.focusedVars[key]
            : (this.focusedVars[key] = (ev, option) => {
                this.setState({
                    keyFocused: key,
                    keyChecked: this.state.keyChecked
                });
            });
        this._onBlur = (ev, option) => {
            this.setState({
                keyFocused: undefined,
                keyChecked: this.state.keyChecked
            });
        };
        this._onChange = (key) => this.changedVars[key]
            ? this.changedVars[key]
            : (this.changedVars[key] = (evt, option) => {
                const { onChanged, onChange, selectedKey, options = [] } = this.props;
                // Only manage state in uncontrolled scenarios.
                if (selectedKey === undefined) {
                    this.setState({
                        keyChecked: key
                    });
                }
                const originalOption = find(options, (value) => value.key === key);
                // TODO: onChanged deprecated, remove else if after 07/17/2017 when onChanged has been removed.
                if (onChange) {
                    onChange(evt, originalOption);
                }
                else if (onChanged) {
                    onChanged(originalOption);
                }
            });
        this._warnDeprecations({ onChanged: 'onChange' });
        this._warnMutuallyExclusive({
            selectedKey: 'defaultSelectedKey'
        });
        this.state = {
            keyChecked: props.defaultSelectedKey === undefined ? this._getKeyChecked(props) : props.defaultSelectedKey,
            keyFocused: undefined
        };
        this._id = getId('ChoiceGroup');
        this._labelId = getId('ChoiceGroupLabel');
    }
    componentWillReceiveProps(newProps) {
        const newKeyChecked = this._getKeyChecked(newProps);
        const oldKeyChecked = this._getKeyChecked(this.props);
        if (newKeyChecked !== oldKeyChecked) {
            this.setState({
                keyChecked: newKeyChecked
            });
        }
    }
    render() {
        const { className, theme, styles, options, label, required, disabled, name, role } = this.props;
        const { keyChecked, keyFocused } = this.state;
        const classNames = getClassNames$j(styles, {
            theme: theme,
            className,
            optionsContainIconOrImage: options.some(option => Boolean(option.iconProps || option.imageSrc))
        });
        const ariaLabelledBy = this.props.ariaLabelledBy
            ? this.props.ariaLabelledBy
            : label
                ? this._id + '-label'
                : this.props['aria-labelledby'];
        // In cases where no option is checked, set focusable to first enabled option so that ChoiceGroup remains focusable.
        // If no options are enabled, ChoiceGroup is not focusable. If any option is checked, do not set keyDefaultFocusable.
        const firstEnabledOption = disabled || options === undefined ? undefined : find(options, option => !option.disabled);
        const keyDefaultFocusable = keyChecked === undefined && firstEnabledOption ? firstEnabledOption.key : undefined;
        return (createElement("div", { role: role, className: classNames.applicationRole },
            createElement("div", Object.assign({ className: classNames.root, role: "radiogroup" }, ariaLabelledBy && { 'aria-labelledby': ariaLabelledBy }),
                label && (createElement(Label, { className: classNames.label, required: required, id: this._id + '-label' }, label)),
                createElement("div", { className: classNames.flexContainer }, options.map((option) => {
                    const innerOptionProps = {
                        ...option,
                        focused: option.key === keyFocused,
                        checked: option.key === keyChecked,
                        'data-is-focusable': option.key === keyChecked || option.key === keyDefaultFocusable ? true : false,
                        disabled: option.disabled || disabled,
                        id: `${this._id}-${option.key}`,
                        labelId: `${this._labelId}-${option.key}`,
                        name: name || this._id,
                        required
                    };
                    return (createElement(ChoiceGroupOption, Object.assign({ key: option.key, onBlur: this._onBlur, onFocus: this._onFocus(option.key), onChange: this._onChange(option.key) }, innerOptionProps)));
                })))));
    }
    focus() {
        const { options } = this.props;
        if (options) {
            for (const option of options) {
                const elementToFocus = document.getElementById(`${this._id}-${option.key}`);
                if (elementToFocus && elementToFocus.getAttribute('data-is-focusable') === 'true') {
                    elementToFocus.focus(); // focus on checked or default focusable key
                    return;
                }
            }
        }
        if (this._inputElement.current) {
            this._inputElement.current.focus();
        }
    }
    _getKeyChecked(props) {
        if (props.selectedKey !== undefined) {
            return props.selectedKey;
        }
        const { options = [] } = props;
        const optionsChecked = options.filter((option) => {
            return option.checked;
        });
        if (optionsChecked.length === 0) {
            return undefined;
        }
        else {
            return optionsChecked[0].key;
        }
    }
}
ChoiceGroupBase.defaultProps = {
    options: []
};

const GlobalClassNames$e = {
    root: 'ms-ChoiceFieldGroup',
    flexContainer: 'ms-ChoiceFieldGroup-flexContainer'
};
const getStyles$q = (props) => {
    const { className, optionsContainIconOrImage, theme } = props;
    const classNames = getGlobalClassNames(GlobalClassNames$e, theme);
    return {
        applicationRole: className,
        root: [
            classNames.root,
            theme.fonts.medium,
            {
                display: 'block'
            }
        ],
        flexContainer: [
            classNames.flexContainer,
            optionsContainIconOrImage && {
                display: 'flex',
                flexDirection: 'row',
                flexWrap: 'wrap'
            }
        ]
    };
};

const ChoiceGroup = styled(ChoiceGroupBase, getStyles$q, undefined, { scope: 'ChoiceGroup' });

const COACHMARK_WIDTH = 32;
const COACHMARK_HEIGHT = 32;
const translateOne = keyframes({
    '0%': {
        transform: 'translate(0, 0)',
        animationTimingFunction: 'linear'
    },
    '78.57%': {
        transform: 'translate(0, 0)',
        animationTimingFunction: 'cubic-bezier(0.62, 0, 0.56, 1)'
    },
    '82.14%': {
        transform: 'translate(0, -5px)',
        animationTimingFunction: 'cubic-bezier(0.58, 0, 0, 1)'
    },
    '84.88%': {
        transform: 'translate(0, 9px)',
        animationTimingFunction: 'cubic-bezier(1, 0, 0.56, 1)'
    },
    '88.1%': {
        transform: 'translate(0, -2px)',
        animationTimingFunction: 'cubic-bezier(0.58, 0, 0.67, 1)'
    },
    '90.12%': {
        transform: 'translate(0, 0)',
        animationTimingFunction: 'linear'
    },
    '100%': {
        transform: 'translate(0, 0)'
    }
});
const scaleOne = keyframes({
    '0%': {
        transform: ' scale(0)',
        animationTimingFunction: 'linear'
    },
    '14.29%': {
        transform: 'scale(0)',
        animationTimingFunction: 'cubic-bezier(0.84, 0, 0.52, 0.99)'
    },
    '16.67%': {
        transform: 'scale(1.15)',
        animationTimingFunction: 'cubic-bezier(0.48, -0.01, 0.52, 1.01)'
    },
    '19.05%': {
        transform: 'scale(0.95)',
        animationTimingFunction: 'cubic-bezier(0.48, 0.02, 0.52, 0.98)'
    },
    '21.43%': {
        transform: 'scale(1)',
        animationTimingFunction: 'linear'
    },
    '42.86%': {
        transform: 'scale(1)',
        animationTimingFunction: 'cubic-bezier(0.48, -0.02, 0.52, 1.02)'
    },
    '45.71%': {
        transform: 'scale(0.8)',
        animationTimingFunction: 'cubic-bezier(0.48, 0.01, 0.52, 0.99)'
    },
    '50%': {
        transform: 'scale(1)',
        animationTimingFunction: 'linear'
    },
    '90.12%': {
        transform: 'scale(1)',
        animationTimingFunction: 'cubic-bezier(0.48, -0.02, 0.52, 1.02)'
    },
    '92.98%': {
        transform: 'scale(0.8)',
        animationTimingFunction: 'cubic-bezier(0.48, 0.01, 0.52, 0.99)'
    },
    '97.26%': {
        transform: 'scale(1)',
        animationTimingFunction: 'linear'
    },
    '100%': {
        transform: 'scale(1)'
    }
});
const rotateOne = keyframes({
    '0%': {
        transform: 'rotate(0deg)',
        animationTimingFunction: 'linear'
    },
    '83.33%': {
        transform: ' rotate(0deg)',
        animationTimingFunction: 'cubic-bezier(0.33, 0, 0.67, 1)'
    },
    '83.93%': {
        transform: 'rotate(15deg)',
        animationTimingFunction: 'cubic-bezier(0.33, 0, 0.67, 1)'
    },
    '84.52%': {
        transform: 'rotate(-15deg)',
        animationTimingFunction: 'cubic-bezier(0.33, 0, 0.67, 1)'
    },
    '85.12%': {
        transform: 'rotate(15deg)',
        animationTimingFunction: 'cubic-bezier(0.33, 0, 0.67, 1)'
    },
    '85.71%': {
        transform: 'rotate(-15deg)',
        animationTimingFunction: 'cubic-bezier(0.33, 0, 0.67, 1)'
    },
    '86.31%': {
        transform: 'rotate(0deg)',
        animationTimingFunction: 'linear'
    },
    '100%': {
        transform: 'rotate(0deg)'
    }
});
function getStyles$r(props, theme = getTheme()) {
    const animationInnerDimension = '35px';
    const animationOuterDimension = '150px';
    const animationBorderWidth = '10px';
    const ContinuousPulse = PulsingBeaconAnimationStyles.continuousPulseAnimationDouble(props.beaconColorOne ? props.beaconColorOne : theme.palette.themePrimary, props.beaconColorTwo ? props.beaconColorTwo : theme.palette.themeTertiary, animationInnerDimension, animationOuterDimension, animationBorderWidth);
    const ContinuousPulseAnimation = PulsingBeaconAnimationStyles.createDefaultAnimation(ContinuousPulse, props.delayBeforeCoachmarkAnimation);
    return {
        root: [
            theme.fonts.medium,
            {
                position: 'relative'
            }
        ],
        pulsingBeacon: [
            {
                position: 'absolute',
                top: '50%',
                left: '50%',
                transform: 'translate(-50%, -50%)',
                width: '0px',
                height: '0px',
                borderRadius: '225px',
                borderStyle: 'solid',
                opacity: '0'
            },
            props.isCollapsed && props.isBeaconAnimating && ContinuousPulseAnimation
        ],
        // Translate Animation Layer
        translateAnimationContainer: [
            {
                width: '100%',
                height: '100%'
            },
            props.isCollapsed && {
                animationDuration: '14s',
                animationTimingFunction: 'linear',
                animationDirection: 'normal',
                animationIterationCount: '1',
                animationDelay: '0s',
                animationFillMode: 'forwards',
                animationName: translateOne,
                transition: 'opacity 0.5s ease-in-out'
            },
            !props.isCollapsed && {
                opacity: '1'
            }
        ],
        // Scale Animation Layer
        scaleAnimationLayer: [
            {
                width: '100%',
                height: '100%'
            },
            props.isCollapsed && {
                animationDuration: '14s',
                animationTimingFunction: 'linear',
                animationDirection: 'normal',
                animationIterationCount: '1',
                animationDelay: '0s',
                animationFillMode: 'forwards',
                animationName: scaleOne
            }
        ],
        // Rotate Animation Layer
        rotateAnimationLayer: [
            {
                width: '100%',
                height: '100%'
            },
            props.isCollapsed && {
                animationDuration: '14s',
                animationTimingFunction: 'linear',
                animationDirection: 'normal',
                animationIterationCount: '1',
                animationDelay: '0s',
                animationFillMode: 'forwards',
                animationName: rotateOne
            },
            !props.isCollapsed && {
                opacity: '1'
            }
        ],
        // Layer Host, defaults to collapsed
        entityHost: [
            {
                position: 'relative',
                outline: 'none',
                overflow: 'hidden',
                backgroundColor: props.color,
                borderRadius: COACHMARK_WIDTH,
                transition: 'border-radius 250ms, width 500ms, height 500ms cubic-bezier(0.5, 0, 0, 1)',
                visibility: 'hidden'
            },
            !props.isMeasuring && {
                width: COACHMARK_WIDTH,
                height: COACHMARK_HEIGHT,
                visibility: 'visible'
            },
            !props.isCollapsed && {
                borderRadius: '1px',
                opacity: '1',
                width: props.entityHostWidth,
                height: props.entityHostHeight
            }
        ],
        entityInnerHost: [
            {
                transition: 'transform 500ms cubic-bezier(0.5, 0, 0, 1)',
                transformOrigin: props.transformOrigin,
                transform: 'scale(0)'
            },
            !props.isCollapsed && {
                width: props.entityHostWidth,
                height: props.entityHostHeight,
                transform: 'scale(1)'
            },
            !props.isMeasuring && {
                visibility: 'visible'
            }
        ],
        childrenContainer: [
            {
                display: props.isMeasured && props.isCollapsed ? 'none' : 'block'
            }
        ],
        ariaContainer: {
            position: 'fixed',
            opacity: 0,
            height: 0,
            width: 0,
            pointerEvents: 'none'
        }
    };
}

// @TODO Remove this tslint disable statement after the styles are converted
// to the updated mergeStyles method.
/* tslint:disable */
function highContrastActive(styles) {
    return {
        '@media screen and (-ms-high-contrast: active)': styles
    };
}
function focusClear$1() {
    return {
        '&::-moz-focus-inner': {
            border: 0
        },
        '&': {
            outline: 'transparent'
        }
    };
}
/* tslint:enable */
const getClassNames$k = memoizeFunction(() => {
    return mergeStyleSets({
        root: {
            position: 'absolute',
            boxSizing: 'border-box',
            border: '1px solid ${}',
            selectors: {
                ...highContrastActive({
                    border: '1px solid WindowText'
                }),
                ...focusClear$1()
            }
        },
        container: {
            position: 'relative'
        },
        main: {
            backgroundColor: '#ffffff',
            overflowX: 'hidden',
            overflowY: 'hidden',
            position: 'relative'
        },
        overFlowYHidden: {
            overflowY: 'hidden'
        }
    });
});

const OFF_SCREEN_STYLE$1 = { opacity: 0 };
// In order for some of the max height logic to work
// properly we need to set the border.
// The value is abitrary.
const BORDER_WIDTH$1 = 1;
const SLIDE_ANIMATIONS = {
    [RectangleEdge.top]: 'slideUpIn20',
    [RectangleEdge.bottom]: 'slideDownIn20',
    [RectangleEdge.left]: 'slideLeftIn20',
    [RectangleEdge.right]: 'slideRightIn20'
};
class PositioningContainer extends BaseComponent {
    constructor(props) {
        super(props);
        /**
         * The primary positioned div.
         */
        this._positionedHost = createRef();
        // @TODO rename to reflect the name of this class
        this._contentHost = createRef();
        /**
         * Deprecated, use `onResize` instead.
         * @deprecated Use `onResize` instead.
         */
        this.dismiss = (ev) => {
            this.onResize(ev);
        };
        this.onResize = (ev) => {
            const { onDismiss } = this.props;
            if (onDismiss) {
                onDismiss(ev);
            }
            else {
                this._updateAsyncPosition();
            }
        };
        this._setInitialFocus = () => {
            if (this._contentHost.current && this.props.setInitialFocus && !this._didSetInitialFocus && this.state.positions) {
                this._didSetInitialFocus = true;
                focusFirstChild(this._contentHost.current);
            }
        };
        this._onComponentDidMount = () => {
            // This is added so the positioningContainer will dismiss when the window is scrolled
            // but not when something inside the positioningContainer is scrolled. The delay seems
            // to be required to avoid React firing an async focus event in IE from
            // the target changing focus quickly prior to rendering the positioningContainer.
            this._async.setTimeout(() => {
                this._events.on(this._targetWindow, 'scroll', this._async.throttle(this._dismissOnScroll, 10), true);
                this._events.on(this._targetWindow, 'resize', this._async.throttle(this.onResize, 10), true);
                this._events.on(this._targetWindow.document.body, 'focus', this._dismissOnLostFocus, true);
                this._events.on(this._targetWindow.document.body, 'click', this._dismissOnLostFocus, true);
            }, 0);
            if (this.props.onLayerMounted) {
                this.props.onLayerMounted();
            }
            this._updateAsyncPosition();
            this._setHeightOffsetEveryFrame();
        };
        this._didSetInitialFocus = false;
        this.state = {
            positions: undefined,
            heightOffset: 0
        };
        this._positionAttempts = 0;
    }
    componentWillMount() {
        this._setTargetWindowAndElement(this._getTarget());
    }
    componentDidMount() {
        this._onComponentDidMount();
    }
    componentDidUpdate() {
        this._setInitialFocus();
        this._updateAsyncPosition();
    }
    componentWillUpdate(newProps) {
        // If the target element changed, find the new one. If we are tracking
        // target with class name, always find element because we do not know if
        // fabric has rendered a new element and disposed the old element.
        const newTarget = this._getTarget(newProps);
        const oldTarget = this._getTarget();
        if (newTarget !== oldTarget || typeof newTarget === 'string' || newTarget instanceof String) {
            this._maxHeight = undefined;
            this._setTargetWindowAndElement(newTarget);
        }
        if (newProps.offsetFromTarget !== this.props.offsetFromTarget) {
            this._maxHeight = undefined;
        }
        if (newProps.finalHeight !== this.props.finalHeight) {
            this._setHeightOffsetEveryFrame();
        }
    }
    render() {
        // If there is no target window then we are likely in server side rendering and we should not render anything.
        if (!this._targetWindow) {
            return null;
        }
        const { className, positioningContainerWidth, positioningContainerMaxHeight, children } = this.props;
        const { positions } = this.state;
        const styles = getClassNames$k();
        const directionalClassName = positions && positions.targetEdge ? AnimationClassNames[SLIDE_ANIMATIONS[positions.targetEdge]] : '';
        const getContentMaxHeight = this._getMaxHeight() + this.state.heightOffset;
        const contentMaxHeight = positioningContainerMaxHeight && positioningContainerMaxHeight > getContentMaxHeight
            ? getContentMaxHeight
            : positioningContainerMaxHeight;
        const content = (createElement("div", { ref: this._positionedHost, className: css('ms-PositioningContainer', styles.container) },
            createElement("div", { className: mergeStyles('ms-PositioningContainer-layerHost', styles.root, className, directionalClassName, !!positioningContainerWidth && { width: positioningContainerWidth }), 
                // tslint:disable-next-line:jsx-ban-props
                style: positions ? positions.elementPosition : OFF_SCREEN_STYLE$1, tabIndex: -1, 
                // See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/button#Clicking_and_focus
                ref: this._contentHost },
                children,
                // @TODO apply to the content container
                contentMaxHeight)));
        return this.props.doNotLayer ? content : createElement(Layer, null, content);
    }
    _dismissOnScroll(ev) {
        const { preventDismissOnScroll } = this.props;
        if (this.state.positions && !preventDismissOnScroll) {
            this._dismissOnLostFocus(ev);
        }
    }
    _dismissOnLostFocus(ev) {
        const target = ev.target;
        const clickedOutsideCallout = this._positionedHost.current && !elementContains(this._positionedHost.current, target);
        if ((!this._target && clickedOutsideCallout) ||
            (ev.target !== this._targetWindow &&
                clickedOutsideCallout &&
                (this._target.stopPropagation ||
                    (!this._target || (target !== this._target && !elementContains(this._target, target)))))) {
            this.onResize(ev);
        }
    }
    _updateAsyncPosition() {
        this._async.requestAnimationFrame(() => this._updatePosition());
    }
    _updatePosition() {
        const { positions } = this.state;
        const { offsetFromTarget, onPositioned } = this.props;
        const hostElement = this._positionedHost.current;
        const positioningContainerElement = this._contentHost.current;
        if (hostElement && positioningContainerElement) {
            let currentProps;
            currentProps = assign(currentProps, this.props);
            currentProps.bounds = this._getBounds();
            currentProps.target = this._target;
            if (document.body.contains(currentProps.target)) {
                currentProps.gapSpace = offsetFromTarget;
                const newPositions = positionElement(currentProps, hostElement, positioningContainerElement);
                // Set the new position only when the positions are not exists or one of the new positioningContainer positions are different.
                // The position should not change if the position is within 2 decimal places.
                if ((!positions && newPositions) ||
                    (positions && newPositions && !this._arePositionsEqual(positions, newPositions) && this._positionAttempts < 5)) {
                    // We should not reposition the positioningContainer more than a few times, if it is then the content is likely resizing
                    // and we should stop trying to reposition to prevent a stack overflow.
                    this._positionAttempts++;
                    this.setState({
                        positions: newPositions
                    }, () => {
                        if (onPositioned) {
                            onPositioned(newPositions);
                        }
                    });
                }
                else {
                    this._positionAttempts = 0;
                    if (onPositioned) {
                        onPositioned(newPositions);
                    }
                }
            }
            else if (positions !== undefined) {
                this.setState({
                    positions: undefined
                });
            }
        }
    }
    _getBounds() {
        if (!this._positioningBounds) {
            let currentBounds = this.props.bounds;
            if (!currentBounds) {
                currentBounds = {
                    top: 0 + this.props.minPagePadding,
                    left: 0 + this.props.minPagePadding,
                    right: this._targetWindow.innerWidth - this.props.minPagePadding,
                    bottom: this._targetWindow.innerHeight - this.props.minPagePadding,
                    width: this._targetWindow.innerWidth - this.props.minPagePadding * 2,
                    height: this._targetWindow.innerHeight - this.props.minPagePadding * 2
                };
            }
            this._positioningBounds = currentBounds;
        }
        return this._positioningBounds;
    }
    /**
     * Return the maximum height the container can grow to
     * without going out of the specified bounds
     */
    _getMaxHeight() {
        const { directionalHintFixed, offsetFromTarget, directionalHint } = this.props;
        if (!this._maxHeight) {
            if (directionalHintFixed && this._target) {
                const gapSpace = offsetFromTarget ? offsetFromTarget : 0;
                this._maxHeight = getMaxHeight(this._target, directionalHint, gapSpace, this._getBounds());
            }
            else {
                this._maxHeight = this._getBounds().height - BORDER_WIDTH$1 * 2;
            }
        }
        return this._maxHeight;
    }
    _arePositionsEqual(positions, newPosition) {
        return this._comparePositions(positions.elementPosition, newPosition.elementPosition);
    }
    _comparePositions(oldPositions, newPositions) {
        for (const key in newPositions) {
            // This needs to be checked here and below because there is a linting error if for in does not immediately have an if statement
            if (newPositions.hasOwnProperty(key)) {
                const oldPositionEdge = oldPositions[key];
                const newPositionEdge = newPositions[key];
                if (oldPositionEdge && newPositionEdge) {
                    if (oldPositionEdge.toFixed(2) !== newPositionEdge.toFixed(2)) {
                        return false;
                    }
                }
            }
        }
        return true;
    }
    _setTargetWindowAndElement(target) {
        if (target) {
            if (typeof target === 'string') {
                const currentDoc = getDocument();
                this._target = currentDoc ? currentDoc.querySelector(target) : null;
                this._targetWindow = getWindow();
            }
            else if (target.stopPropagation) {
                this._targetWindow = getWindow(target.toElement);
                this._target = target;
            }
            else if (target.x !== undefined && target.y !== undefined) {
                this._targetWindow = getWindow();
                this._target = target;
            }
            else {
                const targetElement = target;
                this._targetWindow = getWindow(targetElement);
                this._target = target;
            }
        }
        else {
            this._targetWindow = getWindow();
        }
    }
    /**
     * Animates the height if finalHeight was given.
     */
    _setHeightOffsetEveryFrame() {
        if (this._contentHost && this.props.finalHeight) {
            this._setHeightOffsetTimer = this._async.requestAnimationFrame(() => {
                if (!this._contentHost.current) {
                    return;
                }
                const positioningContainerMainElem = this._contentHost.current.lastChild;
                const cardScrollHeight = positioningContainerMainElem.scrollHeight;
                const cardCurrHeight = positioningContainerMainElem.offsetHeight;
                const scrollDiff = cardScrollHeight - cardCurrHeight;
                this.setState({
                    heightOffset: this.state.heightOffset + scrollDiff
                });
                if (positioningContainerMainElem.offsetHeight < this.props.finalHeight) {
                    this._setHeightOffsetEveryFrame();
                }
                else {
                    this._async.cancelAnimationFrame(this._setHeightOffsetTimer);
                }
            });
        }
    }
    _getTarget(props = this.props) {
        const { target } = props;
        return target;
    }
}
PositioningContainer.defaultProps = {
    preventDismissOnScroll: false,
    offsetFromTarget: 0,
    minPagePadding: 8,
    directionalHint: DirectionalHint.bottomAutoEdge
};

function getStyles$s(props) {
    return {
        root: [
            {
                position: 'absolute',
                boxShadow: 'inherit',
                border: 'none',
                boxSizing: 'border-box',
                transform: props.transform,
                width: props.width,
                height: props.height,
                left: props.left,
                top: props.top,
                right: props.right,
                bottom: props.bottom
            }
        ],
        beak: {
            fill: props.color,
            display: 'block'
        }
    };
}

const BEAK_HEIGHT = 10;
const BEAK_WIDTH = 18;
class Beak extends BaseComponent {
    constructor(props) {
        super(props);
    }
    render() {
        const { left, top, bottom, right, color, direction = RectangleEdge.top } = this.props;
        let svgHeight;
        let svgWidth;
        if (direction === RectangleEdge.top || direction === RectangleEdge.bottom) {
            svgHeight = BEAK_HEIGHT;
            svgWidth = BEAK_WIDTH;
        }
        else {
            svgHeight = BEAK_WIDTH;
            svgWidth = BEAK_HEIGHT;
        }
        let pointOne;
        let pointTwo;
        let pointThree;
        let transform;
        switch (direction) {
            case RectangleEdge.top:
            default:
                pointOne = `${BEAK_WIDTH / 2}, 0`;
                pointTwo = `${BEAK_WIDTH}, ${BEAK_HEIGHT}`;
                pointThree = `0, ${BEAK_HEIGHT}`;
                transform = 'translateY(-100%)';
                break;
            case RectangleEdge.right:
                pointOne = `0, 0`;
                pointTwo = `${BEAK_HEIGHT}, ${BEAK_HEIGHT}`;
                pointThree = `0, ${BEAK_WIDTH}`;
                transform = 'translateX(100%)';
                break;
            case RectangleEdge.bottom:
                pointOne = `0, 0`;
                pointTwo = `${BEAK_WIDTH}, 0`;
                pointThree = `${BEAK_WIDTH / 2}, ${BEAK_HEIGHT}`;
                transform = 'translateY(100%)';
                break;
            case RectangleEdge.left:
                pointOne = `${BEAK_HEIGHT}, 0`;
                pointTwo = `0, ${BEAK_HEIGHT}`;
                pointThree = `${BEAK_HEIGHT}, ${BEAK_WIDTH}`;
                transform = 'translateX(-100%)';
                break;
        }
        const getClassNames = classNamesFunction();
        const classNames = getClassNames(getStyles$s, {
            left,
            top,
            bottom,
            right,
            height: `${svgHeight}px`,
            width: `${svgWidth}px`,
            transform: transform,
            color
        });
        return (createElement("div", { className: classNames.root, role: "presentation" },
            createElement("svg", { height: svgHeight, width: svgWidth, className: classNames.beak },
                createElement("polygon", { points: pointOne + ' ' + pointTwo + ' ' + pointThree }))));
    }
}

// Utilities
const getClassNames$l = classNamesFunction();
const COACHMARK_ATTRIBUTE_NAME = 'data-coachmarkid';
class CoachmarkBase extends BaseComponent {
    constructor(props) {
        super(props);
        /**
         * The cached HTMLElement reference to the Entity Inner Host
         * element.
         */
        this._entityHost = createRef();
        this._entityInnerHostElement = createRef();
        this._translateAnimationContainer = createRef();
        this._ariaAlertContainer = createRef();
        this._childrenContainer = createRef();
        this._positioningContainer = createRef();
        this.dismiss = (ev) => {
            const { onDismiss } = this.props;
            if (onDismiss) {
                onDismiss(ev);
            }
        };
        this._onKeyDown = (e) => {
            // Open coachmark if user presses ALT + C (arbitrary keypress for now)
            if ((e.altKey && e.which === KeyCodes.c) ||
                (e.which === KeyCodes.enter &&
                    this._translateAnimationContainer.current &&
                    this._translateAnimationContainer.current.contains(e.target))) {
                this._onFocusHandler();
            }
        };
        this._onFocusHandler = () => {
            if (this.state.isCollapsed) {
                this._openCoachmark();
            }
        };
        this._onPositioned = (positionData) => {
            this._async.requestAnimationFrame(() => {
                this.setState({
                    targetAlignment: positionData.alignmentEdge,
                    targetPosition: positionData.targetEdge
                });
            });
        };
        this._setBeakPosition = () => {
            let beakLeft;
            let beakTop;
            let beakRight;
            let beakBottom;
            let transformOriginX;
            let transformOriginY;
            const { targetAlignment } = this.state;
            const distanceAdjustment = '3px'; // Adjustment distance for Beak to shift towards Coachmark bubble.
            switch (this._beakDirection) {
                // If Beak is pointing Up or Down
                case RectangleEdge.top:
                case RectangleEdge.bottom:
                    // If there is no target alignment, then beak is X-axis centered in callout
                    if (!targetAlignment) {
                        beakLeft = `calc(50% - ${BEAK_WIDTH / 2}px)`;
                        transformOriginX = 'center';
                    }
                    else {
                        // Beak is aligned to the left of target
                        if (targetAlignment === RectangleEdge.left) {
                            beakLeft = `${COACHMARK_WIDTH / 2 - BEAK_WIDTH / 2}px`;
                            transformOriginX = 'left';
                        }
                        else {
                            // Beak is aligned to the right of target
                            beakRight = `${COACHMARK_WIDTH / 2 - BEAK_WIDTH / 2}px`;
                            transformOriginX = 'right';
                        }
                    }
                    if (this._beakDirection === RectangleEdge.top) {
                        beakTop = distanceAdjustment;
                        transformOriginY = 'top';
                    }
                    else {
                        beakBottom = distanceAdjustment;
                        transformOriginY = 'bottom';
                    }
                    break;
                // If Beak is pointing Left or Right
                case RectangleEdge.left:
                case RectangleEdge.right:
                    // If there is no target alignment, then beak is Y-axis centered in callout
                    if (!targetAlignment) {
                        beakTop = `calc(50% - ${BEAK_WIDTH / 2}px)`;
                        transformOriginY = `center`;
                    }
                    else {
                        // Beak is aligned to the top of target
                        if (targetAlignment === RectangleEdge.top) {
                            beakTop = `${COACHMARK_WIDTH / 2 - BEAK_WIDTH / 2}px`;
                            transformOriginY = `top`;
                        }
                        else {
                            // Beak is aligned to the bottom of target
                            beakBottom = `${COACHMARK_WIDTH / 2 - BEAK_WIDTH / 2}px`;
                            transformOriginY = `bottom`;
                        }
                    }
                    if (this._beakDirection === RectangleEdge.left) {
                        beakLeft = distanceAdjustment;
                        transformOriginX = 'left';
                    }
                    else {
                        beakRight = distanceAdjustment;
                        transformOriginX = 'right';
                    }
                    break;
            }
            this.setState({
                beakLeft: beakLeft,
                beakRight: beakRight,
                beakBottom: beakBottom,
                beakTop: beakTop,
                transformOrigin: `${transformOriginX} ${transformOriginY}`
            });
        };
        this._openCoachmark = () => {
            this.setState({
                isCollapsed: false
            });
            if (this.props.onAnimationOpenStart) {
                this.props.onAnimationOpenStart();
            }
            this._entityInnerHostElement.current &&
                this._entityInnerHostElement.current.addEventListener('transitionend', () => {
                    // Need setTimeout to trigger narrator
                    this._async.setTimeout(() => {
                        if (this._entityInnerHostElement.current) {
                            focusFirstChild(this._entityInnerHostElement.current);
                        }
                    }, 1000);
                    if (this.props.onAnimationOpenEnd) {
                        this.props.onAnimationOpenEnd();
                    }
                });
        };
        this._warnDeprecations({
            teachingBubbleRef: undefined,
            collapsed: 'isCollapsed',
            beakWidth: undefined,
            beakHeight: undefined,
            width: undefined,
            height: undefined
        });
        // Set defaults for state
        this.state = {
            isCollapsed: props.isCollapsed,
            isBeaconAnimating: true,
            isMeasuring: true,
            entityInnerHostRect: {
                width: 0,
                height: 0
            },
            isMouseInProximity: false,
            isMeasured: false
        };
    }
    get _beakDirection() {
        const { targetPosition } = this.state;
        if (targetPosition === undefined) {
            return RectangleEdge.bottom;
        }
        return getOppositeEdge(targetPosition);
    }
    render() {
        const { children, target, color, positioningContainerProps, ariaDescribedBy, ariaDescribedByText, ariaLabelledBy, ariaLabelledByText, ariaAlertText, delayBeforeCoachmarkAnimation } = this.props;
        const { beakLeft, beakTop, beakRight, beakBottom, isCollapsed, isBeaconAnimating, isMeasuring, entityInnerHostRect, transformOrigin, alertText, isMeasured } = this.state;
        const classNames = getClassNames$l(getStyles$r, {
            isCollapsed: isCollapsed,
            isBeaconAnimating: isBeaconAnimating,
            isMeasuring: isMeasuring,
            entityHostHeight: `${entityInnerHostRect.height}px`,
            entityHostWidth: `${entityInnerHostRect.width}px`,
            width: `${COACHMARK_WIDTH}px`,
            height: `${COACHMARK_HEIGHT}px`,
            color: color,
            transformOrigin: transformOrigin,
            isMeasured: isMeasured,
            delayBeforeCoachmarkAnimation: `${delayBeforeCoachmarkAnimation}ms`
        });
        const finalHeight = isCollapsed ? COACHMARK_HEIGHT : entityInnerHostRect.height;
        return (createElement(PositioningContainer, Object.assign({ target: target, offsetFromTarget: BEAK_HEIGHT, componentRef: this._positioningContainer, finalHeight: finalHeight, onPositioned: this._onPositioned, bounds: this._getBounds() }, positioningContainerProps),
            createElement("div", { className: classNames.root },
                ariaAlertText && (createElement("div", { className: classNames.ariaContainer, role: "alert", ref: this._ariaAlertContainer, "aria-hidden": !isCollapsed }, alertText)),
                createElement("div", { className: classNames.pulsingBeacon }),
                createElement("div", { className: classNames.translateAnimationContainer, ref: this._translateAnimationContainer },
                    createElement("div", { className: classNames.scaleAnimationLayer },
                        createElement("div", { className: classNames.rotateAnimationLayer },
                            this._positioningContainer.current && isCollapsed && (createElement(Beak, { left: beakLeft, top: beakTop, right: beakRight, bottom: beakBottom, direction: this._beakDirection, color: color })),
                            createElement("div", { className: classNames.entityHost, ref: this._entityHost, tabIndex: -1, "data-is-focusable": true, role: "dialog", "aria-labelledby": ariaLabelledBy, "aria-describedby": ariaDescribedBy },
                                isCollapsed && [
                                    ariaLabelledBy && (createElement("p", { id: ariaLabelledBy, key: 0, className: classNames.ariaContainer }, ariaLabelledByText)),
                                    ariaDescribedBy && (createElement("p", { id: ariaDescribedBy, key: 1, className: classNames.ariaContainer }, ariaDescribedByText))
                                ],
                                createElement(FocusTrapZone, { isClickableOutsideFocusTrap: true, forceFocusInsideTrap: false },
                                    createElement("div", { className: classNames.entityInnerHost, ref: this._entityInnerHostElement },
                                        createElement("div", { className: classNames.childrenContainer, ref: this._childrenContainer, "aria-hidden": isCollapsed }, children))))))))));
    }
    componentWillReceiveProps(newProps) {
        if (this.props.isCollapsed && !newProps.isCollapsed) {
            // The coachmark is about to open
            this._openCoachmark();
        }
    }
    shouldComponentUpdate(newProps, newState) {
        return !shallowCompare(newProps, this.props) || !shallowCompare(newState, this.state);
    }
    componentDidUpdate(prevProps, prevState) {
        if (prevState.targetAlignment !== this.state.targetAlignment || prevState.targetPosition !== this.state.targetPosition) {
            this._setBeakPosition();
        }
        if (prevProps.preventDismissOnLostFocus !== this.props.preventDismissOnLostFocus) {
            this._addListeners();
        }
    }
    componentDidMount() {
        this._async.requestAnimationFrame(() => {
            if (this._entityInnerHostElement.current && this.state.entityInnerHostRect.width + this.state.entityInnerHostRect.width === 0) {
                this.setState({
                    isMeasuring: false,
                    entityInnerHostRect: {
                        width: this._entityInnerHostElement.current.offsetWidth,
                        height: this._entityInnerHostElement.current.offsetHeight
                    },
                    isMeasured: true
                });
                this._setBeakPosition();
                this.forceUpdate();
            }
            this._addListeners();
            // We don't want to the user to immediately trigger the Coachmark when it's opened
            this._async.setTimeout(() => {
                this._addProximityHandler(this.props.mouseProximityOffset);
            }, this.props.delayBeforeMouseOpen);
            // Need to add setTimeout to have narrator read change in alert container
            if (this.props.ariaAlertText) {
                this._async.setTimeout(() => {
                    if (this.props.ariaAlertText && this._ariaAlertContainer.current) {
                        this.setState({
                            alertText: this.props.ariaAlertText
                        });
                    }
                }, 0);
            }
            if (!this.props.preventFocusOnMount) {
                this._async.setTimeout(() => {
                    if (this._entityHost.current) {
                        this._entityHost.current.focus();
                    }
                }, 1000);
            }
        });
    }
    _addListeners() {
        const { preventDismissOnLostFocus } = this.props;
        const currentDoc = getDocument();
        this._events.off();
        if (currentDoc) {
            this._events.on(currentDoc, 'keydown', this._onKeyDown, true);
            if (!preventDismissOnLostFocus) {
                this._events.on(currentDoc, 'click', this._dismissOnLostFocus, true);
                this._events.on(currentDoc, 'focus', this._dismissOnLostFocus, true);
            }
        }
    }
    _dismissOnLostFocus(ev) {
        const clickTarget = ev.target;
        const clickedOutsideCallout = this._translateAnimationContainer.current && !elementContains(this._translateAnimationContainer.current, clickTarget);
        const { target } = this.props;
        if (clickedOutsideCallout && clickTarget !== target && !elementContains(target, clickTarget)) {
            this.dismiss(ev);
        }
    }
    _getBounds() {
        const { isPositionForced, positioningContainerProps } = this.props;
        if (isPositionForced) {
            // If directionalHint direction is the top or bottom auto edge, then we want to set the left/right bounds
            // to the window x-axis to have auto positioning work correctly.
            if (positioningContainerProps &&
                (positioningContainerProps.directionalHint === DirectionalHint.topAutoEdge ||
                    positioningContainerProps.directionalHint === DirectionalHint.bottomAutoEdge)) {
                return {
                    left: 0,
                    top: -Infinity,
                    bottom: Infinity,
                    right: window.innerWidth,
                    width: window.innerWidth,
                    height: Infinity
                };
            }
            else {
                return {
                    left: -Infinity,
                    top: -Infinity,
                    bottom: Infinity,
                    right: Infinity,
                    width: Infinity,
                    height: Infinity
                };
            }
        }
        else {
            return undefined;
        }
    }
    _addProximityHandler(mouseProximityOffset = 0) {
        /**
         * An array of cached ids returned when setTimeout runs during
         * the window resize event trigger.
         */
        const timeoutIds = [];
        // Take the initial measure out of the initial render to prevent
        // an unnecessary render.
        this._async.setTimeout(() => {
            this._setTargetElementRect();
            // When the window resizes we want to async
            // get the bounding client rectangle.
            // Every time the event is triggered we want to
            // setTimeout and then clear any previous instances
            // of setTimeout.
            this._events.on(window, 'resize', () => {
                timeoutIds.forEach((value) => {
                    clearInterval(value);
                });
                timeoutIds.push(this._async.setTimeout(() => {
                    this._setTargetElementRect();
                }, 100));
            });
        }, 10);
        // Every time the document's mouse move is triggered
        // we want to check if inside of an element and
        // set the state with the result.
        this._events.on(document, 'mousemove', (e) => {
            if (this.state.isCollapsed) {
                const mouseY = e.pageY;
                const mouseX = e.pageX;
                this._setTargetElementRect();
                const isMouseInProximity = this._isInsideElement(mouseX, mouseY, mouseProximityOffset);
                if (isMouseInProximity !== this.state.isMouseInProximity) {
                    this._openCoachmark();
                }
            }
            if (this.props.onMouseMove) {
                this.props.onMouseMove(e);
            }
        });
    }
    _setTargetElementRect() {
        if (this._translateAnimationContainer && this._translateAnimationContainer.current) {
            this._targetElementRect = this._translateAnimationContainer.current.getBoundingClientRect();
        }
    }
    _isInsideElement(mouseX, mouseY, mouseProximityOffset = 0) {
        return (mouseX > this._targetElementRect.left - mouseProximityOffset &&
            mouseX < this._targetElementRect.left + this._targetElementRect.width + mouseProximityOffset &&
            mouseY > this._targetElementRect.top - mouseProximityOffset &&
            mouseY < this._targetElementRect.top + this._targetElementRect.height + mouseProximityOffset);
    }
}
CoachmarkBase.defaultProps = {
    isCollapsed: true,
    mouseProximityOffset: 10,
    delayBeforeMouseOpen: 3600,
    delayBeforeCoachmarkAnimation: 0,
    color: DefaultPalette.themePrimary,
    isPositionForced: true,
    positioningContainerProps: {
        directionalHint: DirectionalHint.bottomAutoEdge
    }
};

const Coachmark = styled(CoachmarkBase, getStyles$r, undefined, {
    scope: 'Coachmark'
});

const COLOR_VALUES = {
    aliceblue: [240, 248, 255],
    antiquewhite: [250, 235, 215],
    aqua: [0, 255, 255],
    aquamarine: [127, 255, 212],
    azure: [240, 255, 255],
    beige: [245, 245, 220],
    bisque: [255, 228, 196],
    black: [0, 0, 0],
    blanchedalmond: [255, 235, 205],
    blue: [0, 0, 255],
    blueviolet: [138, 43, 226],
    brown: [165, 42, 42],
    burlywood: [222, 184, 135],
    cadetblue: [95, 158, 160],
    chartreuse: [127, 255, 0],
    chocolate: [210, 105, 30],
    coral: [255, 127, 80],
    cornflowerblue: [100, 149, 237],
    cornsilk: [255, 248, 220],
    crimson: [220, 20, 60],
    cyan: [0, 255, 255],
    darkblue: [0, 0, 139],
    darkcyan: [0, 139, 139],
    darkgoldenrod: [184, 132, 11],
    darkgray: [169, 169, 169],
    darkgreen: [0, 100, 0],
    darkgrey: [169, 169, 169],
    darkkhaki: [189, 183, 107],
    darkmagenta: [139, 0, 139],
    darkolivegreen: [85, 107, 47],
    darkorange: [255, 140, 0],
    darkorchid: [153, 50, 204],
    darkred: [139, 0, 0],
    darksalmon: [233, 150, 122],
    darkseagreen: [143, 188, 143],
    darkslateblue: [72, 61, 139],
    darkslategray: [47, 79, 79],
    darkslategrey: [47, 79, 79],
    darkturquoise: [0, 206, 209],
    darkviolet: [148, 0, 211],
    deeppink: [255, 20, 147],
    deepskyblue: [0, 191, 255],
    dimgray: [105, 105, 105],
    dimgrey: [105, 105, 105],
    dodgerblue: [30, 144, 255],
    firebrick: [178, 34, 34],
    floralwhite: [255, 255, 240],
    forestgreen: [34, 139, 34],
    fuchsia: [255, 0, 255],
    gainsboro: [220, 220, 220],
    ghostwhite: [248, 248, 255],
    gold: [255, 215, 0],
    goldenrod: [218, 165, 32],
    gray: [128, 128, 128],
    green: [0, 128, 0],
    greenyellow: [173, 255, 47],
    grey: [128, 128, 128],
    honeydew: [240, 255, 240],
    hotpink: [255, 105, 180],
    indianred: [205, 92, 92],
    indigo: [75, 0, 130],
    ivory: [255, 255, 240],
    khaki: [240, 230, 140],
    lavender: [230, 230, 250],
    lavenderblush: [255, 240, 245],
    lawngreen: [124, 252, 0],
    lemonchiffon: [255, 250, 205],
    lightblue: [173, 216, 230],
    lightcoral: [240, 128, 128],
    lightcyan: [224, 255, 255],
    lightgoldenrodyellow: [250, 250, 210],
    lightgray: [211, 211, 211],
    lightgreen: [144, 238, 144],
    lightgrey: [211, 211, 211],
    lightpink: [255, 182, 193],
    lightsalmon: [255, 160, 122],
    lightseagreen: [32, 178, 170],
    lightskyblue: [135, 206, 250],
    lightslategray: [119, 136, 153],
    lightslategrey: [119, 136, 153],
    lightsteelblue: [176, 196, 222],
    lightyellow: [255, 255, 224],
    lime: [0, 255, 0],
    limegreen: [50, 205, 50],
    linen: [250, 240, 230],
    magenta: [255, 0, 255],
    maroon: [128, 0, 0],
    mediumaquamarine: [102, 205, 170],
    mediumblue: [0, 0, 205],
    mediumorchid: [186, 85, 211],
    mediumpurple: [147, 112, 219],
    mediumseagreen: [60, 179, 113],
    mediumslateblue: [123, 104, 238],
    mediumspringgreen: [0, 250, 154],
    mediumturquoise: [72, 209, 204],
    mediumvioletred: [199, 21, 133],
    midnightblue: [25, 25, 112],
    mintcream: [245, 255, 250],
    mistyrose: [255, 228, 225],
    moccasin: [255, 228, 181],
    navajowhite: [255, 222, 173],
    navy: [0, 0, 128],
    oldlace: [253, 245, 230],
    olive: [128, 128, 0],
    olivedrab: [107, 142, 35],
    orange: [255, 165, 0],
    orangered: [255, 69, 0],
    orchid: [218, 112, 214],
    palegoldenrod: [238, 232, 170],
    palegreen: [152, 251, 152],
    paleturquoise: [175, 238, 238],
    palevioletred: [219, 112, 147],
    papayawhip: [255, 239, 213],
    peachpuff: [255, 218, 185],
    peru: [205, 133, 63],
    pink: [255, 192, 203],
    plum: [221, 160, 203],
    powderblue: [176, 224, 230],
    purple: [128, 0, 128],
    rebeccapurple: [102, 51, 153],
    red: [255, 0, 0],
    rosybrown: [188, 143, 143],
    royalblue: [65, 105, 225],
    saddlebrown: [139, 69, 19],
    salmon: [250, 128, 114],
    sandybrown: [244, 164, 96],
    seagreen: [46, 139, 87],
    seashell: [255, 245, 238],
    sienna: [160, 82, 45],
    silver: [192, 192, 192],
    skyblue: [135, 206, 235],
    slateblue: [106, 90, 205],
    slategray: [119, 128, 144],
    slategrey: [119, 128, 144],
    snow: [255, 255, 250],
    springgreen: [0, 255, 127],
    steelblue: [70, 130, 180],
    tan: [210, 180, 140],
    teal: [0, 128, 128],
    thistle: [216, 191, 216],
    tomato: [255, 99, 71],
    turquoise: [64, 224, 208],
    violet: [238, 130, 238],
    wheat: [245, 222, 179],
    white: [255, 255, 255],
    whitesmoke: [245, 245, 245],
    yellow: [255, 255, 0],
    yellowgreen: [154, 205, 5]
};

const MAX_COLOR_SATURATION = 100;
const MAX_COLOR_HUE = 359;
const MAX_COLOR_VALUE = 100;
const MAX_COLOR_RGBA = 255;
function cssColor(color) {
    return _named(color) || _hex3(color) || _hex6(color) || _rgb(color) || _rgba(color) || _hsl(color) || _hsla(color);
}
function rgb2hex(r, g, b) {
    return [_numberToPaddedHex(r), _numberToPaddedHex(g), _numberToPaddedHex(b)].join('');
}
function hsv2hex(h, s, v) {
    const { r, g, b } = hsv2rgb(h, s, v);
    return rgb2hex(r, g, b);
}
function rgb2hsv(r, g, b) {
    let h = NaN;
    let s;
    let v;
    const max = Math.max(r, g, b);
    const min = Math.min(r, g, b);
    const delta = max - min;
    // hue
    if (delta === 0) {
        h = 0;
    }
    else if (r === max) {
        h = ((g - b) / delta) % 6;
    }
    else if (g === max) {
        h = (b - r) / delta + 2;
    }
    else if (b === max) {
        h = (r - g) / delta + 4;
    }
    h = Math.round(h * 60);
    if (h < 0) {
        h += 360;
    }
    // saturation
    s = Math.round((max === 0 ? 0 : delta / max) * 100);
    // value
    v = Math.round((max / 255) * 100);
    return { h, s, v };
}
function hsl2hsv(h, s, l) {
    s *= (l < 50 ? l : 100 - l) / 100;
    return {
        h: h,
        s: ((2 * s) / (l + s)) * 100,
        v: l + s
    };
}
function hsv2hsl(h, s, v) {
    s /= MAX_COLOR_SATURATION;
    v /= MAX_COLOR_VALUE;
    let l = (2 - s) * v;
    let sl = s * v;
    sl /= l <= 1 ? l : 2 - l;
    sl = sl || 0;
    l /= 2;
    return { h: h, s: sl * 100, l: l * 100 };
}
function hsl2rgb(h, s, l) {
    const hsv = hsl2hsv(h, s, l);
    return hsv2rgb(hsv.h, hsv.s, hsv.v);
}
function hsv2rgb(h, s, v) {
    s = s / 100;
    v = v / 100;
    let rgb = [];
    const c = v * s;
    const hh = h / 60;
    const x = c * (1 - Math.abs((hh % 2) - 1));
    const m = v - c;
    switch (Math.floor(hh)) {
        case 0:
            rgb = [c, x, 0];
            break;
        case 1:
            rgb = [x, c, 0];
            break;
        case 2:
            rgb = [0, c, x];
            break;
        case 3:
            rgb = [0, x, c];
            break;
        case 4:
            rgb = [x, 0, c];
            break;
        case 5:
            rgb = [c, 0, x];
            break;
    }
    return {
        r: Math.round(MAX_COLOR_RGBA * (rgb[0] + m)),
        g: Math.round(MAX_COLOR_RGBA * (rgb[1] + m)),
        b: Math.round(MAX_COLOR_RGBA * (rgb[2] + m))
    };
}
function getColorFromString(inputColor) {
    const color = cssColor(inputColor);
    if (!color) {
        return;
    }
    const { a, b, g, r } = color;
    const { h, s, v } = rgb2hsv(r, g, b);
    return {
        a: a,
        b: b,
        g: g,
        h: h,
        hex: rgb2hex(r, g, b),
        r: r,
        s: s,
        str: inputColor,
        v: v
    };
}
function getColorFromRGBA(rgba) {
    const { a, b, g, r } = rgba;
    const { h, s, v } = rgb2hsv(r, g, b);
    const hex = rgb2hex(r, g, b);
    return {
        a: a,
        b: b,
        g: g,
        h: h,
        hex: hex,
        r: r,
        s: s,
        str: a === 100 ? `#${hex}` : `rgba(${r}, ${g}, ${b}, ${a / 100})`,
        v: v
    };
}
function getFullColorString(color) {
    return `#${hsv2hex(color.h, MAX_COLOR_SATURATION, MAX_COLOR_VALUE)}`;
}
function updateSV(color, s, v) {
    const { r, g, b } = hsv2rgb(color.h, s, v);
    const hex = rgb2hex(r, g, b);
    return {
        a: color.a,
        b: b,
        g: g,
        h: color.h,
        hex: hex,
        r: r,
        s: s,
        str: color.a === 100 ? `#${hex}` : `rgba(${r}, ${g}, ${b}, ${color.a / 100})`,
        v: v
    };
}
function updateH(color, h) {
    const { r, g, b } = hsv2rgb(h, color.s, color.v);
    const hex = rgb2hex(r, g, b);
    return {
        a: color.a,
        b: b,
        g: g,
        h: h,
        hex: hex,
        r: r,
        s: color.s,
        str: color.a === 100 ? `#${hex}` : `rgba(${r}, ${g}, ${b}, ${color.a / 100})`,
        v: color.v
    };
}
function updateA(color, a) {
    return assign({}, color, {
        a: a,
        str: a === 100 ? `#${color.hex}` : `rgba(${color.r}, ${color.g}, ${color.b}, ${a / 100})`
    });
}
function _numberToPaddedHex(num) {
    const hex = num.toString(16);
    return hex.length === 1 ? '0' + hex : hex;
}
function _named(str) {
    const c = COLOR_VALUES[str.toLowerCase()];
    if (c) {
        return {
            r: c[0],
            g: c[1],
            b: c[2],
            a: 100
        };
    }
}
function _rgb(str) {
    if (0 === str.indexOf('rgb(')) {
        str = str.match(/rgb\(([^)]+)\)/)[1];
        const parts = str.split(/ *, */).map(Number);
        return {
            r: parts[0],
            g: parts[1],
            b: parts[2],
            a: 100
        };
    }
}
function _rgba(str) {
    if (str.indexOf('rgba(') === 0) {
        str = str.match(/rgba\(([^)]+)\)/)[1];
        const parts = str.split(/ *, */).map(Number);
        return {
            r: parts[0],
            g: parts[1],
            b: parts[2],
            a: parts[3] * 100
        };
    }
}
function _hex6(str) {
    if ('#' === str[0] && 7 === str.length) {
        return {
            r: parseInt(str.slice(1, 3), 16),
            g: parseInt(str.slice(3, 5), 16),
            b: parseInt(str.slice(5, 7), 16),
            a: 100
        };
    }
}
function _hex3(str) {
    if ('#' === str[0] && 4 === str.length) {
        return {
            r: parseInt(str[1] + str[1], 16),
            g: parseInt(str[2] + str[2], 16),
            b: parseInt(str[3] + str[3], 16),
            a: 100
        };
    }
}
function _hsl(str) {
    if (str.indexOf('hsl(') === 0) {
        str = str.match(/hsl\(([^)]+)\)/)[1];
        const parts = str.split(/ *, */);
        const h = parseInt(parts[0], 10);
        const s = parseInt(parts[1], 10);
        const l = parseInt(parts[2], 10);
        const rgba = hsl2rgb(h, s, l);
        rgba.a = 100;
        return rgba;
    }
}
function _hsla(str) {
    if (str.indexOf('hsla(') === 0) {
        str = str.match(/hsla\(([^)]+)\)/)[1];
        const parts = str.split(/ *, */);
        const h = parseInt(parts[0], 10);
        const s = parseInt(parts[1], 10);
        const l = parseInt(parts[2], 10);
        const a = parseInt(parts[3], 10) * 100;
        const rgba = hsl2rgb(h, s, l);
        rgba.a = a;
        return rgba;
    }
}

// Technically this should be shades and tints, but for simplicity we'll call everything a shade.
// Soften: to get closer to the background color's luminance
// (softening with a white background would be lightening, with black it'd be darkening)
// Strongen: opposite of soften
// Luminance multiplier constants for generating shades of a given color
const WhiteShadeTableBG = [0.027, 0.043, 0.082, 0.145, 0.184, 0.216, 0.349, 0.537]; // white bg
const BlackTintTableBG = [0.537, 0.45, 0.349, 0.216, 0.184, 0.145, 0.082, 0.043]; // black bg
const WhiteShadeTable = [0.537, 0.349, 0.216, 0.184, 0.145, 0.082, 0.043, 0.027]; // white fg
const BlackTintTable = [0.537, 0.45, 0.349, 0.216, 0.184, 0.145, 0.082, 0.043]; // black fg
const LumTintTable = [0.88, 0.77, 0.66, 0.55, 0.44, 0.33, 0.22, 0.11]; // light (strongen all)
const LumShadeTable = [0.11, 0.22, 0.33, 0.44, 0.55, 0.66, 0.77, 0.88]; // dark (soften all)
const ColorTintTable = [0.96, 0.84, 0.7, 0.4, 0.12]; // default soften
const ColorShadeTable = [0.1, 0.24, 0.44]; // default strongen
// If the given shade's luminance is below/above these values, we'll swap to using the White/Black tables above
const LowLuminanceThreshold = 0.2;
const HighLuminanceThreshold = 0.8;
/** Shades of a given color, from softest to strongest. */
var Shade;
(function (Shade) {
    Shade[Shade["Unshaded"] = 0] = "Unshaded";
    Shade[Shade["Shade1"] = 1] = "Shade1";
    Shade[Shade["Shade2"] = 2] = "Shade2";
    Shade[Shade["Shade3"] = 3] = "Shade3";
    Shade[Shade["Shade4"] = 4] = "Shade4";
    Shade[Shade["Shade5"] = 5] = "Shade5";
    Shade[Shade["Shade6"] = 6] = "Shade6";
    Shade[Shade["Shade7"] = 7] = "Shade7";
    Shade[Shade["Shade8"] = 8] = "Shade8";
    // remember to update isValidShade()!
})(Shade || (Shade = {}));
/**
 * Returns true if the argument is a valid Shade value
 * @param shade - The Shade value to validate.
 */
function isValidShade(shade) {
    return typeof shade === 'number' && shade >= Shade.Unshaded && shade <= Shade.Shade8;
}
function _isBlack(color) {
    return color.r === 0 && color.g === 0 && color.b === 0;
}
function _isWhite(color) {
    return color.r === MAX_COLOR_RGBA && color.g === MAX_COLOR_RGBA && color.b === MAX_COLOR_RGBA;
}
function _darken(hsv, factor) {
    return {
        h: hsv.h,
        s: hsv.s,
        v: _clamp(hsv.v - hsv.v * factor, 0, 100)
    };
}
function _lighten(hsv, factor) {
    return {
        h: hsv.h,
        s: _clamp(hsv.s - hsv.s * factor, 0, 100),
        v: _clamp(hsv.v + (100 - hsv.v) * factor, 0, 100)
    };
}
function _clamp(n, min, max) {
    return n; // Math.max(min, Math.min(n, max));
}
function isDark(color) {
    return hsv2hsl(color.h, color.s, color.v).l < 50;
}
/**
 * Given a color and a shade specification, generates the requested shade of the color.
 * Logic:
 * if white
 *  darken via tables defined above
 * if black
 *  lighten
 * if light
 *  strongen
 * if dark
 *  soften
 * else default
 *  soften or strongen depending on shade#
 * @param color - The base color whose shade is to be computed
 * @param shade - The shade of the base color to compute
 * @param isInverted - Default false. Whether the given theme is inverted (reverse strongen/soften logic)
 */
function getShade(color, shade, isInverted = false) {
    //'use strict';
    if (!color) {
        return null;
    }
    if (shade === Shade.Unshaded || !isValidShade(shade)) {
        return color;
    }
    const hsl = hsv2hsl(color.h, color.s, color.v);
    let hsv = { h: color.h, s: color.s, v: color.v };
    const tableIndex = shade - 1;
    let _soften = _lighten;
    let _strongen = _darken;
    if (isInverted) {
        _soften = _darken;
        _strongen = _lighten;
    }
    if (_isWhite(color)) {
        // white
        hsv = _darken(hsv, WhiteShadeTable[tableIndex]);
    }
    else if (_isBlack(color)) {
        // black
        hsv = _lighten(hsv, BlackTintTable[tableIndex]);
    }
    else if (hsl.l / 100 > HighLuminanceThreshold) {
        // light
        hsv = _strongen(hsv, LumShadeTable[tableIndex]);
    }
    else if (hsl.l / 100 < LowLuminanceThreshold) {
        // dark
        hsv = _soften(hsv, LumTintTable[tableIndex]);
    }
    else {
        // default
        if (tableIndex < ColorTintTable.length) {
            hsv = _soften(hsv, ColorTintTable[tableIndex]);
        }
        else {
            hsv = _strongen(hsv, ColorShadeTable[tableIndex - ColorTintTable.length]);
        }
    }
    return getColorFromRGBA(assign(hsv2rgb(hsv.h, hsv.s, hsv.v), { a: color.a }));
}
// Background shades/tints are generated differently. The provided color will be guaranteed
//   to be the darkest or lightest one. If it is <50% luminance, it will always be the darkest,
//   otherwise it will always be the lightest.
function getBackgroundShade(color, shade, isInverted = false) {
    // 'use strict';
    if (!color) {
        return null;
    }
    if (shade === Shade.Unshaded || !isValidShade(shade)) {
        return color;
    }
    let hsv = { h: color.h, s: color.s, v: color.v };
    const tableIndex = shade - 1;
    if (!isInverted) {
        // lightish
        hsv = _darken(hsv, WhiteShadeTableBG[tableIndex]);
    }
    else {
        // default: if (hsl.l / 100 < .5) { // darkish
        hsv = _lighten(hsv, BlackTintTableBG[BlackTintTable.length - 1 - tableIndex]);
    }
    return getColorFromRGBA(assign(hsv2rgb(hsv.h, hsv.s, hsv.v), { a: color.a }));
}
/* Calculates the contrast ratio between two colors. Used for verifying
 * color pairs meet minimum accessibility requirements.
 * See: https://www.w3.org/TR/WCAG20/ section 1.4.3
 */
function getContrastRatio(color1, color2) {
    // Formula defined by: http://www.w3.org/TR/UNDERSTANDING-WCAG20/visual-audio-contrast-contrast.html#contrast-ratiodef
    // relative luminance: http://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef
    /* calculate the intermediate value needed to calculating relative luminance */
    function _getThing(x) {
        if (x <= 0.03928) {
            return x / 12.92;
        }
        else {
            return Math.pow((x + 0.055) / 1.055, 2.4);
        }
    }
    const r1 = _getThing(color1.r / MAX_COLOR_RGBA);
    const g1 = _getThing(color1.g / MAX_COLOR_RGBA);
    const b1 = _getThing(color1.b / MAX_COLOR_RGBA);
    let L1 = 0.2126 * r1 + 0.7152 * g1 + 0.0722 * b1; // relative luminance of first color
    L1 += 0.05;
    const r2 = _getThing(color2.r / MAX_COLOR_RGBA);
    const g2 = _getThing(color2.g / MAX_COLOR_RGBA);
    const b2 = _getThing(color2.b / MAX_COLOR_RGBA);
    let L2 = 0.2126 * r2 + 0.7152 * g2 + 0.0722 * b2; // relative luminance of second color
    L2 += 0.05;
    // return the lighter color divided by darker
    return L1 / L2 > 1 ? L1 / L2 : L2 / L1;
}

const getClassNames$m = classNamesFunction();
const DEFAULT_STATE_VALUE = '';
class TextFieldBase extends BaseComponent {
    constructor(props) {
        super(props);
        this._textElement = createRef$1();
        this._onFocus = (ev) => {
            if (this.props.onFocus) {
                this.props.onFocus(ev);
            }
            this.setState({ isFocused: true });
            if (this.props.validateOnFocusIn) {
                this._validate(this.state.value);
            }
        };
        this._onBlur = (ev) => {
            if (this.props.onBlur) {
                this.props.onBlur(ev);
            }
            this.setState({ isFocused: false });
            if (this.props.validateOnFocusOut) {
                this._validate(this.state.value);
            }
        };
        this._onRenderLabel = (props) => {
            const { label, required } = props;
            // IProcessedStyleSet definition requires casting for what Label expects as its styles prop
            const labelStyles = this._classNames.subComponentStyles
                ? this._classNames.subComponentStyles.label
                : undefined;
            if (label) {
                return (createElement(Label, { required: required, htmlFor: this._id, styles: labelStyles }, props.label));
            }
            return null;
        };
        this._onRenderDescription = (props) => {
            if (props.description) {
                return createElement("span", { className: this._classNames.description }, props.description);
            }
            return null;
        };
        this._onInputChange = (event) => {
            event.persist();
            const element = event.target;
            const value = element.value;
            // Avoid doing unnecessary work when the value has not changed.
            if (value === this._latestValue) {
                return;
            }
            this._latestValue = value;
            this.setState({ value: value }, () => {
                this._adjustInputHeight();
                if (this.props.onChange) {
                    this.props.onChange(event, value);
                }
                if (this.props.onChanged) {
                    this.props.onChanged(value);
                }
            });
            const { validateOnFocusIn, validateOnFocusOut } = this.props;
            if (!(validateOnFocusIn || validateOnFocusOut)) {
                this._delayedValidate(value);
            }
            if (this.props.onBeforeChange) {
                this.props.onBeforeChange(value);
            }
        };
        this._warnDeprecations({
            iconClass: 'iconProps',
            addonString: 'prefix',
            onRenderAddon: 'onRenderPrefix',
            onChanged: 'onChange'
        });
        this._warnMutuallyExclusive({
            value: 'defaultValue'
        });
        this._id = props.id || getId('TextField');
        this._descriptionId = getId('TextFieldDescription');
        if (props.value !== undefined) {
            this._latestValue = props.value;
        }
        else if (props.defaultValue !== undefined) {
            this._latestValue = props.defaultValue;
        }
        else {
            this._latestValue = DEFAULT_STATE_VALUE;
        }
        this.state = {
            value: this._latestValue,
            isFocused: false,
            errorMessage: ''
        };
        this._delayedValidate = this._async.debounce(this._validate, this.props.deferredValidationTime);
        this._lastValidation = 0;
    }
    /**
     * Gets the current value of the text field.
     */
    get value() {
        return this.state.value;
    }
    componentDidMount() {
        this._isMounted = true;
        this._adjustInputHeight();
        if (this.props.validateOnLoad) {
            this._validate(this.state.value);
        }
    }
    componentWillReceiveProps(newProps) {
        const { onBeforeChange } = this.props;
        // If old value prop was undefined, then component is controlled and we should
        //    respect new undefined value and update state accordingly.
        if (newProps.value !== this.state.value && (newProps.value !== undefined || this.props.value !== undefined)) {
            if (onBeforeChange) {
                onBeforeChange(newProps.value);
            }
            this._id = newProps.id || this._id;
            this._setValue(newProps.value);
            const { validateOnFocusIn, validateOnFocusOut } = newProps;
            if (!(validateOnFocusIn || validateOnFocusOut)) {
                this._delayedValidate(newProps.value);
            }
        }
        // If component is not currently controlled and defaultValue changes, set value to new defaultValue.
        if (newProps.defaultValue !== this.props.defaultValue && newProps.value === undefined) {
            this._setValue(newProps.defaultValue);
        }
        // Text field is changing between single- and multi-line. After the change is complete,
        // we'll need to reset focus and selection/cursor.
        if (!!newProps.multiline !== !!this.props.multiline && this.state.isFocused) {
            this._shouldResetFocusAfterRender = true;
            this._selectionBeforeInputTypeChange = [this.selectionStart, this.selectionEnd];
        }
    }
    componentDidUpdate() {
        if (this._shouldResetFocusAfterRender) {
            // The text field has just changed between single- and multi-line, so we need to reset focus
            // and selection/cursor.
            this._shouldResetFocusAfterRender = false;
            this.focus();
            if (this._selectionBeforeInputTypeChange) {
                const [start, end] = this._selectionBeforeInputTypeChange;
                if (start !== null && end !== null) {
                    this.setSelectionRange(start, end);
                }
            }
        }
    }
    componentWillUnmount() {
        this._isMounted = false;
    }
    render() {
        const { borderless, className, disabled, iconClass, iconProps, inputClassName, label, multiline, required, underlined, addonString, // @deprecated
        prefix, resizable, suffix, theme, styles, autoAdjustHeight, onRenderAddon = this._onRenderAddon, // @deprecated
        onRenderPrefix = this._onRenderPrefix, onRenderSuffix = this._onRenderSuffix, onRenderLabel = this._onRenderLabel, onRenderDescription = this._onRenderDescription } = this.props;
        const { isFocused } = this.state;
        const errorMessage = this._errorMessage;
        this._classNames = getClassNames$m(styles, {
            theme: theme,
            className,
            disabled,
            focused: isFocused,
            required,
            multiline,
            hasLabel: !!label,
            hasErrorMessage: !!errorMessage,
            borderless,
            resizable,
            hasIcon: !!iconProps,
            underlined,
            iconClass,
            inputClassName,
            autoAdjustHeight
        });
        return (createElement("div", { className: this._classNames.root },
            createElement("div", { className: this._classNames.wrapper },
                onRenderLabel(this.props, this._onRenderLabel),
                createElement("div", { className: this._classNames.fieldGroup },
                    (addonString !== undefined || this.props.onRenderAddon) && (createElement("div", { className: this._classNames.prefix }, onRenderAddon(this.props, this._onRenderAddon))),
                    (prefix !== undefined || this.props.onRenderPrefix) && (createElement("div", { className: this._classNames.prefix }, onRenderPrefix(this.props, this._onRenderPrefix))),
                    multiline ? this._renderTextArea() : this._renderInput(),
                    (iconClass || iconProps) && createElement(Icon, Object.assign({ className: this._classNames.icon }, iconProps)),
                    (suffix !== undefined || this.props.onRenderSuffix) && (createElement("div", { className: this._classNames.suffix }, onRenderSuffix(this.props, this._onRenderSuffix))))),
            this._isDescriptionAvailable && (createElement("span", { id: this._descriptionId },
                onRenderDescription(this.props, this._onRenderDescription),
                errorMessage && (createElement("div", { role: "alert" },
                    createElement(DelayedRender, null,
                        createElement("p", { className: this._classNames.errorMessage },
                            createElement("span", { "data-automation-id": "error-message" }, errorMessage)))))))));
    }
    /**
     * Sets focus on the text field
     */
    focus() {
        if (this._textElement.current) {
            this._textElement.current.focus();
        }
    }
    /**
     * Blurs the text field.
     */
    blur() {
        if (this._textElement.current) {
            this._textElement.current.blur();
        }
    }
    /**
     * Selects the text field
     */
    select() {
        if (this._textElement.current) {
            this._textElement.current.select();
        }
    }
    /**
     * Sets the selection start of the text field to a specified value
     */
    setSelectionStart(value) {
        if (this._textElement.current) {
            this._textElement.current.selectionStart = value;
        }
    }
    /**
     * Sets the selection end of the text field to a specified value
     */
    setSelectionEnd(value) {
        if (this._textElement.current) {
            this._textElement.current.selectionEnd = value;
        }
    }
    /**
     * Gets the selection start of the text field
     */
    get selectionStart() {
        return this._textElement.current ? this._textElement.current.selectionStart : -1;
    }
    /**
     * Gets the selection end of the text field
     */
    get selectionEnd() {
        return this._textElement.current ? this._textElement.current.selectionEnd : -1;
    }
    /**
     * Sets the start and end positions of a selection in a text field.
     * @param start - Index of the start of the selection.
     * @param end - Index of the end of the selection.
     */
    setSelectionRange(start, end) {
        if (this._textElement.current) {
            this._textElement.current.setSelectionRange(start, end);
        }
    }
    _setValue(value) {
        this._latestValue = value;
        this.setState({
            value: value || DEFAULT_STATE_VALUE,
            errorMessage: ''
        }, () => {
            this._adjustInputHeight();
        });
    }
    // @deprecated
    _onRenderAddon(props) {
        const { addonString } = props;
        return createElement("span", { style: { paddingBottom: '1px' } }, addonString);
    }
    _onRenderPrefix(props) {
        const { prefix } = props;
        return createElement("span", { style: { paddingBottom: '1px' } }, prefix);
    }
    _onRenderSuffix(props) {
        const { suffix } = props;
        return createElement("span", { style: { paddingBottom: '1px' } }, suffix);
    }
    get _errorMessage() {
        let { errorMessage } = this.state;
        if (!errorMessage && this.props.errorMessage) {
            errorMessage = this.props.errorMessage;
        }
        return errorMessage;
    }
    /**
     * If a custom description render function is supplied then treat description as always available.
     * Otherwise defer to the presence of description or error message text.
     */
    get _isDescriptionAvailable() {
        const props = this.props;
        return !!(props.onRenderDescription || props.description || this._errorMessage);
    }
    _renderTextArea() {
        const textAreaProps = getNativeProps(this.props, textAreaProperties, ['defaultValue']);
        return (createElement("textarea", Object.assign({ id: this._id }, textAreaProps, { ref: this._textElement, value: this.state.value, onInput: this._onInputChange, onChange: this._onInputChange, className: this._classNames.field, "aria-describedby": this._isDescriptionAvailable ? this._descriptionId : this.props['aria-describedby'], "aria-invalid": !!this.state.errorMessage, "aria-label": this.props.ariaLabel, readOnly: this.props.readOnly, onFocus: this._onFocus, onBlur: this._onBlur })));
    }
    _renderInput() {
        const inputProps = getNativeProps(this.props, inputProperties, ['defaultValue']);
        return (createElement("input", Object.assign({ type: 'text', id: this._id }, inputProps, { ref: this._textElement, value: this.state.value, onInput: this._onInputChange, onChange: this._onInputChange, className: this._classNames.field, "aria-label": this.props.ariaLabel, "aria-describedby": this._isDescriptionAvailable ? this._descriptionId : this.props['aria-describedby'], "aria-invalid": !!this.state.errorMessage, readOnly: this.props.readOnly, onFocus: this._onFocus, onBlur: this._onBlur })));
    }
    _validate(value) {
        const { validateOnFocusIn, validateOnFocusOut } = this.props;
        // In case of _validate called multi-times during executing validate logic with promise return.
        if (this._latestValidateValue === value && !(validateOnFocusIn || validateOnFocusOut)) {
            return;
        }
        this._latestValidateValue = value;
        const onGetErrorMessage = this.props.onGetErrorMessage;
        const result = onGetErrorMessage(value || '');
        if (result !== undefined) {
            if (typeof result === 'string') {
                this.setState({ errorMessage: result });
                this._notifyAfterValidate(value, result);
            }
            else {
                const currentValidation = ++this._lastValidation;
                result.then((errorMessage) => {
                    if (this._isMounted && currentValidation === this._lastValidation) {
                        this.setState({ errorMessage });
                    }
                    this._notifyAfterValidate(value, errorMessage);
                });
            }
        }
        else {
            this._notifyAfterValidate(value, '');
        }
    }
    _notifyAfterValidate(value, errorMessage) {
        if (this._isMounted && value === this.state.value && this.props.onNotifyValidationResult) {
            this.props.onNotifyValidationResult(errorMessage, value);
        }
    }
    _adjustInputHeight() {
        if (this._textElement.current && this.props.autoAdjustHeight && this.props.multiline) {
            const textField = this._textElement.current;
            textField.style.height = '';
            textField.style.height = textField.scrollHeight + 'px';
        }
    }
}
TextFieldBase.defaultProps = {
    multiline: false,
    resizable: true,
    autoAdjustHeight: false,
    underlined: false,
    borderless: false,
    onChange: () => {
        /* noop */
    },
    onBeforeChange: () => {
        /* noop */
    },
    onNotifyValidationResult: () => {
        /* noop */
    },
    onGetErrorMessage: () => undefined,
    deferredValidationTime: 200,
    errorMessage: '',
    validateOnFocusIn: false,
    validateOnFocusOut: false,
    validateOnLoad: true
};

const globalClassNames = {
    root: 'ms-TextField',
    description: 'ms-TextField-description',
    errorMessage: 'ms-TextField-errorMessage',
    field: 'ms-TextField-field',
    fieldGroup: 'ms-TextField-fieldGroup',
    prefix: 'ms-TextField-prefix',
    suffix: 'ms-TextField-suffix',
    wrapper: 'ms-TextField-wrapper',
    multiline: 'ms-TextField--multiline',
    borderless: 'ms-TextField--borderless',
    underlined: 'ms-TextField--underlined',
    unresizable: 'ms-TextField--unresizable',
    required: 'is-required',
    disabled: 'is-disabled',
    active: 'is-active'
};
function getLabelStyles(props) {
    const { underlined, disabled } = props;
    return () => ({
        root: [
            underlined &&
                disabled && {
                color: props.theme.palette.neutralTertiary
            },
            underlined && {
                fontSize: FontSizes.medium,
                marginRight: 8,
                paddingLeft: 12,
                paddingRight: 0,
                lineHeight: '22px',
                height: 32
            }
        ]
    });
}
function getStyles$t(props) {
    const { theme, className, disabled, focused, required, multiline, hasLabel, borderless, underlined, hasIcon, resizable, hasErrorMessage, iconClass, inputClassName, autoAdjustHeight } = props;
    const { semanticColors, palette } = theme;
    const classNames = getGlobalClassNames(globalClassNames, theme);
    const fieldPrefixSuffix = {
        background: palette.neutralLighter,
        color: palette.neutralSecondary,
        display: 'flex',
        alignItems: 'center',
        padding: '0 10px',
        lineHeight: 1,
        whiteSpace: 'nowrap'
    };
    return {
        root: [
            classNames.root,
            required && classNames.required,
            disabled && classNames.disabled,
            focused && classNames.active,
            multiline && classNames.multiline,
            borderless && classNames.borderless,
            underlined && classNames.underlined,
            normalize,
            {
                position: 'relative',
                selectors: {
                    [HighContrastSelector]: {
                        borderWidth: 2
                    }
                }
            },
            focused && {
                borderColor: semanticColors.inputFocusBorderAlt
            },
            underlined &&
                !focused && {
                border: `0px solid ${semanticColors.inputBorder}`
            },
            underlined &&
                !disabled &&
                !focused && {
                selectors: {
                    ':hover': {
                        borderColor: semanticColors.inputBorderHovered
                    }
                }
            },
            className
        ],
        wrapper: [
            classNames.wrapper,
            underlined && {
                display: 'flex',
                borderBottomWidth: 1,
                borderBottomStyle: 'solid',
                borderBottomColor: 'inherit',
                width: '100%'
            },
            hasErrorMessage && {
                borderColor: semanticColors.errorText,
                selectors: {
                    '&:focus, &:hover': {
                        borderColor: semanticColors.errorText
                    }
                }
            },
            hasErrorMessage &&
                underlined &&
                !disabled && {
                borderBottom: `1px solid ${semanticColors.errorText}`,
                selectors: {
                    ':focus': {
                        borderBottom: `1px solid ${semanticColors.errorText}`
                    },
                    ':hover': {
                        borderBottom: `1px solid ${semanticColors.errorText}`
                    }
                }
            },
            underlined &&
                disabled && {
                borderBottomColor: semanticColors.disabledBackground
            },
            underlined &&
                !disabled && {
                selectors: {
                    ':hover': {
                        selectors: {
                            [HighContrastSelector]: {
                                borderColor: 'Highlight'
                            }
                        }
                    }
                }
            },
            underlined &&
                focused && {
                selectors: {
                    [HighContrastSelector]: {
                        borderColor: 'Highlight'
                    }
                }
            }
        ],
        fieldGroup: [
            classNames.fieldGroup,
            normalize,
            {
                border: `1px solid ${semanticColors.inputBorder}`,
                background: semanticColors.bodyBackground,
                height: 32,
                display: 'flex',
                flexDirection: 'row',
                alignItems: 'stretch',
                position: 'relative',
                selectors: {
                    ':hover': {
                        selectors: {
                            [HighContrastSelector]: {
                                borderColor: 'Highlight'
                            }
                        }
                    }
                }
            },
            multiline && {
                minHeight: '60px',
                height: 'auto',
                display: 'flex'
            },
            borderless && {
                borderColor: 'transparent',
                borderWidth: 0
            },
            !focused &&
                !disabled && {
                selectors: {
                    ':hover': {
                        borderColor: semanticColors.inputBorderHovered
                    }
                }
            },
            focused && {
                borderColor: semanticColors.inputFocusBorderAlt,
                selectors: {
                    [HighContrastSelector]: {
                        borderWidth: 2,
                        borderColor: 'Highlight'
                    }
                }
            },
            disabled && {
                backgroundColor: semanticColors.disabledBackground,
                borderColor: semanticColors.disabledBackground
            },
            underlined && {
                flex: '1 1 0px',
                borderWidth: 0,
                textAlign: 'left'
            },
            underlined &&
                disabled && {
                backgroundColor: 'transparent'
            },
            hasErrorMessage && {
                borderColor: semanticColors.errorText,
                selectors: {
                    '&:focus, &:hover': {
                        borderColor: semanticColors.errorText
                    }
                }
            },
            hasErrorMessage &&
                focused && {
                borderColor: semanticColors.errorText
            },
            !hasLabel &&
                required && {
                selectors: {
                    ':after': {
                        content: `'*'`,
                        color: semanticColors.errorText,
                        position: 'absolute',
                        top: -5,
                        right: -10
                    }
                }
            }
        ],
        field: [
            classNames.field,
            normalize,
            {
                fontSize: FontSizes.medium,
                borderRadius: 0,
                border: 'none',
                background: 'none',
                backgroundColor: 'transparent',
                color: semanticColors.bodyText,
                padding: '0 12px',
                width: '100%',
                minWidth: 0,
                textOverflow: 'ellipsis',
                outline: 0,
                selectors: {
                    '&:active, &:focus, &:hover': { outline: 0 },
                    '::-ms-clear': {
                        display: 'none'
                    },
                    '::placeholder': {
                        color: semanticColors.inputPlaceholderText,
                        opacity: 1
                    },
                    ':-ms-input-placeholder': {
                        color: semanticColors.inputPlaceholderText,
                        opacity: 1
                    }
                }
            },
            multiline &&
                !resizable && [
                classNames.unresizable,
                {
                    resize: 'none'
                }
            ],
            multiline && {
                minHeight: 'inherit',
                lineHeight: 17,
                flexGrow: 1,
                paddingTop: 6,
                overflow: 'auto',
                width: '100%'
            },
            multiline &&
                autoAdjustHeight && {
                overflow: 'hidden'
            },
            hasIcon && {
                paddingRight: 24
            },
            multiline &&
                hasIcon && {
                paddingRight: 40
            },
            disabled && {
                backgroundColor: 'transparent',
                borderColor: 'transparent'
            },
            underlined && {
                textAlign: 'left'
            },
            underlined &&
                disabled && {
                backgroundColor: 'transparent',
                color: semanticColors.disabledText
            },
            focused && {
                selectors: {
                    [HighContrastSelector]: {
                        padding: '0 11px 0 11px'
                    }
                }
            },
            inputClassName
        ],
        icon: [
            multiline && {
                paddingRight: 24,
                paddingBottom: 8,
                alignItems: 'flex-end'
            },
            {
                pointerEvents: 'none',
                position: 'absolute',
                bottom: 5,
                right: 8,
                top: 'auto',
                fontSize: 16,
                lineHeight: 18
            },
            iconClass
        ],
        description: [
            classNames.description,
            {
                color: semanticColors.bodySubtext,
                fontSize: FontSizes.xSmall
            }
        ],
        errorMessage: [
            classNames.errorMessage,
            AnimationClassNames.slideDownIn20,
            theme.fonts.small,
            {
                color: semanticColors.errorText,
                margin: 0,
                paddingTop: 5,
                display: 'flex',
                alignItems: 'center'
            }
        ],
        prefix: [classNames.prefix, fieldPrefixSuffix],
        suffix: [classNames.suffix, fieldPrefixSuffix],
        subComponentStyles: {
            label: getLabelStyles(props)
        }
    };
}

const TextField = styled(TextFieldBase, getStyles$t, undefined, {
    scope: 'TextField'
});

const DEFAULT_MASK_FORMAT_CHARS = {
    '9': /[0-9]/,
    a: /[a-zA-Z]/,
    '*': /[a-zA-Z0-9]/
};
/**
 * Takes in the mask string and the formatCharacters and returns an array of MaskValues
 * Example:
 * mask = 'Phone Number: (999) - 9999'
 * return = [
 *    { value: undefined, displayIndex: 16, format: /[0-9]/ },
 *    { value: undefined, displayIndex: 17, format: /[0-9]/ },
 *    { value: undefined, displayIndex: 18, format: /[0-9]/ },
 *    { value: undefined, displayIndex: 22, format: /[0-9]/ },
 * ]
 *
 * @param mask The string use to define the format of the displayed maskedValue.
 * @param formatChars An object defining how certain characters in the mask should accept input.
 */
function parseMask(mask, formatChars = DEFAULT_MASK_FORMAT_CHARS) {
    if (!mask) {
        return [];
    }
    const maskCharData = [];
    // Count the escape characters in the mask string.
    let escapedChars = 0;
    for (let i = 0; i + escapedChars < mask.length; i++) {
        const maskChar = mask.charAt(i + escapedChars);
        if (maskChar === '\\') {
            escapedChars++;
        }
        else {
            // Check if the maskChar is a format character.
            const maskFormat = formatChars[maskChar];
            if (maskFormat) {
                maskCharData.push({
                    /**
                     * Do not add escapedChars to the displayIndex.
                     * The index refers to a position in the mask's displayValue.
                     * Since the backslashes don't appear in the displayValue,
                     * we do not add them to the charData displayIndex.
                     */
                    displayIndex: i,
                    format: maskFormat
                });
            }
        }
    }
    return maskCharData;
}
/**
 * Takes in the mask string, an array of MaskValues, and the maskCharacter
 * returns the mask string formatted with the input values and maskCharacter.
 * If the maskChar is undefined, the maskDisplay is truncated to the last filled format character.
 * Example:
 * mask = 'Phone Number: (999) 999 - 9999'
 * maskCharData = '12345'
 * maskChar = '_'
 * return = 'Phone Number: (123) 45_ - ___'
 *
 * Example:
 * mask = 'Phone Number: (999) 999 - 9999'
 * value = '12345'
 * maskChar = undefined
 * return = 'Phone Number: (123) 45'
 *
 * @param mask The string use to define the format of the displayed maskedValue.
 * @param maskCharData The input values to insert into the mask string for displaying.
 * @param maskChar? A character to display in place of unfilled mask format characters.
 */
function getMaskDisplay(mask, maskCharData, maskChar) {
    let maskDisplay = mask;
    if (!maskDisplay) {
        return '';
    }
    // Remove all backslashes
    maskDisplay = maskDisplay.replace(/\\/g, '');
    // lastDisplayIndex is is used to truncate the string if necessary.
    let lastDisplayIndex = 0;
    if (maskCharData.length > 0) {
        lastDisplayIndex = maskCharData[0].displayIndex - 1;
    }
    /**
     * For each input value, replace the character in the maskDisplay with the value.
     * If there is no value set for the format character, use the maskChar.
     */
    for (const charData of maskCharData) {
        let nextChar = ' ';
        if (charData.value) {
            nextChar = charData.value;
            if (charData.displayIndex > lastDisplayIndex) {
                lastDisplayIndex = charData.displayIndex;
            }
        }
        else {
            if (maskChar) {
                nextChar = maskChar;
            }
        }
        // Insert the character into the maskdisplay at its corresponding index
        maskDisplay = maskDisplay.slice(0, charData.displayIndex) + nextChar + maskDisplay.slice(charData.displayIndex + 1);
    }
    // Cut off all mask characters after the last filled format value
    if (!maskChar) {
        maskDisplay = maskDisplay.slice(0, lastDisplayIndex + 1);
    }
    return maskDisplay;
}
/**
 * Get the next format index right of or at a specified index.
 * If no index exists, returns the rightmost index.
 * @param maskCharData
 * @param index
 */
function getRightFormatIndex(maskCharData, index) {
    for (let i = 0; i < maskCharData.length; i++) {
        if (maskCharData[i].displayIndex >= index) {
            return maskCharData[i].displayIndex;
        }
    }
    return maskCharData[maskCharData.length - 1].displayIndex;
}
/**
 * Get the next format index left of a specified index.
 * If no index exists, returns the leftmost index.
 * @param maskCharData
 * @param index
 */
function getLeftFormatIndex(maskCharData, index) {
    for (let i = maskCharData.length - 1; i >= 0; i--) {
        if (maskCharData[i].displayIndex < index) {
            return maskCharData[i].displayIndex;
        }
    }
    return maskCharData[0].displayIndex;
}
/**
 * Deletes all values in maskCharData with a displayIndex that falls inside the specified range.
 * maskCharData is modified inline and also returned.
 * @param maskCharData
 * @param selectionStart
 * @param selectionCount
 */
function clearRange(maskCharData, selectionStart, selectionCount) {
    for (let i = 0; i < maskCharData.length; i++) {
        if (maskCharData[i].displayIndex >= selectionStart) {
            if (maskCharData[i].displayIndex >= selectionStart + selectionCount) {
                break;
            }
            maskCharData[i].value = undefined;
        }
    }
    return maskCharData;
}
/**
 * Deletes the input character at or after a specified index and returns the new array of charData
 * maskCharData is modified inline and also returned.
 * @param maskCharData
 * @param selectionStart
 */
function clearNext(maskCharData, selectionStart) {
    for (let i = 0; i < maskCharData.length; i++) {
        if (maskCharData[i].displayIndex >= selectionStart) {
            maskCharData[i].value = undefined;
            break;
        }
    }
    return maskCharData;
}
/**
 * Deletes the input character before a specified index and returns the new array of charData
 * maskCharData is modified inline and also returned.
 * @param maskCharData
 * @param selectionStart
 */
function clearPrev(maskCharData, selectionStart) {
    for (let i = maskCharData.length - 1; i >= 0; i--) {
        if (maskCharData[i].displayIndex < selectionStart) {
            maskCharData[i].value = undefined;
            break;
        }
    }
    return maskCharData;
}
/**
 * Deletes all values in maskCharData with a displayIndex that falls inside the specified range.
 * Modifies the maskCharData inplace with the passed string and returns the display index of the
 * next format character after the inserted string.
 * @param maskCharData
 * @param selectionStart
 * @param selectionCount
 * @return The displayIndex of the next format character
 */
function insertString(maskCharData, selectionStart, newString) {
    let stringIndex = 0;
    let nextIndex = 0;
    let isStringInserted = false;
    // Iterate through _maskCharData finding values with a displayIndex after the specified range start
    for (let i = 0; i < maskCharData.length && stringIndex < newString.length; i++) {
        if (maskCharData[i].displayIndex >= selectionStart) {
            isStringInserted = true;
            nextIndex = maskCharData[i].displayIndex;
            // Find the next character in the newString that matches the format
            while (stringIndex < newString.length) {
                // If the character matches the format regexp, set the maskCharData to the new character
                if (maskCharData[i].format.test(newString.charAt(stringIndex))) {
                    maskCharData[i].value = newString.charAt(stringIndex++);
                    // Set the nextIndex to the display index of the next mask format character.
                    if (i + 1 < maskCharData.length) {
                        nextIndex = maskCharData[i + 1].displayIndex;
                    }
                    else {
                        nextIndex++;
                    }
                    break;
                }
                stringIndex++;
            }
        }
    }
    return isStringInserted ? nextIndex : selectionStart;
}

const DEFAULT_MASK_CHAR = '_';
class MaskedTextField extends BaseComponent {
    constructor(props) {
        super(props);
        /**
         * Tell BaseComponent to bypass resolution of componentRef.
         */
        this._skipComponentRefResolution = true;
        // Translate mask into charData
        this._maskCharData = parseMask(props.mask, props.maskFormat);
        // If an initial value is provided, use it to populate the format chars
        props.value && this.setValue(props.value);
        this._isFocused = false;
        this._moveCursorOnMouseUp = false;
        this.state = {
            displayValue: getMaskDisplay(props.mask, this._maskCharData, props.maskChar)
        };
    }
    componentWillReceiveProps(newProps) {
        if (newProps.mask !== this.props.mask) {
            this._maskCharData = parseMask(newProps.mask, newProps.maskFormat);
            this.state = {
                displayValue: getMaskDisplay(newProps.mask, this._maskCharData, newProps.maskChar)
            };
        }
    }
    componentDidUpdate() {
        // Move the cursor to the start of the mask format on update
        if (this.state.maskCursorPosition !== undefined) {
            this._textField.setSelectionRange(this.state.maskCursorPosition, this.state.maskCursorPosition);
        }
    }
    render() {
        return (createElement(TextField, Object.assign({}, this.props, { onFocus: this._onFocus, onBlur: this._onBlur, onMouseDown: this._onMouseDown, onMouseUp: this._onMouseUp, onChange: this._onInputChange, onBeforeChange: this._onBeforeChange, onKeyDown: this._onKeyDown, onPaste: this._onPaste, value: this.state.displayValue, componentRef: this._resolveRef('_textField') })));
    }
    /**
     * @returns The value of all filled format characters or undefined if not all format characters are filled
     */
    get value() {
        let value = '';
        for (let i = 0; i < this._maskCharData.length; i++) {
            if (!this._maskCharData[i].value) {
                return undefined;
            }
            value += this._maskCharData[i].value;
        }
        return value;
    }
    /**
     *
     */
    setValue(newValue) {
        let valueIndex = 0, charDataIndex = 0;
        while (valueIndex < newValue.length && charDataIndex < this._maskCharData.length) {
            // Test if the next character in the new value fits the next format character
            const testVal = newValue[valueIndex];
            if (this._maskCharData[charDataIndex].format.test(testVal)) {
                this._maskCharData[charDataIndex].value = testVal;
                charDataIndex++;
            }
            valueIndex++;
        }
    }
    focus() {
        this._textField && this._textField.focus();
    }
    blur() {
        this._textField && this._textField.blur();
    }
    select() {
        this._textField && this._textField.select();
    }
    setSelectionStart(value) {
        this._textField && this._textField.setSelectionStart(value);
    }
    setSelectionEnd(value) {
        this._textField && this._textField.setSelectionEnd(value);
    }
    setSelectionRange(start, end) {
        this._textField && this._textField.setSelectionRange(start, end);
    }
    get selectionStart() {
        return this._textField && this._textField.selectionStart !== null ? this._textField.selectionStart : -1;
    }
    get selectionEnd() {
        return this._textField && this._textField.selectionEnd ? this._textField.selectionEnd : -1;
    }
    _onFocus(event) {
        if (this.props.onFocus) {
            this.props.onFocus(event);
        }
        this._isFocused = true;
        // Move the cursor position to the leftmost unfilled position
        for (let i = 0; i < this._maskCharData.length; i++) {
            if (!this._maskCharData[i].value) {
                this.setState({
                    maskCursorPosition: this._maskCharData[i].displayIndex
                });
                break;
            }
        }
    }
    _onBlur(event) {
        if (this.props.onBlur) {
            this.props.onBlur(event);
        }
        this._isFocused = false;
        this._moveCursorOnMouseUp = true;
    }
    _onMouseDown(event) {
        if (this.props.onMouseDown) {
            this.props.onMouseDown(event);
        }
        if (!this._isFocused) {
            this._moveCursorOnMouseUp = true;
        }
    }
    _onMouseUp(event) {
        if (this.props.onMouseUp) {
            this.props.onMouseUp(event);
        }
        // Move the cursor on mouseUp after focusing the textField
        if (this._moveCursorOnMouseUp) {
            this._moveCursorOnMouseUp = false;
            // Move the cursor position to the rightmost unfilled position
            for (let i = 0; i < this._maskCharData.length; i++) {
                if (!this._maskCharData[i].value) {
                    this.setState({
                        maskCursorPosition: this._maskCharData[i].displayIndex
                    });
                    break;
                }
            }
        }
    }
    _onBeforeChange(value) {
        if (this.props.onBeforeChange) {
            this.props.onBeforeChange(value);
        }
        if (this._changeSelectionData === null) {
            this._changeSelectionData = {
                changeType: 'default',
                selectionStart: this._textField.selectionStart !== null ? this._textField.selectionStart : -1,
                selectionEnd: this._textField.selectionEnd !== null ? this._textField.selectionEnd : -1
            };
        }
    }
    _onInputChange(ev, value) {
        if (!this._changeSelectionData) {
            return;
        }
        const { displayValue } = this.state;
        // The initial value of cursorPos does not matter
        let cursorPos = 0;
        const { changeType, selectionStart, selectionEnd } = this._changeSelectionData;
        if (changeType === 'textPasted') {
            const charsSelected = selectionEnd - selectionStart, charCount = value.length + charsSelected - displayValue.length, startPos = selectionStart, pastedString = value.substr(startPos, charCount);
            // Clear any selected characters
            if (charsSelected) {
                this._maskCharData = clearRange(this._maskCharData, selectionStart, charsSelected);
            }
            cursorPos = insertString(this._maskCharData, startPos, pastedString);
        }
        else if (changeType === 'delete' || changeType === 'backspace') {
            // isDel is true If the characters are removed LTR, otherwise RTL
            const isDel = changeType === 'delete', charCount = selectionEnd - selectionStart;
            if (charCount) {
                // charCount is > 0 if range was deleted
                this._maskCharData = clearRange(this._maskCharData, selectionStart, charCount);
                cursorPos = getRightFormatIndex(this._maskCharData, selectionStart);
            }
            else {
                // If charCount === 0, there was no selection and a single character was deleted
                if (isDel) {
                    this._maskCharData = clearNext(this._maskCharData, selectionStart);
                    cursorPos = getRightFormatIndex(this._maskCharData, selectionStart);
                }
                else {
                    this._maskCharData = clearPrev(this._maskCharData, selectionStart);
                    cursorPos = getLeftFormatIndex(this._maskCharData, selectionStart);
                }
            }
        }
        else if (value.length > displayValue.length) {
            // This case is if the user added characters
            const charCount = value.length - displayValue.length, startPos = selectionEnd - charCount, enteredString = value.substr(startPos, charCount);
            cursorPos = insertString(this._maskCharData, startPos, enteredString);
        }
        else if (value.length <= displayValue.length) {
            /**
             * This case is reached only if the user has selected a block of 1 or more
             * characters and input a character replacing the characters they've selected.
             */
            const charCount = 1, selectCount = displayValue.length + charCount - value.length, startPos = selectionEnd - charCount, enteredString = value.substr(startPos, charCount);
            // Clear the selected range
            this._maskCharData = clearRange(this._maskCharData, startPos, selectCount);
            // Insert the printed character
            cursorPos = insertString(this._maskCharData, startPos, enteredString);
        }
        this._changeSelectionData = null;
        const newValue = getMaskDisplay(this.props.mask, this._maskCharData, this.props.maskChar);
        this.setState({
            displayValue: newValue,
            maskCursorPosition: cursorPos
        });
        // Perform onChange/d after input has been processed. Return value is expected to be the displayed text
        if (this.props.onChange) {
            this.props.onChange(ev, newValue);
        }
        if (this.props.onChanged) {
            this.props.onChanged(newValue);
        }
    }
    _onKeyDown(event) {
        if (this.props.onKeyDown) {
            this.props.onKeyDown(event);
        }
        this._changeSelectionData = null;
        if (this._textField.value) {
            const { keyCode, ctrlKey, metaKey } = event;
            // Ignore ctrl and meta keydown
            if (ctrlKey || metaKey) {
                return;
            }
            // On backspace or delete, store the selection and the keyCode
            if (keyCode === KeyCodes.backspace || keyCode === KeyCodes.del) {
                const selectionStart = event.target.selectionStart, selectionEnd = event.target.selectionEnd;
                // Check if backspace or delete press is valid.
                if (!(keyCode === KeyCodes.backspace && selectionEnd && selectionEnd > 0) &&
                    !(keyCode === KeyCodes.del && selectionStart !== null && selectionStart < this._textField.value.length)) {
                    return;
                }
                this._changeSelectionData = {
                    changeType: keyCode === KeyCodes.backspace ? 'backspace' : 'delete',
                    selectionStart: selectionStart !== null ? selectionStart : -1,
                    selectionEnd: selectionEnd !== null ? selectionEnd : -1
                };
            }
        }
    }
    _onPaste(event) {
        if (this.props.onPaste) {
            this.props.onPaste(event);
        }
        const selectionStart = event.target.selectionStart, selectionEnd = event.target.selectionEnd;
        // Store the paste selection range
        this._changeSelectionData = {
            changeType: 'textPasted',
            selectionStart: selectionStart !== null ? selectionStart : -1,
            selectionEnd: selectionEnd !== null ? selectionEnd : -1
        };
    }
}
MaskedTextField.defaultProps = {
    maskChar: DEFAULT_MASK_CHAR,
    maskFormat: DEFAULT_MASK_FORMAT_CHARS
};
__decorate([
    autobind
], MaskedTextField.prototype, "_onFocus", null);
__decorate([
    autobind
], MaskedTextField.prototype, "_onBlur", null);
__decorate([
    autobind
], MaskedTextField.prototype, "_onMouseDown", null);
__decorate([
    autobind
], MaskedTextField.prototype, "_onMouseUp", null);
__decorate([
    autobind
], MaskedTextField.prototype, "_onBeforeChange", null);
__decorate([
    autobind
], MaskedTextField.prototype, "_onInputChange", null);
__decorate([
    autobind
], MaskedTextField.prototype, "_onKeyDown", null);
__decorate([
    autobind
], MaskedTextField.prototype, "_onPaste", null);

const getClassNames$n = classNamesFunction();
class ColorRectangleBase extends BaseComponent {
    constructor(props) {
        super(props);
        this._root = createRef();
        this._onMouseDown = (ev) => {
            this._events.on(window, 'mousemove', this._onMouseMove, true);
            this._events.on(window, 'mouseup', this._onMouseUp, true);
            this._onMouseMove(ev);
        };
        this._onMouseMove = (ev) => {
            const { color, onSVChanged } = this.props;
            if (!this._root.current) {
                return;
            }
            const rectSize = this._root.current.getBoundingClientRect();
            const sPercentage = (ev.clientX - rectSize.left) / rectSize.width;
            const vPercentage = (ev.clientY - rectSize.top) / rectSize.height;
            const newColor = assign({}, color, {
                s: Math.min(MAX_COLOR_SATURATION, Math.max(0, sPercentage * MAX_COLOR_SATURATION)),
                v: Math.min(MAX_COLOR_VALUE, Math.max(0, MAX_COLOR_VALUE - vPercentage * MAX_COLOR_VALUE))
            });
            newColor.hex = hsv2hex(newColor.h, newColor.s, newColor.v);
            newColor.str = newColor.a === 100 ? '#' + newColor.hex : `rgba(${newColor.r}, ${newColor.g}, ${newColor.b}, ${newColor.a / 100})`;
            this.setState({
                isAdjusting: true,
                color: newColor
            });
            if (onSVChanged) {
                onSVChanged(newColor.s, newColor.v);
            }
            ev.preventDefault();
            ev.stopPropagation();
        };
        this._onMouseUp = (ev) => {
            this._events.off();
            this.setState({
                isAdjusting: false,
                origin: undefined
            });
        };
        const { color } = this.props;
        this.state = {
            isAdjusting: false,
            origin: undefined,
            color: color,
            fullColorString: getFullColorString(color)
        };
    }
    componentWillUnmount() {
        this._events.dispose();
    }
    componentWillReceiveProps(newProps) {
        const { color } = newProps;
        this.setState({
            color: color,
            fullColorString: getFullColorString(color)
        });
    }
    render() {
        const { minSize, theme, className, styles } = this.props;
        const { color, fullColorString } = this.state;
        const classNames = getClassNames$n(styles, {
            theme: theme,
            className
        });
        return (createElement("div", { ref: this._root, className: classNames.root, style: { minWidth: minSize, minHeight: minSize, backgroundColor: fullColorString }, onMouseDown: this._onMouseDown },
            createElement("div", { className: classNames.light }),
            createElement("div", { className: classNames.dark }),
            createElement("div", { className: classNames.thumb, style: { left: color.s + '%', top: MAX_COLOR_VALUE - color.v + '%', backgroundColor: color.str } })));
    }
}
ColorRectangleBase.defaultProps = {
    minSize: 220
};

const getStyles$u = (props) => {
    const { className } = props;
    return {
        root: [
            'ms-ColorPicker-colorRect',
            {
                position: 'relative',
                marginBottom: 10,
                selectors: {
                    [HighContrastSelector]: {
                        MsHighContrastAdjust: 'none'
                    }
                }
            },
            className
        ],
        light: [
            'ms-ColorPicker-light',
            {
                position: 'absolute',
                left: 0,
                right: 0,
                top: 0,
                bottom: 0,
                background: 'linear-gradient(to right, white 0%, transparent 100%)'
            }
        ],
        dark: [
            'ms-ColorPicker-dark',
            {
                position: 'absolute',
                left: 0,
                right: 0,
                top: 0,
                bottom: 0,
                background: 'linear-gradient(to bottom, transparent 0, #000 100%)'
            }
        ],
        thumb: [
            'ms-ColorPicker-thumb',
            {
                position: 'absolute',
                width: 20,
                height: 20,
                background: 'white',
                border: '1px solid rgba(255,255,255,.8)',
                borderRadius: '50%',
                boxShadow: '0 0 15px -5px black',
                transform: 'translate(-50%, -50%)'
            }
        ]
    };
};

const ColorRectangle = styled(ColorRectangleBase, getStyles$u, undefined, { scope: 'ColorRectangle' });

const getClassNames$o = classNamesFunction();
class ColorSliderBase extends BaseComponent {
    constructor(props) {
        super(props);
        this._root = createRef();
        this._onMouseDown = (ev) => {
            this._events.on(window, 'mousemove', this._onMouseMove, true);
            this._events.on(window, 'mouseup', this._onMouseUp, true);
            this._onMouseMove(ev);
        };
        this._onMouseMove = (ev) => {
            if (!this._root.current) {
                return;
            }
            const { onChange, onChanged, minValue, maxValue } = this.props;
            const rectSize = this._root.current.getBoundingClientRect();
            const currentPercentage = (ev.clientX - rectSize.left) / rectSize.width;
            const newValue = Math.min(maxValue, Math.max(minValue, currentPercentage * maxValue));
            this.setState({
                isAdjusting: true,
                currentValue: newValue
            });
            if (onChange) {
                onChange(ev, newValue);
            }
            if (onChanged) {
                onChanged(newValue);
            }
            ev.preventDefault();
            ev.stopPropagation();
        };
        this._onMouseUp = (ev) => {
            this._events.off();
            this.setState({
                isAdjusting: false,
                origin: undefined
            });
        };
        this._warnDeprecations({
            onChanged: 'onChange'
        });
        const { value } = this.props;
        this.state = {
            isAdjusting: false,
            origin: undefined,
            currentValue: value
        };
    }
    componentWillReceiveProps(newProps) {
        if (newProps && newProps.value) {
            this.setState({ currentValue: newProps.value });
        }
    }
    render() {
        const { isAlpha, minValue, maxValue, overlayStyle, theme, className, styles } = this.props;
        const { currentValue } = this.state;
        const classNames = getClassNames$o(styles, {
            theme: theme,
            className
        });
        const currentPercentage = (100 * (currentValue - minValue)) / (maxValue - minValue);
        const hueStyle = {
            background: 
            // tslint:disable-next-line:max-line-length
            'linear-gradient(to left,red 0,#f09 10%,#cd00ff 20%,#3200ff 30%,#06f 40%,#00fffd 50%,#0f6 60%,#35ff00 70%,#cdff00 80%,#f90 90%,red 100%)'
        };
        const alphaStyle = {
            backgroundImage: 
            // tslint:disable-next-line:max-line-length
            'url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAKCAYAAACNMs+9AAAAJUlEQVQYV2N89erVfwY0ICYmxoguxjgUFKI7GsTH5m4M3w1ChQC1/Ca8i2n1WgAAAABJRU5ErkJggg==)'
        };
        const sliderStyle = isAlpha ? alphaStyle : hueStyle;
        return (createElement("div", { ref: this._root, className: classNames.root, onMouseDown: this._onMouseDown, style: sliderStyle },
            createElement("div", { className: classNames.sliderOverlay, style: overlayStyle }),
            createElement("div", { className: classNames.sliderThumb, style: { left: currentPercentage + '%' } })));
    }
}
ColorSliderBase.defaultProps = {
    minValue: 0,
    maxValue: 100,
    thumbColor: 'inherit',
    value: 0
};

const getStyles$v = (props) => {
    const { theme, className } = props;
    const { palette } = theme;
    return {
        root: [
            'ms-ColorPicker-slider',
            {
                position: 'relative',
                height: 20,
                marginBottom: 5,
                border: `1px solid ${palette.neutralLight}`,
                boxSizing: 'border-box'
            },
            className
        ],
        sliderOverlay: [
            'ms-ColorPicker-sliderOverlay',
            {
                content: '',
                position: 'absolute',
                left: 0,
                right: 0,
                top: 0,
                bottom: 0
            }
        ],
        sliderThumb: [
            'ms-ColorPicker-thumb',
            'is-slider',
            {
                position: 'absolute',
                width: 20,
                height: 20,
                background: 'white',
                border: '1px solid rgba(255,255,255,.8)',
                borderRadius: '50%',
                boxShadow: '0 0 15px -5px black',
                transform: 'translate(-50%, -50%)',
                top: '50%'
            }
        ]
    };
};

const ColorSlider = styled(ColorSliderBase, getStyles$v, undefined, { scope: 'ColorSlider' });

const getClassNames$p = classNamesFunction();
class ColorPickerBase extends BaseComponent {
    constructor(props) {
        super(props);
        this._hexText = createRef();
        this._rText = createRef();
        this._gText = createRef();
        this._bText = createRef();
        this._aText = createRef();
        this._onSVChanged = (s, v) => {
            this._updateColor(updateSV(this.state.color, s, v));
        };
        this._onHChanged = (ev, h) => {
            this._updateColor(updateH(this.state.color, h));
        };
        this._onAChanged = (ev, a) => {
            this._updateColor(updateA(this.state.color, a));
        };
        this._onHexChanged = () => {
            if (this._hexText.current) {
                this._updateColor(getColorFromString('#' + this._hexText.current.value));
            }
        };
        this._onRGBAChanged = () => {
            if (!this._rText.current || !this._gText.current || !this._bText.current || !this._aText.current) {
                return;
            }
            this._updateColor(getColorFromRGBA({
                r: Number(this._rText.current.value),
                g: Number(this._gText.current.value),
                b: Number(this._bText.current.value),
                a: Number(this._aText.current.value || 100)
            }));
        };
        this.state = {
            color: getColorFromString(props.color)
        };
    }
    componentWillReceiveProps(newProps) {
        if (newProps.color) {
            this._updateColor(getColorFromString(newProps.color));
        }
    }
    render() {
        const { theme, className, styles } = this.props;
        const { color } = this.state;
        const classNames = getClassNames$p(styles, {
            theme: theme,
            className
        });
        return (createElement("div", { className: classNames.root },
            createElement("div", { className: classNames.panel },
                createElement(ColorRectangle, { color: color, onSVChanged: this._onSVChanged }),
                createElement(ColorSlider, { className: "is-hue", minValue: 0, maxValue: MAX_COLOR_HUE, value: color.h, onChange: this._onHChanged }),
                !this.props.alphaSliderHidden && (createElement(ColorSlider, { className: "is-alpha", isAlpha: true, overlayStyle: { background: `linear-gradient(to right, transparent 0, #${color.hex} 100%)` }, minValue: 0, maxValue: 100, value: color.a, onChange: this._onAChanged })),
                createElement("table", { className: classNames.table, cellPadding: "0", cellSpacing: "0" },
                    createElement("thead", null,
                        createElement("tr", { className: classNames.tableHeader },
                            createElement("td", { className: classNames.tableHexCell }, this.props.hexLabel),
                            createElement("td", null, this.props.redLabel),
                            createElement("td", null, this.props.greenLabel),
                            createElement("td", null, this.props.blueLabel),
                            !this.props.alphaSliderHidden && createElement("td", null, this.props.alphaLabel))),
                    createElement("tbody", null,
                        createElement("tr", null,
                            createElement("td", null,
                                createElement(TextField, { className: classNames.input, value: color.hex, componentRef: this._hexText, onBlur: this._onHexChanged, spellCheck: false, ariaLabel: this.props.hexLabel })),
                            createElement("td", { style: { width: '18%' } },
                                createElement(TextField, { className: classNames.input, onBlur: this._onRGBAChanged, value: String(color.r), componentRef: this._rText, spellCheck: false, ariaLabel: this.props.redLabel })),
                            createElement("td", { style: { width: '18%' } },
                                createElement(TextField, { className: classNames.input, onBlur: this._onRGBAChanged, value: String(color.g), componentRef: this._gText, spellCheck: false, ariaLabel: this.props.greenLabel })),
                            createElement("td", { style: { width: '18%' } },
                                createElement(TextField, { className: classNames.input, onBlur: this._onRGBAChanged, value: String(color.b), componentRef: this._bText, spellCheck: false, ariaLabel: this.props.blueLabel })),
                            !this.props.alphaSliderHidden && (createElement("td", { style: { width: '18%' } },
                                createElement(TextField, { className: classNames.input, onBlur: this._onRGBAChanged, value: String(color.a ? color.a.toPrecision(3) : color.a), componentRef: this._aText, spellCheck: false, ariaLabel: this.props.alphaLabel })))))))));
    }
    _updateColor(newColor) {
        if (!newColor) {
            return;
        }
        const { onColorChanged } = this.props;
        const { color } = this.state;
        const hasColorStringChanged = newColor.str !== color.str;
        if (newColor.h !== color.h || hasColorStringChanged) {
            this.setState({
                color: newColor
            }, () => {
                if (hasColorStringChanged && onColorChanged) {
                    onColorChanged(newColor.str, newColor);
                }
            });
        }
    }
}
ColorPickerBase.defaultProps = {
    hexLabel: 'Hex',
    redLabel: 'Red',
    greenLabel: 'Green',
    blueLabel: 'Blue',
    alphaLabel: 'Alpha'
};

const getStyles$w = (props) => {
    const { className, theme } = props;
    return {
        root: [
            'ms-ColorPicker',
            theme.fonts.medium,
            {
                position: 'relative',
                maxWidth: 300
            },
            className
        ],
        panel: [
            'ms-ColorPicker-panel',
            {
                padding: '16px'
            }
        ],
        table: [
            'ms-ColorPicker-table',
            {
                tableLayout: 'fixed',
                width: '100%'
            }
        ],
        tableHeader: [
            {
                ...theme.fonts.small
            }
        ],
        tableHexCell: [
            {
                width: '25%'
            }
        ],
        input: [
            'ms-ColorPicker-input',
            {
                width: '100%',
                border: 'none',
                boxSizing: 'border-box',
                height: 30,
                selectors: {
                    '&.ms-TextField': {
                        paddingRight: 2
                    },
                    '& .ms-TextField-field': {
                        minWidth: 'auto',
                        padding: 5,
                        textOverflow: 'clip'
                    }
                }
            }
        ]
    };
};

const ColorPicker = styled(ColorPickerBase, getStyles$w, undefined, { scope: 'ColorPicker' });

var SelectableOptionMenuItemType;
(function (SelectableOptionMenuItemType) {
    SelectableOptionMenuItemType[SelectableOptionMenuItemType["Normal"] = 0] = "Normal";
    SelectableOptionMenuItemType[SelectableOptionMenuItemType["Divider"] = 1] = "Divider";
    SelectableOptionMenuItemType[SelectableOptionMenuItemType["Header"] = 2] = "Header";
})(SelectableOptionMenuItemType || (SelectableOptionMenuItemType = {}));

const ComboBoxHeight = '32px';
const ComboBoxLineHeight = '30px';
const ComboxBoxCaretDownWidth = '32px';
const ComboBoxOptionHeight = '32px';
const getDisabledStyles = memoizeFunction((theme) => {
    const { semanticColors } = theme;
    return {
        backgroundColor: semanticColors.disabledBackground,
        borderColor: semanticColors.disabledBackground,
        color: semanticColors.disabledText,
        cursor: 'default',
        selectors: {
            [HighContrastSelector]: {
                borderColor: 'GrayText',
                color: 'GrayText'
            }
        }
    };
});
const getListOptionHighContrastStyles = memoizeFunction((theme) => {
    return {
        selectors: {
            [HighContrastSelector]: {
                backgroundColor: 'Highlight',
                borderColor: 'Highlight',
                color: 'HighlightText',
                MsHighContrastAdjust: 'none'
            }
        }
    };
});
const getOptionStyles = memoizeFunction((theme, customStylesForAllOptions, customOptionStylesForCurrentOption, isPending) => {
    const { semanticColors, palette } = theme;
    const ComboBoxOptionBackgroundHovered = semanticColors.menuItemBackgroundHovered;
    const ComboBoxOptionTextColorHovered = semanticColors.bodyText;
    const ComboBoxOptionTextColorSelected = palette.black;
    const ComboBoxOptionTextColorDisabled = semanticColors.disabledText;
    const ComboBoxOptionBackgroundDisabled = semanticColors.bodyBackground;
    const optionStyles = {
        root: [
            theme.fonts.medium,
            {
                backgroundColor: isPending ? ComboBoxOptionBackgroundHovered : 'transparent',
                boxSizing: 'border-box',
                cursor: 'pointer',
                display: 'block',
                width: '100%',
                height: 'auto',
                minHeight: ComboBoxOptionHeight,
                lineHeight: '20px',
                padding: '5px 16px',
                position: 'relative',
                borderWidth: '1px',
                borderStyle: 'solid',
                borderColor: 'transparent',
                wordWrap: 'break-word',
                overflowWrap: 'break-word',
                textAlign: 'left',
                selectors: {
                    [HighContrastSelector]: {
                        borderColor: 'Background'
                    }
                }
            }
        ],
        rootHovered: {
            backgroundColor: ComboBoxOptionBackgroundHovered,
            color: ComboBoxOptionTextColorHovered
        },
        rootFocused: {
            backgroundColor: ComboBoxOptionBackgroundHovered
        },
        rootChecked: [
            {
                backgroundColor: ComboBoxOptionBackgroundHovered,
                color: ComboBoxOptionTextColorSelected
            },
            getFocusStyle(theme, undefined, undefined, undefined, undefined, undefined, false),
            getListOptionHighContrastStyles(theme)
        ],
        rootDisabled: {
            backgroundColor: ComboBoxOptionBackgroundDisabled,
            color: ComboBoxOptionTextColorDisabled,
            cursor: 'default',
            selectors: {
                '& .ms-Button-flexContainer': {
                    justifyContent: 'flex-start'
                }
            }
        },
        optionText: {
            overflow: 'hidden',
            whiteSpace: 'nowrap',
            textOverflow: 'ellipsis',
            minWidth: '0px',
            maxWidth: '100%',
            wordWrap: 'break-word',
            overflowWrap: 'break-word',
            margin: '1px',
            display: 'inline-block'
        },
        optionTextWrapper: {
            maxWidth: '100%'
        }
    };
    return concatStyleSets(optionStyles, customStylesForAllOptions, customOptionStylesForCurrentOption);
});
const getCaretDownButtonStyles = memoizeFunction((theme, customStyles) => {
    const { semanticColors } = theme;
    const caretButtonTextColor = semanticColors.bodySubtext;
    const caretButtonTextColorHoveredChecked = semanticColors.buttonTextChecked;
    const caretButtonBackgroundHovered = semanticColors.listItemBackgroundHovered;
    const caretButtonBackgroundChecked = semanticColors.listItemBackgroundChecked;
    const caretButtonBackgroundCheckedHovered = semanticColors.listItemBackgroundCheckedHovered;
    const styles = {
        root: {
            color: caretButtonTextColor,
            fontSize: FontSizes.small,
            position: 'absolute',
            // The negative positioning accounts for the 1px root border now that box-sizing is border-box
            top: '-1px',
            right: '-1px',
            height: ComboBoxHeight,
            lineHeight: ComboBoxLineHeight,
            width: ComboxBoxCaretDownWidth,
            textAlign: 'center',
            cursor: 'default',
            selectors: {
                [HighContrastSelector]: {
                    backgroundColor: 'ButtonFace',
                    borderColor: 'ButtonText',
                    color: 'ButtonText',
                    MsHighContrastAdjust: 'none'
                }
            }
        },
        icon: {
            fontSize: FontSizes.small
        },
        rootHovered: {
            backgroundColor: caretButtonBackgroundHovered,
            color: caretButtonTextColorHoveredChecked,
            cursor: 'pointer'
        },
        rootPressed: {
            backgroundColor: caretButtonBackgroundChecked,
            color: caretButtonTextColorHoveredChecked
        },
        rootChecked: {
            backgroundColor: caretButtonBackgroundChecked,
            color: caretButtonTextColorHoveredChecked
        },
        rootCheckedHovered: {
            backgroundColor: caretButtonBackgroundCheckedHovered,
            color: caretButtonTextColorHoveredChecked
        },
        rootDisabled: getDisabledStyles(theme)
    };
    return concatStyleSets(styles, customStyles);
});
const getStyles$x = memoizeFunction((theme, customStyles, comboBoxOptionWidth) => {
    const { semanticColors, fonts, palette } = theme;
    const ComboBoxRootBackground = semanticColors.bodyBackground;
    const ComboBoxRootTextColor = semanticColors.bodyText;
    const ComboBoxRootBorderColor = semanticColors.inputBorder;
    const ComboBoxRootBorderColorHovered = semanticColors.inputBorderHovered;
    const ComboBoxRootBorderColorFocused = semanticColors.inputFocusBorderAlt;
    const ComboBoxRootColorErrored = semanticColors.errorText;
    const ComboBoxCalloutBorderColor = palette.neutralLight;
    const ComboBoxOptionHeaderTextColor = semanticColors.menuHeader;
    const ComboBoxOptionDividerBorderColor = semanticColors.bodyDivider;
    const ComboBoxRootHighContrastFocused = {
        color: 'HighlightText',
        borderColor: 'Highlight',
        backgroundColor: 'Window',
        borderWidth: '2px',
        MsHighContrastAdjust: 'none',
        paddingLeft: '11px',
        paddingTop: '0',
        paddingBottom: '0',
        selectors: {
            '.ms-ComboBox-CaretDown-button': {
                // Negative positioning to account for the 2px border
                right: '-2px',
                top: '-2px'
            }
        }
    };
    const styles = {
        container: {},
        label: {},
        labelDisabled: {},
        root: [
            theme.fonts.medium,
            {
                boxShadow: 'none',
                marginLeft: '0',
                paddingTop: '1px',
                paddingBottom: '1px',
                paddingRight: ComboxBoxCaretDownWidth,
                paddingLeft: '12px',
                color: ComboBoxRootTextColor,
                position: 'relative',
                outline: '0',
                userSelect: 'none',
                backgroundColor: ComboBoxRootBackground,
                borderWidth: '1px',
                borderStyle: 'solid',
                borderColor: ComboBoxRootBorderColor,
                cursor: 'text',
                display: 'block',
                height: ComboBoxHeight,
                overflow: 'hidden',
                whiteSpace: 'nowrap',
                textOverflow: 'ellipsis',
                boxSizing: 'border-box',
                selectors: {
                    '.ms-Label': {
                        display: 'inline-block',
                        marginBottom: '8px'
                    },
                    input: {
                        selectors: {
                            '::-ms-clear': {
                                display: 'none'
                            }
                        }
                    },
                    '&.is-open': {
                        borderColor: ComboBoxRootBorderColorFocused,
                        selectors: {
                            [HighContrastSelector]: ComboBoxRootHighContrastFocused
                        }
                    }
                }
            }
        ],
        rootHovered: {
            borderColor: ComboBoxRootBorderColorHovered,
            selectors: {
                [HighContrastSelector]: {
                    color: 'HighlightText',
                    borderColor: 'Highlight',
                    backgroundColor: 'Window',
                    MsHighContrastAdjust: 'none'
                }
            }
        },
        rootPressed: {
            borderColor: ComboBoxRootBorderColorFocused,
            selectors: {
                [HighContrastSelector]: ComboBoxRootHighContrastFocused
            }
        },
        rootFocused: {
            borderColor: ComboBoxRootBorderColorFocused,
            selectors: {
                [HighContrastSelector]: ComboBoxRootHighContrastFocused
            }
        },
        rootDisabled: getDisabledStyles(theme),
        rootError: {
            borderColor: ComboBoxRootColorErrored,
            marginBottom: '5px'
        },
        rootDisallowFreeForm: {},
        input: {
            backgroundColor: ComboBoxRootBackground,
            color: ComboBoxRootTextColor,
            boxSizing: 'border-box',
            width: '100%',
            height: '28px',
            borderStyle: 'none',
            outline: 'none',
            font: 'inherit',
            textOverflow: 'ellipsis',
            padding: '0'
        },
        inputDisabled: getDisabledStyles(theme),
        errorMessage: {
            color: ComboBoxRootColorErrored
        },
        callout: {
            boxShadow: '0 0px 5px 0px rgba(0, 0, 0, 0.4)',
            borderWidth: '1px',
            borderStyle: 'solid',
            borderColor: ComboBoxCalloutBorderColor
        },
        optionsContainerWrapper: {
            width: comboBoxOptionWidth
        },
        optionsContainer: {
            display: 'block'
        },
        header: [
            fonts.medium,
            {
                fontWeight: FontWeights.semibold,
                color: ComboBoxOptionHeaderTextColor,
                backgroundColor: 'none',
                borderStyle: 'none',
                height: ComboBoxOptionHeight,
                lineHeight: ComboBoxOptionHeight,
                cursor: 'default',
                padding: '0px 16px',
                userSelect: 'none',
                textAlign: 'left'
            }
        ],
        divider: {
            borderWidth: '1px',
            borderStyle: 'solid',
            borderColor: ComboBoxOptionDividerBorderColor
        }
    };
    return concatStyleSets(styles, customStyles);
});

const getClassNames$q = memoizeFunction((styles, className, isOpen, disabled, required, focused, allowFreeForm, hasErrorMessage) => {
    return {
        container: mergeStyles('ms-ComboBox-container', className, styles.container),
        label: mergeStyles(styles.label, disabled && styles.labelDisabled),
        root: mergeStyles('ms-ComboBox', hasErrorMessage ? styles.rootError : isOpen && 'is-open', required && 'is-required', styles.root, !allowFreeForm && styles.rootDisallowFreeForm, hasErrorMessage ? styles.rootError : !disabled && focused && styles.rootFocused, !disabled && {
            selectors: {
                ':hover': hasErrorMessage ? styles.rootError : !isOpen && !focused && styles.rootHovered,
                ':active': hasErrorMessage ? styles.rootError : styles.rootPressed,
                ':focus': hasErrorMessage ? styles.rootError : styles.rootFocused
            }
        }, disabled && ['is-disabled', styles.rootDisabled]),
        input: mergeStyles('ms-ComboBox-Input', styles.input, disabled && styles.inputDisabled),
        errorMessage: mergeStyles(styles.errorMessage),
        callout: mergeStyles('ms-ComboBox-callout', styles.callout),
        optionsContainerWrapper: mergeStyles('ms-ComboBox-optionsContainerWrapper', styles.optionsContainerWrapper),
        optionsContainer: mergeStyles('ms-ComboBox-optionsContainer', styles.optionsContainer),
        header: mergeStyles('ms-ComboBox-header', styles.header),
        divider: mergeStyles('ms-ComboBox-divider', styles.divider)
    };
});
const getComboBoxOptionClassNames = memoizeFunction((styles) => {
    return {
        optionText: mergeStyles('ms-ComboBox-optionText', styles.optionText),
        root: mergeStyles('ms-ComboBox-option', styles.root, {
            selectors: {
                ':hover': styles.rootHovered,
                ':focus': styles.rootFocused,
                ':active': styles.rootPressed
            }
        }),
        optionTextWrapper: mergeStyles(styles.optionTextWrapper)
    };
});

var SearchDirection;
(function (SearchDirection) {
    SearchDirection[SearchDirection["backward"] = -1] = "backward";
    SearchDirection[SearchDirection["none"] = 0] = "none";
    SearchDirection[SearchDirection["forward"] = 1] = "forward";
})(SearchDirection || (SearchDirection = {}));
var HoverStatus;
(function (HoverStatus) {
    /** Used when the user was hovering and has since moused out of the menu items */
    HoverStatus[HoverStatus["clearAll"] = -2] = "clearAll";
    /** Default "normal" state, when no hover has happened or a hover is in progress */
    HoverStatus[HoverStatus["default"] = -1] = "default";
})(HoverStatus || (HoverStatus = {}));
const ScrollIdleDelay = 250 /* ms */;
const TouchIdleDelay$2 = 500; /* ms */
/**
 * This is used to clear any pending autocomplete text (used when autocomplete is true and
 * allowFreeform is false)
 */
const ReadOnlyPendingAutoCompleteTimeout = 1000 /* ms */;
/**
 * Internal class that is used to wrap all ComboBox options.
 * This is used to customize when we want to rerender components,
 * so we don't rerender every option every time render is executed.
 */
class ComboBoxOptionWrapper extends Component {
    render() {
        return this.props.render();
    }
    shouldComponentUpdate(newProps) {
        // The render function will always be different, so we ignore that prop
        return !shallowCompare({ ...this.props, render: undefined }, { ...newProps, render: undefined });
    }
}
let ComboBox = class ComboBox extends BaseComponent {
    constructor(props) {
        super(props);
        this._root = createRef();
        /** The input aspect of the comboBox */
        this._autofill = createRef();
        /** The wrapping div of the input and button */
        this._comboBoxWrapper = createRef();
        /** The callout element */
        this._comboBoxMenu = createRef();
        /** The menu item element that is currently selected */
        this._selectedElement = createRef();
        /**
         * {@inheritdoc}
         */
        this.focus = (shouldOpenOnFocus, useFocusAsync) => {
            if (this._autofill.current) {
                if (useFocusAsync) {
                    focusAsync(this._autofill.current);
                }
                else {
                    this._autofill.current.focus();
                }
                if (shouldOpenOnFocus) {
                    this.setState({
                        isOpen: true
                    });
                }
            }
        };
        /**
         * Close menu callout if it is open
         */
        this.dismissMenu = () => {
            const { isOpen } = this.state;
            isOpen && this.setState({ isOpen: false });
        };
        /**
         * componentWillReceiveProps handler for the auto fill component
         * Checks/updates the iput value to set, if needed
         * @param defaultVisibleValue - the defaultVisibleValue that got passed
         *  in to the auto fill's componentWillReceiveProps
         * @returns - the updated value to set, if needed
         */
        this._onUpdateValueInAutofillWillReceiveProps = () => {
            const comboBox = this._autofill.current;
            if (!comboBox) {
                return null;
            }
            if (comboBox.value === null || comboBox.value === undefined) {
                return null;
            }
            const visibleValue = this._normalizeToString(this._currentVisibleValue);
            if (comboBox.value !== visibleValue) {
                // If visibleValue is empty, make it a zero width space.
                // If we did not do that, the empty string would not get used
                // potentially resulting in an unexpected value being used
                return visibleValue || '';
            }
            return comboBox.value;
        };
        /**
         * componentDidUpdate handler for the auto fill component
         *
         * @param defaultVisibleValue - the current defaultVisibleValue in the auto fill's componentDidUpdate
         * @param suggestedDisplayValue - the current suggestedDisplayValue in the auto fill's componentDidUpdate
         * @returns - should the full value of the input be selected?
         * True if the defaultVisibleValue equals the suggestedDisplayValue, false otherwise
         */
        this._onShouldSelectFullInputValueInAutofillComponentDidUpdate = () => {
            return this._currentVisibleValue === this.state.suggestedDisplayValue;
        };
        /**
         * Get the correct value to pass to the input
         * to show to the user based off of the current props and state
         * @returns the value to pass to the input
         */
        this._getVisibleValue = () => {
            const { text, value, allowFreeform, autoComplete } = this.props;
            const { selectedIndices, currentPendingValueValidIndex, currentOptions, currentPendingValue, suggestedDisplayValue, isOpen, focused } = this.state;
            const currentPendingIndexValid = this._indexWithinBounds(currentOptions, currentPendingValueValidIndex);
            // If the user passed is a value prop, use that
            // unless we are open and have a valid current pending index
            if (!(isOpen && currentPendingIndexValid) && (text && (currentPendingValue === null || currentPendingValue === undefined))) {
                return text;
            }
            if (!(isOpen && currentPendingIndexValid) && (value && (currentPendingValue === null || currentPendingValue === undefined))) {
                return value;
            }
            // Values to display in the BaseAutoFill area
            const displayValues = [];
            if (this.props.multiSelect) {
                // Multi-select
                if (focused) {
                    let index = -1;
                    if (autoComplete === 'on' && currentPendingIndexValid) {
                        index = currentPendingValueValidIndex;
                    }
                    displayValues.push(currentPendingValue !== null && currentPendingValue !== undefined
                        ? currentPendingValue
                        : this._indexWithinBounds(currentOptions, index)
                            ? currentOptions[index].text
                            : '');
                }
                else {
                    for (let idx = 0; selectedIndices && idx < selectedIndices.length; idx++) {
                        const index = selectedIndices[idx];
                        displayValues.push(this._indexWithinBounds(currentOptions, index) ? currentOptions[index].text : this._normalizeToString(suggestedDisplayValue));
                    }
                }
            }
            else {
                // Single-select
                let index = this._getFirstSelectedIndex();
                if (allowFreeform) {
                    // If we are allowing freeform and autocomplete is also true
                    // and we've got a pending value that matches an option, remember
                    // the matched option's index
                    if (autoComplete === 'on' && currentPendingIndexValid) {
                        index = currentPendingValueValidIndex;
                    }
                    // Since we are allowing freeform, if there is currently a pending value, use that
                    // otherwise use the index determined above (falling back to '' if we did not get a valid index)
                    displayValues.push(currentPendingValue !== null && currentPendingValue !== undefined
                        ? currentPendingValue
                        : this._indexWithinBounds(currentOptions, index)
                            ? currentOptions[index].text
                            : '');
                }
                else {
                    // If we are not allowing freeform and have a
                    // valid index that matches the pending value,
                    // we know we will need some version of the pending value
                    if (currentPendingIndexValid && autoComplete === 'on') {
                        // If autoComplete is on, return the
                        // raw pending value, otherwise remember
                        // the matched option's index
                        index = currentPendingValueValidIndex;
                        displayValues.push(this._normalizeToString(currentPendingValue));
                    }
                    else {
                        displayValues.push(this._indexWithinBounds(currentOptions, index) ? currentOptions[index].text : this._normalizeToString(suggestedDisplayValue));
                    }
                }
            }
            // If we have a valid index then return the text value of that option,
            // otherwise return the suggestedDisplayValue
            let displayString = '';
            for (let idx = 0; idx < displayValues.length; idx++) {
                if (idx > 0) {
                    displayString += ', ';
                }
                displayString += displayValues[idx];
            }
            return displayString;
        };
        /**
         * Handler for typing changes on the input
         * @param updatedValue - the newly changed value
         */
        this._onInputChange = (updatedValue) => {
            if (this.props.disabled) {
                this._handleInputWhenDisabled(null /* event */);
                return;
            }
            this.props.allowFreeform ? this._processInputChangeWithFreeform(updatedValue) : this._processInputChangeWithoutFreeform(updatedValue);
        };
        /**
         * Focus (and select) the content of the input
         * and set the focused state
         */
        this._select = () => {
            if (this._autofill.current && this._autofill.current.inputElement) {
                this._autofill.current.inputElement.select();
            }
            if (!this.state.focused) {
                this.setState({ focused: true });
            }
        };
        /**
         * Callback issued when the options should be resolved, if they have been updated or
         * if they need to be passed in the first time. This only does work if an onResolveOptions
         * callback was passed in
         */
        this._onResolveOptions = () => {
            if (this.props.onResolveOptions) {
                // get the options
                const newOptions = this.props.onResolveOptions({ ...this.state.currentOptions });
                // Check to see if the returned value is an array, if it is update the state
                // If the returned value is not an array then check to see if it's a promise or PromiseLike. If it is then resolve it asynchronously.
                if (Array.isArray(newOptions)) {
                    this.setState({
                        currentOptions: newOptions
                    });
                }
                else if (newOptions && newOptions.then) {
                    // Ensure that the promise will only use the callback if it was the most recent one
                    // and update the state when the promise returns
                    const promise = (this._currentPromise = newOptions);
                    promise.then((newOptionsFromPromise) => {
                        if (promise === this._currentPromise) {
                            this.setState({
                                currentOptions: newOptionsFromPromise
                            });
                        }
                    });
                }
            }
        };
        /**
         * OnBlur handler. Set the focused state to false
         * and submit any pending value
         */
        this._onBlur = (event) => {
            // Do nothing if the blur is coming from something
            // inside the comboBox root or the comboBox menu since
            // it we are not really bluring from the whole comboBox
            let relatedTarget = event.relatedTarget;
            if (event.relatedTarget === null) {
                // In IE11, due to lack of support, event.relatedTarget is always
                // null making every onBlur call to be "outside" of the ComboBox
                // even when it's not. Using document.activeElement is another way
                // for us to be able to get what the relatedTarget without relying
                // on the event
                relatedTarget = document.activeElement;
            }
            if (relatedTarget &&
                // when event coming from withing the comboBox title
                ((this._root.current && this._root.current.contains(relatedTarget)) ||
                    // when event coming from within the comboBox list menu
                    (this._comboBoxMenu.current &&
                        (this._comboBoxMenu.current.contains(relatedTarget) ||
                            // when event coming from the callout containing the comboBox list menu (ex: when scrollBar of the Callout clicked)
                            // checks if the relatedTarget is a parent of _comboBoxMenu
                            findElementRecursive(this._comboBoxMenu.current, element => element === relatedTarget))))) {
                event.preventDefault();
                event.stopPropagation();
                return;
            }
            if (this.state.focused) {
                this.setState({ focused: false });
                if (!this.props.multiSelect) {
                    this._submitPendingValue(event);
                }
            }
        };
        // Render Callout container and pass in list
        this._onRenderContainer = (props) => {
            const { onRenderList, calloutProps, dropdownWidth, dropdownMaxWidth, onRenderLowerContent = this._onRenderLowerContent, useComboBoxAsMenuWidth } = props;
            const comboBoxMenuWidth = useComboBoxAsMenuWidth && this._comboBoxWrapper.current ? this._comboBoxWrapper.current.clientWidth + 2 : undefined;
            return (createElement(Callout, Object.assign({ isBeakVisible: false, gapSpace: 0, doNotLayer: false, directionalHint: DirectionalHint.bottomLeftEdge, directionalHintFixed: false }, calloutProps, { onLayerMounted: this._onLayerMounted, className: css(this._classNames.callout, calloutProps ? calloutProps.className : undefined), target: this._comboBoxWrapper.current, onDismiss: this._onDismiss, onScroll: this._onScroll, setInitialFocus: false, calloutWidth: useComboBoxAsMenuWidth && this._comboBoxWrapper.current ? comboBoxMenuWidth && comboBoxMenuWidth : dropdownWidth, calloutMaxWidth: dropdownMaxWidth ? dropdownMaxWidth : comboBoxMenuWidth }),
                createElement("div", { className: this._classNames.optionsContainerWrapper, ref: this._comboBoxMenu }, onRenderList({ ...props }, this._onRenderList)),
                onRenderLowerContent(this.props, this._onRenderLowerContent)));
        };
        this._onLayerMounted = () => {
            this._gotMouseMove = false;
            if (this.props.calloutProps && this.props.calloutProps.onLayerMounted) {
                this.props.calloutProps.onLayerMounted();
            }
        };
        // Render List of items
        this._onRenderList = (props) => {
            const { onRenderItem, options } = props;
            const id = this._id;
            return (createElement("div", { id: id + '-list', className: this._classNames.optionsContainer, "aria-labelledby": id + '-label', role: "listbox" }, options.map(item => onRenderItem(item, this._onRenderItem))));
        };
        // Render items
        this._onRenderItem = (item) => {
            switch (item.itemType) {
                case SelectableOptionMenuItemType.Divider:
                    return this._renderSeparator(item);
                case SelectableOptionMenuItemType.Header:
                    return this._renderHeader(item);
                default:
                    return this._renderOption(item);
            }
        };
        // Default _onRenderLowerContent function returns nothing
        this._onRenderLowerContent = () => {
            return null;
        };
        this._renderOption = (item) => {
            const { onRenderOption = this._onRenderOptionContent } = this.props;
            const id = this._id;
            const isSelected = this._isOptionSelected(item.index);
            const optionStyles = this._getCurrentOptionStyles(item);
            const optionClassNames = getComboBoxOptionClassNames(this._getCurrentOptionStyles(item));
            const checkboxStyles = () => {
                return optionStyles;
            };
            const title = this._getPreviewText(item);
            const getOptionComponent = () => {
                return !this.props.multiSelect ? (createElement(CommandButton, { id: id + '-list' + item.index, key: item.key, "data-index": item.index, styles: this._getCurrentOptionStyles(item), checked: isSelected, className: 'ms-ComboBox-option', onClick: this._onItemClick(item), onMouseEnter: this._onOptionMouseEnter.bind(this, item.index), onMouseMove: this._onOptionMouseMove.bind(this, item.index), onMouseLeave: this._onOptionMouseLeave, role: "option", "aria-selected": isSelected ? 'true' : 'false', ariaLabel: item.ariaLabel, disabled: item.disabled, title: title },
                    ' ',
                    createElement("span", { className: optionClassNames.optionTextWrapper, ref: isSelected ? this._selectedElement : undefined }, onRenderOption(item, this._onRenderOptionContent)))) : (createElement(Checkbox, { id: id + '-list' + item.index, ariaLabel: item.ariaLabel, key: item.key, "data-index": item.index, styles: checkboxStyles, className: 'ms-ComboBox-option', "data-is-focusable": true, onChange: this._onItemClick(item), label: item.text, role: "option", "aria-selected": isSelected ? 'true' : 'false', checked: isSelected, title: title }, onRenderOption(item, this._onRenderOptionContent)));
            };
            return (createElement(ComboBoxOptionWrapper, { key: item.key, index: item.index, disabled: item.disabled, isSelected: isSelected, text: item.text, render: getOptionComponent }));
        };
        /**
         * Scroll handler for the callout to make sure the mouse events
         * for updating focus are not interacting during scroll
         */
        this._onScroll = () => {
            if (!this._isScrollIdle && this._scrollIdleTimeoutId !== undefined) {
                this._async.clearTimeout(this._scrollIdleTimeoutId);
                this._scrollIdleTimeoutId = undefined;
            }
            else {
                this._isScrollIdle = false;
            }
            this._scrollIdleTimeoutId = this._async.setTimeout(() => {
                this._isScrollIdle = true;
            }, ScrollIdleDelay);
        };
        this._onRenderOptionContent = (item) => {
            const optionClassNames = getComboBoxOptionClassNames(this._getCurrentOptionStyles(item));
            return createElement("span", { className: optionClassNames.optionText }, item.text);
        };
        /**
         * Handles dismissing (cancelling) the menu
         */
        this._onDismiss = () => {
            // close the menu
            this._setOpenStateAndFocusOnClose(false /* isOpen */, false /* focusInputAfterClose */);
            // reset the selected index
            // to the last value state
            this._resetSelectedIndex();
        };
        this._onAfterClearPendingInfo = () => {
            this._processingClearPendingInfo = false;
        };
        /**
         * Handle keydown on the input
         * @param ev - The keyboard event that was fired
         */
        this._onInputKeyDown = (ev) => {
            const { disabled, allowFreeform, autoComplete } = this.props;
            const { isOpen, currentOptions, currentPendingValueValidIndexOnHover } = this.state;
            // Take note if we are processing an alt (option) or meta (command) keydown.
            // See comment in _onInputKeyUp for reasoning.
            this._lastKeyDownWasAltOrMeta = this._isAltOrMeta(ev);
            if (disabled) {
                this._handleInputWhenDisabled(ev);
                return;
            }
            let index = this._getPendingSelectedIndex(false /* includeCurrentPendingValue */);
            switch (ev.which) {
                case KeyCodes.enter:
                    if (this._autofill.current && this._autofill.current.inputElement) {
                        this._autofill.current.inputElement.select();
                    }
                    this._submitPendingValue(ev);
                    if (this.props.multiSelect && isOpen) {
                        this.setState({
                            currentPendingValueValidIndex: index
                        });
                    }
                    else {
                        // On enter submit the pending value
                        if (isOpen ||
                            ((!allowFreeform ||
                                this.state.currentPendingValue === undefined ||
                                this.state.currentPendingValue === null ||
                                this.state.currentPendingValue.length <= 0) &&
                                this.state.currentPendingValueValidIndex < 0)) {
                            // if we are open or
                            // if we are not allowing freeform or
                            // our we have no pending value
                            // and no valid pending index
                            // flip the open state
                            this.setState({
                                isOpen: !isOpen
                            });
                        }
                    }
                    break;
                case KeyCodes.tab:
                    // On enter submit the pending value
                    if (!this.props.multiSelect) {
                        this._submitPendingValue(ev);
                    }
                    // If we are not allowing freeform
                    // or the comboBox is open, flip the open state
                    if (isOpen) {
                        this._setOpenStateAndFocusOnClose(!isOpen, false /* focusInputAfterClose */);
                    }
                    // Allow TAB to propigate
                    return;
                case KeyCodes.escape:
                    // reset the selected index
                    this._resetSelectedIndex();
                    // Close the menu if opened
                    if (isOpen) {
                        this.setState({
                            isOpen: false
                        });
                    }
                    else {
                        return;
                    }
                    break;
                case KeyCodes.up:
                    // if we are in clearAll state (e.g. the user as hovering
                    // and has since mousedOut of the menu items),
                    // go to the last index
                    if (currentPendingValueValidIndexOnHover === HoverStatus.clearAll) {
                        index = this.state.currentOptions.length;
                    }
                    if (ev.altKey || ev.metaKey) {
                        // Close the menu if it is open and break so
                        // that the event get stopPropagation and prevent default.
                        // Otherwise, we need to let the event continue to propagate
                        if (isOpen) {
                            this._setOpenStateAndFocusOnClose(!isOpen, true /* focusInputAfterClose */);
                            break;
                        }
                        return;
                    }
                    // Go to the previous option
                    this._setPendingInfoFromIndexAndDirection(index, SearchDirection.backward);
                    break;
                case KeyCodes.down:
                    // Expand the comboBox on ALT + DownArrow
                    if (ev.altKey || ev.metaKey) {
                        this._setOpenStateAndFocusOnClose(true /* isOpen */, true /* focusInputAfterClose */);
                    }
                    else {
                        // if we are in clearAll state (e.g. the user as hovering
                        // and has since mousedOut of the menu items),
                        // go to the first index
                        if (currentPendingValueValidIndexOnHover === HoverStatus.clearAll) {
                            index = -1;
                        }
                        // Got to the next option
                        this._setPendingInfoFromIndexAndDirection(index, SearchDirection.forward);
                    }
                    break;
                case KeyCodes.home:
                case KeyCodes.end:
                    if (allowFreeform) {
                        return;
                    }
                    // Set the initial values to respond to HOME
                    // which goes to the first selectable option
                    index = -1;
                    let directionToSearch = SearchDirection.forward;
                    // If end, update the values to respond to END
                    // which goes to the last selectable option
                    if (ev.which === KeyCodes.end) {
                        index = currentOptions.length;
                        directionToSearch = SearchDirection.backward;
                    }
                    this._setPendingInfoFromIndexAndDirection(index, directionToSearch);
                    break;
                case KeyCodes.space:
                    // event handled in _onComboBoxKeyUp
                    if (!allowFreeform && autoComplete === 'off') {
                        break;
                    }
                default:
                    // are we processing a function key? if so bail out
                    if (ev.which >= 112 /* F1 */ && ev.which <= 123 /* F12 */) {
                        return;
                    }
                    // If we get here and we got either and ALT key
                    // or meta key, let the event propagate
                    if (ev.keyCode === KeyCodes.alt || ev.key === 'Meta' /* && isOpen */) {
                        return;
                    }
                    // If we are not allowing freeform and
                    // allowing autoComplete, handle the input here
                    // since we have marked the input as readonly
                    if (!allowFreeform && autoComplete === 'on') {
                        this._onInputChange(String.fromCharCode(ev.which));
                        break;
                    }
                    // allow the key to propagate by default
                    return;
            }
            ev.stopPropagation();
            ev.preventDefault();
        };
        /**
         * Handle keyup on the input
         * @param ev - the keyboard event that was fired
         */
        this._onInputKeyUp = (ev) => {
            const { disabled, allowFreeform, autoComplete } = this.props;
            const isOpen = this.state.isOpen;
            // We close the menu on key up only if ALL of the following are true:
            // - Most recent key down was alt or meta (command)
            // - The alt/meta key down was NOT followed by some other key (such as down/up arrow to
            //   expand/collapse the menu)
            // - We're not on a Mac (or iOS)
            // This is because on Windows, pressing alt moves focus to the application menu bar or similar,
            // closing any open context menus. There is not a similar behavior on Macs.
            const keyPressIsAltOrMetaAlone = this._lastKeyDownWasAltOrMeta && this._isAltOrMeta(ev);
            this._lastKeyDownWasAltOrMeta = false;
            const shouldHandleKey = keyPressIsAltOrMetaAlone && !(isMac() || isIOS());
            if (disabled) {
                this._handleInputWhenDisabled(ev);
                return;
            }
            switch (ev.which) {
                case KeyCodes.space:
                    // If we are not allowing freeform and are not autoComplete
                    // make space expand/collapse the comboBox
                    // and allow the event to propagate
                    if (!allowFreeform && autoComplete === 'off') {
                        this._setOpenStateAndFocusOnClose(!isOpen, !!isOpen);
                        return;
                    }
                    break;
                default:
                    if (shouldHandleKey && isOpen) {
                        this._setOpenStateAndFocusOnClose(!isOpen, true /* focusInputAfterClose */);
                    }
                    return;
            }
            ev.stopPropagation();
            ev.preventDefault();
        };
        this._onOptionMouseLeave = () => {
            if (this._shouldIgnoreMouseEvent()) {
                return;
            }
            this.setState({
                currentPendingValueValidIndexOnHover: HoverStatus.clearAll
            });
        };
        /**
         * Click handler for the button of the comboBox
         * and the input when not allowing freeform. This
         * toggles the expand/collapse state of the comboBox (if enbled)
         */
        this._onComboBoxClick = () => {
            const { disabled } = this.props;
            const { isOpen } = this.state;
            if (!disabled) {
                this._setOpenStateAndFocusOnClose(!isOpen, false /* focusInputAfterClose */);
                this.setState({ focused: true });
            }
        };
        /**
         * Click handler for the autofill.
         */
        this._onAutofillClick = () => {
            if (this.props.allowFreeform) {
                this.focus(this.state.isOpen || this._processingTouch);
            }
            else {
                this._onComboBoxClick();
            }
        };
        this._onTouchStart = () => {
            if (this._comboBoxWrapper.current && !('onpointerdown' in this._comboBoxWrapper)) {
                this._handleTouchAndPointerEvent();
            }
        };
        this._onPointerDown = (ev) => {
            if (ev.pointerType === 'touch') {
                this._handleTouchAndPointerEvent();
                ev.preventDefault();
                ev.stopImmediatePropagation();
            }
        };
        this._warnMutuallyExclusive({
            defaultSelectedKey: 'selectedKey',
            text: 'defaultSelectedKey',
            value: 'defaultSelectedKey',
            selectedKey: 'value',
            dropdownWidth: 'useComboBoxAsMenuWidth'
        });
        this._warnDeprecations({
            value: 'text',
            onChanged: 'onChange'
        });
        this._id = props.id || getId('ComboBox');
        const selectedKeys = this._buildDefaultSelectedKeys(props.defaultSelectedKey, props.selectedKey);
        this._isScrollIdle = true;
        this._processingTouch = false;
        this._gotMouseMove = false;
        this._processingClearPendingInfo = false;
        const initialSelectedIndices = this._getSelectedIndices(props.options, selectedKeys);
        this.state = {
            isOpen: false,
            selectedIndices: initialSelectedIndices,
            focused: false,
            suggestedDisplayValue: undefined,
            currentOptions: this.props.options,
            currentPendingValueValidIndex: -1,
            currentPendingValue: undefined,
            currentPendingValueValidIndexOnHover: HoverStatus.default
        };
    }
    componentDidMount() {
        if (this._comboBoxWrapper.current) {
            // hook up resolving the options if needed on focus
            this._events.on(this._comboBoxWrapper.current, 'focus', this._onResolveOptions, true);
            if ('onpointerdown' in this._comboBoxWrapper.current) {
                // For ComboBoxes, touching anywhere in the combo box should drop the dropdown, including the input element.
                // This gives more hit target space for touch environments. We're setting the onpointerdown here, because React
                // does not support Pointer events yet.
                this._events.on(this._comboBoxWrapper.current, 'pointerdown', this._onPointerDown, true);
            }
        }
    }
    componentWillReceiveProps(newProps) {
        // Update the selectedIndex and currentOptions state if
        // the selectedKey, value, or options have changed
        if (newProps.selectedKey !== this.props.selectedKey ||
            newProps.text !== this.props.text ||
            newProps.value !== this.props.value ||
            newProps.options !== this.props.options) {
            const selectedKeys = this._buildSelectedKeys(newProps.selectedKey);
            const indices = this._getSelectedIndices(newProps.options, selectedKeys);
            this.setState({
                selectedIndices: indices,
                currentOptions: newProps.options
            });
        }
    }
    componentDidUpdate(prevProps, prevState) {
        const { allowFreeform, text, value, onMenuOpen, onMenuDismissed } = this.props;
        const { isOpen, focused, selectedIndices, currentPendingValueValidIndex } = this.state;
        // If we are newly open or are open and the pending valid index changed,
        // make sure the currently selected/pending option is scrolled into view
        if (isOpen && (!prevState.isOpen || prevState.currentPendingValueValidIndex !== currentPendingValueValidIndex)) {
            // Need this timeout so that the selectedElement ref is correctly updated
            this._async.setTimeout(() => this._scrollIntoView(), 0);
        }
        // if an action is taken that put focus in the ComboBox
        // and If we are open or we are just closed, shouldFocusAfterClose is set,
        // but we are not the activeElement set focus on the input
        if (focused &&
            (isOpen ||
                (prevState.isOpen &&
                    !isOpen &&
                    this._focusInputAfterClose &&
                    this._autofill.current &&
                    document.activeElement !== this._autofill.current.inputElement))) {
            this.focus(undefined /*shouldOpenOnFocus*/, true /*useFocusAsync*/);
        }
        // If we should focusAfterClose AND
        //   just opened/closed the menu OR
        //   are focused AND
        //     updated the selectedIndex with the menu closed OR
        //     are not allowing freeform OR
        //     the value changed
        // we need to set selection
        if (this._focusInputAfterClose &&
            ((prevState.isOpen && !isOpen) ||
                (focused &&
                    ((!isOpen &&
                        !this.props.multiSelect &&
                        prevState.selectedIndices &&
                        selectedIndices &&
                        prevState.selectedIndices[0] !== selectedIndices[0]) ||
                        !allowFreeform ||
                        text !== prevProps.text ||
                        value !== prevProps.value)))) {
            this._select();
        }
        this._notifyPendingValueChanged(prevState);
        if (isOpen && !prevState.isOpen && onMenuOpen) {
            onMenuOpen();
        }
        if (!isOpen && prevState.isOpen && onMenuDismissed) {
            onMenuDismissed();
        }
    }
    componentWillUnmount() {
        super.componentWillUnmount();
        // remove the eventHanlder that was added in componentDidMount
        this._events.off(this._comboBoxWrapper.current);
    }
    // Primary Render
    render() {
        const id = this._id;
        const { className, label, disabled, ariaLabel, required, errorMessage, onRenderContainer = this._onRenderContainer, onRenderList = this._onRenderList, onRenderItem = this._onRenderItem, onRenderOption = this._onRenderOptionContent, allowFreeform, buttonIconProps, isButtonAriaHidden = true, styles: customStyles, theme, title, keytipProps, placeholder } = this.props;
        const { isOpen, focused, suggestedDisplayValue } = this.state;
        this._currentVisibleValue = this._getVisibleValue();
        const divProps = getNativeProps(this.props, divProperties, ['onChange', 'value']);
        const hasErrorMessage = errorMessage && errorMessage.length > 0 ? true : false;
        this._classNames = this.props.getClassNames
            ? this.props.getClassNames(theme, !!isOpen, !!disabled, !!required, !!focused, !!allowFreeform, !!hasErrorMessage, className)
            : getClassNames$q(getStyles$x(theme, customStyles), className, !!isOpen, !!disabled, !!required, !!focused, !!allowFreeform, !!hasErrorMessage);
        return (createElement("div", Object.assign({}, divProps, { ref: this._root, className: this._classNames.container }),
            label && (createElement(Label, { id: id + '-label', disabled: disabled, required: required, htmlFor: id + '-input', className: this._classNames.label }, label)),
            createElement(KeytipData, { keytipProps: keytipProps, disabled: disabled }, (keytipAttributes) => (createElement("div", { "data-ktp-target": keytipAttributes['data-ktp-target'], ref: this._comboBoxWrapper, id: id + 'wrapper', className: this._classNames.root },
                createElement(Autofill, { "data-ktp-execute-target": keytipAttributes['data-ktp-execute-target'], "data-is-interactable": !disabled, componentRef: this._autofill, id: id + '-input', className: this._classNames.input, type: "text", onFocus: this._select, onBlur: this._onBlur, onKeyDown: this._onInputKeyDown, onKeyUp: this._onInputKeyUp, onClick: this._onAutofillClick, onTouchStart: this._onTouchStart, onInputValueChange: this._onInputChange, "aria-expanded": isOpen, "aria-autocomplete": this._getAriaAutoCompleteValue(), role: "combobox", readOnly: disabled || !allowFreeform, "aria-labelledby": label && !ariaLabel ? id + '-label' : undefined, "aria-label": ariaLabel, "aria-describedby": keytipAttributes['aria-describedby'], "aria-activedescendant": this._getAriaActiveDescentValue(), "aria-disabled": disabled, "aria-owns": isOpen ? id + '-list' : undefined, spellCheck: false, defaultVisibleValue: this._currentVisibleValue, suggestedDisplayValue: suggestedDisplayValue, updateValueInWillReceiveProps: this._onUpdateValueInAutofillWillReceiveProps, shouldSelectFullInputValueInComponentDidUpdate: this._onShouldSelectFullInputValueInAutofillComponentDidUpdate, title: title, preventValueSelection: !focused, placeholder: placeholder }),
                createElement(IconButton, { className: 'ms-ComboBox-CaretDown-button', styles: this._getCaretButtonStyles(), role: "presentation", "aria-hidden": isButtonAriaHidden, "data-is-focusable": false, tabIndex: -1, onClick: this._onComboBoxClick, iconProps: buttonIconProps, disabled: disabled, checked: isOpen })))),
            isOpen &&
                onRenderContainer({
                    ...this.props,
                    onRenderList,
                    onRenderItem,
                    onRenderOption,
                    options: this.state.currentOptions.map((item, index) => ({ ...item, index: index }))
                }, this._onRenderContainer),
            errorMessage && createElement("div", { className: this._classNames.errorMessage }, errorMessage)));
    }
    /**
     * Is the index within the bounds of the array?
     * @param options - options to check if the index is valid for
     * @param index - the index to check
     * @returns - true if the index is valid for the given options, false otherwise
     */
    _indexWithinBounds(options, index) {
        if (!options) {
            return false;
        }
        return index >= 0 && index < options.length;
    }
    /**
     * Process the new input's new value when the comboBox
     * allows freeform entry
     * @param updatedValue - the input's newly changed value
     */
    _processInputChangeWithFreeform(updatedValue) {
        const { currentOptions } = this.state;
        updatedValue = this._removeZeroWidthSpaces(updatedValue);
        let newCurrentPendingValueValidIndex = -1;
        // if the new value is empty, see if we have an exact match
        // and then set the pending info
        if (updatedValue === '') {
            const items = currentOptions
                .map((item, index) => {
                return { ...item, index };
            })
                .filter(option => option.itemType !== SelectableOptionMenuItemType.Header && option.itemType !== SelectableOptionMenuItemType.Divider)
                .filter(option => this._getPreviewText(option) === updatedValue);
            // if we found a match remember the index
            if (items.length === 1) {
                newCurrentPendingValueValidIndex = items[0].index;
            }
            this._setPendingInfo(updatedValue, newCurrentPendingValueValidIndex, updatedValue);
            return;
        }
        // Remember the original value and then,
        // make the value lowercase for comparison
        const originalUpdatedValue = updatedValue;
        updatedValue = updatedValue.toLocaleLowerCase();
        let newSuggestedDisplayValue = '';
        // If autoComplete is on, attempt to find a match from the available options
        if (this.props.autoComplete === 'on') {
            // If autoComplete is on, attempt to find a match where the text of an option starts with the updated value
            const items = currentOptions
                .map((item, index) => {
                return { ...item, index };
            })
                .filter(option => option.itemType !== SelectableOptionMenuItemType.Header && option.itemType !== SelectableOptionMenuItemType.Divider)
                .filter(option => this._getPreviewText(option)
                .toLocaleLowerCase()
                .indexOf(updatedValue) === 0);
            if (items.length > 0) {
                // use ariaLabel as the value when the option is set
                const text = this._getPreviewText(items[0]);
                // If the user typed out the complete option text, we don't need any suggested display text anymore
                newSuggestedDisplayValue = text.toLocaleLowerCase() !== updatedValue ? text : '';
                // remember the index of the match we found
                newCurrentPendingValueValidIndex = items[0].index;
            }
        }
        else {
            // If autoComplete is off, attempt to find a match only when the value is exactly equal to the text of an option
            const items = currentOptions
                .map((item, index) => {
                return { ...item, index };
            })
                .filter(option => option.itemType !== SelectableOptionMenuItemType.Header && option.itemType !== SelectableOptionMenuItemType.Divider)
                .filter(option => this._getPreviewText(option).toLocaleLowerCase() === updatedValue);
            // if we found a match remember the index
            if (items.length === 1) {
                newCurrentPendingValueValidIndex = items[0].index;
            }
        }
        // Set the updated state
        this._setPendingInfo(originalUpdatedValue, newCurrentPendingValueValidIndex, newSuggestedDisplayValue);
    }
    /**
     * Process the new input's new value when the comboBox
     * does not allow freeform entry
     * @param updatedValue - the input's newly changed value
     */
    _processInputChangeWithoutFreeform(updatedValue) {
        const { currentPendingValue, currentPendingValueValidIndex, currentOptions } = this.state;
        updatedValue = this._removeZeroWidthSpaces(updatedValue);
        if (this.props.autoComplete === 'on') {
            // If autoComplete is on while allow freeform is off,
            // we will remember the keypresses and build up a string to attempt to match
            // as long as characters are typed within a the timeout span of each other,
            // otherwise we will clear the string and start building a new one on the next keypress.
            // Also, only do this processing if we have a non-empty value
            if (updatedValue !== '') {
                // If we have a pending autocomplete clearing task,
                // we know that the user is typing with keypresses happening
                // within the timeout of each other so remove the clearing task
                // and continue building the pending value with the udpated value
                if (this._lastReadOnlyAutoCompleteChangeTimeoutId !== undefined) {
                    this._async.clearTimeout(this._lastReadOnlyAutoCompleteChangeTimeoutId);
                    this._lastReadOnlyAutoCompleteChangeTimeoutId = undefined;
                    updatedValue = this._normalizeToString(currentPendingValue) + updatedValue;
                }
                const originalUpdatedValue = updatedValue;
                updatedValue = updatedValue.toLocaleLowerCase();
                // If autoComplete is on, attempt to find a match where the text of an option starts with the updated value
                const items = currentOptions
                    .map((item, i) => {
                    return { ...item, index: i };
                })
                    .filter(option => option.itemType !== SelectableOptionMenuItemType.Header && option.itemType !== SelectableOptionMenuItemType.Divider)
                    .filter(option => option.text.toLocaleLowerCase().indexOf(updatedValue) === 0);
                // If we found a match, udpdate the state
                if (items.length > 0) {
                    this._setPendingInfo(originalUpdatedValue, items[0].index, this._getPreviewText(items[0]));
                }
                // Schedule a timeout to clear the pending value after the timeout span
                this._lastReadOnlyAutoCompleteChangeTimeoutId = this._async.setTimeout(() => {
                    this._lastReadOnlyAutoCompleteChangeTimeoutId = undefined;
                }, ReadOnlyPendingAutoCompleteTimeout);
                return;
            }
        }
        // If we get here, either autoComplete is on or we did not find a match with autoComplete on.
        // Remember we are not allowing freeform, so at this point, if we have a pending valid value index
        // use that; otherwise use the selectedIndex
        const index = currentPendingValueValidIndex >= 0 ? currentPendingValueValidIndex : this._getFirstSelectedIndex();
        // Since we are not allowing freeform, we need to
        // set both the pending and suggested values/index
        // to allow us to select all content in the input to
        // give the illusion that we are readonly (e.g. freeform off)
        this._setPendingInfoFromIndex(index);
    }
    _getFirstSelectedIndex() {
        return this.state.selectedIndices && this.state.selectedIndices.length > 0 ? this.state.selectedIndices[0] : -1;
    }
    /**
     * Walk along the options starting at the index, stepping by the delta (positive or negative)
     * looking for the next valid selectable index (e.g. skipping headings and dividers)
     * @param index - the index to get the next selectable index from
     * @param delta - optional delta to step by when finding the next index, defaults to 0
     * @returns - the next valid selectable index. If the new index is outside of the bounds,
     * it will snap to the edge of the options array. If delta == 0 and the given index is not selectable
     */
    _getNextSelectableIndex(index, searchDirection) {
        const { currentOptions } = this.state;
        let newIndex = index + searchDirection;
        newIndex = Math.max(0, Math.min(currentOptions.length - 1, newIndex));
        if (!this._indexWithinBounds(currentOptions, newIndex)) {
            return -1;
        }
        const option = currentOptions[newIndex];
        // attempt to skip headers and dividers
        if (option.itemType === SelectableOptionMenuItemType.Header || option.itemType === SelectableOptionMenuItemType.Divider) {
            // Should we continue looking for an index to select?
            if (searchDirection !== SearchDirection.none &&
                ((newIndex > 0 && searchDirection < SearchDirection.none) ||
                    (newIndex >= 0 && newIndex < currentOptions.length && searchDirection > SearchDirection.none))) {
                newIndex = this._getNextSelectableIndex(newIndex, searchDirection);
            }
            else {
                // If we cannot perform a useful search just return the index we were given
                return index;
            }
        }
        // We have the next valid selectable index, return it
        return newIndex;
    }
    /**
     * Set the selected index. Note, this is
     * the "real" selected index, not the pending selected index
     * @param index - the index to set (or the index to set from if a search direction is provided)
     * @param searchDirection - the direction to search along the options from the given index
     */
    _setSelectedIndex(index, submitPendingValueEvent, searchDirection = SearchDirection.none) {
        const { onChange, onChanged, onPendingValueChanged } = this.props;
        const { currentOptions } = this.state;
        let { selectedIndices } = this.state;
        if (!selectedIndices) {
            selectedIndices = [];
        }
        // Find the next selectable index, if searchDirection is none
        // we will get our starting index back
        index = this._getNextSelectableIndex(index, searchDirection);
        if (!this._indexWithinBounds(currentOptions, index)) {
            return;
        }
        // Are we at a new index? If so, update the state, otherwise
        // there is nothing to do
        if (this.props.multiSelect || selectedIndices.length < 1 || (selectedIndices.length === 1 && selectedIndices[0] !== index)) {
            const option = currentOptions[index];
            if (!option) {
                return;
            }
            if (this.props.multiSelect) {
                // Setting the initial state of option.selected in Multi-select combobox by checking the
                // selectedIndices array and overriding the undefined issue
                option.selected = option.selected !== undefined ? !option.selected : selectedIndices.indexOf(index) < 0;
                if (option.selected && selectedIndices.indexOf(index) < 0) {
                    selectedIndices.push(index);
                }
                else if (!option.selected && selectedIndices.indexOf(index) >= 0) {
                    selectedIndices = selectedIndices.filter((value) => value !== index);
                }
            }
            else {
                selectedIndices[0] = index;
            }
            // Set the selected option
            this.setState({
                selectedIndices: selectedIndices
            });
            // If ComboBox value is changed, revert preview first
            if (this._hasPendingValue && onPendingValueChanged) {
                onPendingValueChanged();
                this._hasPendingValue = false;
            }
            if (onChange) {
                onChange(submitPendingValueEvent, option, index, undefined);
            }
            if (onChanged) {
                onChanged(option, index, undefined, submitPendingValueEvent);
            }
            // if we have a new selected index,
            // clear all of the pending info
            this._clearPendingInfo();
        }
    }
    /**
     * Submit a pending value if there is one
     */
    _submitPendingValue(submitPendingValueEvent) {
        const { onChange, onChanged, allowFreeform, autoComplete } = this.props;
        const { currentPendingValue, currentPendingValueValidIndex, currentOptions, currentPendingValueValidIndexOnHover } = this.state;
        let { selectedIndices } = this.state;
        // Do not submit any pending value if we
        // have already initiated clearing the pending info
        if (this._processingClearPendingInfo) {
            return;
        }
        // If we allow freeform we need to handle that
        if (allowFreeform) {
            // if currentPendingValue is null or undefined the user did not submit anything
            // (not even empty because we would have stored that as the pending value)
            if (currentPendingValue === null || currentPendingValue === undefined) {
                // if a user did not type anything they may just hovered over an item
                if (currentPendingValueValidIndexOnHover >= 0) {
                    this._setSelectedIndex(currentPendingValueValidIndexOnHover, submitPendingValueEvent);
                    this._clearPendingInfo();
                }
                return;
            }
            // Check to see if the user typed an exact match
            if (this._indexWithinBounds(currentOptions, currentPendingValueValidIndex)) {
                const pendingOptionText = this._getPreviewText(currentOptions[currentPendingValueValidIndex]).toLocaleLowerCase();
                // By exact match, that means: our pending value is the same as the the pending option text OR
                // the pending option starts with the pending value and we have an "autoComplete" selection
                // where the total length is equal to pending option length OR
                // the live value in the underlying input matches the pending option; update the state
                if (currentPendingValue.toLocaleLowerCase() === pendingOptionText ||
                    ((autoComplete &&
                        pendingOptionText.indexOf(currentPendingValue.toLocaleLowerCase()) === 0 &&
                        (this._autofill.current &&
                            this._autofill.current.isValueSelected &&
                            currentPendingValue.length + (this._autofill.current.selectionEnd - this._autofill.current.selectionStart) ===
                                pendingOptionText.length)) ||
                        (this._autofill.current &&
                            this._autofill.current.inputElement &&
                            this._autofill.current.inputElement.value.toLocaleLowerCase() === pendingOptionText))) {
                    this._setSelectedIndex(currentPendingValueValidIndex, submitPendingValueEvent);
                    this._clearPendingInfo();
                    return;
                }
            }
            if (onChange || onChanged) {
                if (onChange) {
                    // trigger onChange to clear value
                    onChange(submitPendingValueEvent, undefined, undefined, currentPendingValue);
                }
                if (onChanged) {
                    // trigger onChanged to clear value
                    onChanged(undefined, undefined, currentPendingValue, submitPendingValueEvent);
                }
            }
            else {
                // If we are not controlled, create a new option
                const newOption = {
                    key: currentPendingValue || getId(),
                    text: this._normalizeToString(currentPendingValue)
                };
                const newOptions = [...currentOptions, newOption];
                if (selectedIndices) {
                    if (!this.props.multiSelect) {
                        selectedIndices = [];
                    }
                    selectedIndices.push(newOptions.length - 1);
                }
                this.setState({
                    currentOptions: newOptions,
                    selectedIndices: selectedIndices
                });
            }
        }
        else if (currentPendingValueValidIndex >= 0) {
            // Since we are not allowing freeform, we must have a matching
            // to be able to update state
            this._setSelectedIndex(currentPendingValueValidIndex, submitPendingValueEvent);
        }
        else if (currentPendingValueValidIndexOnHover >= 0) {
            // If all else failed and we were hovering over an item, select it
            this._setSelectedIndex(currentPendingValueValidIndexOnHover, submitPendingValueEvent);
        }
        // Finally, clear the pending info
        this._clearPendingInfo();
    }
    // Render separator
    _renderSeparator(item) {
        const { index, key } = item;
        if (index && index > 0) {
            return createElement("div", { role: "separator", key: key, className: this._classNames.divider });
        }
        return null;
    }
    _renderHeader(item) {
        const { onRenderOption = this._onRenderOptionContent } = this.props;
        return (createElement("div", { key: item.key, className: this._classNames.header }, onRenderOption(item, this._onRenderOptionContent)));
    }
    /**
     * If we are coming from a mouseOut:
     * there is no visible selected option.
     *
     * Else if We are hovering over an item:
     * that gets the selected look.
     *
     * Else:
     * Use the current valid pending index if it exists OR
     * we do not have a valid index and we currently have a pending input value,
     * otherwise use the selected index
     * */
    _isOptionSelected(index) {
        const { currentPendingValueValidIndexOnHover } = this.state;
        // If the hover state is set to clearAll, don't show a selected index.
        // Note, this happens when the user moused out of the menu items
        if (currentPendingValueValidIndexOnHover === HoverStatus.clearAll) {
            return false;
        }
        if (!this.props.multiSelect && this._getPendingSelectedIndex(true /* includePendingValue */) === index) {
            return true;
        }
        let idxOfSelectedIndex = -1;
        if (this.props.multiSelect && index !== undefined && this.state.selectedIndices) {
            idxOfSelectedIndex = this.state.selectedIndices.indexOf(index);
        }
        return idxOfSelectedIndex >= 0;
    }
    /**
     * Gets the pending selected index taking into account hover, valueValidIndex, and selectedIndex
     * @param includeCurrentPendingValue - Should we include the currentPendingValue when
     * finding the index
     */
    _getPendingSelectedIndex(includeCurrentPendingValue) {
        const { currentPendingValueValidIndexOnHover, currentPendingValueValidIndex, currentPendingValue } = this.state;
        return currentPendingValueValidIndexOnHover >= 0
            ? currentPendingValueValidIndexOnHover
            : currentPendingValueValidIndex >= 0 ||
                (includeCurrentPendingValue && (currentPendingValue !== null && currentPendingValue !== undefined))
                ? currentPendingValueValidIndex
                : this.props.multiSelect
                    ? 0
                    : this._getFirstSelectedIndex();
    }
    /**
     * Scroll the selected element into view
     */
    _scrollIntoView() {
        const { onScrollToItem, scrollSelectedToTop } = this.props;
        const { currentPendingValueValidIndex, currentPendingValue } = this.state;
        if (onScrollToItem) {
            // Use the custom scroll handler
            onScrollToItem(currentPendingValueValidIndex >= 0 || currentPendingValue !== '' ? currentPendingValueValidIndex : this._getFirstSelectedIndex());
        }
        else if (this._selectedElement.current && this._selectedElement.current.offsetParent) {
            // We are using refs, scroll the ref into view
            if (scrollSelectedToTop) {
                this._selectedElement.current.offsetParent.scrollIntoView(true);
            }
            else {
                let alignToTop = true;
                if (this._comboBoxMenu.current && this._comboBoxMenu.current.offsetParent) {
                    const scrollableParentRect = this._comboBoxMenu.current.offsetParent.getBoundingClientRect();
                    const selectedElementRect = this._selectedElement.current.offsetParent.getBoundingClientRect();
                    // If we are completely in view then we do not need to scroll
                    if (scrollableParentRect.top <= selectedElementRect.top &&
                        scrollableParentRect.top + scrollableParentRect.height >= selectedElementRect.top + selectedElementRect.height) {
                        return;
                    }
                    // If we are lower than the scrollable parent viewport then we should align to the bottom
                    if (scrollableParentRect.top + scrollableParentRect.height <= selectedElementRect.top + selectedElementRect.height) {
                        alignToTop = false;
                    }
                }
                this._selectedElement.current.offsetParent.scrollIntoView(alignToTop);
            }
        }
    }
    /**
     * Click handler for the menu items
     * to select the item and also close the menu
     * @param index - the index of the item that was clicked
     */
    _onItemClick(item) {
        const { onItemClick } = this.props;
        const { index } = item;
        return (ev) => {
            onItemClick && onItemClick(ev, item, index);
            this._setSelectedIndex(index, ev);
            if (!this.props.multiSelect) {
                // only close the callout when it's in single-select mode
                this.setState({
                    isOpen: false
                });
            }
        };
    }
    /**
     * Get the index of the option that is marked as selected
     * @param options - the comboBox options
     * @param selectedKeys - the known selected key to find
     * @returns - the index of the selected option, -1 if not found
     */
    _getSelectedIndices(options, selectedKeys) {
        const selectedIndices = [];
        if (options === undefined || selectedKeys === undefined) {
            return selectedIndices;
        }
        for (const selectedKey of selectedKeys) {
            const index = findIndex(options, option => option.selected || option.key === selectedKey);
            if (index > -1) {
                selectedIndices.push(index);
            }
        }
        return selectedIndices;
    }
    /**
     * Reset the selected index by clearing the
     * input (of any pending text), clearing the pending state,
     * and setting the suggested display value to the last
     * selected state text
     */
    _resetSelectedIndex() {
        const { currentOptions } = this.state;
        this._clearPendingInfo();
        const selectedIndex = this._getFirstSelectedIndex();
        if (selectedIndex > 0 && selectedIndex < currentOptions.length) {
            this.setState({
                suggestedDisplayValue: currentOptions[selectedIndex].text
            });
        }
        else if (this.props.text || this.props.value) {
            // If we had a value initially, restore it
            this.setState({
                suggestedDisplayValue: this.props.text || this.props.value
            });
        }
    }
    /**
     * Clears the pending info state
     */
    _clearPendingInfo() {
        this._processingClearPendingInfo = true;
        this.setState({
            currentPendingValue: undefined,
            currentPendingValueValidIndex: -1,
            suggestedDisplayValue: undefined,
            currentPendingValueValidIndexOnHover: HoverStatus.default
        }, this._onAfterClearPendingInfo);
    }
    /**
     * Set the pending info
     * @param currentPendingValue - new pending value to set
     * @param currentPendingValueValidIndex - new pending value index to set
     * @param suggestedDisplayValue - new suggest display value to set
     */
    _setPendingInfo(currentPendingValue, currentPendingValueValidIndex = -1, suggestedDisplayValue) {
        if (this._processingClearPendingInfo) {
            return;
        }
        this.setState({
            currentPendingValue: currentPendingValue && this._removeZeroWidthSpaces(currentPendingValue),
            currentPendingValueValidIndex: currentPendingValueValidIndex,
            suggestedDisplayValue: suggestedDisplayValue,
            currentPendingValueValidIndexOnHover: HoverStatus.default
        });
    }
    /**
     * Set the pending info from the given index
     * @param index - the index to set the pending info from
     */
    _setPendingInfoFromIndex(index) {
        const { currentOptions } = this.state;
        if (index >= 0 && index < currentOptions.length) {
            const option = currentOptions[index];
            this._setPendingInfo(this._getPreviewText(option), index, this._getPreviewText(option));
        }
        else {
            this._clearPendingInfo();
        }
    }
    /**
     * Sets the pending info for the comboBox
     * @param index - the index to search from
     * @param searchDirection - the direction to search
     */
    _setPendingInfoFromIndexAndDirection(index, searchDirection) {
        const { currentOptions } = this.state;
        // update index to allow content to wrap
        if (searchDirection === SearchDirection.forward && index >= currentOptions.length - 1) {
            index = -1;
        }
        else if (searchDirection === SearchDirection.backward && index <= 0) {
            index = currentOptions.length;
        }
        // get the next "valid" index
        const indexUpdate = this._getNextSelectableIndex(index, searchDirection);
        // if the two indicies are equal we didn't move and
        // we should attempt to get  get the first/last "valid" index to use
        // (Note, this takes care of the potential cases where the first/last
        // item is not focusable), otherwise use the updated index
        if (index === indexUpdate) {
            if (searchDirection === SearchDirection.forward) {
                index = this._getNextSelectableIndex(-1, searchDirection);
            }
            else if (searchDirection === SearchDirection.backward) {
                index = this._getNextSelectableIndex(currentOptions.length, searchDirection);
            }
        }
        else {
            index = indexUpdate;
        }
        if (this._indexWithinBounds(currentOptions, index)) {
            this._setPendingInfoFromIndex(index);
        }
    }
    _notifyPendingValueChanged(prevState) {
        const { onPendingValueChanged } = this.props;
        if (!onPendingValueChanged) {
            return;
        }
        const { currentPendingValue, currentOptions, currentPendingValueValidIndex, currentPendingValueValidIndexOnHover } = this.state;
        let newPendingIndex = undefined;
        let newPendingValue = undefined;
        if (currentPendingValueValidIndexOnHover !== prevState.currentPendingValueValidIndexOnHover &&
            this._indexWithinBounds(currentOptions, currentPendingValueValidIndexOnHover)) {
            // Set new pending index if hover index was changed
            newPendingIndex = currentPendingValueValidIndexOnHover;
        }
        else if (currentPendingValueValidIndex !== prevState.currentPendingValueValidIndex &&
            this._indexWithinBounds(currentOptions, currentPendingValueValidIndex)) {
            // Set new pending index if currentPendingValueValidIndex was changed
            newPendingIndex = currentPendingValueValidIndex;
        }
        else if (currentPendingValue !== prevState.currentPendingValue && currentPendingValue !== '') {
            // Set pendingValue in the case it was changed and no index was changed
            newPendingValue = currentPendingValue;
        }
        // Notify when there is a new pending index/value. Also, if there is a pending value, it needs to send undefined.
        if (newPendingIndex !== undefined || newPendingValue !== undefined || this._hasPendingValue) {
            onPendingValueChanged(newPendingIndex !== undefined ? currentOptions[newPendingIndex] : undefined, newPendingIndex, newPendingValue);
            this._hasPendingValue = newPendingIndex !== undefined || newPendingValue !== undefined;
        }
    }
    /**
     * Sets the isOpen state and updates focusInputAfterClose
     */
    _setOpenStateAndFocusOnClose(isOpen, focusInputAfterClose) {
        this._focusInputAfterClose = focusInputAfterClose;
        this.setState({
            isOpen: isOpen
        });
    }
    /**
     * Returns true if the key for the event is alt (Mac option) or meta (Mac command).
     */
    _isAltOrMeta(ev) {
        return ev.which === KeyCodes.alt || ev.key === 'Meta';
    }
    _onOptionMouseEnter(index) {
        if (this._shouldIgnoreMouseEvent()) {
            return;
        }
        this.setState({
            currentPendingValueValidIndexOnHover: index
        });
    }
    _onOptionMouseMove(index) {
        this._gotMouseMove = true;
        if (!this._isScrollIdle || this.state.currentPendingValueValidIndexOnHover === index) {
            return;
        }
        this.setState({
            currentPendingValueValidIndexOnHover: index
        });
    }
    _shouldIgnoreMouseEvent() {
        return !this._isScrollIdle || !this._gotMouseMove;
    }
    /**
     * Handle dismissing the menu and
     * eating the required key event when disabled
     * @param ev - the keyboard event that was fired
     */
    _handleInputWhenDisabled(ev) {
        // If we are disabled, close the menu (if needed)
        // and eat all keystokes other than TAB or ESC
        if (this.props.disabled) {
            if (this.state.isOpen) {
                this.setState({ isOpen: false });
            }
            // When disabled stop propagation and prevent default
            // of the event unless we have a tab, escape, or function key
            if (ev !== null &&
                ev.which !== KeyCodes.tab &&
                ev.which !== KeyCodes.escape &&
                (ev.which < 112 /* F1 */ || ev.which > 123) /* F12 */) {
                ev.stopPropagation();
                ev.preventDefault();
            }
        }
    }
    _handleTouchAndPointerEvent() {
        // If we already have an existing timeeout from a previous touch and pointer event
        // cancel that timeout so we can set a nwe one.
        if (this._lastTouchTimeoutId !== undefined) {
            this._async.clearTimeout(this._lastTouchTimeoutId);
            this._lastTouchTimeoutId = undefined;
        }
        this._processingTouch = true;
        this._lastTouchTimeoutId = this._async.setTimeout(() => {
            this._processingTouch = false;
            this._lastTouchTimeoutId = undefined;
        }, TouchIdleDelay$2);
    }
    /**
     * Get the styles for the current option.
     * @param item Item props for the current option
     */
    _getCaretButtonStyles() {
        const { caretDownButtonStyles: customCaretDownButtonStyles } = this.props;
        return getCaretDownButtonStyles(this.props.theme, customCaretDownButtonStyles);
    }
    /**
     * Get the styles for the current option.
     * @param item Item props for the current option
     */
    _getCurrentOptionStyles(item) {
        const { comboBoxOptionStyles: customStylesForAllOptions } = this.props;
        const { styles: customStylesForCurrentOption } = item;
        return getOptionStyles(this.props.theme, customStylesForAllOptions, customStylesForCurrentOption, this._isPendingOption(item));
    }
    /**
     * Get the aria-activedescendant value for the comboxbox.
     * @returns the id of the current focused combo item, otherwise the id of the currently selected element, null otherwise
     */
    _getAriaActiveDescentValue() {
        let descendantText = this.state.isOpen && this.state.selectedIndices && this.state.selectedIndices.length >= 0
            ? this._id + '-list' + this.state.selectedIndices[0]
            : undefined;
        if (this.state.isOpen && this.state.focused && this.state.currentPendingValueValidIndex !== -1) {
            descendantText = this._id + '-list' + this.state.currentPendingValueValidIndex;
        }
        return descendantText;
    }
    /**
     * Get the aria autocomplete value for the Combobox
     * @returns 'inline' if auto-complete automatically dynamic, 'both' if we have a list of possible values to pick from and can
     * dynamically populate input, and 'none' if auto-complete is not enabled as we can't give user inputs.
     */
    _getAriaAutoCompleteValue() {
        const autoComplete = !this.props.disabled && this.props.autoComplete === 'on';
        return autoComplete ? (this.props.allowFreeform ? 'inline' : 'both') : 'none';
    }
    _isPendingOption(item) {
        return item && item.index === this.state.currentPendingValueValidIndex;
    }
    /**
     * Given default selected key(s) and selected key(s), return the selected keys(s).
     * When default selected key(s) are available, they take precedence and return them instead of selected key(s).
     *
     * @returns No matter what specific types the input parameters are, always return an array of
     *  either strings or numbers instead of premitive type.  This normlization makes caller's logic easier.
     */
    _buildDefaultSelectedKeys(defaultSelectedKey, selectedKey) {
        const selectedKeys = this._buildSelectedKeys(defaultSelectedKey);
        if (selectedKeys.length) {
            return selectedKeys;
        }
        return this._buildSelectedKeys(selectedKey);
    }
    _buildSelectedKeys(selectedKey) {
        if (selectedKey === undefined) {
            return [];
        }
        // need to cast here so typescript does not complain
        return (selectedKey instanceof Array ? selectedKey : [selectedKey]);
    }
    // For scenarios where the option's text prop contains embedded styles, we use the option's
    // ariaLabel value as the text in the input and for autocomplete matching. We know to use this
    // when the useAriaLabelAsText prop is set to true
    _getPreviewText(item) {
        return item.useAriaLabelAsText && item.ariaLabel ? item.ariaLabel : item.text;
    }
    _normalizeToString(value) {
        return value || '';
    }
    _removeZeroWidthSpaces(value) {
        // remove any zero width space characters
        return value.replace(RegExp('', 'g'), '');
    }
};
ComboBox.defaultProps = {
    options: [],
    allowFreeform: false,
    autoComplete: 'on',
    buttonIconProps: { iconName: 'ChevronDown' }
};
ComboBox = __decorate([
    customizable('ComboBox', ['theme', 'styles'], true)
], ComboBox);

const ScrollToMode = {
    /**
     * Does not make any consideration to where in the viewport the item should align to.
     */
    auto: 0,
    /**
     * Attempts to scroll the list so the top of the desired item is aligned with the top of the viewport.
     */
    top: 1,
    /**
     * Attempts to scroll the list so the bottom of the desired item is aligned with the bottom of the viewport.
     */
    bottom: 2,
    /**
     * Attempts to scroll the list so the desired item is in the exact center of the viewport.
     */
    center: 3
};

const RESIZE_DELAY$1 = 16;
const MIN_SCROLL_UPDATE_DELAY = 100;
const MAX_SCROLL_UPDATE_DELAY = 500;
const IDLE_DEBOUNCE_DELAY = 200;
// The amount of time to wait before declaring that the list isn't scrolling
const DONE_SCROLLING_WAIT = 500;
const DEFAULT_ITEMS_PER_PAGE = 10;
const DEFAULT_PAGE_HEIGHT = 30;
const DEFAULT_RENDERED_WINDOWS_BEHIND = 2;
const DEFAULT_RENDERED_WINDOWS_AHEAD = 2;
const PAGE_KEY_PREFIX = 'page-';
const SPACER_KEY_PREFIX = 'spacer-';
const EMPTY_RECT = {
    top: -1,
    bottom: -1,
    left: -1,
    right: -1,
    width: 0,
    height: 0
};
// Naming expensive measures so that they're named in profiles.
const _measurePageRect = (element) => element.getBoundingClientRect();
const _measureSurfaceRect = _measurePageRect;
const _measureScrollRect = _measurePageRect;
/**
 * The List renders virtualized pages of items. Each page's item count is determined by the getItemCountForPage callback if
 * provided by the caller, or 10 as default. Each page's height is determined by the getPageHeight callback if provided by
 * the caller, or by cached measurements if available, or by a running average, or a default fallback.
 *
 * The algorithm for rendering pages works like this:
 *
 * 1. Predict visible pages based on "current measure data" (page heights, surface position, visible window)
 * 2. If changes are necessary, apply changes (add/remove pages)
 * 3. For pages that are added, measure the page heights if we need to using getBoundingClientRect
 * 4. If measurements don't match predictions, update measure data and goto step 1 asynchronously
 *
 * Measuring too frequently can pull performance down significantly. To compensate, we cache measured values so that
 * we can avoid re-measuring during operations that should not alter heights, like scrolling.
 *
 * To optimize glass rendering performance, onShouldVirtualize can be set. When onShouldVirtualize return false,
 * List will run in fast mode (not virtualized) to render all items without any measurements to improve page load time. And we
 * start doing measurements and rendering in virtualized mode when items grows larger than this threshold.
 *
 * However, certain operations can make measure data stale. For example, resizing the list, or passing in new props,
 * or forcing an update change cause pages to shrink/grow. When these operations occur, we increment a measureVersion
 * number, which we associate with cached measurements and use to determine if a remeasure should occur.
 */
class List extends BaseComponent {
    constructor(props) {
        super(props);
        this._root = createRef();
        this._surface = createRef();
        this._onRenderPage = (pageProps, defaultRender) => {
            const { onRenderCell, role } = this.props;
            const { page: { items, startIndex }, ...divProps } = pageProps;
            // only assign list item role if no role is assigned
            const cellRole = role === undefined ? 'listitem' : 'presentation';
            const cells = (items || []).map((item, offset) => {
                const index = startIndex + offset;
                let itemKey = this.props.getKey ? this.props.getKey(item, index) : item && item.key;
                if (itemKey === null || itemKey === undefined) {
                    itemKey = index;
                }
                return (createElement("div", { role: cellRole, className: css('ms-List-cell'), key: itemKey, "data-list-index": index, "data-automationid": "ListCell" }, onRenderCell && onRenderCell(item, index, this.state.isScrolling)));
            });
            return createElement("div", Object.assign({}, divProps), cells);
        };
        this.state = {
            pages: [],
            isScrolling: false
        };
        this._estimatedPageHeight = 0;
        this._totalEstimates = 0;
        this._requiredWindowsAhead = 0;
        this._requiredWindowsBehind = 0;
        // Track the measure version for everything.
        this._measureVersion = 0;
        // Ensure that scrolls are lazy updated.
        this._onAsyncScroll = this._async.debounce(this._onAsyncScroll, MIN_SCROLL_UPDATE_DELAY, {
            leading: false,
            maxWait: MAX_SCROLL_UPDATE_DELAY
        });
        this._onAsyncIdle = this._async.debounce(this._onAsyncIdle, IDLE_DEBOUNCE_DELAY, {
            leading: false
        });
        this._onAsyncResize = this._async.debounce(this._onAsyncResize, RESIZE_DELAY$1, {
            leading: false
        });
        this._onScrollingDone = this._async.debounce(this._onScrollingDone, DONE_SCROLLING_WAIT, {
            leading: false
        });
        this._cachedPageHeights = {};
        this._estimatedPageHeight = 0;
        this._focusedIndex = -1;
        this._pageCache = {};
    }
    /**
     * Scroll to the given index. By default will bring the page the specified item is on into the view. If a callback
     * to measure the height of an individual item is specified, will only scroll to bring the specific item into view.
     *
     * Note: with items of variable height and no passed in `getPageHeight` method, the list might jump after scrolling
     * when windows before/ahead are being rendered, and the estimated height is replaced using actual elements.
     *
     * @param index - Index of item to scroll to
     * @param measureItem - Optional callback to measure the height of an individual item
     * @param scrollToMode - Optional defines where in the window the item should be positioned to when scrolling
     */
    scrollToIndex(index, measureItem, scrollToMode = ScrollToMode.auto) {
        const startIndex = this.props.startIndex;
        const renderCount = this._getRenderCount();
        const endIndex = startIndex + renderCount;
        const allowedRect = this._allowedRect;
        let scrollTop = 0;
        let itemsPerPage = 1;
        for (let itemIndex = startIndex; itemIndex < endIndex; itemIndex += itemsPerPage) {
            const pageSpecification = this._getPageSpecification(itemIndex, allowedRect);
            const pageHeight = pageSpecification.height;
            itemsPerPage = pageSpecification.itemCount;
            const requestedIndexIsInPage = itemIndex <= index && itemIndex + itemsPerPage > index;
            if (requestedIndexIsInPage) {
                // We have found the page. If the user provided a way to measure an individual item, we will try to scroll in just
                // the given item, otherwise we'll only bring the page into view
                if (measureItem) {
                    const scrollRect = _measureScrollRect(this._scrollElement);
                    const scrollWindow = {
                        top: this._scrollElement.scrollTop,
                        bottom: this._scrollElement.scrollTop + scrollRect.height
                    };
                    // Adjust for actual item position within page
                    const itemPositionWithinPage = index - itemIndex;
                    for (let itemIndexInPage = 0; itemIndexInPage < itemPositionWithinPage; ++itemIndexInPage) {
                        scrollTop += measureItem(itemIndex + itemIndexInPage);
                    }
                    const scrollBottom = scrollTop + measureItem(index);
                    // If scrollToMode is set to something other than auto, we always want to
                    // scroll the item into a specific position on the page.
                    switch (scrollToMode) {
                        case ScrollToMode.top:
                            this._scrollElement.scrollTop = scrollTop;
                            return;
                        case ScrollToMode.bottom:
                            this._scrollElement.scrollTop = scrollBottom - scrollRect.height;
                            return;
                        case ScrollToMode.center:
                            this._scrollElement.scrollTop = (scrollTop + scrollBottom - scrollRect.height) / 2;
                            return;
                        case ScrollToMode.auto:
                        default:
                            break;
                    }
                    const itemIsFullyVisible = scrollTop >= scrollWindow.top && scrollBottom <= scrollWindow.bottom;
                    if (itemIsFullyVisible) {
                        // Item is already visible, do nothing.
                        return;
                    }
                    const itemIsPartiallyAbove = scrollTop < scrollWindow.top;
                    const itemIsPartiallyBelow = scrollBottom > scrollWindow.bottom;
                    if (itemIsPartiallyAbove) ;
                    else if (itemIsPartiallyBelow) {
                        //  Adjust scrollTop position to just bring in the element
                        // .------.  - scrollTop
                        // |      |
                        // | .------.
                        // '-|----' | - scrollWindow.bottom
                        //   | Item |
                        //   '------' - scrollBottom
                        scrollTop = scrollBottom - scrollRect.height;
                    }
                }
                this._scrollElement.scrollTop = scrollTop;
                return;
            }
            scrollTop += pageHeight;
        }
    }
    getStartItemIndexInView(measureItem) {
        const pages = this.state.pages || [];
        for (const page of pages) {
            const isPageVisible = !page.isSpacer && (this._scrollTop || 0) >= page.top && (this._scrollTop || 0) <= page.top + page.height;
            if (isPageVisible) {
                if (!measureItem) {
                    const rowHeight = Math.floor(page.height / page.itemCount);
                    return page.startIndex + Math.floor((this._scrollTop - page.top) / rowHeight);
                }
                else {
                    let totalRowHeight = 0;
                    for (let itemIndex = page.startIndex; itemIndex < page.startIndex + page.itemCount; itemIndex++) {
                        const rowHeight = measureItem(itemIndex);
                        if (page.top + totalRowHeight <= this._scrollTop && this._scrollTop < page.top + totalRowHeight + rowHeight) {
                            return itemIndex;
                        }
                        else {
                            totalRowHeight += rowHeight;
                        }
                    }
                }
            }
        }
        return 0;
    }
    componentDidMount() {
        this._updatePages();
        this._measureVersion++;
        this._scrollElement = findScrollableParent(this._root.current);
        this._events.on(window, 'resize', this._onAsyncResize);
        if (this._root.current) {
            this._events.on(this._root.current, 'focus', this._onFocus, true);
        }
        if (this._scrollElement) {
            this._events.on(this._scrollElement, 'scroll', this._onScroll);
            this._events.on(this._scrollElement, 'scroll', this._onAsyncScroll);
        }
    }
    componentWillReceiveProps(newProps) {
        if (newProps.items !== this.props.items ||
            newProps.renderCount !== this.props.renderCount ||
            newProps.startIndex !== this.props.startIndex) {
            // We have received new items so we want to make sure that initially we only render a single window to
            // fill the currently visible rect, and then later render additional windows.
            this._resetRequiredWindows();
            this._requiredRect = null;
            this._measureVersion++;
            this._invalidatePageCache();
            this._updatePages(newProps);
        }
    }
    shouldComponentUpdate(newProps, newState) {
        const { pages: oldPages } = this.state;
        const { pages: newPages } = newState;
        let shouldComponentUpdate = false;
        // Update if the page stops scrolling
        if (!newState.isScrolling && this.state.isScrolling) {
            return true;
        }
        if (newProps.items === this.props.items && oldPages.length === newPages.length) {
            for (let i = 0; i < oldPages.length; i++) {
                const oldPage = oldPages[i];
                const newPage = newPages[i];
                if (oldPage.key !== newPage.key || oldPage.itemCount !== newPage.itemCount) {
                    shouldComponentUpdate = true;
                    break;
                }
            }
        }
        else {
            shouldComponentUpdate = true;
        }
        return shouldComponentUpdate;
    }
    forceUpdate() {
        this._invalidatePageCache();
        // Ensure that when the list is force updated we update the pages first before render.
        this._updateRenderRects(this.props, true);
        this._updatePages();
        this._measureVersion++;
        super.forceUpdate();
    }
    render() {
        const { className, role } = this.props;
        const { pages = [] } = this.state;
        const pageElements = [];
        const divProps = getNativeProps(this.props, divProperties);
        for (const page of pages) {
            pageElements.push(this._renderPage(page));
        }
        return (createElement("div", Object.assign({ ref: this._root }, divProps, { role: role === undefined ? 'list' : role, className: css('ms-List', className) }),
            createElement("div", { ref: this._surface, className: css('ms-List-surface'), role: "presentation" }, pageElements)));
    }
    _shouldVirtualize(props = this.props) {
        const { onShouldVirtualize } = props;
        return !onShouldVirtualize || onShouldVirtualize(props);
    }
    /**
     * when props.items change or forceUpdate called, throw away cached pages
     */
    _invalidatePageCache() {
        this._pageCache = {};
    }
    _renderPage(page) {
        const { usePageCache } = this.props;
        let cachedPage;
        // if usePageCache is set and cached page element can be found, just return cached page
        if (usePageCache) {
            cachedPage = this._pageCache[page.key];
            if (cachedPage && cachedPage.pageElement) {
                return cachedPage.pageElement;
            }
        }
        const pageStyle = this._getPageStyle(page);
        const { onRenderPage = this._onRenderPage } = this.props;
        const pageElement = onRenderPage({
            page: page,
            className: css('ms-List-page'),
            key: page.key,
            ref: page.key,
            style: pageStyle,
            role: 'presentation'
        }, this._onRenderPage);
        // cache the first page for now since it is re-rendered a lot times unnecessarily.
        // todo: a more aggresive caching mechanism is to cache pages constaining the items not changed.
        // now we re-render pages too frequently, for example, props.items increased from 30 to 60, although the
        // first 30 items did not change, we still re-rendered all of them in this props.items change.
        if (usePageCache && page.startIndex === 0) {
            this._pageCache[page.key] = {
                page: page,
                pageElement: pageElement
            };
        }
        return pageElement;
    }
    /** Generate the style object for the page. */
    _getPageStyle(page) {
        const { getPageStyle } = this.props;
        return {
            ...(getPageStyle ? getPageStyle(page) : {}),
            ...(!page.items
                ? {
                    height: page.height
                }
                : {})
        };
    }
    /** Track the last item index focused so that we ensure we keep it rendered. */
    _onFocus(ev) {
        let target = ev.target;
        while (target !== this._surface.current) {
            const indexString = target.getAttribute('data-list-index');
            if (indexString) {
                this._focusedIndex = Number(indexString);
                break;
            }
            target = getParent(target);
        }
    }
    /**
     * Called synchronously to reset the required render range to 0 on scrolling. After async scroll has executed,
     * we will call onAsyncIdle which will reset it back to it's correct value.
     */
    _onScroll() {
        if (!this.state.isScrolling) {
            this.setState({ isScrolling: true });
        }
        this._resetRequiredWindows();
        this._onScrollingDone();
    }
    _resetRequiredWindows() {
        this._requiredWindowsAhead = 0;
        this._requiredWindowsBehind = 0;
    }
    /**
     * Debounced method to asynchronously update the visible region on a scroll event.
     */
    _onAsyncScroll() {
        this._updateRenderRects();
        // Only update pages when the visible rect falls outside of the materialized rect.
        if (!this._materializedRect || !_isContainedWithin(this._requiredRect, this._materializedRect)) {
            this._updatePages();
        }
    }
    /**
     * This is an async debounced method that will try and increment the windows we render. If we can increment
     * either, we increase the amount we render and re-evaluate.
     */
    _onAsyncIdle() {
        const { renderedWindowsAhead, renderedWindowsBehind } = this.props;
        const { _requiredWindowsAhead: requiredWindowsAhead, _requiredWindowsBehind: requiredWindowsBehind } = this;
        const windowsAhead = Math.min(renderedWindowsAhead, requiredWindowsAhead + 1);
        const windowsBehind = Math.min(renderedWindowsBehind, requiredWindowsBehind + 1);
        if (windowsAhead !== requiredWindowsAhead || windowsBehind !== requiredWindowsBehind) {
            // console.log('idling', windowsBehind, windowsAhead);
            this._requiredWindowsAhead = windowsAhead;
            this._requiredWindowsBehind = windowsBehind;
            this._updateRenderRects();
            this._updatePages();
        }
        if (renderedWindowsAhead > windowsAhead || renderedWindowsBehind > windowsBehind) {
            // Async increment on next tick.
            this._onAsyncIdle();
        }
    }
    /**
     * Function to call when the list is done scrolling.
     * This function is debounced.
     */
    _onScrollingDone() {
        this.setState({ isScrolling: false });
    }
    _onAsyncResize() {
        this.forceUpdate();
    }
    _updatePages(props = this.props) {
        // console.log('updating pages');
        if (!this._requiredRect) {
            this._updateRenderRects(props);
        }
        const newListState = this._buildPages(props);
        const oldListPages = this.state.pages;
        this._notifyPageChanges(oldListPages, newListState.pages);
        this.setState(newListState, () => {
            // If we weren't provided with the page height, measure the pages
            if (!props.getPageHeight) {
                // If measured version is invalid since we've updated the DOM
                const heightsChanged = this._updatePageMeasurements(newListState.pages);
                // On first render, we should re-measure so that we don't get a visual glitch.
                if (heightsChanged) {
                    this._materializedRect = null;
                    if (!this._hasCompletedFirstRender) {
                        this._hasCompletedFirstRender = true;
                        this._updatePages(props);
                    }
                    else {
                        this._onAsyncScroll();
                    }
                }
                else {
                    // Enqueue an idle bump.
                    this._onAsyncIdle();
                }
            }
            else {
                // Enqueue an idle bump
                this._onAsyncIdle();
            }
            // Notify the caller that rendering the new pages has completed
            if (props.onPagesUpdated) {
                props.onPagesUpdated(this.state.pages);
            }
        });
    }
    /**
     * Notify consumers that the rendered pages have changed
     * @param oldPages - The old pages
     * @param newPages - The new pages
     * @param props - The props to use
     */
    _notifyPageChanges(oldPages, newPages, props = this.props) {
        const { onPageAdded, onPageRemoved } = props;
        if (onPageAdded || onPageRemoved) {
            const renderedIndexes = {};
            for (const page of oldPages) {
                if (page.items) {
                    renderedIndexes[page.startIndex] = page;
                }
            }
            for (const page of newPages) {
                if (page.items) {
                    if (!renderedIndexes[page.startIndex]) {
                        this._onPageAdded(page);
                    }
                    else {
                        delete renderedIndexes[page.startIndex];
                    }
                }
            }
            for (const index in renderedIndexes) {
                if (renderedIndexes.hasOwnProperty(index)) {
                    this._onPageRemoved(renderedIndexes[index]);
                }
            }
        }
    }
    _updatePageMeasurements(pages) {
        let heightChanged = false;
        // when not in virtualize mode, we render all the items without page measurement
        if (!this._shouldVirtualize()) {
            return heightChanged;
        }
        for (let i = 0; i < pages.length; i++) {
            const page = pages[i];
            if (page.items) {
                heightChanged = this._measurePage(page) || heightChanged;
            }
        }
        return heightChanged;
    }
    /**
     * Given a page, measure its dimensions, update cache.
     * @returns True if the height has changed.
     */
    _measurePage(page) {
        let hasChangedHeight = false;
        const pageElement = this.refs[page.key];
        const cachedHeight = this._cachedPageHeights[page.startIndex];
        // console.log('   * measure attempt', page.startIndex, cachedHeight);
        if (pageElement && this._shouldVirtualize() && (!cachedHeight || cachedHeight.measureVersion !== this._measureVersion)) {
            const newClientRect = {
                width: pageElement.clientWidth,
                height: pageElement.clientHeight
            };
            if (newClientRect.height || newClientRect.width) {
                hasChangedHeight = page.height !== newClientRect.height;
                // console.warn(' *** expensive page measure', page.startIndex, page.height, newClientRect.height);
                page.height = newClientRect.height;
                this._cachedPageHeights[page.startIndex] = {
                    height: newClientRect.height,
                    measureVersion: this._measureVersion
                };
                this._estimatedPageHeight = Math.round((this._estimatedPageHeight * this._totalEstimates + newClientRect.height) / (this._totalEstimates + 1));
                this._totalEstimates++;
            }
        }
        return hasChangedHeight;
    }
    /** Called when a page has been added to the DOM. */
    _onPageAdded(page) {
        const { onPageAdded } = this.props;
        // console.log('page added', page.startIndex, this.state.pages.map(page => page.key).join(', '));
        if (onPageAdded) {
            onPageAdded(page);
        }
    }
    /** Called when a page has been removed from the DOM. */
    _onPageRemoved(page) {
        const { onPageRemoved } = this.props;
        // console.log('  --- page removed', page.startIndex, this.state.pages.map(page => page.key).join(', '));
        if (onPageRemoved) {
            onPageRemoved(page);
        }
    }
    /** Build up the pages that should be rendered. */
    _buildPages(props) {
        let { renderCount } = props;
        const { items, startIndex, getPageHeight } = props;
        renderCount = this._getRenderCount(props);
        const materializedRect = { ...EMPTY_RECT };
        const pages = [];
        let itemsPerPage = 1;
        let pageTop = 0;
        let currentSpacer = null;
        const focusedIndex = this._focusedIndex;
        const endIndex = startIndex + renderCount;
        const shouldVirtualize = this._shouldVirtualize(props);
        // First render is very important to track; when we render cells, we have no idea of estimated page height.
        // So we should default to rendering only the first page so that we can get information.
        // However if the user provides a measure function, let's just assume they know the right heights.
        const isFirstRender = this._estimatedPageHeight === 0 && !getPageHeight;
        const allowedRect = this._allowedRect;
        for (let itemIndex = startIndex; itemIndex < endIndex; itemIndex += itemsPerPage) {
            const pageSpecification = this._getPageSpecification(itemIndex, allowedRect);
            const pageHeight = pageSpecification.height;
            const pageData = pageSpecification.data;
            const key = pageSpecification.key;
            itemsPerPage = pageSpecification.itemCount;
            const pageBottom = pageTop + pageHeight - 1;
            const isPageRendered = findIndex(this.state.pages, (page) => !!page.items && page.startIndex === itemIndex) > -1;
            const isPageInAllowedRange = !allowedRect || (pageBottom >= allowedRect.top && pageTop <= allowedRect.bottom);
            const isPageInRequiredRange = !this._requiredRect || (pageBottom >= this._requiredRect.top && pageTop <= this._requiredRect.bottom);
            const isPageVisible = (!isFirstRender && (isPageInRequiredRange || (isPageInAllowedRange && isPageRendered))) || !shouldVirtualize;
            const isPageFocused = focusedIndex >= itemIndex && focusedIndex < itemIndex + itemsPerPage;
            const isFirstPage = itemIndex === startIndex;
            // console.log('building page', itemIndex, 'pageTop: ' + pageTop, 'inAllowed: ' +
            // isPageInAllowedRange, 'inRequired: ' + isPageInRequiredRange);
            // Only render whats visible, focused, or first page,
            // or when running in fast rendering mode (not in virtualized mode), we render all current items in pages
            if (isPageVisible || isPageFocused || isFirstPage) {
                if (currentSpacer) {
                    pages.push(currentSpacer);
                    currentSpacer = null;
                }
                const itemsInPage = Math.min(itemsPerPage, endIndex - itemIndex);
                const newPage = this._createPage(key, items.slice(itemIndex, itemIndex + itemsInPage), itemIndex, undefined, undefined, pageData);
                newPage.top = pageTop;
                newPage.height = pageHeight;
                pages.push(newPage);
                if (isPageInRequiredRange && this._allowedRect) {
                    _mergeRect(materializedRect, {
                        top: pageTop,
                        bottom: pageBottom,
                        height: pageHeight,
                        left: allowedRect.left,
                        right: allowedRect.right,
                        width: allowedRect.width
                    });
                }
            }
            else {
                if (!currentSpacer) {
                    currentSpacer = this._createPage(SPACER_KEY_PREFIX + itemIndex, undefined, itemIndex, 0, undefined, pageData, true /*isSpacer*/);
                }
                currentSpacer.height = (currentSpacer.height || 0) + (pageBottom - pageTop) + 1;
                currentSpacer.itemCount += itemsPerPage;
            }
            pageTop += pageBottom - pageTop + 1;
            // in virtualized mode, we render need to render first page then break and measure,
            // otherwise, we render all items without measurement to make rendering fast
            if (isFirstRender && shouldVirtualize) {
                break;
            }
        }
        if (currentSpacer) {
            currentSpacer.key = SPACER_KEY_PREFIX + 'end';
            pages.push(currentSpacer);
        }
        this._materializedRect = materializedRect;
        // console.log('materialized: ', materializedRect);
        return {
            pages: pages,
            measureVersion: this._measureVersion
        };
    }
    _getPageSpecification(itemIndex, visibleRect) {
        const { getPageSpecification } = this.props;
        if (getPageSpecification) {
            const pageData = getPageSpecification(itemIndex, visibleRect);
            const { itemCount = this._getItemCountForPage(itemIndex, visibleRect) } = pageData;
            const { height = this._getPageHeight(itemIndex, itemCount, visibleRect) } = pageData;
            return {
                itemCount: itemCount,
                height: height,
                data: pageData.data,
                key: pageData.key
            };
        }
        else {
            const itemCount = this._getItemCountForPage(itemIndex, visibleRect);
            return {
                itemCount: itemCount,
                height: this._getPageHeight(itemIndex, itemCount, visibleRect)
            };
        }
    }
    /**
     * Get the pixel height of a give page. Will use the props getPageHeight first, and if not provided, fallback to
     * cached height, or estimated page height, or default page height.
     */
    _getPageHeight(itemIndex, itemsPerPage, visibleRect) {
        if (this.props.getPageHeight) {
            return this.props.getPageHeight(itemIndex, visibleRect);
        }
        else {
            const cachedHeight = this._cachedPageHeights[itemIndex];
            return cachedHeight ? cachedHeight.height : this._estimatedPageHeight || DEFAULT_PAGE_HEIGHT;
        }
    }
    _getItemCountForPage(itemIndex, visibileRect) {
        const itemsPerPage = this.props.getItemCountForPage ? this.props.getItemCountForPage(itemIndex, visibileRect) : DEFAULT_ITEMS_PER_PAGE;
        return itemsPerPage ? itemsPerPage : DEFAULT_ITEMS_PER_PAGE;
    }
    _createPage(pageKey, items, startIndex = -1, count = items ? items.length : 0, style = {}, data = undefined, isSpacer) {
        pageKey = pageKey || PAGE_KEY_PREFIX + startIndex;
        const cachedPage = this._pageCache[pageKey];
        if (cachedPage && cachedPage.page) {
            return cachedPage.page;
        }
        // Fill undefined cells because array.map will ignore undefined cells.
        if (items) {
            for (let i = 0; i < items.length; i++) {
                items[i] = items[i] || undefined;
            }
        }
        return {
            key: pageKey,
            startIndex: startIndex,
            itemCount: count,
            items: items,
            style: style || {},
            top: 0,
            height: 0,
            data: data,
            isSpacer: isSpacer || false
        };
    }
    _getRenderCount(props) {
        const { items, startIndex, renderCount } = props || this.props;
        return renderCount === undefined ? (items ? items.length - startIndex : 0) : renderCount;
    }
    /** Calculate the visible rect within the list where top: 0 and left: 0 is the top/left of the list. */
    _updateRenderRects(props, forceUpdate) {
        props = props || this.props;
        const { renderedWindowsAhead, renderedWindowsBehind } = props;
        const { pages } = this.state;
        // when not in virtualize mode, we render all items without measurement to optimize page rendering perf
        if (!this._shouldVirtualize(props)) {
            return;
        }
        let surfaceRect = this._surfaceRect;
        const scrollHeight = this._scrollElement && this._scrollElement.scrollHeight;
        const scrollTop = this._scrollElement ? this._scrollElement.scrollTop : 0;
        // WARNING: EXPENSIVE CALL! We need to know the surface top relative to the window.
        // This needs to be called to recalculate when new pages should be loaded.
        // We check to see how far we've scrolled and if it's further than a third of a page we run it again.
        if (this._surface.current &&
            (forceUpdate ||
                !pages ||
                !this._surfaceRect ||
                !scrollHeight ||
                scrollHeight !== this._scrollHeight ||
                Math.abs(this._scrollTop - scrollTop) > this._estimatedPageHeight / 3)) {
            surfaceRect = this._surfaceRect = _measureSurfaceRect(this._surface.current);
            this._scrollTop = scrollTop;
        }
        // If the scroll height has changed, something in the container likely resized and
        // we should redo the page heights incase their content resized.
        if (forceUpdate || !scrollHeight || scrollHeight !== this._scrollHeight) {
            this._measureVersion++;
        }
        this._scrollHeight = scrollHeight;
        // If the surface is above the container top or below the container bottom, or if this is not the first
        // render return empty rect.
        // The first time the list gets rendered we need to calculate the rectangle. The width of the list is
        // used to calculate the width of the list items.
        const visibleTop = Math.max(0, -surfaceRect.top);
        const visibleRect = {
            top: visibleTop,
            left: surfaceRect.left,
            bottom: visibleTop + window.innerHeight,
            right: surfaceRect.right,
            width: surfaceRect.width,
            height: window.innerHeight
        };
        // The required/allowed rects are adjusted versions of the visible rect.
        this._requiredRect = _expandRect(visibleRect, this._requiredWindowsBehind, this._requiredWindowsAhead);
        this._allowedRect = _expandRect(visibleRect, renderedWindowsBehind, renderedWindowsAhead);
    }
}
List.defaultProps = {
    startIndex: 0,
    onRenderCell: (item, index, containsFocus) => createElement("div", null, (item && item.name) || ''),
    renderedWindowsAhead: DEFAULT_RENDERED_WINDOWS_AHEAD,
    renderedWindowsBehind: DEFAULT_RENDERED_WINDOWS_BEHIND
};
function _expandRect(rect, pagesBefore, pagesAfter) {
    const top = rect.top - pagesBefore * rect.height;
    const height = rect.height + (pagesBefore + pagesAfter) * rect.height;
    return {
        top: top,
        bottom: top + height,
        height: height,
        left: rect.left,
        right: rect.right,
        width: rect.width
    };
}
function _isContainedWithin(innerRect, outerRect) {
    return (innerRect.top >= outerRect.top &&
        innerRect.left >= outerRect.left &&
        innerRect.bottom <= outerRect.bottom &&
        innerRect.right <= outerRect.right);
}
function _mergeRect(targetRect, newRect) {
    targetRect.top = newRect.top < targetRect.top || targetRect.top === -1 ? newRect.top : targetRect.top;
    targetRect.left = newRect.left < targetRect.left || targetRect.left === -1 ? newRect.left : targetRect.left;
    targetRect.bottom = newRect.bottom > targetRect.bottom || targetRect.bottom === -1 ? newRect.bottom : targetRect.bottom;
    targetRect.right = newRect.right > targetRect.right || targetRect.right === -1 ? newRect.right : targetRect.right;
    targetRect.width = targetRect.right - targetRect.left + 1;
    targetRect.height = targetRect.bottom - targetRect.top + 1;
    return targetRect;
}

class VirtualizedComboBox extends BaseComponent {
    constructor() {
        super(...arguments);
        /** The combo box element */
        this._comboBox = createRef();
        /** The virtualized list element */
        this._list = createRef();
        this._onRenderList = (props) => {
            const { onRenderItem } = props;
            // Render virtualized list
            return (createElement(List, { componentRef: this._list, role: "listbox", items: props.options, onRenderCell: onRenderItem ? (item) => onRenderItem(item) : () => null }));
        };
        this._onScrollToItem = (itemIndex) => {
            // We are using the List component, call scrollToIndex
            this._list.current && this._list.current.scrollToIndex(itemIndex);
        };
    }
    dismissMenu() {
        if (this._comboBox.current) {
            return this._comboBox.current.dismissMenu();
        }
    }
    focus() {
        if (this._comboBox.current) {
            this._comboBox.current.focus();
            return true;
        }
        return false;
    }
    render() {
        return (createElement(ComboBox, Object.assign({}, this.props, { componentRef: this._comboBox, onRenderList: this._onRenderList, onScrollToItem: this._onScrollToItem })));
    }
}

const getClassNames$r = classNamesFunction();
class OverflowSetBase extends BaseComponent {
    constructor(props) {
        super(props);
        this._focusZone = createRef();
        this._persistedKeytips = {};
        this._keytipManager = KeytipManager.getInstance();
        this._divContainer = createRef();
        this._onRenderItems = (items) => {
            return items.map((item, i) => {
                const wrapperDivProps = {
                    className: this._classNames.item
                };
                return (createElement("div", Object.assign({ key: item.key }, wrapperDivProps), this.props.onRenderItem(item)));
            });
        };
        this._onRenderOverflowButtonWrapper = (items) => {
            const wrapperDivProps = {
                className: this._classNames.overflowButton
            };
            const overflowKeytipSequences = this.props.keytipSequences;
            let newOverflowItems = [];
            if (overflowKeytipSequences) {
                items.forEach(overflowItem => {
                    const keytip = overflowItem.keytipProps;
                    if (keytip) {
                        // Create persisted keytip
                        const persistedKeytip = {
                            content: keytip.content,
                            keySequences: keytip.keySequences,
                            disabled: keytip.disabled || !!(overflowItem.disabled || overflowItem.isDisabled)
                        };
                        if (keytip.hasDynamicChildren || this._getSubMenuForItem(overflowItem)) {
                            // If the keytip has a submenu or children nodes, change onExecute to persistedKeytipExecute
                            persistedKeytip.onExecute = this._keytipManager.menuExecute.bind(this._keytipManager, overflowKeytipSequences, overflowItem.keytipProps.keySequences);
                        }
                        else {
                            // If the keytip doesn't have a submenu, just execute the original function
                            persistedKeytip.onExecute = keytip.onExecute;
                        }
                        // Add this persisted keytip to our internal list, use a temporary uniqueID (its content)
                        // uniqueID will get updated on register
                        this._persistedKeytips[persistedKeytip.content] = persistedKeytip;
                        // Add the overflow sequence to this item
                        const newOverflowItem = {
                            ...overflowItem,
                            keytipProps: {
                                ...keytip,
                                overflowSetSequence: overflowKeytipSequences
                            }
                        };
                        newOverflowItems.push(newOverflowItem);
                    }
                    else {
                        // Nothing to change, add overflowItem to list
                        newOverflowItems.push(overflowItem);
                    }
                });
            }
            else {
                newOverflowItems = items;
            }
            return createElement("div", Object.assign({}, wrapperDivProps), this.props.onRenderOverflowButton(newOverflowItems));
        };
        if (props.doNotContainWithinFocusZone) {
            this._warnMutuallyExclusive({
                doNotContainWithinFocusZone: 'focusZoneProps'
            });
        }
    }
    render() {
        const { items, overflowItems, className, focusZoneProps, styles, vertical, role, doNotContainWithinFocusZone } = this.props;
        this._classNames = getClassNames$r(styles, { className, vertical });
        let Tag;
        let uniqueComponentProps;
        if (doNotContainWithinFocusZone) {
            Tag = 'div';
            uniqueComponentProps = {
                ...getNativeProps(this.props, divProperties),
                ref: this._divContainer
            };
        }
        else {
            Tag = FocusZone;
            uniqueComponentProps = {
                ...getNativeProps(this.props, divProperties),
                ...focusZoneProps,
                componentRef: this._focusZone,
                direction: vertical ? FocusZoneDirection.vertical : FocusZoneDirection.horizontal
            };
        }
        return (createElement(Tag, Object.assign({}, uniqueComponentProps, { className: this._classNames.root, role: role }),
            items && this._onRenderItems(items),
            overflowItems && overflowItems.length > 0 && this._onRenderOverflowButtonWrapper(overflowItems)));
    }
    /**
     * Sets focus to the first tabbable item in the OverflowSet.
     * @param forceIntoFirstElement - If true, focus will be forced into the first element,
     * even if focus is already in theOverflowSet
     * @returns True if focus could be set to an active element, false if no operation was taken.
     */
    focus(forceIntoFirstElement) {
        let focusSucceeded = false;
        if (this.props.doNotContainWithinFocusZone) {
            if (this._divContainer.current) {
                focusSucceeded = focusFirstChild(this._divContainer.current);
            }
        }
        else if (this._focusZone.current) {
            focusSucceeded = this._focusZone.current.focus(forceIntoFirstElement);
        }
        return focusSucceeded;
    }
    /**
     * Sets focus to a specific child element within the OverflowSet.
     * @param childElement - The child element within the zone to focus.
     * @returns True if focus could be set to an active element, false if no operation was taken.
     */
    focusElement(childElement) {
        let focusSucceeded = false;
        if (!childElement) {
            return false;
        }
        if (this.props.doNotContainWithinFocusZone) {
            if (this._divContainer.current && elementContains(this._divContainer.current, childElement)) {
                childElement.focus();
                focusSucceeded = document.activeElement === childElement;
            }
        }
        else if (this._focusZone.current) {
            focusSucceeded = this._focusZone.current.focusElement(childElement);
        }
        return focusSucceeded;
    }
    // Add keytip register/unregister handlers to lifecycle functions to correctly manage persisted keytips
    componentDidMount() {
        this._registerPersistedKeytips();
    }
    componentWillUnmount() {
        this._unregisterPersistedKeytips();
    }
    componentWillUpdate() {
        this._unregisterPersistedKeytips();
    }
    componentDidUpdate() {
        this._registerPersistedKeytips();
    }
    _registerPersistedKeytips() {
        Object.keys(this._persistedKeytips).forEach((key) => {
            const keytip = this._persistedKeytips[key];
            const uniqueID = this._keytipManager.register(keytip, true);
            // Update map
            this._persistedKeytips[uniqueID] = keytip;
            delete this._persistedKeytips[key];
        });
    }
    _unregisterPersistedKeytips() {
        // Delete all persisted keytips saved
        Object.keys(this._persistedKeytips).forEach((uniqueID) => {
            this._keytipManager.unregister(this._persistedKeytips[uniqueID], uniqueID, true);
        });
        this._persistedKeytips = {};
    }
    /**
     * Gets the subMenu for an overflow item
     * Checks if itemSubMenuProvider has been defined, if not defaults to subMenuProps
     */
    _getSubMenuForItem(item) {
        if (this.props.itemSubMenuProvider) {
            return this.props.itemSubMenuProvider(item);
        }
        if (item.subMenuProps) {
            return item.subMenuProps.items;
        }
        return undefined;
    }
}
OverflowSetBase.defaultProps = {
    vertical: false,
    role: 'menubar'
};

const overflowItemStyle = {
    flexShrink: 0,
    display: 'inherit'
};
const getStyles$y = props => {
    const { className, vertical } = props;
    return {
        root: [
            'ms-OverflowSet',
            {
                position: 'relative',
                display: 'flex',
                flexWrap: 'nowrap'
            },
            vertical && { flexDirection: 'column' },
            className
        ],
        item: ['ms-OverflowSet-item', overflowItemStyle],
        overflowButton: ['ms-OverflowSet-overflowButton', overflowItemStyle]
    };
};

const OverflowSet = styled(OverflowSetBase, getStyles$y, undefined, {
    scope: 'OverflowSet'
});

const getClassNames$s = classNamesFunction();
class CommandBarBase extends BaseComponent {
    constructor() {
        super(...arguments);
        this._overflowSet = createRef();
        this._resizeGroup = createRef();
        this._onRenderData = (data) => {
            return (createElement(FocusZone, { className: css(this._classNames.root), direction: FocusZoneDirection.horizontal, role: 'menubar', "aria-label": this.props.ariaLabel },
                createElement(OverflowSet, { componentRef: this._resolveRef('_overflowSet'), className: css(this._classNames.primarySet), doNotContainWithinFocusZone: true, role: 'presentation', items: data.primaryItems, overflowItems: data.overflowItems.length ? data.overflowItems : undefined, onRenderItem: this._onRenderItem, onRenderOverflowButton: this._onRenderOverflowButton }),
                data.farItems && (createElement(OverflowSet, { className: css(this._classNames.secondarySet), doNotContainWithinFocusZone: true, role: 'presentation', items: data.farItems, onRenderItem: this._onRenderItem, onRenderOverflowButton: nullRender }))));
        };
        this._onRenderItem = (item) => {
            const CommandButtonType = this.props.buttonAs || item.commandBarButtonAs || CommandBarButton;
            const itemText = item.text || item.name;
            if (item.onRender) {
                // These are the top level items, there is no relevant menu dismissing function to
                // provide for the IContextualMenuItem onRender function. Pass in a no op function instead.
                return item.onRender(item, () => undefined);
            }
            const commandButtonProps = {
                allowDisabledFocus: true,
                role: 'menuitem',
                ...item,
                styles: { root: { height: '100%' }, label: { whiteSpace: 'nowrap' }, ...item.buttonStyles },
                className: css('ms-CommandBarItem-link', item.className),
                text: !item.iconOnly ? itemText : undefined,
                menuProps: item.subMenuProps,
                onClick: this._onButtonClick(item)
            };
            if (item.iconOnly && itemText !== undefined) {
                return (createElement(TooltipHost, Object.assign({ content: itemText }, item.tooltipHostProps),
                    createElement(CommandButtonType, Object.assign({}, commandButtonProps, { defaultRender: CommandBarButton }))));
            }
            //@ts-ignore
            return createElement(CommandButtonType, Object.assign({}, commandButtonProps, { defaultRender: CommandBarButton }));
        };
        this._onRenderOverflowButton = (overflowItems) => {
            const { overflowButtonAs: OverflowButtonType = CommandBarButton, overflowButtonProps = {} // assure that props is not empty
             } = this.props;
            const combinedOverflowItems = [
                ...(overflowButtonProps.menuProps ? overflowButtonProps.menuProps.items : []),
                ...overflowItems
            ];
            const overflowProps = {
                ...overflowButtonProps,
                styles: { menuIcon: { fontSize: '17px' }, ...overflowButtonProps.styles },
                className: css('ms-CommandBar-overflowButton', overflowButtonProps.className),
                menuProps: { ...overflowButtonProps.menuProps, items: combinedOverflowItems },
                menuIconProps: { iconName: 'More', ...overflowButtonProps.menuIconProps }
            };
            return createElement(OverflowButtonType, Object.assign({}, overflowProps));
        };
        this._onReduceData = (data) => {
            const { shiftOnReduce, onDataReduced } = this.props;
            let { primaryItems, overflowItems, cacheKey } = data;
            // Use first item if shiftOnReduce, otherwise use last item
            const movedItem = primaryItems[shiftOnReduce ? 0 : primaryItems.length - 1];
            if (movedItem !== undefined) {
                movedItem.renderedInOverflow = true;
                overflowItems = [movedItem, ...overflowItems];
                primaryItems = shiftOnReduce ? primaryItems.slice(1) : primaryItems.slice(0, -1);
                const newData = { ...data, primaryItems, overflowItems };
                cacheKey = this._computeCacheKey(newData);
                if (onDataReduced) {
                    onDataReduced(movedItem);
                }
                newData.cacheKey = cacheKey;
                return newData;
            }
            return undefined;
        };
        this._onGrowData = (data) => {
            const { shiftOnReduce, onDataGrown } = this.props;
            const { minimumOverflowItems } = data;
            let { primaryItems, overflowItems, cacheKey } = data;
            const movedItem = overflowItems[0];
            // Make sure that moved item exists and is not one of the original overflow items
            if (movedItem !== undefined && overflowItems.length > minimumOverflowItems) {
                movedItem.renderedInOverflow = false;
                overflowItems = overflowItems.slice(1);
                // if shiftOnReduce, movedItem goes first, otherwise, last.
                primaryItems = shiftOnReduce ? [movedItem, ...primaryItems] : [...primaryItems, movedItem];
                const newData = { ...data, primaryItems, overflowItems };
                cacheKey = this._computeCacheKey(newData);
                if (onDataGrown) {
                    onDataGrown(movedItem);
                }
                newData.cacheKey = cacheKey;
                return newData;
            }
            return undefined;
        };
    }
    render() {
        const { className, items, overflowItems, farItems, styles, theme, onReduceData = this._onReduceData, onGrowData = this._onGrowData } = this.props;
        const commandBarData = {
            primaryItems: [...items],
            overflowItems: [...overflowItems],
            minimumOverflowItems: [...overflowItems].length,
            farItems,
            cacheKey: ''
        };
        this._classNames = getClassNames$s(styles, { theme: theme });
        return (createElement(ResizeGroup, { componentRef: this._resizeGroup, className: className, data: commandBarData, onReduceData: onReduceData, onGrowData: onGrowData, onRenderData: this._onRenderData }));
    }
    focus() {
        const { current: overflowSet } = this._overflowSet;
        overflowSet && overflowSet.focus();
    }
    remeasure() {
        this._resizeGroup.current && this._resizeGroup.current.remeasure();
    }
    _onButtonClick(item) {
        return ev => {
            // inactive is deprecated. remove check in 7.0
            if (item.inactive) {
                return;
            }
            if (item.onClick) {
                item.onClick(ev, item);
            }
        };
    }
    _computeCacheKey(data) {
        const { primaryItems, farItems = [], overflowItems } = data;
        const returnKey = (acc, current) => {
            const { cacheKey = current.key } = current;
            return acc + cacheKey;
        };
        const primaryKey = primaryItems.reduce(returnKey, '');
        const farKey = farItems.reduce(returnKey, '');
        const overflowKey = !!overflowItems.length ? 'overflow' : '';
        return [primaryKey, farKey, overflowKey].join(' ');
    }
}
CommandBarBase.defaultProps = {
    items: [],
    overflowItems: []
};

const getStyles$z = (props) => {
    const { className, theme } = props;
    const { palette } = theme;
    return {
        root: [
            theme.fonts.medium,
            'ms-CommandBar',
            {
                display: 'flex',
                backgroundColor: palette.neutralLighter,
                padding: '0 16px',
                height: '40px'
            },
            className
        ],
        primarySet: [
            'ms-CommandBar-primaryCommand',
            {
                flexGrow: '1',
                display: 'flex',
                alignItems: 'stretch'
            }
        ],
        secondarySet: [
            'ms-CommandBar-secondaryCommand',
            {
                flexShrink: '0',
                display: 'flex',
                alignItems: 'stretch'
            }
        ]
    };
};

// Create a CommandBar variant which uses these default styles and this styled subcomponent.
const CommandBar = styled(CommandBarBase, getStyles$z, undefined, {
    scope: 'CommandBar'
});

const getClassNames$t = classNamesFunction();
const DEFAULT_STRINGS = {
    months: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'],
    shortMonths: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
    days: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
    shortDays: ['S', 'M', 'T', 'W', 'T', 'F', 'S'],
    goToToday: 'Go to today',
    prevMonthAriaLabel: 'Go to previous month',
    nextMonthAriaLabel: 'Go to next month',
    prevYearAriaLabel: 'Go to previous year',
    nextYearAriaLabel: 'Go to next year',
    closeButtonAriaLabel: 'Close date picker'
};
class DatePickerBase extends BaseComponent {
    constructor(props) {
        super(props);
        this._calendar = createRef();
        this._datePickerDiv = createRef();
        this._textField = createRef();
        this._onSelectDate = (date) => {
            const { formatDate, onSelectDate } = this.props;
            if (this.props.calendarProps && this.props.calendarProps.onSelectDate) {
                this.props.calendarProps.onSelectDate(date);
            }
            this.setState({
                selectedDate: date,
                formattedDate: formatDate && date ? formatDate(date) : ''
            });
            if (onSelectDate) {
                onSelectDate(date);
            }
            this._calendarDismissed();
        };
        this._onCalloutPositioned = () => {
            if (this._calendar.current && !this.props.disableAutoFocus) {
                this._calendar.current.focus();
            }
        };
        this._onTextFieldFocus = (ev) => {
            if (this.props.disableAutoFocus) {
                return;
            }
            if (!this.props.allowTextInput) {
                if (!this._preventFocusOpeningPicker) {
                    this._showDatePickerPopup();
                }
                else {
                    this._preventFocusOpeningPicker = false;
                }
            }
        };
        this._onTextFieldBlur = (ev) => {
            this._validateTextInput();
        };
        this._onTextFieldChanged = (ev, newValue) => {
            if (this.props.allowTextInput) {
                if (this.state.isDatePickerShown) {
                    this._dismissDatePickerPopup();
                }
                const { isRequired, value, strings } = this.props;
                this.setState({
                    errorMessage: isRequired && !value ? strings.isRequiredErrorMessage || ' ' : undefined,
                    formattedDate: newValue
                });
            }
        };
        this._onTextFieldKeyDown = (ev) => {
            switch (ev.which) {
                case KeyCodes.enter:
                    ev.preventDefault();
                    ev.stopPropagation();
                    if (!this.state.isDatePickerShown) {
                        this._validateTextInput();
                        this._showDatePickerPopup();
                    }
                    else {
                        // When DatePicker allows input date string directly,
                        // it is expected to hit another enter to close the popup
                        if (this.props.allowTextInput) {
                            this._dismissDatePickerPopup();
                        }
                    }
                    break;
                case KeyCodes.escape:
                    this._handleEscKey(ev);
                    break;
                default:
                    break;
            }
        };
        this._onTextFieldClick = (ev) => {
            if (!this.state.isDatePickerShown && !this.props.disabled) {
                this._showDatePickerPopup();
            }
            else {
                if (this.props.allowTextInput) {
                    this.setState({
                        isDatePickerShown: false
                    });
                }
            }
        };
        this._onIconClick = (ev) => {
            ev.stopPropagation();
            this._onTextFieldClick(ev);
        };
        this._dismissDatePickerPopup = () => {
            if (this.state.isDatePickerShown) {
                this.setState({
                    isDatePickerShown: false
                }, () => {
                    // setState is async, so we must call validate in a callback
                    this._validateTextInput();
                });
            }
        };
        /**
         * Callback for closing the calendar callout
         */
        this._calendarDismissed = () => {
            this._preventFocusOpeningPicker = true;
            this._dismissDatePickerPopup();
            // don't need to focus the text box, if necessary the focusTrapZone will do it
        };
        this._handleEscKey = (ev) => {
            ev.stopPropagation();
            this._calendarDismissed();
        };
        this._validateTextInput = () => {
            const { isRequired, allowTextInput, strings, parseDateFromString, onSelectDate, formatDate, minDate, maxDate } = this.props;
            const inputValue = this.state.formattedDate;
            // Do validation only if DatePicker's popup is dismissed
            if (this.state.isDatePickerShown) {
                return;
            }
            if (allowTextInput) {
                let date = null;
                if (inputValue) {
                    // Don't parse if the selected date has the same formatted string as what we're about to parse.
                    // The formatted string might be ambiguous (ex: "1/2/3" or "New Year Eve") and the parser might
                    // not be able to come up with the exact same date.
                    if (this.state.selectedDate && formatDate && formatDate(this.state.selectedDate) === inputValue) {
                        date = this.state.selectedDate;
                    }
                    else {
                        date = parseDateFromString(inputValue);
                        // Check if date is null, or date is Invalid Date
                        if (!date || isNaN(date.getTime())) {
                            // Reset invalid input field, if formatting is available
                            if (formatDate) {
                                date = this.state.selectedDate;
                                this.setState({
                                    formattedDate: formatDate(date).toString()
                                });
                            }
                            this.setState({
                                errorMessage: strings.invalidInputErrorMessage || ' '
                            });
                        }
                        else {
                            // Check against optional date boundaries
                            if (this._isDateOutOfBounds(date, minDate, maxDate)) {
                                this.setState({
                                    errorMessage: strings.isOutOfBoundsErrorMessage || ' '
                                });
                            }
                            else {
                                this.setState({
                                    selectedDate: date,
                                    errorMessage: ''
                                });
                                // When formatting is available. If formatted date is valid, but is different from input, update with formatted date
                                // This occurs when an invalid date is entered twice
                                if (formatDate && formatDate(date) !== inputValue) {
                                    this.setState({
                                        formattedDate: formatDate(date).toString()
                                    });
                                }
                            }
                        }
                    }
                }
                else {
                    // Only show error for empty inputValue if it is a required field
                    this.setState({
                        errorMessage: isRequired ? strings.isRequiredErrorMessage || ' ' : ''
                    });
                }
                // Execute onSelectDate callback
                if (onSelectDate) {
                    // If no input date string or input date string is invalid
                    // date variable will be null, callback should expect null value for this case
                    onSelectDate(date);
                }
            }
            else if (isRequired && !inputValue) {
                // Check when DatePicker is a required field but has NO input value
                this.setState({
                    errorMessage: strings.isRequiredErrorMessage || ' '
                });
            }
        };
        this.state = this._getDefaultState();
        this._id = props.id || getId('DatePicker');
        this._preventFocusOpeningPicker = false;
    }
    componentWillReceiveProps(nextProps) {
        const { formatDate, isRequired, strings, value, minDate, maxDate } = nextProps;
        if (compareDates(this.props.minDate, nextProps.minDate) &&
            compareDates(this.props.maxDate, nextProps.maxDate) &&
            this.props.isRequired === nextProps.isRequired &&
            compareDates(this.state.selectedDate, value) &&
            this.props.formatDate === formatDate) {
            // if the props we care about haven't changed, don't run validation or updates
            return;
        }
        let errorMessage = isRequired && !value ? strings.isRequiredErrorMessage || ' ' : undefined;
        if (!errorMessage && value) {
            errorMessage = this._isDateOutOfBounds(value, minDate, maxDate) ? strings.isOutOfBoundsErrorMessage || ' ' : undefined;
        }
        this._id = nextProps.id || this._id;
        // Set error message
        this.setState({
            errorMessage: errorMessage
        });
        // Issue# 1274: Check if the date value changed from old value, i.e., if indeed a new date is being
        // passed in or if the formatting function was modified. We only update the selected date if either of these
        // had a legit change. Note tha the bug will still repro when only the formatDate was passed in props and this
        // is the result of the onSelectDate callback, but this should be a rare scenario.
        const oldValue = this.state.selectedDate;
        if (!compareDates(oldValue, value) || this.props.formatDate !== formatDate) {
            this.setState({
                selectedDate: value || undefined,
                formattedDate: formatDate && value ? formatDate(value) : ''
            });
        }
    }
    componentDidUpdate(prevProps, prevState) {
        if (prevState.isDatePickerShown && !this.state.isDatePickerShown) {
            // In browsers like IE, textfield gets unfocused when datepicker is collapsed
            if (this.props.allowTextInput) {
                this._async.requestAnimationFrame(() => this.focus());
            }
            // If DatePicker's menu (Calendar) is closed, run onAfterMenuDismiss
            if (this.props.onAfterMenuDismiss) {
                this.props.onAfterMenuDismiss();
            }
        }
    }
    render() {
        const { firstDayOfWeek, strings, label, theme, className, styles, initialPickerDate, isRequired, disabled, ariaLabel, pickerAriaLabel, placeholder, allowTextInput, borderless, minDate, maxDate, showCloseButton, calendarProps, calloutProps, underlined, allFocusable, calendarAs: CalendarType = Calendar, tabIndex } = this.props;
        const { isDatePickerShown, formattedDate, selectedDate, errorMessage } = this.state;
        const classNames = getClassNames$t(styles, {
            theme: theme,
            className,
            disabled,
            label: !!label,
            isDatePickerShown
        });
        const calloutId = getId('DatePicker-Callout');
        const nativeProps = getNativeProps(this.props, divProperties, ['value']);
        return (createElement("div", Object.assign({}, nativeProps, { className: classNames.root }),
            createElement("div", { ref: this._datePickerDiv, role: "combobox", "aria-expanded": isDatePickerShown, "aria-haspopup": "true", "aria-owns": calloutId },
                createElement(TextField, { id: this._id + '-label', label: label, ariaLabel: ariaLabel, "aria-controls": isDatePickerShown ? calloutId : undefined, required: isRequired, disabled: disabled, onKeyDown: this._onTextFieldKeyDown, onFocus: this._onTextFieldFocus, onBlur: this._onTextFieldBlur, onClick: this._onTextFieldClick, onChange: this._onTextFieldChanged, errorMessage: errorMessage, placeholder: placeholder, borderless: borderless, iconProps: {
                        iconName: 'Calendar',
                        onClick: this._onIconClick,
                        className: classNames.icon
                    }, readOnly: !allowTextInput, value: formattedDate, componentRef: this._textField, underlined: underlined, tabIndex: tabIndex })),
            isDatePickerShown && (createElement(Callout, Object.assign({ id: calloutId, role: "dialog", ariaLabel: pickerAriaLabel, isBeakVisible: false, gapSpace: 0, doNotLayer: false, target: this._datePickerDiv.current, directionalHint: DirectionalHint.bottomLeftEdge }, calloutProps, { className: css(classNames.callout, calloutProps && calloutProps.className), onDismiss: this._calendarDismissed, onPositioned: this._onCalloutPositioned }),
                createElement(FocusTrapZone, { isClickableOutsideFocusTrap: true, disableFirstFocus: this.props.disableAutoFocus },
                    createElement(CalendarType, Object.assign({}, calendarProps, { onSelectDate: this._onSelectDate, onDismiss: this._calendarDismissed, isMonthPickerVisible: this.props.isMonthPickerVisible, showMonthPickerAsOverlay: this.props.showMonthPickerAsOverlay, today: this.props.today, value: selectedDate || initialPickerDate, firstDayOfWeek: firstDayOfWeek, strings: strings, highlightCurrentMonth: this.props.highlightCurrentMonth, highlightSelectedMonth: this.props.highlightSelectedMonth, showWeekNumbers: this.props.showWeekNumbers, firstWeekOfYear: this.props.firstWeekOfYear, showGoToToday: this.props.showGoToToday, dateTimeFormatter: this.props.dateTimeFormatter, minDate: minDate, maxDate: maxDate, componentRef: this._calendar, showCloseButton: showCloseButton, allFocusable: allFocusable })))))));
    }
    focus() {
        if (this._textField.current) {
            this._textField.current.focus();
        }
    }
    reset() {
        this.setState(this._getDefaultState());
    }
    _showDatePickerPopup() {
        if (!this.state.isDatePickerShown) {
            this._preventFocusOpeningPicker = true;
            this.setState({
                isDatePickerShown: true,
                errorMessage: ''
            });
        }
    }
    _getDefaultState(props = this.props) {
        return {
            selectedDate: props.value || undefined,
            formattedDate: props.formatDate && props.value ? props.formatDate(props.value) : '',
            isDatePickerShown: false,
            errorMessage: undefined
        };
    }
    _isDateOutOfBounds(date, minDate, maxDate) {
        return (!!minDate && compareDatePart(minDate, date) > 0) || (!!maxDate && compareDatePart(maxDate, date) < 0);
    }
}
DatePickerBase.defaultProps = {
    allowTextInput: false,
    formatDate: (date) => {
        if (date) {
            return date.toDateString();
        }
        return '';
    },
    parseDateFromString: (dateStr) => {
        const date = Date.parse(dateStr);
        if (date) {
            return new Date(date);
        }
        return null;
    },
    firstDayOfWeek: DayOfWeek.Sunday,
    initialPickerDate: new Date(),
    isRequired: false,
    isMonthPickerVisible: true,
    showMonthPickerAsOverlay: false,
    strings: DEFAULT_STRINGS,
    highlightCurrentMonth: false,
    highlightSelectedMonth: false,
    borderless: false,
    pickerAriaLabel: 'Calendar',
    showWeekNumbers: false,
    firstWeekOfYear: FirstWeekOfYear.FirstDay,
    showGoToToday: true,
    dateTimeFormatter: undefined,
    showCloseButton: false,
    underlined: false,
    allFocusable: false
};

const GlobalClassNames$f = {
    root: 'ms-DatePicker',
    callout: 'ms-DatePicker-callout',
    withLabel: 'ms-DatePicker-event--with-label',
    withoutLabel: 'ms-DatePicker-event--without-label',
    disabled: 'msDatePickerDisabled '
};
const styles$4 = (props) => {
    const { className, theme, disabled, label, isDatePickerShown } = props;
    const { palette } = theme;
    const classNames = getGlobalClassNames(GlobalClassNames$f, theme);
    const DatePickerEvent = {
        color: palette.neutralSecondary,
        fontSize: FontSizes.icon,
        lineHeight: '18px',
        pointerEvents: 'none',
        position: 'absolute',
        right: '9px'
    };
    return {
        root: [classNames.root, theme.fonts.medium, isDatePickerShown && 'is-open', normalize, className],
        textField: [
            {
                position: 'relative',
                selectors: {
                    '& input[readonly]': {
                        cursor: 'pointer'
                    },
                    input: {
                        selectors: {
                            '::-ms-clear': {
                                display: 'none'
                            }
                        }
                    }
                }
            }
        ],
        callout: [classNames.callout],
        icon: [
            DatePickerEvent,
            !label && [classNames.withoutLabel, { top: '7px' }],
            label && [classNames.withLabel, { bottom: '5px' }],
            !disabled && [
                classNames.disabled,
                {
                    pointerEvents: 'initial',
                    cursor: 'pointer'
                }
            ]
        ]
    };
};

/**
 * DatePicker description
 */
const DatePicker = styled(DatePickerBase, styles$4, undefined, {
    scope: 'DatePicker'
});

const SELECTION_CHANGE = 'change';
var SelectionMode;
(function (SelectionMode) {
    SelectionMode[SelectionMode["none"] = 0] = "none";
    SelectionMode[SelectionMode["single"] = 1] = "single";
    SelectionMode[SelectionMode["multiple"] = 2] = "multiple";
})(SelectionMode || (SelectionMode = {}));
var SelectionDirection;
(function (SelectionDirection) {
    SelectionDirection[SelectionDirection["horizontal"] = 0] = "horizontal";
    SelectionDirection[SelectionDirection["vertical"] = 1] = "vertical";
})(SelectionDirection || (SelectionDirection = {}));

class Selection {
    constructor(options = {}) {
        const { onSelectionChanged, getKey, canSelectItem = (item) => true, selectionMode = SelectionMode.multiple } = options;
        this.mode = selectionMode;
        this._getKey = getKey || defaultGetKey;
        this._changeEventSuppressionCount = 0;
        this._exemptedCount = 0;
        this._anchoredIndex = 0;
        this._unselectableCount = 0;
        this._onSelectionChanged = onSelectionChanged;
        this._canSelectItem = canSelectItem;
        this._isModal = false;
        this.setItems([], true);
    }
    canSelectItem(item, index) {
        if (typeof index === 'number' && index < 0) {
            return false;
        }
        return this._canSelectItem(item, index);
    }
    getKey(item, index) {
        const key = this._getKey(item, index);
        return typeof key === 'number' || key ? `${key}` : '';
    }
    setChangeEvents(isEnabled, suppressChange) {
        this._changeEventSuppressionCount += isEnabled ? -1 : 1;
        if (this._changeEventSuppressionCount === 0 && this._hasChanged) {
            this._hasChanged = false;
            if (!suppressChange) {
                this._change();
            }
        }
    }
    isModal() {
        return this._isModal;
    }
    setModal(isModal) {
        if (this._isModal !== isModal) {
            this.setChangeEvents(false);
            this._isModal = isModal;
            if (!isModal) {
                this.setAllSelected(false);
            }
            this._change();
            this.setChangeEvents(true);
        }
    }
    /**
     * Selection needs the items, call this method to set them. If the set
     * of items is the same, this will re-evaluate selection and index maps.
     * Otherwise, shouldClear should be set to true, so that selection is
     * cleared.
     */
    setItems(items, shouldClear = true) {
        const newKeyToIndexMap = {};
        const newUnselectableIndices = {};
        let hasSelectionChanged = false;
        this.setChangeEvents(false);
        // Reset the unselectable count.
        this._unselectableCount = 0;
        // Build lookup table for quick selection evaluation.
        for (let i = 0; i < items.length; i++) {
            const item = items[i];
            if (item) {
                const key = this.getKey(item, i);
                if (key) {
                    newKeyToIndexMap[key] = i;
                }
            }
            newUnselectableIndices[i] = item && !this.canSelectItem(item);
            if (newUnselectableIndices[i]) {
                this._unselectableCount++;
            }
        }
        if (shouldClear || items.length === 0) {
            this.setAllSelected(false);
        }
        // Check the exemption list for discrepencies.
        const newExemptedIndicies = {};
        let newExemptedCount = 0;
        for (const indexProperty in this._exemptedIndices) {
            if (this._exemptedIndices.hasOwnProperty(indexProperty)) {
                const index = Number(indexProperty);
                const item = this._items[index];
                const exemptKey = item ? this.getKey(item, Number(index)) : undefined;
                const newIndex = exemptKey ? newKeyToIndexMap[exemptKey] : index;
                if (newIndex === undefined) {
                    // The item has likely been replaced or removed.
                    hasSelectionChanged = true;
                }
                else {
                    // We know the new index of the item. update the existing exemption table.
                    newExemptedIndicies[newIndex] = true;
                    newExemptedCount++;
                    hasSelectionChanged = hasSelectionChanged || newIndex !== index;
                }
            }
        }
        if (this._items && this._exemptedCount === 0 && items.length !== this._items.length && this._isAllSelected) {
            // If everything was selected but the number of items has changed, selection has changed.
            hasSelectionChanged = true;
        }
        this._exemptedIndices = newExemptedIndicies;
        this._exemptedCount = newExemptedCount;
        this._keyToIndexMap = newKeyToIndexMap;
        this._unselectableIndices = newUnselectableIndices;
        this._items = items;
        this._selectedItems = null;
        if (hasSelectionChanged) {
            this._updateCount();
            this._change();
        }
        this.setChangeEvents(true);
    }
    getItems() {
        return this._items;
    }
    getSelection() {
        if (!this._selectedItems) {
            this._selectedItems = [];
            const items = this._items;
            if (items) {
                for (let i = 0; i < items.length; i++) {
                    if (this.isIndexSelected(i)) {
                        this._selectedItems.push(items[i]);
                    }
                }
            }
        }
        return this._selectedItems;
    }
    getSelectedCount() {
        return this._isAllSelected ? this._items.length - this._exemptedCount - this._unselectableCount : this._exemptedCount;
    }
    getSelectedIndices() {
        if (!this._selectedIndices) {
            this._selectedIndices = [];
            const items = this._items;
            if (items) {
                for (let i = 0; i < items.length; i++) {
                    if (this.isIndexSelected(i)) {
                        this._selectedIndices.push(i);
                    }
                }
            }
        }
        return this._selectedIndices;
    }
    isRangeSelected(fromIndex, count) {
        if (count === 0) {
            return false;
        }
        const endIndex = fromIndex + count;
        for (let i = fromIndex; i < endIndex; i++) {
            if (!this.isIndexSelected(i)) {
                return false;
            }
        }
        return true;
    }
    isAllSelected() {
        let selectableCount = this._items.length - this._unselectableCount;
        // In single mode, we can only have a max of 1 item.
        if (this.mode === SelectionMode.single) {
            selectableCount = Math.min(selectableCount, 1);
        }
        return ((this.count > 0 && (this._isAllSelected && this._exemptedCount === 0)) ||
            (!this._isAllSelected && this._exemptedCount === selectableCount && selectableCount > 0));
    }
    isKeySelected(key) {
        const index = this._keyToIndexMap[key];
        return this.isIndexSelected(index);
    }
    isIndexSelected(index) {
        return !!((this.count > 0 && (this._isAllSelected && !this._exemptedIndices[index] && !this._unselectableIndices[index])) ||
            (!this._isAllSelected && this._exemptedIndices[index]));
    }
    setAllSelected(isAllSelected) {
        if (isAllSelected && this.mode !== SelectionMode.multiple) {
            return;
        }
        const selectableCount = this._items ? this._items.length - this._unselectableCount : 0;
        this.setChangeEvents(false);
        if (selectableCount > 0 && (this._exemptedCount > 0 || isAllSelected !== this._isAllSelected)) {
            this._exemptedIndices = {};
            if (isAllSelected !== this._isAllSelected || this._exemptedCount > 0) {
                this._exemptedCount = 0;
                this._isAllSelected = isAllSelected;
                this._change();
            }
            this._updateCount();
        }
        this.setChangeEvents(true);
    }
    setKeySelected(key, isSelected, shouldAnchor) {
        const index = this._keyToIndexMap[key];
        if (index >= 0) {
            this.setIndexSelected(index, isSelected, shouldAnchor);
        }
    }
    setIndexSelected(index, isSelected, shouldAnchor) {
        if (this.mode === SelectionMode.none) {
            return;
        }
        // Clamp the index.
        index = Math.min(Math.max(0, index), this._items.length - 1);
        // No-op on out of bounds selections.
        if (index < 0 || index >= this._items.length) {
            return;
        }
        this.setChangeEvents(false);
        const isExempt = this._exemptedIndices[index];
        const canSelect = !this._unselectableIndices[index];
        if (canSelect) {
            if (isSelected && this.mode === SelectionMode.single) {
                // If this is single-select, the previous selection should be removed.
                this.setAllSelected(false);
            }
            // Determine if we need to remove the exemption.
            if (isExempt && ((isSelected && this._isAllSelected) || (!isSelected && !this._isAllSelected))) {
                delete this._exemptedIndices[index];
                this._exemptedCount--;
            }
            // Determine if we need to add the exemption.
            if (!isExempt && ((isSelected && !this._isAllSelected) || (!isSelected && this._isAllSelected))) {
                this._exemptedIndices[index] = true;
                this._exemptedCount++;
            }
            if (shouldAnchor) {
                this._anchoredIndex = index;
            }
        }
        this._updateCount();
        this.setChangeEvents(true);
    }
    selectToKey(key, clearSelection) {
        this.selectToIndex(this._keyToIndexMap[key], clearSelection);
    }
    selectToIndex(index, clearSelection) {
        if (this.mode === SelectionMode.none) {
            return;
        }
        if (this.mode === SelectionMode.single) {
            this.setIndexSelected(index, true, true);
            return;
        }
        const anchorIndex = this._anchoredIndex || 0;
        let startIndex = Math.min(index, anchorIndex);
        const endIndex = Math.max(index, anchorIndex);
        this.setChangeEvents(false);
        if (clearSelection) {
            this.setAllSelected(false);
        }
        for (; startIndex <= endIndex; startIndex++) {
            this.setIndexSelected(startIndex, true, false);
        }
        this.setChangeEvents(true);
    }
    toggleAllSelected() {
        this.setAllSelected(!this.isAllSelected());
    }
    toggleKeySelected(key) {
        this.setKeySelected(key, !this.isKeySelected(key), true);
    }
    toggleIndexSelected(index) {
        this.setIndexSelected(index, !this.isIndexSelected(index), true);
    }
    toggleRangeSelected(fromIndex, count) {
        if (this.mode === SelectionMode.none) {
            return;
        }
        const isRangeSelected = this.isRangeSelected(fromIndex, count);
        const endIndex = fromIndex + count;
        if (this.mode === SelectionMode.single && count > 1) {
            return;
        }
        this.setChangeEvents(false);
        for (let i = fromIndex; i < endIndex; i++) {
            this.setIndexSelected(i, !isRangeSelected, false);
        }
        this.setChangeEvents(true);
    }
    _updateCount() {
        const count = this.getSelectedCount();
        if (count !== this.count) {
            this.count = count;
            this._change();
        }
        if (!this.count) {
            this.setModal(false);
        }
    }
    _change() {
        if (this._changeEventSuppressionCount === 0) {
            this._selectedItems = null;
            this._selectedIndices = undefined;
            EventGroup.raise(this, SELECTION_CHANGE);
            if (this._onSelectionChanged) {
                this._onSelectionChanged();
            }
        }
        else {
            this._hasChanged = true;
        }
    }
}
function defaultGetKey(item, index) {
    return item && item.key ? item.key : `${index}`;
}

// Selection definitions:
//
// Anchor index: the point from which a range selection starts.
// Focus index: the point from which layout movement originates from.
//
// These two can differ. Tests:
//
// If you start at index 5
// Shift click to index 10
//    The focus is 10, the anchor is 5.
// If you shift click at index 0
//    The anchor remains at 5, the items between 0 and 5 are selected and everything else is cleared.
// If you click index 8
//    The anchor and focus are set to 8.
const SELECTION_DISABLED_ATTRIBUTE_NAME = 'data-selection-disabled';
const SELECTION_INDEX_ATTRIBUTE_NAME = 'data-selection-index';
const SELECTION_TOGGLE_ATTRIBUTE_NAME = 'data-selection-toggle';
const SELECTION_INVOKE_ATTRIBUTE_NAME = 'data-selection-invoke';
const SELECTALL_TOGGLE_ALL_ATTRIBUTE_NAME = 'data-selection-all-toggle';
const SELECTION_SELECT_ATTRIBUTE_NAME = 'data-selection-select';
class SelectionZone extends BaseComponent {
    constructor() {
        super(...arguments);
        this._root = createRef$1();
        /**
         * In some cases, the consuming scenario requires to set focus on a row without having SelectionZone
         * react to the event. Note that focus events in IE \<= 11 will occur asynchronously after .focus() has
         * been called on an element, so we need a flag to store the idea that we will bypass the "next"
         * focus event that occurs. This method does that.
         */
        this.ignoreNextFocus = () => {
            this._handleNextFocus(false);
        };
        this._onMouseDownCapture = (ev) => {
            if (document.activeElement !== ev.target && !elementContains(document.activeElement, ev.target)) {
                this.ignoreNextFocus();
                return;
            }
            if (!elementContains(ev.target, this._root.current)) {
                return;
            }
            let target = ev.target;
            while (target !== this._root.current) {
                if (this._hasAttribute(target, SELECTION_INVOKE_ATTRIBUTE_NAME)) {
                    this.ignoreNextFocus();
                    break;
                }
                target = getParent(target);
            }
        };
        /**
         * When we focus an item, for single/multi select scenarios, we should try to select it immediately
         * as long as the focus did not originate from a mouse down/touch event. For those cases, we handle them
         * specially.
         */
        this._onFocus = (ev) => {
            const target = ev.target;
            const { selection } = this.props;
            const isToggleModifierPressed = this._isCtrlPressed || this._isMetaPressed;
            const selectionMode = this._getSelectionMode();
            if (this._shouldHandleFocus && selectionMode !== SelectionMode.none) {
                const isToggle = this._hasAttribute(target, SELECTION_TOGGLE_ATTRIBUTE_NAME);
                const itemRoot = this._findItemRoot(target);
                if (!isToggle && itemRoot) {
                    const index = this._getItemIndex(itemRoot);
                    if (isToggleModifierPressed) {
                        // set anchor only.
                        selection.setIndexSelected(index, selection.isIndexSelected(index), true);
                        if (this.props.enterModalOnTouch && this._isTouch && selection.setModal) {
                            selection.setModal(true);
                            this._setIsTouch(false);
                        }
                    }
                    else {
                        if (this.props.isSelectedOnFocus) {
                            this._onItemSurfaceClick(ev, index);
                        }
                    }
                }
            }
            this._handleNextFocus(false);
        };
        this._onMouseDown = (ev) => {
            this._updateModifiers(ev);
            let target = ev.target;
            const itemRoot = this._findItemRoot(target);
            // No-op if selection is disabled
            if (this._isSelectionDisabled(target)) {
                return;
            }
            while (target !== this._root.current) {
                if (this._hasAttribute(target, SELECTALL_TOGGLE_ALL_ATTRIBUTE_NAME)) {
                    break;
                }
                else if (itemRoot) {
                    if (this._hasAttribute(target, SELECTION_TOGGLE_ATTRIBUTE_NAME)) {
                        break;
                    }
                    else if (this._hasAttribute(target, SELECTION_INVOKE_ATTRIBUTE_NAME)) {
                        break;
                    }
                    else if ((target === itemRoot || this._shouldAutoSelect(target)) &&
                        !this._isShiftPressed &&
                        !this._isCtrlPressed &&
                        !this._isMetaPressed) {
                        this._onInvokeMouseDown(ev, this._getItemIndex(itemRoot));
                        break;
                    }
                    else if (this.props.disableAutoSelectOnInputElements &&
                        (target.tagName === 'A' || target.tagName === 'BUTTON' || target.tagName === 'INPUT')) {
                        return;
                    }
                }
                target = getParent(target);
            }
        };
        this._onTouchStartCapture = (ev) => {
            this._setIsTouch(true);
        };
        this._onClick = (ev) => {
            this._updateModifiers(ev);
            let target = ev.target;
            const itemRoot = this._findItemRoot(target);
            // No-op if selection is disabled
            if (this._isSelectionDisabled(target)) {
                return;
            }
            while (target !== this._root.current) {
                if (this._hasAttribute(target, SELECTALL_TOGGLE_ALL_ATTRIBUTE_NAME)) {
                    this._onToggleAllClick(ev);
                    break;
                }
                else if (itemRoot) {
                    const index = this._getItemIndex(itemRoot);
                    if (this._hasAttribute(target, SELECTION_TOGGLE_ATTRIBUTE_NAME)) {
                        if (this._isShiftPressed) {
                            this._onItemSurfaceClick(ev, index);
                        }
                        else {
                            this._onToggleClick(ev, index);
                        }
                        break;
                    }
                    else if (this._hasAttribute(target, SELECTION_INVOKE_ATTRIBUTE_NAME)) {
                        this._onInvokeClick(ev, index);
                        break;
                    }
                    else if (target === itemRoot) {
                        this._onItemSurfaceClick(ev, index);
                        break;
                    }
                    else if (target.tagName === 'A' || target.tagName === 'BUTTON' || target.tagName === 'INPUT') {
                        return;
                    }
                }
                target = getParent(target);
            }
        };
        this._onContextMenu = (ev) => {
            const target = ev.target;
            const { onItemContextMenu, selection } = this.props;
            if (onItemContextMenu) {
                const itemRoot = this._findItemRoot(target);
                if (itemRoot) {
                    const index = this._getItemIndex(itemRoot);
                    this._onInvokeMouseDown(ev, index);
                    const skipPreventDefault = onItemContextMenu(selection.getItems()[index], index, ev.nativeEvent);
                    // In order to keep back compat, if the value here is undefined, then we should still
                    // call preventDefault(). Only in the case where true is explicitly returned should
                    // the call be skipped.
                    if (!skipPreventDefault) {
                        ev.preventDefault();
                    }
                }
            }
        };
        /**
         * In multi selection, if you double click within an item's root (but not within the invoke element or input elements),
         * we should execute the invoke handler.
         */
        this._onDoubleClick = (ev) => {
            let target = ev.target;
            if (this._isSelectionDisabled(target)) {
                return;
            }
            const { onItemInvoked } = this.props;
            const itemRoot = this._findItemRoot(target);
            const selectionMode = this._getSelectionMode();
            if (itemRoot && onItemInvoked && selectionMode !== SelectionMode.none && !this._isInputElement(target)) {
                const index = this._getItemIndex(itemRoot);
                while (target !== this._root.current) {
                    if (this._hasAttribute(target, SELECTION_TOGGLE_ATTRIBUTE_NAME) || this._hasAttribute(target, SELECTION_INVOKE_ATTRIBUTE_NAME)) {
                        break;
                    }
                    else if (target === itemRoot) {
                        this._onInvokeClick(ev, index);
                        break;
                    }
                    target = getParent(target);
                }
                target = getParent(target);
            }
        };
        this._onKeyDownCapture = (ev) => {
            this._updateModifiers(ev);
            this._handleNextFocus(true);
        };
        this._onKeyDown = (ev) => {
            this._updateModifiers(ev);
            let target = ev.target;
            if (this._isSelectionDisabled(target)) {
                return;
            }
            const { selection } = this.props;
            const isSelectAllKey = ev.which === KeyCodes.a && (this._isCtrlPressed || this._isMetaPressed);
            const isClearSelectionKey = ev.which === KeyCodes.escape;
            // Ignore key downs from input elements.
            if (this._isInputElement(target)) {
                // A key was pressed while an item in this zone was focused.
                return;
            }
            const selectionMode = this._getSelectionMode();
            // If ctrl-a is pressed, select all (if all are not already selected.)
            if (isSelectAllKey && selectionMode === SelectionMode.multiple && !selection.isAllSelected()) {
                selection.setAllSelected(true);
                ev.stopPropagation();
                ev.preventDefault();
                return;
            }
            // If escape is pressed, clear selection (if any are selected.)
            if (isClearSelectionKey && selection.getSelectedCount() > 0) {
                selection.setAllSelected(false);
                ev.stopPropagation();
                ev.preventDefault();
                return;
            }
            const itemRoot = this._findItemRoot(target);
            // If a key was pressed within an item, we should treat "enters" as invokes and "space" as toggle
            if (itemRoot) {
                const index = this._getItemIndex(itemRoot);
                while (target !== this._root.current) {
                    if (this._hasAttribute(target, SELECTION_TOGGLE_ATTRIBUTE_NAME)) {
                        // For toggle elements, assuming they are rendered as buttons, they will generate a click event,
                        // so we can no-op for any keydowns in this case.
                        break;
                    }
                    else if (this._shouldAutoSelect(target)) {
                        // If the event went to an element which should trigger auto-select, select it and then let
                        // the default behavior kick in.
                        this._onInvokeMouseDown(ev, index);
                        break;
                    }
                    else if ((ev.which === KeyCodes.enter || ev.which === KeyCodes.space) &&
                        (target.tagName === 'BUTTON' || target.tagName === 'A' || target.tagName === 'INPUT')) {
                        return false;
                    }
                    else if (target === itemRoot) {
                        if (ev.which === KeyCodes.enter) {
                            this._onInvokeClick(ev, index);
                            ev.preventDefault();
                            return;
                        }
                        else if (ev.which === KeyCodes.space) {
                            this._onToggleClick(ev, index);
                            ev.preventDefault();
                            return;
                        }
                        break;
                    }
                    target = getParent(target);
                }
            }
        };
    }
    componentDidMount() {
        const win = getWindow(this._root.current);
        const scrollElement = findScrollableParent(this._root.current);
        // Track the latest modifier keys globally.
        this._events.on(win, 'keydown, keyup', this._updateModifiers, true);
        this._events.on(scrollElement, 'click', this._tryClearOnEmptyClick);
        this._events.on(document.body, 'touchstart', this._onTouchStartCapture, true);
        this._events.on(document.body, 'touchend', this._onTouchStartCapture, true);
    }
    render() {
        return (createElement("div", Object.assign({ className: "ms-SelectionZone", ref: this._root, onKeyDown: this._onKeyDown, onMouseDown: this._onMouseDown, onKeyDownCapture: this._onKeyDownCapture, onClick: this._onClick, role: "presentation", onDoubleClick: this._onDoubleClick, onContextMenu: this._onContextMenu }, {
            onMouseDownCapture: this._onMouseDownCapture,
            onFocusCapture: this._onFocus
        }), this.props.children));
    }
    _isSelectionDisabled(target) {
        while (target !== this._root.current) {
            if (this._hasAttribute(target, SELECTION_DISABLED_ATTRIBUTE_NAME)) {
                return true;
            }
            target = getParent(target);
        }
        return false;
    }
    _onToggleAllClick(ev) {
        const { selection } = this.props;
        const selectionMode = this._getSelectionMode();
        if (selectionMode === SelectionMode.multiple) {
            selection.toggleAllSelected();
            ev.stopPropagation();
            ev.preventDefault();
        }
    }
    _onToggleClick(ev, index) {
        const { selection } = this.props;
        const selectionMode = this._getSelectionMode();
        selection.setChangeEvents(false);
        if (this.props.enterModalOnTouch && this._isTouch && !selection.isIndexSelected(index) && selection.setModal) {
            selection.setModal(true);
            this._setIsTouch(false);
        }
        if (selectionMode === SelectionMode.multiple) {
            selection.toggleIndexSelected(index);
        }
        else if (selectionMode === SelectionMode.single) {
            const isSelected = selection.isIndexSelected(index);
            selection.setAllSelected(false);
            selection.setIndexSelected(index, !isSelected, true);
        }
        else {
            selection.setChangeEvents(true);
            return;
        }
        selection.setChangeEvents(true);
        ev.stopPropagation();
        // NOTE: ev.preventDefault is not called for toggle clicks, because this will kill the browser behavior
        // for checkboxes if you use a checkbox for the toggle.
    }
    _onInvokeClick(ev, index) {
        const { selection, onItemInvoked } = this.props;
        if (onItemInvoked) {
            onItemInvoked(selection.getItems()[index], index, ev.nativeEvent);
            ev.preventDefault();
            ev.stopPropagation();
        }
    }
    _onItemSurfaceClick(ev, index) {
        const { selection } = this.props;
        const isToggleModifierPressed = this._isCtrlPressed || this._isMetaPressed;
        const selectionMode = this._getSelectionMode();
        if (selectionMode === SelectionMode.multiple) {
            if (this._isShiftPressed && !this._isTabPressed) {
                selection.selectToIndex(index, !isToggleModifierPressed);
            }
            else if (isToggleModifierPressed) {
                selection.toggleIndexSelected(index);
            }
            else {
                this._clearAndSelectIndex(index);
            }
        }
        else if (selectionMode === SelectionMode.single) {
            this._clearAndSelectIndex(index);
        }
    }
    _onInvokeMouseDown(ev, index) {
        const { selection } = this.props;
        // Only do work if item is not selected.
        if (selection.isIndexSelected(index)) {
            return;
        }
        this._clearAndSelectIndex(index);
    }
    _tryClearOnEmptyClick(ev) {
        if (!this.props.selectionPreservedOnEmptyClick && this._isNonHandledClick(ev.target)) {
            this.props.selection.setAllSelected(false);
        }
    }
    _clearAndSelectIndex(index) {
        const { selection } = this.props;
        const isAlreadySingleSelected = selection.getSelectedCount() === 1 && selection.isIndexSelected(index);
        if (!isAlreadySingleSelected) {
            selection.setChangeEvents(false);
            selection.setAllSelected(false);
            selection.setIndexSelected(index, true, true);
            if (this.props.enterModalOnTouch && this._isTouch && selection.setModal) {
                selection.setModal(true);
                this._setIsTouch(false);
            }
            selection.setChangeEvents(true);
        }
    }
    /**
     * We need to track the modifier key states so that when focus events occur, which do not contain
     * modifier states in the Event object, we know how to behave.
     */
    _updateModifiers(ev) {
        this._isShiftPressed = ev.shiftKey;
        this._isCtrlPressed = ev.ctrlKey;
        this._isMetaPressed = ev.metaKey;
        const keyCode = ev.keyCode;
        this._isTabPressed = keyCode ? keyCode === KeyCodes.tab : false;
    }
    _findItemRoot(target) {
        const { selection } = this.props;
        while (target !== this._root.current) {
            const indexValue = target.getAttribute(SELECTION_INDEX_ATTRIBUTE_NAME);
            const index = Number(indexValue);
            if (indexValue !== null && index >= 0 && index < selection.getItems().length) {
                break;
            }
            target = getParent(target);
        }
        if (target === this._root.current) {
            return undefined;
        }
        return target;
    }
    _getItemIndex(itemRoot) {
        return Number(itemRoot.getAttribute(SELECTION_INDEX_ATTRIBUTE_NAME));
    }
    _shouldAutoSelect(element) {
        return this._hasAttribute(element, SELECTION_SELECT_ATTRIBUTE_NAME);
    }
    _hasAttribute(element, attributeName) {
        let isToggle = false;
        while (!isToggle && element !== this._root.current) {
            isToggle = element.getAttribute(attributeName) === 'true';
            element = getParent(element);
        }
        return isToggle;
    }
    _isInputElement(element) {
        return element.tagName === 'INPUT' || element.tagName === 'TEXTAREA';
    }
    _isNonHandledClick(element) {
        const doc = getDocument();
        if (doc && element) {
            while (element && element !== doc.documentElement) {
                if (isElementTabbable(element)) {
                    return false;
                }
                element = getParent(element);
            }
        }
        return true;
    }
    _handleNextFocus(handleFocus) {
        if (this._shouldHandleFocusTimeoutId) {
            this._async.clearTimeout(this._shouldHandleFocusTimeoutId);
            this._shouldHandleFocusTimeoutId = undefined;
        }
        this._shouldHandleFocus = handleFocus;
        if (handleFocus) {
            this._async.setTimeout(() => {
                this._shouldHandleFocus = false;
            }, 100);
        }
    }
    _setIsTouch(isTouch) {
        if (this._isTouchTimeoutId) {
            this._async.clearTimeout(this._isTouchTimeoutId);
            this._isTouchTimeoutId = undefined;
        }
        this._isTouch = true;
        if (isTouch) {
            this._async.setTimeout(() => {
                this._isTouch = false;
            }, 300);
        }
    }
    _getSelectionMode() {
        const { selection } = this.props;
        const { selectionMode = selection ? selection.mode : SelectionMode.none } = this.props;
        return selectionMode;
    }
}
SelectionZone.defaultProps = {
    isMultiSelectEnabled: true,
    isSelectedOnFocus: true,
    selectionMode: SelectionMode.multiple
};

var CollapseAllVisibility;
(function (CollapseAllVisibility) {
    CollapseAllVisibility[CollapseAllVisibility["hidden"] = 0] = "hidden";
    CollapseAllVisibility[CollapseAllVisibility["visible"] = 1] = "visible";
})(CollapseAllVisibility || (CollapseAllVisibility = {}));

/**
 * Enum to describe how a particular column header behaves.... This enum is used to
 * to specify the property IColumn:columnActionsMode.
 * If IColumn:columnActionsMode is undefined, then it's equivalent to ColumnActionsMode.clickable
 */
var ColumnActionsMode;
(function (ColumnActionsMode) {
    /**
     * Renders the column header as disabled.
     */
    ColumnActionsMode[ColumnActionsMode["disabled"] = 0] = "disabled";
    /**
     * Renders the column header is clickable.
     */
    ColumnActionsMode[ColumnActionsMode["clickable"] = 1] = "clickable";
    /**
     * Renders the column header ias clickable and displays the dropdown cheveron.
     */
    ColumnActionsMode[ColumnActionsMode["hasDropdown"] = 2] = "hasDropdown";
})(ColumnActionsMode || (ColumnActionsMode = {}));
var ConstrainMode;
(function (ConstrainMode) {
    /** If specified, lets the content grow which allows the page to manage scrolling. */
    ConstrainMode[ConstrainMode["unconstrained"] = 0] = "unconstrained";
    /**
     * If specified, constrains the list to the given layout space.
     */
    ConstrainMode[ConstrainMode["horizontalConstrained"] = 1] = "horizontalConstrained";
})(ConstrainMode || (ConstrainMode = {}));
/**
 * Enum to describe where the column has been dropped, after starting the drag
 */
var ColumnDragEndLocation;
(function (ColumnDragEndLocation) {
    /**
     * Drag ended outside of current list
     */
    ColumnDragEndLocation[ColumnDragEndLocation["outside"] = 0] = "outside";
    /**
     * Drag ended on current List
     */
    ColumnDragEndLocation[ColumnDragEndLocation["surface"] = 1] = "surface";
    /**
     * Drag ended on Header
     */
    ColumnDragEndLocation[ColumnDragEndLocation["header"] = 2] = "header";
})(ColumnDragEndLocation || (ColumnDragEndLocation = {}));
var DetailsListLayoutMode;
(function (DetailsListLayoutMode) {
    /**
     * Lets the user resize columns and makes not attempt to fit them.
     */
    DetailsListLayoutMode[DetailsListLayoutMode["fixedColumns"] = 0] = "fixedColumns";
    /**
     * Manages which columns are visible, tries to size them according to their min/max rules and drops
     * off columns that can't fit and have isCollapsible set.
     */
    DetailsListLayoutMode[DetailsListLayoutMode["justified"] = 1] = "justified";
})(DetailsListLayoutMode || (DetailsListLayoutMode = {}));
var CheckboxVisibility;
(function (CheckboxVisibility) {
    /**
     * Visible on hover.
     */
    CheckboxVisibility[CheckboxVisibility["onHover"] = 0] = "onHover";
    /**
     * Visible always.
     */
    CheckboxVisibility[CheckboxVisibility["always"] = 1] = "always";
    /**
     * Hide checkboxes.
     */
    CheckboxVisibility[CheckboxVisibility["hidden"] = 2] = "hidden";
})(CheckboxVisibility || (CheckboxVisibility = {}));

const GlobalClassNames$g = {
    root: 'ms-GroupSpacer'
};
const getStyles$A = (props) => {
    const { theme } = props;
    const classNames = getGlobalClassNames(GlobalClassNames$g, theme);
    return {
        root: [classNames.root, theme.fonts.medium, { display: 'inline-block' }]
    };
};

const getClassNames$u = classNamesFunction();
const SPACER_WIDTH = 32;
const GroupSpacer = styled((props) => {
    const { count, styles, theme, indentWidth = SPACER_WIDTH } = props;
    const classNames = getClassNames$u(styles, {
        theme: theme
    });
    return count > 0 ? createElement("span", { className: classNames.root, style: { width: count * indentWidth } }) : null;
}, getStyles$A, undefined, { scope: 'GroupSpacer' });

const GlobalClassNames$h = {
    root: 'ms-GroupedList',
    compact: 'ms-GroupedList--Compact',
    group: 'ms-GroupedList-group',
    link: 'ms-Link',
    listCell: 'ms-List-cell'
};
const beziers = {
    easeInOutSine: 'cubic-bezier(0.445, 0.050, 0.550, 0.950)'
};
const getStyles$B = (props) => {
    const { theme, className, compact } = props;
    const { palette } = theme;
    const classNames = getGlobalClassNames(GlobalClassNames$h, theme);
    return {
        root: [
            classNames.root,
            theme.fonts.medium,
            {
                position: 'relative',
                fontSize: FontSizes.small,
                selectors: {
                    [`.${classNames.listCell}`]: {
                        minHeight: 38 // be consistent with DetailsList styles
                    }
                }
            },
            compact && [
                classNames.compact,
                {
                    selectors: {
                        [`.${classNames.listCell}`]: {
                            minHeight: 32 // be consistent with DetailsList styles
                        }
                    }
                }
            ],
            className
        ],
        group: [
            classNames.group,
            {
                transition: `background-color ${AnimationVariables.durationValue2} ${beziers.easeInOutSine}`
            }
        ],
        groupIsDropping: [
            {
                backgroundColor: palette.neutralLight
            }
        ]
    };
};

const GlobalClassNames$i = {
    root: 'ms-DetailsRow',
    compact: 'ms-DetailsList--Compact',
    cell: 'ms-DetailsRow-cell',
    cellCheck: 'ms-DetailsRow-cellCheck',
    cellMeasurer: 'ms-DetailsRow-cellMeasurer',
    listCellFirstChild: 'ms-List-cell:first-child',
    isFocusable: "[data-is-focusable='true']",
    isContentUnselectable: 'is-contentUnselectable',
    isSelected: 'is-selected',
    isCheckVisible: 'is-check-visible',
    fields: 'ms-DetailsRow-fields'
};
const DEFAULT_CELL_STYLE_PROPS = {
    cellLeftPadding: 12,
    cellRightPadding: 8,
    cellExtraRightPadding: 24
};
// Source of default row heights to share.
const DEFAULT_ROW_HEIGHTS = {
    rowHeight: 42,
    compactRowHeight: 32
};
// Constant values
let values$1 = {
    ...DEFAULT_ROW_HEIGHTS,
    rowVerticalPadding: 11,
    compactRowVerticalPadding: 6,
    rowShimmerLineHeight: 7,
    rowShimmerIconPlaceholderHeight: 16,
    rowShimmerVerticalBorder: 0,
    compactRowShimmerVerticalBorder: 0
};
// Computed Values
values$1 = {
    ...values$1,
    ...{
        rowShimmerVerticalBorder: (values$1.rowHeight - values$1.rowShimmerLineHeight) / 2,
        compactRowShimmerVerticalBorder: (values$1.compactRowHeight - values$1.rowShimmerLineHeight) / 2
    }
};
const getStyles$C = (props) => {
    const { theme, isSelected, canSelect, droppingClassName, anySelected, isCheckVisible, checkboxCellClassName, compact, className, cellStyleProps = DEFAULT_CELL_STYLE_PROPS } = props;
    const { neutralPrimary, white, neutralSecondary, neutralLighter, neutralLight, neutralDark, neutralQuaternaryAlt, black } = theme.palette;
    const { focusBorder } = theme.semanticColors;
    const classNames = getGlobalClassNames(GlobalClassNames$i, theme);
    const colors = {
        // Default
        defaultHeaderTextColor: neutralPrimary,
        defaultMetaTextColor: neutralSecondary,
        defaultBackgroundColor: white,
        // Hover
        hoverTextColor: neutralPrimary,
        hoverColorBackground: neutralLighter,
        // Selected
        selectedTextColor: neutralDark,
        selectedMetaTextColor: neutralPrimary,
        selectedBackgroundColor: neutralLight,
        // Selected Hover
        selectedHoverTextColor: black,
        selectedHoverMetaTextColor: neutralDark,
        selectedHoverBackgroundColor: neutralQuaternaryAlt,
        // Focus
        focusHeaderTextColor: black,
        focusBackgroundColor: neutralQuaternaryAlt,
        focusMetaTextColor: neutralDark
    };
    const shimmerRightBorderStyle = `${cellStyleProps.cellRightPadding * 4}px solid ${colors.defaultBackgroundColor}`;
    const shimmerLeftBorderStyle = `${cellStyleProps.cellLeftPadding}px solid ${colors.defaultBackgroundColor}`;
    const selectedStyles = [
        getFocusStyle(theme, -1, undefined, undefined, focusBorder, white),
        classNames.isSelected,
        {
            color: colors.selectedMetaTextColor,
            background: colors.selectedBackgroundColor,
            borderBottom: `1px solid ${white}`,
            selectors: {
                '&:before': {
                    position: 'absolute',
                    display: 'block',
                    top: -1,
                    height: 1,
                    bottom: 0,
                    left: 0,
                    right: 0,
                    content: '',
                    borderTop: `1px solid ${white}`
                },
                // Selected State hover
                '&:hover': {
                    background: colors.selectedHoverBackgroundColor,
                    selectors: {
                        // Selected State hover meta cell
                        $cell: {
                            color: colors.selectedHoverMetaTextColor,
                            selectors: {
                                [HighContrastSelector]: {
                                    color: 'HighlightText',
                                    selectors: {
                                        '> a': {
                                            color: 'HighlightText'
                                        }
                                    }
                                },
                                // Selected State hover Header cell
                                '&.$isRowHeader': {
                                    color: colors.selectedHoverTextColor,
                                    selectors: {
                                        [HighContrastSelector]: {
                                            color: 'HighlightText'
                                        }
                                    }
                                }
                            }
                        }
                    }
                },
                // Focus state
                '&:focus': {
                    background: colors.focusBackgroundColor,
                    selectors: {
                        // Selected State hover meta cell
                        $cell: {
                            color: colors.focusMetaTextColor,
                            [HighContrastSelector]: {
                                color: 'HighlightText',
                                selectors: {
                                    '> a': {
                                        color: 'HighlightText'
                                    }
                                }
                            },
                            // Row header cell
                            '&.$isRowHeader': {
                                color: colors.focusHeaderTextColor,
                                selectors: {
                                    [HighContrastSelector]: {
                                        color: 'HighlightText'
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    ];
    const cannotSelectStyles = [
        classNames.isContentUnselectable,
        {
            userSelect: 'none',
            cursor: 'default'
        }
    ];
    const rootCompactStyles = {
        minHeight: values$1.compactRowHeight,
        border: 0
    };
    const cellCompactStyles = {
        minHeight: values$1.compactRowHeight,
        paddingTop: values$1.compactRowVerticalPadding,
        paddingBottom: values$1.compactRowVerticalPadding,
        paddingLeft: `${cellStyleProps.cellLeftPadding}px`,
        selectors: {
            // Masking the running shimmer background with borders
            [`&$shimmer`]: {
                padding: 0,
                borderLeft: shimmerLeftBorderStyle,
                borderRight: shimmerRightBorderStyle,
                borderTop: `${values$1.compactRowShimmerVerticalBorder}px solid ${colors.defaultBackgroundColor}`,
                borderBottom: `${values$1.compactRowShimmerVerticalBorder}px solid ${colors.defaultBackgroundColor}`
            },
            // Masking the running shimmer background with borders when it's an Icon placeholder
            [`&$shimmerIconPlaceholder`]: {
                borderRight: `${cellStyleProps.cellRightPadding}px solid ${colors.defaultBackgroundColor}`,
                borderBottom: `${(values$1.compactRowHeight - values$1.rowShimmerIconPlaceholderHeight) / 2}px solid ${colors.defaultBackgroundColor}`,
                borderTop: `${(values$1.compactRowHeight - values$1.rowShimmerIconPlaceholderHeight) / 2}px solid ${colors.defaultBackgroundColor}`
            }
        }
    };
    const defaultCellStyles = [
        getFocusStyle(theme, -1),
        classNames.cell,
        {
            display: 'inline-block',
            position: 'relative',
            boxSizing: 'border-box',
            minHeight: values$1.rowHeight,
            verticalAlign: 'top',
            whiteSpace: 'nowrap',
            overflow: 'hidden',
            textOverflow: 'ellipsis',
            paddingTop: values$1.rowVerticalPadding,
            paddingBottom: values$1.rowVerticalPadding,
            paddingLeft: `${cellStyleProps.cellLeftPadding}px`,
            selectors: {
                '& > button': {
                    maxWidth: '100%'
                },
                [classNames.isFocusable]: getFocusStyle(theme, -1, undefined, undefined, neutralSecondary, white),
                '&$shimmer': {
                    padding: 0,
                    borderLeft: shimmerLeftBorderStyle,
                    borderRight: shimmerRightBorderStyle,
                    borderTop: `${values$1.rowShimmerVerticalBorder}px solid ${colors.defaultBackgroundColor}`,
                    borderBottom: `${values$1.rowShimmerVerticalBorder}px solid ${colors.defaultBackgroundColor}`
                },
                '&$shimmerIconPlaceholder': {
                    borderRight: `${cellStyleProps.cellRightPadding}px solid ${colors.defaultBackgroundColor}`,
                    borderBottom: `${(values$1.rowHeight - values$1.rowShimmerIconPlaceholderHeight) / 2}px solid ${colors.defaultBackgroundColor}`,
                    borderTop: `${(values$1.rowHeight - values$1.rowShimmerIconPlaceholderHeight) / 2}px solid ${colors.defaultBackgroundColor}`
                }
            }
        },
        isSelected && {
            selectors: {
                '&.$isRowHeader': {
                    color: colors.selectedTextColor,
                    selectors: {
                        [HighContrastSelector]: {
                            color: 'HighlightText'
                        }
                    }
                },
                [HighContrastSelector]: {
                    background: 'Highlight',
                    color: 'HighlightText',
                    '-ms-high-contrast-adjust': 'none',
                    selectors: {
                        a: {
                            color: 'HighlightText'
                        }
                    }
                }
            }
        },
        compact && cellCompactStyles
    ];
    return {
        root: [
            classNames.root,
            AnimationClassNames.fadeIn400,
            droppingClassName,
            theme.fonts.small,
            isCheckVisible && classNames.isCheckVisible,
            getFocusStyle(theme, 0, undefined, undefined, focusBorder, white),
            {
                borderBottom: `1px solid ${neutralLighter}`,
                background: colors.defaultBackgroundColor,
                color: colors.defaultMetaTextColor,
                display: 'inline-flex',
                minWidth: '100%',
                minHeight: values$1.rowHeight,
                whiteSpace: 'nowrap',
                padding: 0,
                boxSizing: 'border-box',
                verticalAlign: 'top',
                textAlign: 'left',
                selectors: {
                    [`${classNames.listCellFirstChild} &:before`]: {
                        display: 'none'
                    },
                    '&:hover': {
                        background: colors.hoverColorBackground
                    },
                    '&:hover $check': {
                        opacity: 1
                    }
                }
            },
            isSelected && selectedStyles,
            !canSelect && cannotSelectStyles,
            compact && rootCompactStyles,
            className
        ],
        cellUnpadded: [
            {
                paddingRight: `${cellStyleProps.cellRightPadding}px`
            }
        ],
        cellPadded: [
            {
                paddingRight: `${cellStyleProps.cellExtraRightPadding + cellStyleProps.cellRightPadding}px`,
                selectors: {
                    '&.$checkCell': {
                        paddingRight: 0
                    }
                }
            }
        ],
        cell: defaultCellStyles,
        cellMeasurer: [
            classNames.cellMeasurer,
            {
                overflow: 'visible',
                whiteSpace: 'nowrap'
            }
        ],
        checkCell: [
            defaultCellStyles,
            classNames.cellCheck,
            checkboxCellClassName,
            {
                padding: 0,
                // Ensure that the check cell covers the top border of the cell.
                // This ensures the click target does not leave a spot which would
                // cause other items to be deselected.
                paddingTop: 1,
                marginTop: -1,
                flexShrink: 0
            }
        ],
        checkCover: [
            {
                position: 'absolute',
                top: -1,
                left: 0,
                bottom: 0,
                right: 0,
                display: 'none'
            },
            anySelected && {
                display: 'block'
            }
        ],
        fields: [
            classNames.fields,
            {
                display: 'flex',
                alignItems: 'stretch'
            }
        ],
        isRowHeader: [
            {
                color: colors.defaultHeaderTextColor,
                fontSize: FontSizes.medium
            }
        ],
        isMultiline: [
            defaultCellStyles,
            {
                whiteSpace: 'normal',
                wordBreak: 'break-word',
                textOverflow: 'clip'
            }
        ],
        shimmer: [],
        shimmerIconPlaceholder: [],
        shimmerLeftBorder: [
            {
                // 40px to take into account the checkbox of items if present.
                borderLeft: `40px solid ${colors.defaultBackgroundColor}`
            }
        ],
        shimmerBottomBorder: [
            {
                // 1px to take into account the border-bottom when items replace shimmer lines and in default state.
                borderBottom: `1px solid ${colors.defaultBackgroundColor}`
            }
        ],
        check: []
    };
};

const GlobalClassNames$j = {
    root: 'ms-GroupHeader',
    compact: 'ms-GroupHeader--compact',
    check: 'ms-GroupHeader-check',
    dropIcon: 'ms-GroupHeader-dropIcon',
    expand: 'ms-GroupHeader-expand',
    isCollapsed: 'is-collapsed',
    title: 'ms-GroupHeader-title',
    isSelected: 'is-selected',
    iconTag: 'ms-Icon--Tag',
    group: 'ms-GroupedList-group',
    isDropping: 'is-dropping'
};
const beziers$1 = {
    easeOutCirc: 'cubic-bezier(0.075, 0.820, 0.165, 1.000)',
    easeOutSine: 'cubic-bezier(0.390, 0.575, 0.565, 1.000)',
    easeInBack: 'cubic-bezier(0.600, -0.280, 0.735, 0.045)'
};
const getStyles$D = (props) => {
    const { theme, className, selected, isCollapsed, compact } = props;
    const { rowHeight, compactRowHeight } = DEFAULT_ROW_HEIGHTS;
    const { cellLeftPadding } = DEFAULT_CELL_STYLE_PROPS; // padding from the source to align GroupHeader title with DetailsRow's first cell.
    const finalRowHeight = compact ? compactRowHeight : rowHeight;
    const { semanticColors, palette } = theme;
    const classNames = getGlobalClassNames(GlobalClassNames$j, theme);
    const checkExpandResetStyles = [
        getFocusStyle(theme),
        {
            cursor: 'default',
            background: 'none',
            backgroundColor: 'transparent',
            border: 'none',
            padding: 0 // cancel default <button> padding
        }
    ];
    return {
        root: [
            classNames.root,
            getFocusStyle(theme),
            theme.fonts.medium,
            {
                borderBottom: `1px solid ${semanticColors.listBackground}`,
                cursor: 'default',
                userSelect: 'none',
                selectors: {
                    ':hover': {
                        background: semanticColors.listItemBackgroundHovered
                    },
                    ':hover $check': {
                        opacity: 1
                    },
                    ':focus $check': {
                        opacity: 1
                    },
                    [`:global(.${classNames.group}.${classNames.isDropping})`]: {
                        selectors: {
                            '> $root $dropIcon': {
                                transition: `transform ${AnimationVariables.durationValue4} ${beziers$1.easeOutCirc} opacity ${AnimationVariables.durationValue1} ${beziers$1.easeOutSine}`,
                                transitionDelay: AnimationVariables.durationValue3,
                                opacity: 1,
                                transform: `rotate(0.2deg) scale(1);` // rotation prevents jittery motion in IE
                            },
                            $check: {
                                opacity: 0
                            }
                        }
                    }
                }
            },
            selected && [
                classNames.isSelected,
                {
                    background: semanticColors.listItemBackgroundChecked,
                    selectors: {
                        ':hover': {
                            background: semanticColors.listItemBackgroundCheckedHovered
                        },
                        $check: {
                            opacity: 1
                        }
                    }
                }
            ],
            compact && [classNames.compact, { border: 'none' }],
            className
        ],
        groupHeaderContainer: [
            {
                display: 'flex',
                alignItems: 'center',
                height: finalRowHeight
            }
        ],
        headerCount: [
            {
                padding: '0px 4px'
            }
        ],
        check: [
            classNames.check,
            checkExpandResetStyles,
            {
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
                // paddingTop and marginTop brought from the DetailsRow.styles.ts with explanation below.
                // Ensure that the check cell covers the top border of the cell.
                // This ensures the click target does not leave a spot which would
                // cause other items to be deselected.
                paddingTop: 1,
                marginTop: -1,
                opacity: 0,
                width: '40px',
                height: finalRowHeight,
                selectors: {
                    ':focus': {
                        opacity: 1
                    }
                }
            }
        ],
        expand: [
            classNames.expand,
            checkExpandResetStyles,
            {
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
                fontSize: compact ? FontSizes.mediumPlus : 18,
                width: SPACER_WIDTH,
                height: finalRowHeight,
                color: selected ? palette.neutralPrimary : palette.neutralSecondary,
                selectors: {
                    ':hover': {
                        backgroundColor: selected ? palette.neutralQuaternary : palette.neutralLight
                    },
                    ':active': {
                        backgroundColor: selected ? palette.neutralTertiaryAlt : palette.neutralQuaternaryAlt
                    }
                }
            }
        ],
        expandIsCollapsed: [
            isCollapsed
                ? [
                    classNames.isCollapsed,
                    {
                        transform: 'rotate(0deg)',
                        transformOrigin: '50% 50%',
                        transition: 'transform .1s linear'
                    }
                ]
                : {
                    transform: 'rotate(90deg)',
                    transformOrigin: '50% 50%',
                    transition: 'transform .1s linear'
                }
        ],
        title: [
            classNames.title,
            {
                paddingLeft: cellLeftPadding,
                fontSize: compact ? FontSizes.large : FontSizes.xLarge,
                fontWeight: FontWeights.semilight,
                cursor: 'pointer',
                outline: 0,
                whiteSpace: 'nowrap',
                textOverflow: 'ellipsis'
            }
        ],
        dropIcon: [
            classNames.dropIcon,
            {
                position: 'absolute',
                left: -26,
                fontSize: IconFontSizes.large,
                color: palette.neutralSecondary,
                transition: `transform ${AnimationVariables.durationValue2} ${beziers$1.easeInBack}, opacity ${AnimationVariables.durationValue4} ${beziers$1.easeOutSine}`,
                opacity: 0,
                transform: 'rotate(0.2deg) scale(0.65)',
                transformOrigin: '10px 10px',
                selectors: {
                    [`:global(.${classNames.iconTag})`]: {
                        position: 'absolute'
                    }
                }
            }
        ]
    };
};

/**
 * Possible variations of the spinner circle size.
 */
var SpinnerSize;
(function (SpinnerSize) {
    /**
     * 12px Spinner diameter
     */
    SpinnerSize[SpinnerSize["xSmall"] = 0] = "xSmall";
    /**
     * 16px Spinner diameter
     */
    SpinnerSize[SpinnerSize["small"] = 1] = "small";
    /**
     * 20px Spinner diameter
     */
    SpinnerSize[SpinnerSize["medium"] = 2] = "medium";
    /**
     * 28px Spinner diameter
     */
    SpinnerSize[SpinnerSize["large"] = 3] = "large";
})(SpinnerSize || (SpinnerSize = {}));
/**
 * Deprecated at v2.0.0, use `SpinnerSize` instead.
 * @deprecated Use `SpinnerSize` instead.
 */
var SpinnerType;
(function (SpinnerType) {
    /**
     * Deprecated and will be removed at \>= 2.0.0. Use `SpinnerSize.medium` instead.
     * @deprecated Use `SpinnerSize.medium` instead.
     */
    SpinnerType[SpinnerType["normal"] = 0] = "normal";
    /**
     * Deprecated and will be removed at \>= 2.0.0. Use `SpinnerSize.large` instead.
     * @deprecated Use `SpinnerSize.large` instead.
     */
    SpinnerType[SpinnerType["large"] = 1] = "large";
})(SpinnerType || (SpinnerType = {}));

const getClassNames$v = classNamesFunction();
class SpinnerBase extends BaseComponent {
    render() {
        const { type, size, ariaLabel, ariaLive, styles, label, theme, className, labelPosition } = this.props;
        const statusMessage = ariaLabel || label;
        const nativeProps = getNativeProps(this.props, divProperties, ['size']);
        // SpinnerType is deprecated. If someone is still using this property, rather than putting the SpinnerType into the ISpinnerStyleProps,
        // we'll map SpinnerType to its equivalent SpinnerSize and pass that in. Once SpinnerType finally goes away we should delete this.
        let styleSize = size;
        if (styleSize === undefined && type !== undefined) {
            styleSize = type === SpinnerType.large ? SpinnerSize.large : SpinnerSize.medium;
        }
        const classNames = getClassNames$v(styles, {
            theme: theme,
            size: styleSize,
            className,
            labelPosition
        });
        return (createElement("div", Object.assign({}, nativeProps, { className: classNames.root }),
            createElement("div", { className: classNames.circle }),
            label && createElement("div", { className: classNames.label }, label),
            statusMessage && (createElement("div", { role: "status", "aria-live": ariaLive },
                createElement(DelayedRender, null,
                    createElement("div", { className: classNames.screenReaderText }, statusMessage))))));
    }
}
SpinnerBase.defaultProps = {
    size: SpinnerSize.medium,
    ariaLive: 'polite',
    labelPosition: 'bottom'
};

const GlobalClassNames$k = {
    root: 'ms-Spinner',
    circle: 'ms-Spinner-circle',
    label: 'ms-Spinner-label'
};
const spinAnimation = keyframes({
    '0%': {
        transform: 'rotate(0deg)'
    },
    '100%': {
        transform: 'rotate(360deg)'
    }
});
const getStyles$E = (props) => {
    const { theme, size, className, labelPosition } = props;
    const { palette } = theme;
    const classNames = getGlobalClassNames(GlobalClassNames$k, theme);
    return {
        root: [
            classNames.root,
            {
                display: 'flex',
                flexDirection: 'column',
                alignItems: 'center',
                justifyContent: 'center'
            },
            labelPosition === 'top' && {
                flexDirection: 'column-reverse'
            },
            labelPosition === 'right' && {
                flexDirection: 'row'
            },
            labelPosition === 'left' && {
                flexDirection: 'row-reverse'
            },
            className
        ],
        circle: [
            classNames.circle,
            {
                boxSizing: 'border-box',
                borderRadius: '50%',
                border: '1.5px solid ' + palette.themeLight,
                borderTopColor: palette.themePrimary,
                animationName: spinAnimation,
                animationDuration: '1.3s',
                animationIterationCount: 'infinite',
                animationTimingFunction: 'cubic-bezier(.53,.21,.29,.67)',
                selectors: {
                    [HighContrastSelector]: {
                        borderTopColor: 'Highlight'
                    }
                }
            },
            size === SpinnerSize.xSmall && [
                'ms-Spinner--xSmall',
                {
                    width: 12,
                    height: 12
                }
            ],
            size === SpinnerSize.small && [
                'ms-Spinner--small',
                {
                    width: 16,
                    height: 16
                }
            ],
            size === SpinnerSize.medium && [
                'ms-Spinner--medium',
                {
                    width: 20,
                    height: 20
                }
            ],
            size === SpinnerSize.large && [
                'ms-Spinner--large',
                {
                    width: 28,
                    height: 28
                }
            ]
        ],
        label: [
            classNames.label,
            {
                color: palette.themePrimary,
                margin: '10px 0 0',
                textAlign: 'center'
            },
            labelPosition === 'top' && {
                margin: '0 0 10px'
            },
            labelPosition === 'right' && {
                margin: '0 0 0 10px'
            },
            labelPosition === 'left' && {
                margin: '0 10px 0 0'
            }
        ],
        screenReaderText: hiddenContentStyle
    };
};

const Spinner = styled(SpinnerBase, getStyles$E, undefined, { scope: 'Spinner' });

const getClassNames$w = classNamesFunction();
class GroupHeaderBase extends BaseComponent {
    constructor(props) {
        super(props);
        this._onToggleCollapse = (ev) => {
            const { group, onToggleCollapse, isGroupLoading } = this.props;
            const { isCollapsed } = this.state;
            const newCollapsed = !isCollapsed;
            const newLoadingVisible = !newCollapsed && isGroupLoading && isGroupLoading(group);
            this.setState({
                isCollapsed: newCollapsed,
                isLoadingVisible: newLoadingVisible
            });
            if (onToggleCollapse) {
                onToggleCollapse(group);
            }
            ev.stopPropagation();
            ev.preventDefault();
        };
        this._onToggleSelectGroupClick = (ev) => {
            const { onToggleSelectGroup, group } = this.props;
            if (onToggleSelectGroup) {
                onToggleSelectGroup(group);
            }
            ev.preventDefault();
            ev.stopPropagation();
        };
        this._onHeaderClick = () => {
            const { group, onGroupHeaderClick, onToggleSelectGroup } = this.props;
            if (onGroupHeaderClick) {
                onGroupHeaderClick(group);
            }
            else if (onToggleSelectGroup) {
                onToggleSelectGroup(group);
            }
        };
        this._onRenderTitle = (props) => {
            const { group } = props;
            if (!group) {
                return null;
            }
            return (createElement("div", { className: this._classNames.title },
                createElement("span", null, group.name),
                createElement("span", { className: this._classNames.headerCount },
                    "(",
                    group.count,
                    group.hasMoreData && '+',
                    ")")));
        };
        this.state = {
            isCollapsed: (this.props.group && this.props.group.isCollapsed),
            isLoadingVisible: false
        };
    }
    componentWillReceiveProps(newProps) {
        if (newProps.group) {
            const newCollapsed = newProps.group.isCollapsed;
            const isGroupLoading = newProps.headerProps && newProps.headerProps.isGroupLoading;
            const newLoadingVisible = !newCollapsed && isGroupLoading && isGroupLoading(newProps.group);
            this.setState({
                isCollapsed: newCollapsed,
                isLoadingVisible: newLoadingVisible
            });
        }
    }
    render() {
        const { group, groupLevel, viewport, selectionMode, loadingText, isSelected, selected, indentWidth, onRenderTitle = this._onRenderTitle, isCollapsedGroupSelectVisible = true, expandButtonProps, theme, styles, className, groupedListId, compact } = this.props;
        const { isCollapsed, isLoadingVisible } = this.state;
        const canSelectGroup = selectionMode === SelectionMode.multiple;
        const isSelectionCheckVisible = canSelectGroup && (isCollapsedGroupSelectVisible || !(group && group.isCollapsed));
        const currentlySelected = isSelected || selected;
        const isRTL = getRTL();
        this._classNames = getClassNames$w(styles, {
            theme: theme,
            className,
            selected: currentlySelected,
            isCollapsed,
            compact
        });
        if (!group) {
            return null;
        }
        return (createElement("div", { className: this._classNames.root, style: viewport ? { minWidth: viewport.width } : {}, onClick: this._onHeaderClick, "aria-label": group.ariaLabel || group.name, "data-is-focusable": true },
            createElement(FocusZone, { className: this._classNames.groupHeaderContainer, direction: FocusZoneDirection.horizontal },
                isSelectionCheckVisible ? (createElement("button", { type: "button", className: this._classNames.check, role: "checkbox", "aria-checked": !!currentlySelected, "data-selection-toggle": true, onClick: this._onToggleSelectGroupClick },
                    createElement(Check, { checked: currentlySelected }))) : (selectionMode !== SelectionMode.none && createElement(GroupSpacer, { indentWidth: indentWidth, count: 1 })),
                createElement(GroupSpacer, { indentWidth: indentWidth, count: groupLevel }),
                createElement("div", { className: this._classNames.dropIcon },
                    createElement(Icon, { iconName: "Tag" })),
                createElement("button", Object.assign({ type: "button", className: this._classNames.expand, onClick: this._onToggleCollapse, "aria-expanded": group ? !group.isCollapsed : undefined, "aria-controls": group && !group.isCollapsed ? groupedListId : undefined }, expandButtonProps),
                    createElement(Icon, { className: this._classNames.expandIsCollapsed, iconName: isRTL ? 'ChevronLeftMed' : 'ChevronRightMed' })),
                onRenderTitle(this.props, this._onRenderTitle),
                isLoadingVisible && createElement(Spinner, { label: loadingText }))));
    }
}
GroupHeaderBase.defaultProps = {
    expandButtonProps: { 'aria-label': 'expand collapse group' }
};

const GroupHeader = styled(GroupHeaderBase, getStyles$D, undefined, {
    scope: 'GroupHeader'
});

const GlobalClassNames$l = {
    root: 'ms-GroupShowAll',
    link: 'ms-Link'
};
const getStyles$F = (props) => {
    const { theme } = props;
    const classNames = getGlobalClassNames(GlobalClassNames$l, theme);
    return {
        root: [
            classNames.root,
            theme.fonts.medium,
            {
                position: 'relative',
                padding: '10px 84px',
                cursor: 'pointer',
                selectors: {
                    [`.${classNames.link}`]: {
                        fontSize: FontSizes.small
                    }
                }
            }
        ]
    };
};

const getClassNames$x = classNamesFunction();
class GroupShowAllBase extends BaseComponent {
    constructor() {
        super(...arguments);
        this._onSummarizeClick = (ev) => {
            this.props.onToggleSummarize(this.props.group);
            ev.stopPropagation();
            ev.preventDefault();
        };
    }
    render() {
        const { group, groupLevel, showAllLinkText, styles, theme } = this.props;
        const classNames = getClassNames$x(styles, { theme: theme });
        if (group) {
            return (createElement("div", { className: classNames.root },
                createElement(GroupSpacer, { count: groupLevel }),
                createElement(Link, { onClick: this._onSummarizeClick }, showAllLinkText)));
        }
        return null;
    }
}
GroupShowAllBase.defaultProps = {
    showAllLinkText: 'Show All'
};

const GroupShowAll = styled(GroupShowAllBase, getStyles$F, undefined, { scope: 'GroupShowAll' });

const GlobalClassNames$m = {
    root: 'ms-groupFooter'
};
const getStyles$G = (props) => {
    const { theme, className } = props;
    const classNames = getGlobalClassNames(GlobalClassNames$m, theme);
    return {
        root: [
            theme.fonts.medium,
            classNames.root,
            {
                position: 'relative',
                padding: '5px 38px'
            },
            className
        ]
    };
};

const getClassNames$y = classNamesFunction();
class GroupFooterBase extends BaseComponent {
    render() {
        const { group, groupLevel, footerText, indentWidth, styles, theme } = this.props;
        const classNames = getClassNames$y(styles, { theme: theme });
        if (group && footerText) {
            return (createElement("div", { className: classNames.root },
                createElement(GroupSpacer, { indentWidth: indentWidth, count: groupLevel }),
                footerText));
        }
        return null;
    }
}

const GroupFooter = styled(GroupFooterBase, getStyles$G, undefined, {
    scope: 'GroupFooter'
});

const DEFAULT_DROPPING_CSS_CLASS = 'is-dropping';
class GroupedListSection extends BaseComponent {
    constructor(props) {
        super(props);
        this._root = createRef();
        this._list = createRef();
        this._onRenderGroupHeader = (props) => {
            return createElement(GroupHeader, Object.assign({}, props));
        };
        this._onRenderGroupShowAll = (props) => {
            return createElement(GroupShowAll, Object.assign({}, props));
        };
        this._onRenderGroupFooter = (props) => {
            return createElement(GroupFooter, Object.assign({}, props));
        };
        this._renderSubGroup = (subGroup, subGroupIndex) => {
            const { dragDropEvents, dragDropHelper, eventsToRegister, getGroupItemLimit, groupNestingDepth, groupProps, items, headerProps, showAllProps, footerProps, listProps, onRenderCell, selection, selectionMode, viewport, onRenderGroupHeader, onRenderGroupShowAll, onRenderGroupFooter, onShouldVirtualize, group, compact } = this.props;
            return !subGroup || subGroup.count > 0 || (groupProps && groupProps.showEmptyGroups) ? (createElement(GroupedListSection, { ref: 'subGroup_' + subGroupIndex, key: this._getGroupKey(subGroup, subGroupIndex), dragDropEvents: dragDropEvents, dragDropHelper: dragDropHelper, eventsToRegister: eventsToRegister, footerProps: footerProps, getGroupItemLimit: getGroupItemLimit, group: subGroup, groupIndex: subGroupIndex, groupNestingDepth: groupNestingDepth, groupProps: groupProps, headerProps: headerProps, items: items, listProps: listProps, onRenderCell: onRenderCell, selection: selection, selectionMode: selectionMode, showAllProps: showAllProps, viewport: viewport, onRenderGroupHeader: onRenderGroupHeader, onRenderGroupShowAll: onRenderGroupShowAll, onRenderGroupFooter: onRenderGroupFooter, onShouldVirtualize: onShouldVirtualize, groups: group.children, compact: compact })) : null;
        };
        /**
         * collect all the data we need to enable drag/drop for a group
         */
        this._getGroupDragDropOptions = () => {
            const { group, groupIndex, dragDropEvents, eventsToRegister } = this.props;
            const options = {
                eventMap: eventsToRegister,
                selectionIndex: -1,
                context: { data: group, index: groupIndex, isGroup: true },
                canDrag: () => false,
                canDrop: dragDropEvents.canDrop,
                updateDropState: this._updateDroppingState
            };
            return options;
        };
        /**
         * update groupIsDropping state based on the input value, which is used to change style during drag and drop
         *
         * @private
         * @param {boolean} newValue (new isDropping state value)
         * @param {DragEvent} event (the event trigger dropping state change which can be dragenter, dragleave etc)
         */
        this._updateDroppingState = (newIsDropping, event) => {
            const { isDropping } = this.state;
            const { dragDropEvents } = this.props;
            if (!isDropping) {
                if (dragDropEvents && dragDropEvents.onDragLeave) {
                    dragDropEvents.onDragLeave(event, undefined);
                }
            }
            else {
                if (dragDropEvents && dragDropEvents.onDragEnter) {
                    dragDropEvents.onDragEnter(event, undefined);
                }
            }
            if (isDropping !== newIsDropping) {
                this.setState({ isDropping: newIsDropping });
            }
        };
        const { selection, group } = props;
        this._id = getId('GroupedListSection');
        this.state = {
            isDropping: false,
            isSelected: selection && group ? selection.isRangeSelected(group.startIndex, group.count) : false
        };
    }
    componentDidMount() {
        const { dragDropHelper, selection } = this.props;
        if (dragDropHelper && this._root.current) {
            this._dragDropSubscription = dragDropHelper.subscribe(this._root.current, this._events, this._getGroupDragDropOptions());
        }
        if (selection) {
            this._events.on(selection, SELECTION_CHANGE, this._onSelectionChange);
        }
    }
    componentWillUnmount() {
        if (this._dragDropSubscription) {
            this._dragDropSubscription.dispose();
        }
    }
    componentDidUpdate(previousProps) {
        if (this.props.group !== previousProps.group ||
            this.props.groupIndex !== previousProps.groupIndex ||
            this.props.dragDropHelper !== previousProps.dragDropHelper) {
            if (this._dragDropSubscription) {
                this._dragDropSubscription.dispose();
                delete this._dragDropSubscription;
            }
            if (this.props.dragDropHelper && this._root.current) {
                this._dragDropSubscription = this.props.dragDropHelper.subscribe(this._root.current, this._events, this._getGroupDragDropOptions());
            }
        }
    }
    render() {
        const { getGroupItemLimit, group, groupIndex, headerProps, showAllProps, footerProps, viewport, selectionMode, onRenderGroupHeader = this._onRenderGroupHeader, onRenderGroupShowAll = this._onRenderGroupShowAll, onRenderGroupFooter = this._onRenderGroupFooter, onShouldVirtualize, groupedListClassNames, groups, compact } = this.props;
        const { isSelected } = this.state;
        const renderCount = group && getGroupItemLimit ? getGroupItemLimit(group) : Infinity;
        const isShowAllVisible = group && !group.children && !group.isCollapsed && !group.isShowingAll && (group.count > renderCount || group.hasMoreData);
        const hasNestedGroups = group && group.children && group.children.length > 0;
        const dividerProps = {
            group,
            groupIndex,
            groupLevel: group ? group.level : 0,
            isSelected,
            viewport,
            selectionMode,
            groups,
            compact
        };
        const ariaControlsProps = {
            groupedListId: this._id
        };
        const groupHeaderProps = assign({}, headerProps, dividerProps, ariaControlsProps);
        const groupShowAllProps = assign({}, showAllProps, dividerProps);
        const groupFooterProps = assign({}, footerProps, dividerProps);
        return (createElement("div", { ref: this._root, className: css(groupedListClassNames && groupedListClassNames.group, this._getDroppingClassName()), role: "presentation" },
            onRenderGroupHeader(groupHeaderProps, this._onRenderGroupHeader),
            group && group.isCollapsed ? null : hasNestedGroups ? (createElement(List, { role: "presentation", ref: this._list, items: group.children, onRenderCell: this._renderSubGroup, getItemCountForPage: this._returnOne, onShouldVirtualize: onShouldVirtualize, id: this._id })) : (this._onRenderGroup(renderCount)),
            group && group.isCollapsed ? null : isShowAllVisible && onRenderGroupShowAll(groupShowAllProps, this._onRenderGroupShowAll),
            onRenderGroupFooter(groupFooterProps, this._onRenderGroupFooter)));
    }
    forceUpdate() {
        super.forceUpdate();
        this.forceListUpdate();
    }
    forceListUpdate() {
        const { group } = this.props;
        if (this._list.current) {
            this._list.current.forceUpdate();
            if (group && group.children && group.children.length > 0) {
                const subGroupCount = group.children.length;
                for (let i = 0; i < subGroupCount; i++) {
                    const subGroup = this._list.current.refs['subGroup_' + String(i)];
                    if (subGroup) {
                        subGroup.forceListUpdate();
                    }
                }
            }
        }
        else {
            const subGroup = this.refs['subGroup_' + String(0)];
            if (subGroup) {
                subGroup.forceListUpdate();
            }
        }
    }
    _onSelectionChange() {
        const { group, selection } = this.props;
        const isSelected = selection.isRangeSelected(group.startIndex, group.count);
        if (isSelected !== this.state.isSelected) {
            this.setState({ isSelected });
        }
    }
    _onRenderGroupCell(onRenderCell, groupNestingDepth) {
        return (item, itemIndex) => {
            return onRenderCell(groupNestingDepth, item, itemIndex);
        };
    }
    _onRenderGroup(renderCount) {
        const { group, items, onRenderCell, listProps, groupNestingDepth, onShouldVirtualize } = this.props;
        const count = group ? group.count : items.length;
        const startIndex = group ? group.startIndex : 0;
        return (createElement(List, Object.assign({ role: "grid", items: items, onRenderCell: this._onRenderGroupCell(onRenderCell, groupNestingDepth), ref: this._list, renderCount: Math.min(count, renderCount), startIndex: startIndex, onShouldVirtualize: onShouldVirtualize, id: this._id }, listProps)));
    }
    _returnOne() {
        return 1;
    }
    _getGroupKey(group, index) {
        return 'group-' + (group && group.key ? group.key : String(group.level) + String(index));
    }
    /**
     * get the correct css class to reflect the dropping state for a given group
     *
     * If the group is the current drop target, return the default dropping class name
     * Otherwise, return '';
     *
     */
    _getDroppingClassName() {
        let { isDropping } = this.state;
        const { group, groupedListClassNames } = this.props;
        isDropping = !!(group && isDropping);
        return css(isDropping && DEFAULT_DROPPING_CSS_CLASS, isDropping && groupedListClassNames && groupedListClassNames.groupIsDropping);
    }
}

const getClassNames$z = classNamesFunction();
class GroupedListBase extends BaseComponent {
    constructor(props) {
        super(props);
        this._list = createRef();
        this._renderGroup = (group, groupIndex) => {
            const { dragDropEvents, dragDropHelper, eventsToRegister, groupProps, items, listProps, onRenderCell, selectionMode, selection, viewport, onShouldVirtualize, groups, compact } = this.props;
            // override group header/footer props as needed
            const dividerProps = {
                onToggleSelectGroup: this._onToggleSelectGroup,
                onToggleCollapse: this._onToggleCollapse,
                onToggleSummarize: this._onToggleSummarize
            };
            const headerProps = assign({}, groupProps.headerProps, dividerProps);
            const showAllProps = assign({}, groupProps.showAllProps, dividerProps);
            const footerProps = assign({}, groupProps.footerProps, dividerProps);
            const groupNestingDepth = this._getGroupNestingDepth();
            if (!groupProps.showEmptyGroups && group && group.count === 0) {
                return null;
            }
            return (createElement(GroupedListSection, { ref: 'group_' + groupIndex, key: this._getGroupKey(group, groupIndex), dragDropEvents: dragDropEvents, dragDropHelper: dragDropHelper, eventsToRegister: eventsToRegister, footerProps: footerProps, getGroupItemLimit: groupProps && groupProps.getGroupItemLimit, group: group, groupIndex: groupIndex, groupNestingDepth: groupNestingDepth, groupProps: groupProps, headerProps: headerProps, listProps: listProps, items: items, onRenderCell: onRenderCell, onRenderGroupHeader: groupProps.onRenderHeader, onRenderGroupShowAll: groupProps.onRenderShowAll, onRenderGroupFooter: groupProps.onRenderFooter, selectionMode: selectionMode, selection: selection, showAllProps: showAllProps, viewport: viewport, onShouldVirtualize: onShouldVirtualize, groupedListClassNames: this._classNames, groups: groups, compact: compact }));
        };
        this._getPageHeight = (getGroupHeight) => (itemIndex) => {
            const { groups } = this.state;
            const pageGroup = groups && groups[itemIndex];
            return getGroupHeight(pageGroup, itemIndex);
        };
        this._onToggleCollapse = (group) => {
            const { groupProps } = this.props;
            const onToggleCollapse = groupProps && groupProps.headerProps && groupProps.headerProps.onToggleCollapse;
            if (group) {
                if (onToggleCollapse) {
                    onToggleCollapse(group);
                }
                group.isCollapsed = !group.isCollapsed;
                this._updateIsSomeGroupExpanded();
                this.forceUpdate();
            }
        };
        this._onToggleSelectGroup = (group) => {
            if (group) {
                this.props.selection.toggleRangeSelected(group.startIndex, group.count);
            }
        };
        this._onToggleSummarize = (group) => {
            const { groupProps } = this.props;
            const onToggleSummarize = groupProps && groupProps.showAllProps && groupProps.showAllProps.onToggleSummarize;
            if (onToggleSummarize) {
                onToggleSummarize(group);
            }
            else {
                if (group) {
                    group.isShowingAll = !group.isShowingAll;
                }
                this.forceUpdate();
            }
        };
        this._getPageSpecification = (itemIndex, visibleRect) => {
            const groups = this.state.groups;
            const pageGroup = groups && groups[itemIndex];
            return {
                key: pageGroup && pageGroup.key
            };
        };
        this._isSomeGroupExpanded = this._computeIsSomeGroupExpanded(props.groups);
        this.state = {
            lastWidth: 0,
            groups: props.groups
        };
    }
    scrollToIndex(index, measureItem, scrollToMode) {
        if (this._list.current) {
            this._list.current.scrollToIndex(index, measureItem, scrollToMode);
        }
    }
    getStartItemIndexInView() {
        return this._list.current.getStartItemIndexInView() || 0;
    }
    componentWillReceiveProps(newProps) {
        const { groups, selectionMode, compact } = this.props;
        let shouldForceUpdates = false;
        if (newProps.groups !== groups) {
            this.setState({ groups: newProps.groups });
            shouldForceUpdates = true;
        }
        if (newProps.selectionMode !== selectionMode || newProps.compact !== compact) {
            shouldForceUpdates = true;
        }
        if (shouldForceUpdates) {
            this._forceListUpdates();
        }
    }
    render() {
        const { className, usePageCache, onShouldVirtualize, getGroupHeight, theme, styles, compact } = this.props;
        const { groups } = this.state;
        this._classNames = getClassNames$z(styles, {
            theme: theme,
            className,
            compact: compact
        });
        return (createElement("div", { className: this._classNames.root, "data-automationid": "GroupedList", "data-is-scrollable": "false", role: "presentation" }, !groups ? (this._renderGroup(null, 0)) : (createElement(List, { ref: this._list, role: "presentation", items: groups, onRenderCell: this._renderGroup, getItemCountForPage: this._returnOne, getPageHeight: getGroupHeight && this._getPageHeight(getGroupHeight), getPageSpecification: this._getPageSpecification, usePageCache: usePageCache, onShouldVirtualize: onShouldVirtualize }))));
    }
    forceUpdate() {
        super.forceUpdate();
        this._forceListUpdates();
    }
    toggleCollapseAll(allCollapsed) {
        const { groups } = this.state;
        const { groupProps } = this.props;
        const onToggleCollapseAll = groupProps && groupProps.onToggleCollapseAll;
        if (groups) {
            if (onToggleCollapseAll) {
                onToggleCollapseAll(allCollapsed);
            }
            for (let groupIndex = 0; groupIndex < groups.length; groupIndex++) {
                groups[groupIndex].isCollapsed = allCollapsed;
            }
            this._updateIsSomeGroupExpanded();
            this.forceUpdate();
        }
    }
    _returnOne() {
        return 1;
    }
    _getGroupKey(group, index) {
        return 'group-' + (group && group.key ? group.key : String(index));
    }
    _getGroupNestingDepth() {
        const { groups } = this.state;
        let level = 0;
        let groupsInLevel = groups;
        while (groupsInLevel && groupsInLevel.length > 0) {
            level++;
            groupsInLevel = groupsInLevel[0].children;
        }
        return level;
    }
    _forceListUpdates(groups) {
        groups = groups || this.state.groups;
        const groupCount = groups ? groups.length : 1;
        if (this._list.current) {
            this._list.current.forceUpdate();
            for (let i = 0; i < groupCount; i++) {
                const group = this._list.current.refs['group_' + String(i)];
                if (group) {
                    group.forceListUpdate();
                }
            }
        }
        else {
            const group = this.refs['group_' + String(0)];
            if (group) {
                group.forceListUpdate();
            }
        }
    }
    _computeIsSomeGroupExpanded(groups) {
        return !!(groups && groups.some(group => (group.children ? this._computeIsSomeGroupExpanded(group.children) : !group.isCollapsed)));
    }
    _updateIsSomeGroupExpanded() {
        const { groups } = this.state;
        const { onGroupExpandStateChanged } = this.props;
        const newIsSomeGroupExpanded = this._computeIsSomeGroupExpanded(groups);
        if (this._isSomeGroupExpanded !== newIsSomeGroupExpanded) {
            if (onGroupExpandStateChanged) {
                onGroupExpandStateChanged(newIsSomeGroupExpanded);
            }
            this._isSomeGroupExpanded = newIsSomeGroupExpanded;
        }
    }
}
GroupedListBase.defaultProps = {
    selectionMode: SelectionMode.multiple,
    isHeaderVisible: true,
    groupProps: {},
    compact: false
};

const GroupedList = styled(GroupedListBase, getStyles$B, undefined, {
    scope: 'GroupedList'
});

const GlobalClassNames$n = {
    tooltipHost: 'ms-TooltipHost',
    root: 'ms-DetailsHeader',
    cell: 'ms-DetailsHeader-cell',
    cellIsCheck: 'ms-DetailsHeader-cellIsCheck',
    collapseButton: 'ms-DetailsHeader-collapseButton',
    isCollapsed: 'is-collapsed',
    isAllSelected: 'is-allSelected',
    isSelectAllHidden: 'is-selectAllHidden',
    isResizingColumn: 'is-resizingColumn',
    cellSizer: 'ms-DetailsHeader-cellSizer',
    isResizing: 'is-resizing',
    dropHintCircleStyle: 'ms-DetailsHeader-dropHintCircleStyle',
    dropHintCaretStyle: 'ms-DetailsHeader-dropHintCaretStyle',
    dropHintLineStyle: 'ms-DetailsHeader-dropHintLineStyle',
    cellTitle: 'ms-DetailsHeader-cellTitle',
    cellName: 'ms-DetailsHeader-cellName',
    filterChevron: 'ms-DetailsHeader-filterChevron',
    gripperBarVertical: 'ms-DetailsColumn-gripperBarVertical'
};
const HEADER_HEIGHT = 32;
const getCellStyles = (props) => {
    const { theme, cellStyleProps = DEFAULT_CELL_STYLE_PROPS } = props;
    const { semanticColors } = theme;
    const classNames = getGlobalClassNames(GlobalClassNames$n, theme);
    return [
        classNames.cell,
        getFocusStyle(theme),
        {
            color: semanticColors.bodyText,
            position: 'relative',
            display: 'inline-block',
            boxSizing: 'border-box',
            padding: `0 ${cellStyleProps.cellRightPadding}px 0 ${cellStyleProps.cellLeftPadding}px`,
            lineHeight: 'inherit',
            margin: '0',
            height: HEADER_HEIGHT,
            verticalAlign: 'top',
            whiteSpace: 'nowrap',
            textOverflow: 'ellipsis',
            textAlign: 'left'
        }
    ];
};
const getStyles$H = (props) => {
    const { theme, className, isSelectAllHidden, isAllSelected, isResizingColumn, isSizing, isAllCollapsed, cellStyleProps = DEFAULT_CELL_STYLE_PROPS } = props;
    const { semanticColors, palette } = theme;
    const classNames = getGlobalClassNames(GlobalClassNames$n, theme);
    const colors = {
        iconForegroundColor: semanticColors.bodySubtext,
        headerForegroundColor: semanticColors.bodyText,
        headerBackgroundColor: semanticColors.bodyBackground,
        dropdownChevronForegroundColor: palette.neutralTertiary,
        resizerColor: palette.neutralTertiaryAlt
    };
    const cellSizerFadeInStyles = {
        opacity: 1,
        transition: 'opacity 0.3s linear'
    };
    const cellStyles = getCellStyles(props);
    return {
        root: [
            classNames.root,
            theme.fonts.small,
            {
                display: 'inline-block',
                background: colors.headerBackgroundColor,
                position: 'relative',
                minWidth: '100%',
                verticalAlign: 'top',
                height: HEADER_HEIGHT,
                lineHeight: HEADER_HEIGHT,
                whiteSpace: 'nowrap',
                boxSizing: 'content-box',
                paddingBottom: '1px',
                borderBottom: `1px solid ${semanticColors.bodyDivider}`,
                cursor: 'default',
                userSelect: 'none',
                selectors: {
                    '&:hover $check': {
                        opacity: 1
                    },
                    [`${classNames.tooltipHost} $checkTooltip`]: {
                        display: 'block'
                    }
                }
            },
            isAllSelected && classNames.isAllSelected,
            isSelectAllHidden && {
                selectors: {
                    $cell$cellIsCheck: {
                        visibility: 'hidden'
                    }
                }
            },
            isResizingColumn && classNames.isResizingColumn,
            className
        ],
        check: [
            {
                height: HEADER_HEIGHT
            },
            {
                selectors: {
                    [`.${IsFocusVisibleClassName} &:focus`]: {
                        opacity: 1
                    }
                }
            }
        ],
        cellWrapperPadded: [
            {
                paddingRight: cellStyleProps.cellExtraRightPadding + cellStyleProps.cellRightPadding
            }
        ],
        cellIsCheck: [
            cellStyles,
            classNames.cellIsCheck,
            {
                position: 'relative',
                padding: 0,
                margin: 0,
                display: 'inline-flex',
                alignItems: 'center',
                border: 'none'
            },
            isAllSelected && {
                opacity: 1
            }
        ],
        cellIsGroupExpander: [
            cellStyles,
            {
                display: 'inline-flex',
                alignItems: 'center',
                justifyContent: 'center',
                fontSize: FontSizes.small,
                padding: 0,
                border: 'none',
                width: SPACER_WIDTH,
                color: palette.neutralSecondary,
                selectors: {
                    ':hover': {
                        backgroundColor: palette.neutralLighter
                    },
                    ':active': {
                        backgroundColor: palette.neutralLight
                    }
                }
            }
        ],
        cellIsActionable: [
            {
                selectors: {
                    ':hover': {
                        color: semanticColors.bodyText,
                        background: semanticColors.listHeaderBackgroundHovered
                    },
                    ':active': {
                        background: semanticColors.listHeaderBackgroundPressed
                    }
                }
            }
        ],
        cellIsEmpty: [
            {
                textOverflow: 'clip'
            }
        ],
        cellSizer: [
            classNames.cellSizer,
            focusClear(),
            {
                display: 'inline-block',
                position: 'relative',
                cursor: 'ew-resize',
                bottom: 0,
                top: 0,
                overflow: 'hidden',
                height: 'inherit',
                background: 'transparent',
                zIndex: 1,
                width: 16,
                selectors: {
                    ':after': {
                        content: '""',
                        position: 'absolute',
                        top: 0,
                        bottom: 0,
                        width: 1,
                        background: colors.resizerColor,
                        opacity: 0,
                        left: '50%'
                    },
                    ':focus:after': cellSizerFadeInStyles,
                    ':hover:after': cellSizerFadeInStyles,
                    '&$cellIsResizing:after': [
                        cellSizerFadeInStyles,
                        {
                            boxShadow: '0 0 5px 0 rgba(0, 0, 0, 0.4)'
                        }
                    ]
                }
            }
        ],
        cellIsResizing: [classNames.isResizing],
        cellSizerStart: [
            {
                margin: '0 -8px'
            }
        ],
        cellSizerEnd: [
            {
                margin: 0,
                marginLeft: -16
            }
        ],
        collapseButton: [
            classNames.collapseButton,
            isAllCollapsed
                ? [
                    classNames.isCollapsed,
                    {
                        transform: 'rotate(0deg)',
                        transformOrigin: '50% 50%',
                        transition: 'transform .1s linear'
                    }
                ]
                : {
                    transform: 'rotate(90deg)',
                    transformOrigin: '50% 50%',
                    transition: 'transform .1s linear'
                }
        ],
        checkTooltip: [],
        sizingOverlay: [
            isSizing && {
                position: 'absolute',
                left: 0,
                top: 0,
                right: 0,
                bottom: 0,
                cursor: 'ew-resize',
                background: 'rgba(255, 255, 255, 0)',
                selectors: {
                    [HighContrastSelector]: {
                        background: 'transparent',
                        '-ms-high-contrast-adjust': 'none'
                    }
                }
            }
        ],
        accessibleLabel: [hiddenContentStyle],
        dropHintCircleStyle: [
            classNames.dropHintCircleStyle,
            {
                display: 'inline-block',
                visibility: 'hidden',
                position: 'absolute',
                bottom: 0,
                height: 9,
                width: 9,
                borderRadius: '50%',
                marginLeft: -5,
                top: 34,
                overflow: 'visible',
                zIndex: 10,
                border: `1px solid ${palette.themePrimary}`,
                background: palette.white
            }
        ],
        dropHintCaretStyle: [
            classNames.dropHintCaretStyle,
            {
                display: 'none',
                position: 'absolute',
                top: 22,
                left: -7.5,
                fontSize: 16,
                color: palette.themePrimary,
                overflow: 'visible',
                zIndex: 10
            }
        ],
        dropHintLineStyle: [
            classNames.dropHintLineStyle,
            {
                display: 'none',
                position: 'absolute',
                bottom: 0,
                top: -3,
                overflow: 'hidden',
                height: 37,
                width: 1,
                background: palette.themePrimary,
                zIndex: 10
            }
        ],
        dropHintStyle: [
            {
                display: 'inline-block',
                position: 'absolute'
            }
        ]
    };
};

const GlobalClassNames$o = {
    root: 'ms-DetailsRow-check',
    isDisabled: 'ms-DetailsRow-check--isDisabled',
    isHeader: 'ms-DetailsRow-check--isHeader'
};
const getStyles$I = (props) => {
    const { theme, className, isHeader, selected, anySelected, canSelect, compact, isVisible } = props;
    const classNames = getGlobalClassNames(GlobalClassNames$o, theme);
    const { rowHeight, compactRowHeight } = DEFAULT_ROW_HEIGHTS;
    const height = isHeader ? HEADER_HEIGHT : compact ? compactRowHeight : rowHeight;
    const isCheckVisible = isVisible || selected || anySelected;
    return {
        root: [classNames.root, className],
        check: [
            !canSelect && [classNames.isDisabled, { visibility: 'hidden' }],
            isHeader && classNames.isHeader,
            getFocusStyle(theme),
            theme.fonts.small,
            {
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
                cursor: 'default',
                boxSizing: 'border-box',
                verticalAlign: 'top',
                background: 'none',
                backgroundColor: 'transparent',
                border: 'none',
                opacity: 0,
                height: height,
                width: 40,
                padding: 0,
                margin: 0,
                selectors: {
                    '&:hover': {
                        opacity: 1
                    }
                }
            },
            isCheckVisible && {
                opacity: 1
            }
        ],
        isDisabled: []
    };
};

const getCheckClassNames = classNamesFunction();
const getClassNames$A = classNamesFunction();
const DetailsRowCheckBase = (props) => {
    const { isVisible = false, canSelect = false, isSelected = false, anySelected = false, selected = false, isHeader = false, className, checkClassName, styles, theme, compact, ...buttonProps } = props;
    const isPressed = props.isSelected || props.selected;
    const checkStyles = getStyles$m({ theme: theme });
    const checkClassNames = getCheckClassNames(checkStyles, {
        theme: theme
    });
    const classNames = getClassNames$A(styles, {
        theme: theme,
        canSelect,
        selected: isPressed,
        anySelected,
        className,
        isHeader,
        isVisible,
        compact
    });
    return (createElement("div", Object.assign({}, buttonProps, { role: "checkbox", className: css(classNames.root, classNames.check, checkClassNames.checkHost), "aria-checked": isPressed, "data-selection-toggle": true, "data-automationid": "DetailsRowCheck" }),
        createElement(Check, { checked: isPressed })));
};
const DetailsRowCheck = styled(DetailsRowCheckBase, getStyles$I, undefined, { scope: 'DetailsRowCheck' });

const MOUSEDOWN_PRIMARY_BUTTON = 0; // for mouse down event we are using ev.button property, 0 means left button
const MOUSEMOVE_PRIMARY_BUTTON = 1; // for mouse move event we are using ev.buttons property, 1 means left button
class DragDropHelper {
    constructor(params) {
        this._selection = params.selection;
        this._dragEnterCounts = {};
        this._activeTargets = {};
        this._lastId = 0;
        this._events = new EventGroup(this);
        // clear drag data when mouse up, use capture event to ensure it will be run
        this._events.on(document.body, 'mouseup', this._onMouseUp.bind(this), true);
        this._events.on(document, 'mouseup', this._onDocumentMouseUp.bind(this), true);
    }
    dispose() {
        this._events.dispose();
    }
    subscribe(root, events, dragDropOptions) {
        const { key = `${++this._lastId}` } = dragDropOptions;
        const handlers = [];
        let onDragStart;
        let onDragLeave;
        let onDragEnter;
        let onDragEnd;
        let onDrop;
        let onDragOver;
        let onMouseDown;
        let isDraggable;
        let isDroppable;
        let activeTarget;
        if (dragDropOptions && root) {
            const { eventMap, context, updateDropState } = dragDropOptions;
            const dragDropTarget = {
                root: root,
                options: dragDropOptions,
                key: key
            };
            isDraggable = this._isDraggable(dragDropTarget);
            isDroppable = this._isDroppable(dragDropTarget);
            if (isDraggable || isDroppable) {
                if (eventMap) {
                    for (const event of eventMap) {
                        const handler = {
                            callback: event.callback.bind(null, context),
                            eventName: event.eventName
                        };
                        handlers.push(handler);
                        this._events.on(root, handler.eventName, handler.callback);
                    }
                }
            }
            if (isDroppable) {
                // If the target is droppable, wire up global event listeners to track drop-related events.
                onDragLeave = (event) => {
                    if (!event.isHandled) {
                        event.isHandled = true;
                        this._dragEnterCounts[key]--;
                        if (this._dragEnterCounts[key] === 0) {
                            updateDropState(false /* isDropping */, event);
                        }
                    }
                };
                onDragEnter = (event) => {
                    event.preventDefault(); // needed for IE
                    if (!event.isHandled) {
                        event.isHandled = true;
                        this._dragEnterCounts[key]++;
                        if (this._dragEnterCounts[key] === 1) {
                            updateDropState(true /* isDropping */, event);
                        }
                    }
                };
                onDragEnd = (event) => {
                    this._dragEnterCounts[key] = 0;
                    updateDropState(false /* isDropping */, event);
                };
                onDrop = (event) => {
                    this._dragEnterCounts[key] = 0;
                    updateDropState(false /* isDropping */, event);
                    if (dragDropOptions.onDrop) {
                        dragDropOptions.onDrop(dragDropOptions.context.data, event);
                    }
                };
                onDragOver = (event) => {
                    event.preventDefault();
                    if (dragDropOptions.onDragOver) {
                        dragDropOptions.onDragOver(dragDropOptions.context.data, event);
                    }
                };
                this._dragEnterCounts[key] = 0;
                // dragenter and dragleave will be fired when hover to the child element
                // but we only want to change state when enter or leave the current element
                // use the count to ensure it.
                events.on(root, 'dragenter', onDragEnter);
                events.on(root, 'dragleave', onDragLeave);
                events.on(root, 'dragend', onDragEnd);
                events.on(root, 'drop', onDrop);
                events.on(root, 'dragover', onDragOver);
            }
            if (isDraggable) {
                // If the target is draggable, wire up local event listeners for mouse events.
                onMouseDown = this._onMouseDown.bind(this, dragDropTarget);
                onDragEnd = this._onDragEnd.bind(this, dragDropTarget);
                // We need to add in data so that on Firefox we show the ghost element when dragging
                onDragStart = (event) => {
                    const { options } = this._dragData.dragTarget;
                    if (options && options.onDragStart) {
                        options.onDragStart(options.context.data, options.context.index, this._selection.getSelection(), event);
                    }
                    this._isDragging = true;
                    event.dataTransfer.setData('id', root.id);
                };
                events.on(root, 'dragstart', onDragStart);
                events.on(root, 'mousedown', onMouseDown);
                events.on(root, 'dragend', onDragEnd);
            }
            activeTarget = {
                target: dragDropTarget,
                dispose: () => {
                    if (this._activeTargets[key] === activeTarget) {
                        delete this._activeTargets[key];
                    }
                    if (root) {
                        for (const handler of handlers) {
                            this._events.off(root, handler.eventName, handler.callback);
                        }
                        if (isDroppable) {
                            events.off(root, 'dragenter', onDragEnter);
                            events.off(root, 'dragleave', onDragLeave);
                            events.off(root, 'dragend', onDragEnd);
                            events.off(root, 'dragover', onDragOver);
                            events.off(root, 'drop', onDrop);
                        }
                        if (isDraggable) {
                            events.off(root, 'dragstart', onDragStart);
                            events.off(root, 'mousedown', onMouseDown);
                            events.off(root, 'dragend', onDragEnd);
                        }
                    }
                }
            };
            this._activeTargets[key] = activeTarget;
        }
        return {
            key: key,
            dispose: () => {
                if (activeTarget) {
                    activeTarget.dispose();
                }
            }
        };
    }
    unsubscribe(root, key) {
        const activeTarget = this._activeTargets[key];
        if (activeTarget) {
            activeTarget.dispose();
        }
    }
    _onDragEnd(target, event) {
        const { options } = target;
        if (options.onDragEnd) {
            options.onDragEnd(options.context.data, event);
        }
    }
    /**
     * clear drag data when mouse up on body
     */
    _onMouseUp(event) {
        this._isDragging = false;
        if (this._dragData) {
            for (const key of Object.keys(this._activeTargets)) {
                const activeTarget = this._activeTargets[key];
                if (activeTarget.target.root) {
                    this._events.off(activeTarget.target.root, 'mousemove');
                    this._events.off(activeTarget.target.root, 'mouseleave');
                }
            }
            if (this._dragData.dropTarget) {
                // raise dragleave event to let dropTarget know it need to remove dropping style
                EventGroup.raise(this._dragData.dropTarget.root, 'dragleave');
                EventGroup.raise(this._dragData.dropTarget.root, 'drop');
            }
        }
        this._dragData = null;
    }
    /**
     * clear drag data when mouse up outside of the document
     */
    _onDocumentMouseUp(event) {
        if (event.target === document.documentElement) {
            this._onMouseUp(event);
        }
    }
    /**
     * when mouse move over a new drop target while dragging some items,
     * fire dragleave on the old target and fire dragenter to the new target
     * The target will handle style change on dragenter and dragleave events.
     */
    _onMouseMove(target, event) {
        const { 
        // use buttons property here since ev.button in some edge case is not updating well during the move.
        // but firefox doesn't support it, so we set the default value when it is not defined.
        buttons = MOUSEMOVE_PRIMARY_BUTTON } = event;
        if (this._dragData && buttons !== MOUSEMOVE_PRIMARY_BUTTON) {
            // cancel mouse down event and return early when the primary button is not pressed
            this._onMouseUp(event);
            return;
        }
        const { root, key } = target;
        if (this._isDragging) {
            if (this._isDroppable(target)) {
                // we can have nested drop targets in the DOM, like a folder inside a group. In that case, when we drag into
                // the inner target (folder), we first set dropTarget to the inner element. But the same event is bubbled to the
                // outer target too, and we need to prevent the outer one from taking over.
                // So, check if the last dropTarget is not a child of the current.
                if (this._dragData) {
                    if (this._dragData.dropTarget && this._dragData.dropTarget.key !== key && !this._isChild(root, this._dragData.dropTarget.root)) {
                        if (this._dragEnterCounts[this._dragData.dropTarget.key] > 0) {
                            EventGroup.raise(this._dragData.dropTarget.root, 'dragleave');
                            EventGroup.raise(root, 'dragenter');
                            this._dragData.dropTarget = target;
                        }
                    }
                }
            }
        }
    }
    /**
     * when mouse leave a target while dragging some items, fire dragleave to the target
     */
    _onMouseLeave(target, event) {
        if (this._isDragging) {
            if (this._dragData && this._dragData.dropTarget && this._dragData.dropTarget.key === target.key) {
                EventGroup.raise(target.root, 'dragleave');
                this._dragData.dropTarget = undefined;
            }
        }
    }
    /**
     * when mouse down on a draggable item, we start to track dragdata.
     */
    _onMouseDown(target, event) {
        if (event.button !== MOUSEDOWN_PRIMARY_BUTTON) {
            // Ignore anything except the primary button.
            return;
        }
        if (this._isDraggable(target)) {
            this._dragData = {
                clientX: event.clientX,
                clientY: event.clientY,
                eventTarget: event.target,
                dragTarget: target
            };
            for (const key of Object.keys(this._activeTargets)) {
                const activeTarget = this._activeTargets[key];
                if (activeTarget.target.root) {
                    this._events.on(activeTarget.target.root, 'mousemove', this._onMouseMove.bind(this, activeTarget.target));
                    this._events.on(activeTarget.target.root, 'mouseleave', this._onMouseLeave.bind(this, activeTarget.target));
                }
            }
        }
        else {
            this._dragData = null;
        }
    }
    /**
     * determine whether the child target is a descendant of the parent
     */
    _isChild(parent, child) {
        const parentElement = findDOMNode(parent);
        let childElement = findDOMNode(child);
        while (childElement && childElement.parentElement) {
            if (childElement.parentElement === parentElement) {
                return true;
            }
            childElement = childElement.parentElement;
        }
        return false;
    }
    _isDraggable(target) {
        const { options } = target;
        return !!(options.canDrag && options.canDrag(options.context.data));
    }
    _isDroppable(target) {
        // TODO: take the drag item into consideration to prevent dragging an item into the same group
        const { options } = target;
        const dragContext = this._dragData && this._dragData.dragTarget ? this._dragData.dragTarget.options.context : undefined;
        return !!(options.canDrop && options.canDrop(options.context, dragContext));
    }
}

const MOUSEDOWN_PRIMARY_BUTTON$1 = 0; // for mouse down event we are using ev.button property, 0 means left button
const getClassNames$B = classNamesFunction();
const TRANSITION_DURATION_DRAG = 200; // ms
const TRANSITION_DURATION_DROP = 1500; // ms
const CLASSNAME_ADD_INTERVAL = 20; // ms
class DetailsColumnBase extends BaseComponent {
    constructor(props) {
        super(props);
        this._onRenderColumnHeaderTooltip = (tooltipHostProps, defaultRender) => {
            return createElement("span", { className: tooltipHostProps.hostClassName }, tooltipHostProps.children);
        };
        this._onRootMouseDown = (ev) => {
            const { isDraggable } = this.props;
            // Ignore anything except the primary button.
            if (isDraggable && ev.button === MOUSEDOWN_PRIMARY_BUTTON$1) {
                ev.stopPropagation();
            }
        };
        this._root = createRef();
        this._onDragStart = this._onDragStart.bind(this);
        this._onDragEnd = this._onDragEnd.bind(this);
        this._onRootMouseDown = this._onRootMouseDown.bind(this);
        this._updateHeaderDragInfo = this._updateHeaderDragInfo.bind(this);
    }
    render() {
        const { column, columnIndex, parentId, isDraggable, styles, theme, cellStyleProps = DEFAULT_CELL_STYLE_PROPS } = this.props;
        const { onRenderColumnHeaderTooltip = this._onRenderColumnHeaderTooltip } = this.props;
        this._classNames = getClassNames$B(styles, {
            theme: theme,
            headerClassName: column.headerClassName,
            iconClassName: column.iconClassName,
            isActionable: column.columnActionsMode !== ColumnActionsMode.disabled,
            isEmpty: !column.name,
            isIconVisible: column.isSorted || column.isGrouped || column.isFiltered,
            isPadded: column.isPadded,
            isIconOnly: column.isIconOnly,
            cellStyleProps,
            transitionDurationDrag: TRANSITION_DURATION_DRAG,
            transitionDurationDrop: TRANSITION_DURATION_DROP
        });
        const classNames = this._classNames;
        return (createElement(Fragment, null,
            createElement("div", { key: column.key, ref: this._root, role: 'columnheader', "aria-sort": column.isSorted ? (column.isSortedDescending ? 'descending' : 'ascending') : 'none', "aria-colindex": columnIndex, className: classNames.root, "data-is-draggable": isDraggable, draggable: isDraggable, style: {
                    width: column.calculatedWidth +
                        cellStyleProps.cellLeftPadding +
                        cellStyleProps.cellRightPadding +
                        (column.isPadded ? cellStyleProps.cellExtraRightPadding : 0)
                }, "data-automationid": 'ColumnsHeaderColumn', "data-item-key": column.key },
                isDraggable && createElement(Icon, { iconName: "GripperBarVertical", className: classNames.gripperBarVerticalStyle }),
                onRenderColumnHeaderTooltip({
                    hostClassName: classNames.cellTooltip,
                    id: `${parentId}-${column.key}-tooltip`,
                    setAriaDescribedBy: false,
                    content: column.columnActionsMode !== ColumnActionsMode.disabled ? column.ariaLabel : '',
                    children: (createElement("span", { id: `${parentId}-${column.key}`, "aria-label": column.isIconOnly ? column.name : undefined, "aria-labelledby": column.isIconOnly ? undefined : `${parentId}-${column.key}-name `, className: classNames.cellTitle, "data-is-focusable": column.columnActionsMode !== ColumnActionsMode.disabled, role: column.columnActionsMode !== ColumnActionsMode.disabled &&
                            (column.onColumnClick !== undefined || this.props.onColumnClick !== undefined)
                            ? 'button'
                            : undefined, "aria-describedby": !this.props.onRenderColumnHeaderTooltip && this._hasAccessibleLabel() ? `${parentId}-${column.key}-tooltip` : undefined, onContextMenu: this._onColumnContextMenu.bind(this, column), onClick: this._onColumnClick.bind(this, column), "aria-haspopup": column.columnActionsMode === ColumnActionsMode.hasDropdown },
                        createElement("span", { id: `${parentId}-${column.key}-name`, className: classNames.cellName },
                            (column.iconName || column.iconClassName) && createElement(Icon, { className: classNames.iconClassName, iconName: column.iconName }),
                            column.isIconOnly ? createElement("span", { className: classNames.accessibleLabel }, column.name) : column.name),
                        column.isFiltered && createElement(Icon, { className: classNames.nearIcon, iconName: 'Filter' }),
                        column.isSorted && createElement(Icon, { className: classNames.sortIcon, iconName: column.isSortedDescending ? 'SortDown' : 'SortUp' }),
                        column.isGrouped && createElement(Icon, { className: classNames.nearIcon, iconName: 'GroupedDescending' }),
                        column.columnActionsMode === ColumnActionsMode.hasDropdown && !column.isIconOnly && (createElement(Icon, { "aria-hidden": true, className: classNames.filterChevron, iconName: 'ChevronDown' }))))
                }, this._onRenderColumnHeaderTooltip)),
            !this.props.onRenderColumnHeaderTooltip ? this._renderAccessibleLabel() : null));
    }
    componentDidMount() {
        if (this._dragDropSubscription) {
            this._dragDropSubscription.dispose();
            delete this._dragDropSubscription;
        }
        if (this.props.dragDropHelper && this.props.isDraggable) {
            this._dragDropSubscription = this.props.dragDropHelper.subscribe(this._root.current, this._events, this._getColumnDragDropOptions());
            // We need to use native on this to avoid MarqueeSelection from handling the event before us.
            this._events.on(this._root.current, 'mousedown', this._onRootMouseDown);
        }
        const classNames = this._classNames;
        if (this.props.isDropped) {
            if (this._root.current) {
                this._root.current.classList.add(classNames.borderAfterDropping);
                this._async.setTimeout(() => {
                    if (this._root.current) {
                        this._root.current.classList.add(classNames.noBorderAfterDropping);
                    }
                }, CLASSNAME_ADD_INTERVAL);
            }
            this._async.setTimeout(() => {
                if (this._root.current) {
                    this._root.current.classList.remove(classNames.borderAfterDropping);
                    this._root.current.classList.remove(classNames.noBorderAfterDropping);
                }
            }, TRANSITION_DURATION_DROP + CLASSNAME_ADD_INTERVAL);
        }
    }
    componentWillUnmount() {
        if (this._dragDropSubscription) {
            this._dragDropSubscription.dispose();
            delete this._dragDropSubscription;
        }
    }
    componentDidUpdate() {
        if (!this._dragDropSubscription && this.props.dragDropHelper && this.props.isDraggable) {
            this._dragDropSubscription = this.props.dragDropHelper.subscribe(this._root.current, this._events, this._getColumnDragDropOptions());
            // We need to use native on this to avoid MarqueeSelection from handling the event before us.
            this._events.on(this._root.current, 'mousedown', this._onRootMouseDown);
        }
        if (this._dragDropSubscription && !this.props.isDraggable) {
            this._dragDropSubscription.dispose();
            this._events.off(this._root.current, 'mousedown');
            delete this._dragDropSubscription;
        }
    }
    _onColumnClick(column, ev) {
        if (column.columnActionsMode === ColumnActionsMode.disabled) {
            return;
        }
        const { onColumnClick } = this.props;
        if (column.onColumnClick) {
            column.onColumnClick(ev, column);
        }
        if (onColumnClick) {
            onColumnClick(ev, column);
        }
    }
    _getColumnDragDropOptions() {
        const { columnIndex } = this.props;
        const options = {
            selectionIndex: columnIndex,
            context: { data: columnIndex, index: columnIndex },
            canDrag: () => this.props.isDraggable,
            canDrop: () => false,
            onDragStart: this._onDragStart,
            updateDropState: () => undefined,
            onDrop: () => undefined,
            onDragEnd: this._onDragEnd
        };
        return options;
    }
    _hasAccessibleLabel() {
        const { column } = this.props;
        return !!(column.ariaLabel ||
            column.filterAriaLabel ||
            column.sortAscendingAriaLabel ||
            column.sortDescendingAriaLabel ||
            column.groupAriaLabel);
    }
    _renderAccessibleLabel() {
        const { column, parentId } = this.props;
        const classNames = this._classNames;
        return this._hasAccessibleLabel() && !this.props.onRenderColumnHeaderTooltip ? (createElement("label", { key: `${column.key}_label`, id: `${parentId}-${column.key}-tooltip`, className: classNames.accessibleLabel },
            column.ariaLabel,
            (column.isFiltered && column.filterAriaLabel) || null,
            (column.isSorted && (column.isSortedDescending ? column.sortDescendingAriaLabel : column.sortAscendingAriaLabel)) || null,
            (column.isGrouped && column.groupAriaLabel) || null)) : null;
    }
    _onDragStart(item, itemIndex, selectedItems, event) {
        const classNames = this._classNames;
        if (itemIndex) {
            this._updateHeaderDragInfo(itemIndex);
            this._root.current.classList.add(classNames.borderWhileDragging);
            this._async.setTimeout(() => {
                if (this._root.current) {
                    this._root.current.classList.add(classNames.noBorderWhileDragging);
                }
            }, CLASSNAME_ADD_INTERVAL);
        }
    }
    _onDragEnd(item, event) {
        const classNames = this._classNames;
        if (event) {
            this._updateHeaderDragInfo(-1, event);
        }
        this._root.current.classList.remove(classNames.borderWhileDragging);
        this._root.current.classList.remove(classNames.noBorderWhileDragging);
    }
    _updateHeaderDragInfo(itemIndex, event) {
        if (this.props.setDraggedItemIndex) {
            this.props.setDraggedItemIndex(itemIndex);
        }
        if (this.props.updateDragInfo) {
            this.props.updateDragInfo({ itemIndex }, event);
        }
    }
    _onColumnContextMenu(column, ev) {
        const { onColumnContextMenu } = this.props;
        if (column.onColumnContextMenu) {
            column.onColumnContextMenu(column, ev);
            ev.preventDefault();
        }
        if (onColumnContextMenu) {
            onColumnContextMenu(column, ev);
            ev.preventDefault();
        }
    }
}

const GlobalClassNames$p = {
    isActionable: 'is-actionable',
    cellIsCheck: 'ms-DetailsHeader-cellIsCheck',
    collapseButton: 'ms-DetailsHeader-collapseButton',
    isCollapsed: 'is-collapsed',
    isAllSelected: 'is-allSelected',
    isSelectAllHidden: 'is-selectAllHidden',
    isResizingColumn: 'is-resizingColumn',
    isEmpty: 'is-empty',
    isIconVisible: 'is-icon-visible',
    cellSizer: 'ms-DetailsHeader-cellSizer',
    isResizing: 'is-resizing',
    dropHintCircleStyle: 'ms-DetailsHeader-dropHintCircleStyle',
    dropHintLineStyle: 'ms-DetailsHeader-dropHintLineStyle',
    cellTitle: 'ms-DetailsHeader-cellTitle',
    cellName: 'ms-DetailsHeader-cellName',
    filterChevron: 'ms-DetailsHeader-filterChevron',
    gripperBarVerticalStyle: 'ms-DetailsColumn-gripperBar'
};
const getStyles$J = (props) => {
    const { theme, headerClassName, iconClassName, isActionable, isEmpty, isIconVisible, isPadded, isIconOnly, cellStyleProps = DEFAULT_CELL_STYLE_PROPS, transitionDurationDrag, transitionDurationDrop } = props;
    const { semanticColors, palette } = theme;
    const classNames = getGlobalClassNames(GlobalClassNames$p, theme);
    const colors = {
        iconForegroundColor: semanticColors.bodySubtext,
        headerForegroundColor: semanticColors.bodyText,
        headerBackgroundColor: semanticColors.bodyBackground,
        dropdownChevronForegroundColor: palette.neutralTertiary,
        resizerColor: palette.neutralTertiaryAlt
    };
    const nearIconStyle = {
        color: colors.iconForegroundColor,
        opacity: 1,
        paddingLeft: 8
    };
    const borderWhileDragging = [
        {
            borderStyle: 'solid',
            borderWidth: 1,
            borderColor: palette.themePrimary
        }
    ];
    const borderAfterDragOrDrop = [
        {
            borderColor: 'transparent'
        }
    ];
    return {
        root: [
            getCellStyles(props),
            headerClassName,
            theme.fonts.small,
            isActionable && [
                classNames.isActionable,
                {
                    selectors: {
                        ':hover': {
                            color: semanticColors.bodyText,
                            background: semanticColors.listHeaderBackgroundHovered
                        },
                        ':active': {
                            background: semanticColors.listHeaderBackgroundPressed
                        }
                    }
                }
            ],
            isEmpty && [
                classNames.isEmpty,
                {
                    textOverflow: 'clip'
                }
            ],
            isIconVisible && classNames.isIconVisible,
            isPadded && {
                paddingRight: cellStyleProps.cellExtraRightPadding + cellStyleProps.cellRightPadding
            },
            {
                selectors: {
                    ':hover i[data-icon-name="GripperBarVertical"]': {
                        display: 'block'
                    }
                }
            }
        ],
        gripperBarVerticalStyle: [
            {
                display: 'none',
                position: 'absolute',
                textAlign: 'left',
                color: palette.neutralTertiary,
                left: 1
            }
        ],
        nearIcon: nearIconStyle,
        sortIcon: [
            nearIconStyle,
            {
                paddingLeft: 4,
                position: 'relative',
                top: 1
            }
        ],
        iconClassName: [
            {
                color: colors.iconForegroundColor,
                opacity: 1
            },
            iconClassName
        ],
        filterChevron: [
            classNames.filterChevron,
            {
                color: colors.dropdownChevronForegroundColor,
                paddingLeft: 4,
                verticalAlign: 'middle'
            }
        ],
        cellTitle: [
            classNames.cellTitle,
            getFocusStyle(theme),
            {
                display: 'flex',
                flexDirection: 'row',
                justifyContent: 'flex-start',
                alignItems: 'stretch',
                boxSizing: 'border-box',
                overflow: 'hidden',
                padding: `0 ${cellStyleProps.cellRightPadding}px 0 ${cellStyleProps.cellLeftPadding}px`,
                ...(isIconOnly
                    ? {
                        alignContent: 'flex-end',
                        maxHeight: '100%',
                        flexWrap: 'wrap-reverse'
                    }
                    : {})
            }
        ],
        cellName: [
            classNames.cellName,
            {
                flex: '0 1 auto',
                overflow: 'hidden',
                textOverflow: 'ellipsis'
            },
            isIconOnly && {
                selectors: {
                    $nearIcon: {
                        paddingLeft: 0
                    }
                }
            }
        ],
        cellTooltip: [
            {
                display: 'block',
                position: 'absolute',
                top: 0,
                left: 0,
                bottom: 0,
                right: 0
            }
        ],
        accessibleLabel: [hiddenContentStyle],
        borderWhileDragging: borderWhileDragging,
        noBorderWhileDragging: [borderAfterDragOrDrop, { transition: `border-color  ${transitionDurationDrag}ms ease` }],
        borderAfterDropping: [borderWhileDragging, { left: -1, lineHeight: 31 }],
        noBorderAfterDropping: [borderAfterDragOrDrop, { transition: `border-color  ${transitionDurationDrop}ms ease` }]
    };
};

const DetailsColumn = styled(DetailsColumnBase, getStyles$J, undefined, { scope: 'DetailsColumn' });

var SelectAllVisibility;
(function (SelectAllVisibility) {
    SelectAllVisibility[SelectAllVisibility["none"] = 0] = "none";
    SelectAllVisibility[SelectAllVisibility["hidden"] = 1] = "hidden";
    SelectAllVisibility[SelectAllVisibility["visible"] = 2] = "visible";
})(SelectAllVisibility || (SelectAllVisibility = {}));

const getClassNames$C = classNamesFunction();
const MOUSEDOWN_PRIMARY_BUTTON$2 = 0; // for mouse down event we are using ev.button property, 0 means left button
const MOUSEMOVE_PRIMARY_BUTTON$1 = 1; // for mouse move event we are using ev.buttons property, 1 means left button
const NO_COLUMNS = [];
class DetailsHeaderBase extends BaseComponent {
    constructor(props) {
        super(props);
        this._rootComponent = createRef();
        this._draggedColumnIndex = -1;
        this._dropHintDetails = {};
        this._getDropHintPositions = () => {
            const { columns = NO_COLUMNS } = this.props;
            const { columnReorderProps } = this.state;
            let prevX = 0;
            let prevMid = 0;
            let prevRef;
            const frozenColumnCountFromStart = columnReorderProps && columnReorderProps.frozenColumnCountFromStart ? columnReorderProps.frozenColumnCountFromStart : 0;
            const frozenColumnCountFromEnd = columnReorderProps && columnReorderProps.frozenColumnCountFromEnd ? columnReorderProps.frozenColumnCountFromEnd : 0;
            for (let i = frozenColumnCountFromStart; i < columns.length - frozenColumnCountFromEnd + 1; i++) {
                if (this._rootElement) {
                    const dropHintElement = this._rootElement.querySelectorAll('#columnDropHint_' + i)[0];
                    if (dropHintElement) {
                        if (i === frozenColumnCountFromStart) {
                            prevX = dropHintElement.offsetLeft;
                            prevMid = dropHintElement.offsetLeft;
                            prevRef = dropHintElement;
                        }
                        else {
                            const newMid = (dropHintElement.offsetLeft + prevX) / 2;
                            this._dropHintDetails[i - 1] = {
                                originX: prevX,
                                startX: prevMid,
                                endX: newMid,
                                dropHintElementRef: prevRef
                            };
                            prevMid = newMid;
                            prevRef = dropHintElement;
                            prevX = dropHintElement.offsetLeft;
                            if (i === columns.length - frozenColumnCountFromEnd) {
                                this._dropHintDetails[i] = {
                                    originX: prevX,
                                    startX: prevMid,
                                    endX: dropHintElement.offsetLeft,
                                    dropHintElementRef: prevRef
                                };
                            }
                        }
                    }
                }
            }
        };
        /**
         * Based on the given cursor position, finds the nearest drop hint and updates the state to make it visible
         *
         */
        this._computeDropHintToBeShown = (clientX) => {
            if (this._rootElement) {
                const clientRect = this._rootElement.getBoundingClientRect();
                const headerOriginX = clientRect.left;
                const eventXRelativePosition = clientX - headerOriginX;
                const currentDropHintIndex = this._currentDropHintIndex;
                if (this._isValidCurrentDropHintIndex()) {
                    if (this._liesBetween(eventXRelativePosition, this._dropHintDetails[currentDropHintIndex].startX, this._dropHintDetails[currentDropHintIndex].endX)) {
                        return;
                    }
                }
                const { columns = NO_COLUMNS } = this.props;
                const { columnReorderProps } = this.state;
                const frozenColumnCountFromStart = columnReorderProps && columnReorderProps.frozenColumnCountFromStart ? columnReorderProps.frozenColumnCountFromStart : 0;
                const frozenColumnCountFromEnd = columnReorderProps && columnReorderProps.frozenColumnCountFromEnd ? columnReorderProps.frozenColumnCountFromEnd : 0;
                const currentIndex = frozenColumnCountFromStart;
                const lastValidColumn = columns.length - frozenColumnCountFromEnd;
                let indexToUpdate = -1;
                if (this._isBefore(eventXRelativePosition, this._dropHintDetails[currentIndex].endX)) {
                    indexToUpdate = currentIndex;
                }
                else if (this._isAfter(eventXRelativePosition, this._dropHintDetails[lastValidColumn].startX)) {
                    indexToUpdate = lastValidColumn;
                }
                else if (this._isValidCurrentDropHintIndex()) {
                    if (this._dropHintDetails[currentDropHintIndex + 1] &&
                        this._liesBetween(eventXRelativePosition, this._dropHintDetails[currentDropHintIndex + 1].startX, this._dropHintDetails[currentDropHintIndex + 1].endX)) {
                        indexToUpdate = currentDropHintIndex + 1;
                    }
                    else if (this._dropHintDetails[currentDropHintIndex - 1] &&
                        this._liesBetween(eventXRelativePosition, this._dropHintDetails[currentDropHintIndex - 1].startX, this._dropHintDetails[currentDropHintIndex - 1].endX)) {
                        indexToUpdate = currentDropHintIndex - 1;
                    }
                }
                if (indexToUpdate === -1) {
                    let startIndex = frozenColumnCountFromStart;
                    let endIndex = lastValidColumn;
                    while (startIndex < endIndex) {
                        const middleIndex = Math.ceil((endIndex + startIndex) / 2);
                        if (this._liesBetween(eventXRelativePosition, this._dropHintDetails[middleIndex].startX, this._dropHintDetails[middleIndex].endX)) {
                            indexToUpdate = middleIndex;
                            break;
                        }
                        else if (this._isBefore(eventXRelativePosition, this._dropHintDetails[middleIndex].originX)) {
                            endIndex = middleIndex;
                        }
                        else if (this._isAfter(eventXRelativePosition, this._dropHintDetails[middleIndex].originX)) {
                            startIndex = middleIndex;
                        }
                    }
                }
                if (indexToUpdate === this._draggedColumnIndex || indexToUpdate === this._draggedColumnIndex + 1) {
                    if (this._isValidCurrentDropHintIndex()) {
                        this._resetDropHints();
                    }
                }
                else if (currentDropHintIndex !== indexToUpdate && indexToUpdate >= 0) {
                    this._resetDropHints();
                    this._updateDropHintElement(this._dropHintDetails[indexToUpdate].dropHintElementRef, 'inline-block');
                    this._currentDropHintIndex = indexToUpdate;
                }
            }
        };
        this._renderColumnSizer = ({ columnIndex }) => {
            const { columns = NO_COLUMNS } = this.props;
            const column = columns[columnIndex];
            const { columnResizeDetails } = this.state;
            const classNames = this._classNames;
            return column.isResizable ? (createElement("div", { key: `${column.key}_sizer`, "aria-hidden": true, role: "button", "data-is-focusable": false, onClick: stopPropagation, "data-sizer-index": columnIndex, onBlur: this._onSizerBlur, className: css(classNames.cellSizer, columnIndex < columns.length - 1 ? classNames.cellSizerStart : classNames.cellSizerEnd, {
                    [classNames.cellIsResizing]: columnResizeDetails && columnResizeDetails.columnIndex === columnIndex
                }), onDoubleClick: this._onSizerDoubleClick.bind(this, columnIndex) })) : null;
        };
        this._onRenderColumnHeaderTooltip = (tooltipHostProps, defaultRender) => {
            return createElement("span", { className: tooltipHostProps.hostClassName }, tooltipHostProps.children);
        };
        /**
         * Called when the select all toggle is clicked.
         */
        this._onSelectAllClicked = () => {
            const { selection } = this.props;
            if (selection) {
                selection.toggleAllSelected();
            }
        };
        this._onRootMouseDown = (ev) => {
            const columnIndexAttr = ev.target.getAttribute('data-sizer-index');
            const columnIndex = Number(columnIndexAttr);
            const { columns = NO_COLUMNS } = this.props;
            if (columnIndexAttr === null || ev.button !== MOUSEDOWN_PRIMARY_BUTTON$2) {
                // Ignore anything except the primary button.
                return;
            }
            this.setState({
                columnResizeDetails: {
                    columnIndex: columnIndex,
                    columnMinWidth: columns[columnIndex].calculatedWidth,
                    originX: ev.clientX
                }
            });
            ev.preventDefault();
            ev.stopPropagation();
        };
        this._onRootMouseMove = (ev) => {
            const { columnResizeDetails, isSizing } = this.state;
            if (columnResizeDetails && !isSizing && ev.clientX !== columnResizeDetails.originX) {
                this.setState({ isSizing: true });
            }
        };
        this._onRootRef = (focusZone) => {
            if (focusZone) {
                // Need to resolve the actual DOM node, not the component. The element itself will be used for drag/drop and focusing.
                this._rootElement = findDOMNode(focusZone);
            }
            else {
                this._rootElement = undefined;
            }
        };
        this._onRootKeyDown = (ev) => {
            const { columnResizeDetails, isSizing } = this.state;
            const { columns = NO_COLUMNS, onColumnResized } = this.props;
            const columnIndexAttr = ev.target.getAttribute('data-sizer-index');
            if (!columnIndexAttr || isSizing) {
                return;
            }
            const columnIndex = Number(columnIndexAttr);
            if (!columnResizeDetails) {
                if (ev.which === KeyCodes.enter) {
                    this.setState({
                        columnResizeDetails: {
                            columnIndex: columnIndex,
                            columnMinWidth: columns[columnIndex].calculatedWidth
                        }
                    });
                    ev.preventDefault();
                    ev.stopPropagation();
                }
            }
            else {
                let increment;
                if (ev.which === KeyCodes.enter) {
                    this.setState({
                        columnResizeDetails: undefined
                    });
                    ev.preventDefault();
                    ev.stopPropagation();
                }
                else if (ev.which === KeyCodes.left) {
                    increment = getRTL() ? 1 : -1;
                }
                else if (ev.which === KeyCodes.right) {
                    increment = getRTL() ? -1 : 1;
                }
                if (increment) {
                    if (!ev.shiftKey) {
                        increment *= 10;
                    }
                    this.setState({
                        columnResizeDetails: {
                            ...columnResizeDetails,
                            columnMinWidth: columnResizeDetails.columnMinWidth + increment
                        }
                    });
                    if (onColumnResized) {
                        onColumnResized(columns[columnIndex], columnResizeDetails.columnMinWidth + increment, columnIndex);
                    }
                    ev.preventDefault();
                    ev.stopPropagation();
                }
            }
        };
        /**
         * mouse move event handler in the header
         * it will set isSizing state to true when user clicked on the sizer and move the mouse.
         *
         * @private
         * @param {React.MouseEvent} ev (mouse move event)
         */
        this._onSizerMouseMove = (ev) => {
            const { 
            // use buttons property here since ev.button in some edge case is not upding well during the move.
            // but firefox doesn't support it, so we set the default value when it is not defined.
            buttons } = ev;
            const { onColumnIsSizingChanged, onColumnResized, columns = NO_COLUMNS } = this.props;
            const { columnResizeDetails } = this.state;
            if (buttons !== undefined && buttons !== MOUSEMOVE_PRIMARY_BUTTON$1) {
                // cancel mouse down event and return early when the primary button is not pressed
                this._onSizerMouseUp(ev);
                return;
            }
            if (ev.clientX !== columnResizeDetails.originX) {
                if (onColumnIsSizingChanged) {
                    onColumnIsSizingChanged(columns[columnResizeDetails.columnIndex], true);
                }
            }
            if (onColumnResized) {
                let movement = ev.clientX - columnResizeDetails.originX;
                if (getRTL()) {
                    movement = -movement;
                }
                onColumnResized(columns[columnResizeDetails.columnIndex], columnResizeDetails.columnMinWidth + movement, columnResizeDetails.columnIndex);
            }
        };
        this._onSizerBlur = (ev) => {
            const { columnResizeDetails } = this.state;
            if (columnResizeDetails) {
                this.setState({
                    columnResizeDetails: undefined,
                    isSizing: false
                });
            }
        };
        /**
         * mouse up event handler in the header
         * clear the resize related state.
         * This is to ensure we can catch double click event
         *
         * @private
         * @param {React.MouseEvent} ev (mouse up event)
         */
        this._onSizerMouseUp = (ev) => {
            const { columns = NO_COLUMNS, onColumnIsSizingChanged } = this.props;
            const { columnResizeDetails } = this.state;
            this.setState({
                columnResizeDetails: undefined,
                isSizing: false
            });
            if (onColumnIsSizingChanged) {
                onColumnIsSizingChanged(columns[columnResizeDetails.columnIndex], false);
            }
        };
        const columnReorderProps = props.columnReorderProps || (props.columnReorderOptions && getLegacyColumnReorderProps(props.columnReorderOptions));
        this.state = {
            columnReorderProps,
            columnResizeDetails: undefined,
            groupNestingDepth: this.props.groupNestingDepth,
            isAllCollapsed: this.props.isAllCollapsed,
            isAllSelected: !!this.props.selection && this.props.selection.isAllSelected()
        };
        this._onToggleCollapseAll = this._onToggleCollapseAll.bind(this);
        this._onSelectAllClicked = this._onSelectAllClicked.bind(this);
        this._updateDragInfo = this._updateDragInfo.bind(this);
        this._onDragOver = this._onDragOver.bind(this);
        this._onDrop = this._onDrop.bind(this);
        this._getHeaderDragDropOptions = this._getHeaderDragDropOptions.bind(this);
        this._updateDroppingState = this._updateDroppingState.bind(this);
        this._getDropHintPositions = this._getDropHintPositions.bind(this);
        this._computeDropHintToBeShown = this._computeDropHintToBeShown.bind(this);
        this._resetDropHints = this._resetDropHints.bind(this);
        this._isValidCurrentDropHintIndex = this._isValidCurrentDropHintIndex.bind(this);
        this._onRootRef = this._onRootRef.bind(this);
        this._isEventOnHeader = this._isEventOnHeader.bind(this);
        this._onDropIndexInfo = {
            sourceIndex: Number.MIN_SAFE_INTEGER,
            targetIndex: Number.MIN_SAFE_INTEGER
        };
        this._id = getId('header');
        this._currentDropHintIndex = Number.MIN_SAFE_INTEGER;
    }
    componentDidMount() {
        const { selection } = this.props;
        const { columnReorderProps } = this.state;
        this._events.on(selection, SELECTION_CHANGE, this._onSelectionChanged);
        // We need to use native on this to avoid MarqueeSelection from handling the event before us.
        this._events.on(this._rootElement, 'mousedown', this._onRootMouseDown);
        this._events.on(this._rootElement, 'keydown', this._onRootKeyDown);
        if (columnReorderProps && this._dragDropHelper) {
            this._subscriptionObject = this._dragDropHelper.subscribe(this._rootElement, this._events, this._getHeaderDragDropOptions());
        }
    }
    componentDidUpdate(prevProps) {
        const { columnReorderProps } = this.state;
        if (!columnReorderProps) {
            if (this._subscriptionObject) {
                this._subscriptionObject.dispose();
                delete this._subscriptionObject;
            }
        }
        else if (!this._subscriptionObject && this._dragDropHelper) {
            this._subscriptionObject = this._dragDropHelper.subscribe(this._rootElement, this._events, this._getHeaderDragDropOptions());
        }
        if (this.props !== prevProps && this._onDropIndexInfo.sourceIndex >= 0 && this._onDropIndexInfo.targetIndex >= 0) {
            const { columns: previousColumns = NO_COLUMNS } = prevProps;
            const { columns = NO_COLUMNS } = this.props;
            if (previousColumns[this._onDropIndexInfo.sourceIndex].key === columns[this._onDropIndexInfo.targetIndex].key) {
                this._onDropIndexInfo = {
                    sourceIndex: Number.MIN_SAFE_INTEGER,
                    targetIndex: Number.MIN_SAFE_INTEGER
                };
            }
        }
    }
    componentWillReceiveProps(newProps) {
        const columnReorderProps = newProps.columnReorderProps || (newProps.columnReorderOptions && getLegacyColumnReorderProps(newProps.columnReorderOptions));
        const { groupNestingDepth } = this.state;
        if (newProps.groupNestingDepth !== groupNestingDepth) {
            this.setState({
                columnReorderProps,
                groupNestingDepth: newProps.groupNestingDepth
            });
        }
        else {
            this.setState({ columnReorderProps });
        }
        if (newProps.isAllCollapsed !== undefined) {
            this.setState({
                isAllCollapsed: newProps.isAllCollapsed
            });
        }
    }
    componentWillUnmount() {
        if (this._subscriptionObject) {
            this._subscriptionObject.dispose();
            delete this._subscriptionObject;
        }
    }
    render() {
        const { columns = NO_COLUMNS, ariaLabel, ariaLabelForSelectAllCheckbox, selectAllVisibility, ariaLabelForSelectionColumn, indentWidth, viewport, onColumnClick, onColumnContextMenu, onRenderColumnHeaderTooltip = this._onRenderColumnHeaderTooltip, styles, theme } = this.props;
        const { isAllSelected, columnResizeDetails, isSizing, groupNestingDepth, isAllCollapsed, columnReorderProps } = this.state;
        const showCheckbox = selectAllVisibility !== SelectAllVisibility.none;
        const isCheckboxHidden = selectAllVisibility === SelectAllVisibility.hidden;
        if (!this._dragDropHelper && columnReorderProps) {
            this._dragDropHelper = new DragDropHelper({
                selection: {
                    getSelection: () => {
                        return;
                    }
                },
                minimumPixelsForDrag: this.props.minimumPixelsForDrag
            });
        }
        const frozenColumnCountFromStart = columnReorderProps && columnReorderProps.frozenColumnCountFromStart ? columnReorderProps.frozenColumnCountFromStart : 0;
        const frozenColumnCountFromEnd = columnReorderProps && columnReorderProps.frozenColumnCountFromEnd ? columnReorderProps.frozenColumnCountFromEnd : 0;
        this._classNames = getClassNames$C(styles, {
            theme: theme,
            isAllSelected,
            isSelectAllHidden: selectAllVisibility === SelectAllVisibility.hidden,
            isResizingColumn: !!columnResizeDetails && isSizing,
            isSizing,
            isAllCollapsed,
            isCheckboxHidden
        });
        const classNames = this._classNames;
        const isRTL = getRTL();
        return (createElement(FocusZone, { role: "row", "aria-label": ariaLabel, className: classNames.root, componentRef: this._rootComponent, ref: this._onRootRef, onMouseMove: this._onRootMouseMove, "data-automationid": "DetailsHeader", style: { minWidth: viewport ? viewport.width : 0 }, direction: FocusZoneDirection.horizontal },
            showCheckbox
                ? [
                    createElement("div", { key: "__checkbox", className: classNames.cellIsCheck, "aria-labelledby": `${this._id}-check`, onClick: !isCheckboxHidden ? this._onSelectAllClicked : undefined, "aria-colindex": 1, role: 'columnheader', "aria-hidden": isCheckboxHidden ? true : undefined }, onRenderColumnHeaderTooltip({
                        hostClassName: css(classNames.checkTooltip),
                        id: `${this._id}-checkTooltip`,
                        setAriaDescribedBy: false,
                        content: ariaLabelForSelectAllCheckbox,
                        children: (createElement(DetailsRowCheck, { id: `${this._id}-check`, "aria-label": ariaLabelForSelectionColumn, "aria-describedby": ariaLabelForSelectAllCheckbox && !this.props.onRenderColumnHeaderTooltip ? `${this._id}-checkTooltip` : undefined, "data-is-focusable": !isCheckboxHidden, isHeader: true, selected: isAllSelected, anySelected: false, canSelect: !isCheckboxHidden, className: classNames.check }))
                    }, this._onRenderColumnHeaderTooltip)),
                    ariaLabelForSelectAllCheckbox && !this.props.onRenderColumnHeaderTooltip ? (createElement("label", { key: "__checkboxLabel", id: `${this._id}-checkTooltip`, className: classNames.accessibleLabel }, ariaLabelForSelectAllCheckbox)) : null
                ]
                : null,
            groupNestingDepth > 0 && this.props.collapseAllVisibility === CollapseAllVisibility.visible ? (createElement("div", { className: classNames.cellIsGroupExpander, onClick: this._onToggleCollapseAll, "data-is-focusable": true },
                createElement(Icon, { className: classNames.collapseButton, iconName: isRTL ? 'ChevronLeftMed' : 'ChevronRightMed' }))) : null,
            createElement(GroupSpacer, { indentWidth: indentWidth, count: groupNestingDepth - 1 }),
            columns.map((column, columnIndex) => {
                const _isDraggable = columnReorderProps
                    ? columnIndex >= frozenColumnCountFromStart && columnIndex < columns.length - frozenColumnCountFromEnd
                    : false;
                return [
                    columnReorderProps &&
                        (_isDraggable || columnIndex === columns.length - frozenColumnCountFromEnd) &&
                        this._renderDropHint(columnIndex),
                    createElement(DetailsColumn, { column: column, key: column.key, columnIndex: (showCheckbox ? 2 : 1) + columnIndex, parentId: this._id, isDraggable: _isDraggable, updateDragInfo: this._updateDragInfo, dragDropHelper: this._dragDropHelper, onColumnClick: onColumnClick, onColumnContextMenu: onColumnContextMenu, 
                        // Do not render tooltips by default, but allow for override via props.
                        onRenderColumnHeaderTooltip: this.props.onRenderColumnHeaderTooltip, isDropped: this._onDropIndexInfo.targetIndex === columnIndex, cellStyleProps: this.props.cellStyleProps }),
                    this._renderColumnDivider(columnIndex)
                ];
            }),
            columnReorderProps && frozenColumnCountFromEnd === 0 && this._renderDropHint(columns.length),
            isSizing && (createElement(Layer, null,
                createElement("div", { className: classNames.sizingOverlay, onMouseMove: this._onSizerMouseMove, onMouseUp: this._onSizerMouseUp })))));
    }
    /** Set focus to the active thing in the focus area. */
    focus() {
        return Boolean(this._rootComponent.current && this._rootComponent.current.focus());
    }
    _getHeaderDragDropOptions() {
        const options = {
            selectionIndex: 1,
            context: { data: this, index: 0 },
            canDrag: () => false,
            canDrop: () => true,
            onDragStart: () => undefined,
            updateDropState: this._updateDroppingState,
            onDrop: this._onDrop,
            onDragEnd: () => undefined,
            onDragOver: this._onDragOver
        };
        return options;
    }
    _updateDroppingState(newValue, event) {
        if (this._draggedColumnIndex >= 0 && event.type !== 'drop') {
            if (!newValue) {
                this._resetDropHints();
            }
        }
    }
    _isValidCurrentDropHintIndex() {
        return this._currentDropHintIndex >= 0;
    }
    _onDragOver(item, event) {
        if (this._draggedColumnIndex >= 0) {
            event.stopPropagation();
            this._computeDropHintToBeShown(event.clientX);
        }
    }
    _onDrop(item, event) {
        const { columnReorderProps } = this.state;
        // Target index will not get changed if draggeditem is after target item.
        if (this._draggedColumnIndex >= 0 && event) {
            const targetIndex = this._draggedColumnIndex > this._currentDropHintIndex ? this._currentDropHintIndex : this._currentDropHintIndex - 1;
            let isValidDrop = false;
            event.stopPropagation();
            if (this._isValidCurrentDropHintIndex()) {
                isValidDrop = true;
                this._onDropIndexInfo.sourceIndex = this._draggedColumnIndex;
                this._onDropIndexInfo.targetIndex = targetIndex;
            }
            if (isValidDrop) {
                if (columnReorderProps && columnReorderProps.onColumnDrop) {
                    const dragDropDetails = {
                        draggedIndex: this._draggedColumnIndex,
                        targetIndex: targetIndex
                    };
                    columnReorderProps.onColumnDrop(dragDropDetails);
                }
                else if (columnReorderProps && columnReorderProps.handleColumnReorder) {
                    columnReorderProps.handleColumnReorder(this._draggedColumnIndex, targetIndex);
                }
            }
        }
        this._resetDropHints();
        this._dropHintDetails = {};
        this._draggedColumnIndex = -1;
    }
    /**
     * @returns whether or not the "Select All" checkbox column is hidden.
     */
    _isCheckboxColumnHidden() {
        const { selectionMode, checkboxVisibility } = this.props;
        return selectionMode === SelectionMode.none || checkboxVisibility === CheckboxVisibility.hidden;
    }
    _updateDragInfo(props, event) {
        const { columnReorderProps } = this.state;
        const itemIndex = props.itemIndex;
        if (itemIndex >= 0) {
            // Column index is set based on the checkbox
            this._draggedColumnIndex = this._isCheckboxColumnHidden() ? itemIndex - 1 : itemIndex - 2;
            this._getDropHintPositions();
            if (columnReorderProps && columnReorderProps.onColumnDragStart) {
                columnReorderProps.onColumnDragStart(true);
            }
        }
        else if (event && this._draggedColumnIndex >= 0) {
            this._resetDropHints();
            this._draggedColumnIndex = -1;
            this._dropHintDetails = {};
            if (columnReorderProps && columnReorderProps.onColumnDragEnd) {
                const columnDragEndLocation = this._isEventOnHeader(event);
                columnReorderProps.onColumnDragEnd({ dropLocation: columnDragEndLocation }, event);
            }
        }
    }
    _resetDropHints() {
        if (this._currentDropHintIndex >= 0) {
            this._updateDropHintElement(this._dropHintDetails[this._currentDropHintIndex].dropHintElementRef, 'none');
            this._currentDropHintIndex = Number.MIN_SAFE_INTEGER;
        }
    }
    _updateDropHintElement(element, displayProperty) {
        element.childNodes[1].style.display = displayProperty;
        element.childNodes[0].style.display = displayProperty;
    }
    _liesBetween(target, left, right) {
        return getRTL() ? target <= left && target >= right : target >= left && target <= right;
    }
    _isBefore(a, b) {
        return getRTL() ? a >= b : a <= b;
    }
    _isAfter(a, b) {
        return getRTL() ? a <= b : a >= b;
    }
    _isEventOnHeader(event) {
        if (this._rootElement) {
            const clientRect = this._rootElement.getBoundingClientRect();
            if (event.clientX > clientRect.left &&
                event.clientX < clientRect.right &&
                event.clientY > clientRect.top &&
                event.clientY < clientRect.bottom) {
                return ColumnDragEndLocation.header;
            }
        }
    }
    _renderColumnDivider(columnIndex) {
        const { columns = NO_COLUMNS } = this.props;
        const column = columns[columnIndex];
        const { onRenderDivider } = column;
        return onRenderDivider
            ? onRenderDivider({ column, columnIndex }, this._renderColumnSizer)
            : this._renderColumnSizer({ column, columnIndex });
    }
    _renderDropHint(dropHintIndex) {
        const classNames = this._classNames;
        return (createElement("div", { key: 'dropHintKey', className: classNames.dropHintStyle, id: `columnDropHint_${dropHintIndex}` },
            createElement(Icon, { key: `dropHintCaretKey`, "aria-hidden": true, "data-is-focusable": false, "data-sizer-index": dropHintIndex, className: classNames.dropHintCaretStyle, iconName: 'CaretUpSolid8' }),
            createElement("div", { key: `dropHintLineKey`, "aria-hidden": true, "data-is-focusable": false, "data-sizer-index": dropHintIndex, className: classNames.dropHintLineStyle })));
    }
    /**
     * double click on the column sizer will auto ajust column width
     * to fit the longest content among current rendered rows.
     *
     * @private
     * @param {number} columnIndex (index of the column user double clicked)
     * @param {React.MouseEvent} ev (mouse double click event)
     */
    _onSizerDoubleClick(columnIndex, ev) {
        const { onColumnAutoResized, columns = NO_COLUMNS } = this.props;
        if (onColumnAutoResized) {
            onColumnAutoResized(columns[columnIndex], columnIndex);
        }
    }
    _onSelectionChanged() {
        const isAllSelected = !!this.props.selection && this.props.selection.isAllSelected();
        if (this.state.isAllSelected !== isAllSelected) {
            this.setState({
                isAllSelected: isAllSelected
            });
        }
    }
    _onToggleCollapseAll() {
        const { onToggleCollapseAll } = this.props;
        const newCollapsed = !this.state.isAllCollapsed;
        this.setState({
            isAllCollapsed: newCollapsed
        });
        if (onToggleCollapseAll) {
            onToggleCollapseAll(newCollapsed);
        }
    }
}
DetailsHeaderBase.defaultProps = {
    selectAllVisibility: SelectAllVisibility.visible,
    collapseAllVisibility: CollapseAllVisibility.visible
};
function getLegacyColumnReorderProps(columnReorderOptions) {
    return {
        ...columnReorderOptions,
        onColumnDragEnd: undefined
    };
}
function stopPropagation(ev) {
    ev.stopPropagation();
}

const DetailsHeader = styled(DetailsHeaderBase, getStyles$H, undefined, { scope: 'DetailsHeader' });

class DetailsRowFields extends BaseComponent {
    constructor(props) {
        super(props);
        this.state = this._getState(props);
    }
    componentWillReceiveProps(newProps) {
        this.setState(this._getState(newProps));
    }
    render() {
        const { columns, columnStartIndex, shimmer, rowClassNames, cellStyleProps = DEFAULT_CELL_STYLE_PROPS } = this.props;
        const { cellContent } = this.state;
        return (createElement("div", { className: rowClassNames.fields, "data-automationid": "DetailsRowFields", role: "presentation" }, columns.map((column, columnIndex) => {
            const width = typeof column.calculatedWidth === 'undefined'
                ? 'auto'
                : column.calculatedWidth +
                    cellStyleProps.cellLeftPadding +
                    cellStyleProps.cellRightPadding +
                    (column.isPadded ? cellStyleProps.cellExtraRightPadding : 0);
            return (createElement("div", { key: columnIndex, role: column.isRowHeader ? 'rowheader' : 'gridcell', "aria-colindex": columnIndex + columnStartIndex + 1, className: css(column.className, column.isMultiline && rowClassNames.isMultiline, column.isRowHeader && rowClassNames.isRowHeader, column.isIconOnly && shimmer && rowClassNames.shimmerIconPlaceholder, shimmer && rowClassNames.shimmer, rowClassNames.cell, column.isPadded ? rowClassNames.cellPadded : rowClassNames.cellUnpadded), style: { width }, "data-automationid": "DetailsRowCell", "data-automation-key": column.key }, cellContent[columnIndex]));
        })));
    }
    _getState(props) {
        const { item, itemIndex, onRenderItemColumn, shimmer } = props;
        return {
            cellContent: props.columns.map(column => {
                let cellContent;
                try {
                    const render = column.onRender || onRenderItemColumn;
                    cellContent = render && !shimmer ? render(item, itemIndex, column) : this._getCellText(item, column);
                }
                catch (e) {
                    /* no-op */
                }
                return cellContent;
            })
        };
    }
    _getCellText(item, column) {
        let value = item && column && column.fieldName ? item[column.fieldName] : '';
        if (value === null || value === undefined) {
            value = '';
        }
        return value;
    }
}

const getClassNames$D = classNamesFunction();
const DEFAULT_DROPPING_CSS_CLASS$1 = 'is-dropping';
const NO_COLUMNS$1 = [];
class DetailsRowBase extends BaseComponent {
    constructor(props) {
        super(props);
        this._cellMeasurer = createRef();
        this._focusZone = createRef();
        this._onRootRef = (focusZone) => {
            if (focusZone) {
                // Need to resolve the actual DOM node, not the component. The element itself will be used for drag/drop and focusing.
                this._root = findDOMNode(focusZone);
            }
            else {
                this._root = undefined;
            }
        };
        this.state = {
            selectionState: this._getSelectionState(props),
            columnMeasureInfo: undefined,
            isDropping: false,
            groupNestingDepth: props.groupNestingDepth
        };
        this._droppingClassNames = '';
        this._updateDroppingState = this._updateDroppingState.bind(this);
        this._onToggleSelection = this._onToggleSelection.bind(this);
    }
    componentDidMount() {
        const { dragDropHelper } = this.props;
        if (dragDropHelper) {
            this._dragDropSubscription = dragDropHelper.subscribe(this._root, this._events, this._getRowDragDropOptions());
        }
        this._events.on(this.props.selection, SELECTION_CHANGE, this._onSelectionChanged);
        if (this.props.onDidMount && this.props.item) {
            // If the item appears later, we should wait for it before calling this method.
            this._hasMounted = true;
            this.props.onDidMount(this);
        }
    }
    componentDidUpdate(previousProps) {
        const state = this.state;
        const { item, onDidMount } = this.props;
        const { columnMeasureInfo } = state;
        if (this.props.itemIndex !== previousProps.itemIndex ||
            this.props.item !== previousProps.item ||
            this.props.dragDropHelper !== previousProps.dragDropHelper) {
            if (this._dragDropSubscription) {
                this._dragDropSubscription.dispose();
                delete this._dragDropSubscription;
            }
            if (this.props.dragDropHelper) {
                this._dragDropSubscription = this.props.dragDropHelper.subscribe(this._root, this._events, this._getRowDragDropOptions());
            }
        }
        if (columnMeasureInfo && columnMeasureInfo.index >= 0 && this._cellMeasurer.current) {
            const newWidth = this._cellMeasurer.current.getBoundingClientRect().width;
            columnMeasureInfo.onMeasureDone(newWidth);
            this.setState({
                columnMeasureInfo: undefined
            });
        }
        if (item && onDidMount && !this._hasMounted) {
            this._hasMounted = true;
            onDidMount(this);
        }
    }
    componentWillUnmount() {
        const { item, onWillUnmount } = this.props;
        // Only call the onWillUnmount callback if we have an item.
        if (onWillUnmount && item) {
            onWillUnmount(this);
        }
        if (this._dragDropSubscription) {
            this._dragDropSubscription.dispose();
            delete this._dragDropSubscription;
        }
    }
    componentWillReceiveProps(newProps) {
        this.setState({
            selectionState: this._getSelectionState(newProps),
            groupNestingDepth: newProps.groupNestingDepth
        });
    }
    shouldComponentUpdate(nextProps, nextState) {
        if (this.props.useReducedRowRenderer) {
            if (this.state.selectionState) {
                const newSelectionState = this._getSelectionState(nextProps);
                if (this.state.selectionState.isSelected !== newSelectionState.isSelected) {
                    return true;
                }
            }
            return shallowCompare(this.props, nextProps);
        }
        else {
            return true;
        }
    }
    render() {
        const { className, columns = NO_COLUMNS$1, dragDropEvents, item, itemIndex, onRenderCheck = this._onRenderCheck, onRenderItemColumn, selectionMode, viewport, checkboxVisibility, getRowAriaLabel, getRowAriaDescribedBy, checkButtonAriaLabel, checkboxCellClassName, 
        /** Alias rowFieldsAs as RowFields and default to DetailsRowFields if rowFieldsAs does not exist */
        rowFieldsAs: RowFields = DetailsRowFields, selection, indentWidth, shimmer, compact, theme, styles } = this.props;
        const { columnMeasureInfo, isDropping, groupNestingDepth } = this.state;
        const { isSelected = false, isSelectionModal = false } = this.state.selectionState;
        const isDraggable = Boolean(dragDropEvents && dragDropEvents.canDrag && dragDropEvents.canDrag(item));
        const droppingClassName = isDropping ? (this._droppingClassNames ? this._droppingClassNames : DEFAULT_DROPPING_CSS_CLASS$1) : '';
        const ariaLabel = getRowAriaLabel ? getRowAriaLabel(item) : undefined;
        const ariaDescribedBy = getRowAriaDescribedBy ? getRowAriaDescribedBy(item) : undefined;
        const canSelect = !!selection && selection.canSelectItem(item, itemIndex);
        const isContentUnselectable = selectionMode === SelectionMode.multiple;
        const showCheckbox = selectionMode !== SelectionMode.none && checkboxVisibility !== CheckboxVisibility.hidden;
        const ariaSelected = selectionMode === SelectionMode.none ? undefined : isSelected;
        const classNames = getClassNames$D(styles, {
            theme: theme,
            isSelected,
            canSelect: !isContentUnselectable,
            anySelected: isSelectionModal,
            checkboxCellClassName,
            droppingClassName,
            className,
            compact
        });
        const rowFields = (createElement(RowFields, { rowClassNames: classNames, columns: columns, item: item, itemIndex: itemIndex, columnStartIndex: showCheckbox ? 1 : 0, onRenderItemColumn: onRenderItemColumn, shimmer: shimmer }));
        // Rendering Shimmer Animation outside the focus zone
        if (shimmer) {
            return (createElement("div", { className: css(showCheckbox && classNames.shimmerLeftBorder, !compact && classNames.shimmerBottomBorder) }, rowFields));
        }
        return (createElement(FocusZone, Object.assign({}, getNativeProps(this.props, divProperties), { direction: FocusZoneDirection.horizontal, ref: this._onRootRef, componentRef: this._focusZone, role: "row", "aria-label": ariaLabel, ariaDescribedBy: ariaDescribedBy, className: css(classNames.root), "data-is-focusable": true, "data-selection-index": itemIndex, "data-item-index": itemIndex, "aria-rowindex": itemIndex + 1, "data-is-draggable": isDraggable, draggable: isDraggable, "data-automationid": "DetailsRow", style: { minWidth: viewport ? viewport.width : 0 }, "aria-selected": ariaSelected, allowFocusRoot: true }),
            showCheckbox && (createElement("div", { role: "gridcell", "aria-colindex": 1, "data-selection-toggle": true, className: classNames.checkCell }, onRenderCheck({
                selected: isSelected,
                anySelected: isSelectionModal,
                title: checkButtonAriaLabel,
                canSelect,
                compact,
                className: classNames.check,
                theme,
                isVisible: checkboxVisibility === CheckboxVisibility.always
            }))),
            createElement(GroupSpacer, { indentWidth: indentWidth, count: groupNestingDepth - (this.props.collapseAllVisibility === CollapseAllVisibility.hidden ? 1 : 0) }),
            item && rowFields,
            columnMeasureInfo && (createElement("span", { role: "presentation", className: css(classNames.cellMeasurer, classNames.cell), ref: this._cellMeasurer },
                createElement(RowFields, { rowClassNames: classNames, columns: [columnMeasureInfo.column], item: item, itemIndex: itemIndex, columnStartIndex: (showCheckbox ? 1 : 0) + columns.length, onRenderItemColumn: onRenderItemColumn }))),
            createElement("span", { role: "checkbox", className: css(classNames.checkCover), "aria-checked": isSelected, "data-selection-toggle": true })));
    }
    /**
     * measure cell at index. and call the call back with the measured cell width when finish measure
     *
     * @param index - The cell index
     * @param onMeasureDone - The call back function when finish measure
     */
    measureCell(index, onMeasureDone) {
        const { columns = NO_COLUMNS$1 } = this.props;
        const column = assign({}, columns[index]);
        column.minWidth = 0;
        column.maxWidth = 999999;
        delete column.calculatedWidth;
        this.setState({
            columnMeasureInfo: {
                index,
                column,
                onMeasureDone
            }
        });
    }
    focus(forceIntoFirstElement = false) {
        return !!this._focusZone.current && this._focusZone.current.focus(forceIntoFirstElement);
    }
    _onRenderCheck(props) {
        return createElement(DetailsRowCheck, Object.assign({}, props));
    }
    _getSelectionState(props) {
        const { itemIndex, selection } = props;
        return {
            isSelected: !!selection && selection.isIndexSelected(itemIndex),
            isSelectionModal: !!selection && !!selection.isModal && selection.isModal()
        };
    }
    _onSelectionChanged() {
        const selectionState = this._getSelectionState(this.props);
        if (!shallowCompare(selectionState, this.state.selectionState)) {
            this.setState({
                selectionState: selectionState
            });
        }
    }
    _onToggleSelection() {
        const { selection } = this.props;
        if (selection && this.props.itemIndex > -1) {
            selection.toggleIndexSelected(this.props.itemIndex);
        }
    }
    _getRowDragDropOptions() {
        const { item, itemIndex, dragDropEvents, eventsToRegister } = this.props;
        const options = {
            eventMap: eventsToRegister,
            selectionIndex: itemIndex,
            context: { data: item, index: itemIndex },
            canDrag: dragDropEvents.canDrag,
            canDrop: dragDropEvents.canDrop,
            onDragStart: dragDropEvents.onDragStart,
            updateDropState: this._updateDroppingState,
            onDrop: dragDropEvents.onDrop,
            onDragEnd: dragDropEvents.onDragEnd
        };
        return options;
    }
    /**
     * update isDropping state based on the input value, which is used to change style during drag and drop
     *
     * when change to true, that means drag enter. we will add default dropping class name
     * or the custom dropping class name (return result from onDragEnter) to the root elemet.
     *
     * when change to false, that means drag leave. we will remove the dropping class name from root element.
     *
     * @private
     * @param newValue - New isDropping state value
     * @param event - The event trigger dropping state change which can be dragenter, dragleave etc
     */
    _updateDroppingState(newValue, event) {
        const { selectionState, isDropping } = this.state;
        const { dragDropEvents, item } = this.props;
        if (!newValue) {
            if (dragDropEvents.onDragLeave) {
                dragDropEvents.onDragLeave(item, event);
            }
        }
        else {
            if (dragDropEvents.onDragEnter) {
                this._droppingClassNames = dragDropEvents.onDragEnter(item, event);
            }
        }
        if (isDropping !== newValue) {
            this.setState({ selectionState: selectionState, isDropping: newValue });
        }
    }
}

const DetailsRow = styled(DetailsRowBase, getStyles$C, undefined, {
    scope: 'DetailsRow'
});

const RESIZE_DELAY$2 = 500;
const MAX_RESIZE_ATTEMPTS = 3;
function withViewport(ComposedComponent) {
    return class WithViewportComponent extends BaseDecorator {
        constructor(props) {
            super(props);
            this._root = createRef$1();
            /* Note: using lambda here because decorators don't seem to work in decorators. */
            this._updateViewport = (withForceUpdate) => {
                const { viewport } = this.state;
                const viewportElement = this._root.current;
                const scrollElement = findScrollableParent(viewportElement);
                const scrollRect = getRect(scrollElement);
                const clientRect = getRect(viewportElement);
                const updateComponent = () => {
                    if (withForceUpdate && this._composedComponentInstance) {
                        this._composedComponentInstance.forceUpdate();
                    }
                };
                const isSizeChanged = (clientRect && clientRect.width) !== viewport.width || (scrollRect && scrollRect.height) !== viewport.height;
                if (isSizeChanged && this._resizeAttempts < MAX_RESIZE_ATTEMPTS && clientRect && scrollRect) {
                    this._resizeAttempts++;
                    this.setState({
                        viewport: {
                            width: clientRect.width,
                            height: scrollRect.height
                        }
                    }, () => {
                        this._updateViewport(withForceUpdate);
                    });
                }
                else {
                    this._resizeAttempts = 0;
                    updateComponent();
                }
            };
            this._resizeAttempts = 0;
            this.state = {
                viewport: {
                    width: 0,
                    height: 0
                }
            };
        }
        componentDidMount() {
            const { skipViewportMeasures } = this.props;
            this._onAsyncResize = this._async.debounce(this._onAsyncResize, RESIZE_DELAY$2, {
                leading: false
            });
            const window = getWindow();
            const viewportElement = this._root.current;
            // ResizeObserver seems always fire even window is not resized. This is
            // particularly bad when skipViewportMeasures is set when optimizing fixed layout lists.
            // It will measure and update and re-render the entire list after list is fully rendered.
            // So fallback to listen to resize event when skipViewportMeasures is set.
            if (!skipViewportMeasures && window && window.ResizeObserver) {
                this._viewportResizeObserver = new window.ResizeObserver(this._onAsyncResize);
                this._viewportResizeObserver.observe(viewportElement);
            }
            else {
                this._events.on(window, 'resize', this._onAsyncResize);
            }
            if (!skipViewportMeasures) {
                this._updateViewport();
            }
        }
        componentWillUnmount() {
            this._events.dispose();
            if (this._viewportResizeObserver) {
                this._viewportResizeObserver.disconnect();
            }
        }
        render() {
            const { viewport } = this.state;
            const { skipViewportMeasures } = this.props;
            const isViewportVisible = skipViewportMeasures || (viewport.width > 0 && viewport.height > 0);
            return (createElement("div", { className: "ms-Viewport", ref: this._root, style: { minWidth: 1, minHeight: 1 } }, isViewportVisible && createElement(ComposedComponent, Object.assign({ ref: this._updateComposedComponentRef, viewport: viewport }, this.props))));
        }
        forceUpdate() {
            this._updateViewport(true);
        }
        _onAsyncResize() {
            this._updateViewport();
        }
    };
}

/**
 * Takes an array of groups and returns a count of the groups and all descendant groups.
 * @param groups - The array of groups to count.
 */
const GetGroupCount = (groups) => {
    let total = 0;
    if (groups) {
        const remainingGroups = [...groups];
        let currentGroup;
        while (remainingGroups && remainingGroups.length > 0) {
            ++total;
            currentGroup = remainingGroups.pop();
            if (currentGroup && currentGroup.children) {
                remainingGroups.push(...currentGroup.children);
            }
        }
    }
    return total;
};

const getClassNames$E = classNamesFunction();
const MIN_COLUMN_WIDTH = 100; // this is the global min width
const CHECKBOX_WIDTH = 40;
const DEFAULT_RENDERED_WINDOWS_AHEAD$1 = 2;
const DEFAULT_RENDERED_WINDOWS_BEHIND$1 = 2;
const SHIMMER_INITIAL_ITEMS = 10;
const SHIMMER_ITEMS = new Array(SHIMMER_INITIAL_ITEMS);
let DetailsListBase = class DetailsListBase extends BaseComponent {
    constructor(props) {
        super(props);
        // References
        this._root = createRef();
        this._header = createRef();
        this._groupedList = createRef();
        this._list = createRef();
        this._focusZone = createRef();
        this._selectionZone = createRef();
        this._onRenderRow = (props, defaultRender) => {
            return createElement(DetailsRow, Object.assign({}, props));
        };
        this._onRenderDetailsHeader = (detailsHeaderProps, defaultRender) => {
            return createElement(DetailsHeader, Object.assign({}, detailsHeaderProps));
        };
        this._onRenderDetailsFooter = (detailsFooterProps, defaultRender) => {
            return null;
        };
        this._onRenderListCell = (nestingDepth) => {
            return (item, itemIndex) => {
                return this._onRenderCell(nestingDepth, item, itemIndex);
            };
        };
        this._activeRows = {};
        this._columnOverrides = {};
        this._onColumnIsSizingChanged = this._onColumnIsSizingChanged.bind(this);
        this._onColumnResized = this._onColumnResized.bind(this);
        this._onColumnAutoResized = this._onColumnAutoResized.bind(this);
        this._onRowDidMount = this._onRowDidMount.bind(this);
        this._onRowWillUnmount = this._onRowWillUnmount.bind(this);
        this._onToggleCollapse = this._onToggleCollapse.bind(this);
        this._onActiveRowChanged = this._onActiveRowChanged.bind(this);
        this._onBlur = this._onBlur.bind(this);
        this._onHeaderKeyDown = this._onHeaderKeyDown.bind(this);
        this._onContentKeyDown = this._onContentKeyDown.bind(this);
        this._onRenderCell = this._onRenderCell.bind(this);
        this._onGroupExpandStateChanged = this._onGroupExpandStateChanged.bind(this);
        this._onColumnDragEnd = this._onColumnDragEnd.bind(this);
        this.state = {
            focusedItemIndex: -1,
            lastWidth: 0,
            adjustedColumns: this._getAdjustedColumns(props),
            isSizing: false,
            isDropping: false,
            isCollapsed: props.groupProps && props.groupProps.isAllGroupsCollapsed,
            isSomeGroupExpanded: props.groupProps && !props.groupProps.isAllGroupsCollapsed
        };
        this._selection = props.selection || new Selection({ onSelectionChanged: undefined, getKey: props.getKey });
        if (!this.props.disableSelectionZone) {
            this._selection.setItems(props.items, false);
        }
        this._dragDropHelper = props.dragDropEvents
            ? new DragDropHelper({
                selection: this._selection,
                minimumPixelsForDrag: props.minimumPixelsForDrag
            })
            : null;
        this._initialFocusedIndex = props.initialFocusedIndex;
    }
    scrollToIndex(index, measureItem, scrollToMode) {
        this._list.current && this._list.current.scrollToIndex(index, measureItem, scrollToMode);
        this._groupedList.current && this._groupedList.current.scrollToIndex(index, measureItem, scrollToMode);
    }
    focusIndex(index, forceIntoFirstElement = false, measureItem, scrollToMode) {
        const item = this.props.items[index];
        if (item) {
            this.scrollToIndex(index, measureItem, scrollToMode);
            const itemKey = this._getItemKey(item, index);
            const row = this._activeRows[itemKey];
            if (row) {
                this._setFocusToRow(row, forceIntoFirstElement);
            }
        }
    }
    getStartItemIndexInView() {
        if (this._list && this._list.current) {
            return this._list.current.getStartItemIndexInView();
        }
        else if (this._groupedList && this._groupedList.current) {
            return this._groupedList.current.getStartItemIndexInView();
        }
        return 0;
    }
    componentWillUnmount() {
        if (this._dragDropHelper) {
            this._dragDropHelper.dispose();
        }
    }
    componentDidUpdate(prevProps, prevState) {
        if (this._initialFocusedIndex !== undefined) {
            const item = this.props.items[this._initialFocusedIndex];
            if (item) {
                const itemKey = this._getItemKey(item, this._initialFocusedIndex);
                const row = this._activeRows[itemKey];
                if (row) {
                    this._setFocusToRowIfPending(row);
                }
            }
        }
        if (this.props.items !== prevProps.items &&
            this.props.items.length > 0 &&
            this.state.focusedItemIndex !== -1 &&
            !elementContains(this._root.current, document.activeElement, false)) {
            // Item set has changed and previously-focused item is gone.
            // Set focus to item at index of previously-focused item if it is in range,
            // else set focus to the last item.
            const index = this.state.focusedItemIndex < this.props.items.length ? this.state.focusedItemIndex : this.props.items.length - 1;
            const item = this.props.items[index];
            const itemKey = this._getItemKey(item, this.state.focusedItemIndex);
            const row = this._activeRows[itemKey];
            if (row) {
                this._setFocusToRow(row);
            }
            else {
                this._initialFocusedIndex = index;
            }
        }
        if (this.props.onDidUpdate) {
            this.props.onDidUpdate(this);
        }
    }
    componentWillReceiveProps(newProps) {
        const { checkboxVisibility, items, setKey, selectionMode = this._selection.mode, columns, viewport, compact } = this.props;
        const { isAllGroupsCollapsed = undefined } = this.props.groupProps || {};
        const shouldResetSelection = newProps.setKey !== setKey || newProps.setKey === undefined;
        let shouldForceUpdates = false;
        if (newProps.layoutMode !== this.props.layoutMode) {
            shouldForceUpdates = true;
        }
        if (shouldResetSelection) {
            this._initialFocusedIndex = newProps.initialFocusedIndex;
            // reset focusedItemIndex when setKey changes
            this.setState({
                focusedItemIndex: this._initialFocusedIndex !== undefined ? this._initialFocusedIndex : -1
            });
        }
        if (!this.props.disableSelectionZone && newProps.items !== items) {
            this._selection.setItems(newProps.items, shouldResetSelection);
        }
        if (newProps.checkboxVisibility !== checkboxVisibility ||
            newProps.columns !== columns ||
            newProps.viewport.width !== viewport.width ||
            newProps.compact !== compact) {
            shouldForceUpdates = true;
        }
        this._adjustColumns(newProps, true);
        if (newProps.selectionMode !== selectionMode) {
            shouldForceUpdates = true;
        }
        if (isAllGroupsCollapsed === undefined && (newProps.groupProps && newProps.groupProps.isAllGroupsCollapsed !== undefined)) {
            this.setState({
                isCollapsed: newProps.groupProps.isAllGroupsCollapsed,
                isSomeGroupExpanded: !newProps.groupProps.isAllGroupsCollapsed
            });
        }
        if (shouldForceUpdates) {
            this._pendingForceUpdate = true;
        }
    }
    componentWillUpdate() {
        if (this._pendingForceUpdate) {
            this._forceListUpdates();
        }
    }
    render() {
        const { ariaLabelForListHeader, ariaLabelForSelectAllCheckbox, ariaLabelForSelectionColumn, className, checkboxVisibility, compact, constrainMode, dragDropEvents, groups, groupProps, indentWidth, items, isHeaderVisible, layoutMode, onItemInvoked, onItemContextMenu, onColumnHeaderClick, onColumnHeaderContextMenu, selectionMode = this._selection.mode, selectionPreservedOnEmptyClick, selectionZoneProps, ariaLabel, ariaLabelForGrid, rowElementEventMap, shouldApplyApplicationRole = false, getKey, listProps, usePageCache, onShouldVirtualize, enableShimmer, viewport, minimumPixelsForDrag, getGroupHeight, styles, theme, cellStyleProps = DEFAULT_CELL_STYLE_PROPS } = this.props;
        const { adjustedColumns, isCollapsed, isSizing, isSomeGroupExpanded } = this.state;
        const { _selection: selection, _dragDropHelper: dragDropHelper } = this;
        const groupNestingDepth = this._getGroupNestingDepth();
        const additionalListProps = {
            renderedWindowsAhead: isSizing ? 0 : DEFAULT_RENDERED_WINDOWS_AHEAD$1,
            renderedWindowsBehind: isSizing ? 0 : DEFAULT_RENDERED_WINDOWS_BEHIND$1,
            getKey,
            ...listProps
        };
        let selectAllVisibility = SelectAllVisibility.none; // for SelectionMode.none
        if (selectionMode === SelectionMode.single) {
            selectAllVisibility = SelectAllVisibility.hidden;
        }
        if (selectionMode === SelectionMode.multiple) {
            // if isCollapsedGroupSelectVisible is false, disable select all when the list has all collapsed groups
            let isCollapsedGroupSelectVisible = groupProps && groupProps.headerProps && groupProps.headerProps.isCollapsedGroupSelectVisible;
            if (isCollapsedGroupSelectVisible === undefined) {
                isCollapsedGroupSelectVisible = true;
            }
            const isSelectAllVisible = isCollapsedGroupSelectVisible || !groups || isSomeGroupExpanded;
            selectAllVisibility = isSelectAllVisible ? SelectAllVisibility.visible : SelectAllVisibility.hidden;
        }
        if (checkboxVisibility === CheckboxVisibility.hidden) {
            selectAllVisibility = SelectAllVisibility.none;
        }
        const { onRenderDetailsHeader = this._onRenderDetailsHeader, onRenderDetailsFooter = this._onRenderDetailsFooter } = this.props;
        const detailsFooterProps = this._getDetailsFooterProps();
        const columnReorderProps = this._getColumnReorderProps();
        const rowCount = (isHeaderVisible ? 1 : 0) + GetGroupCount(groups) + (items ? items.length : 0);
        const classNames = getClassNames$E(styles, {
            theme: theme,
            compact,
            isFixed: layoutMode === DetailsListLayoutMode.fixedColumns,
            isHorizontalConstrained: constrainMode === ConstrainMode.horizontalConstrained,
            className
        });
        const list = groups ? (createElement(GroupedList, { componentRef: this._groupedList, groups: groups, groupProps: groupProps ? this._getGroupProps(groupProps) : undefined, items: items, onRenderCell: this._onRenderCell, selection: selection, selectionMode: checkboxVisibility !== CheckboxVisibility.hidden ? selectionMode : SelectionMode.none, dragDropEvents: dragDropEvents, dragDropHelper: dragDropHelper, eventsToRegister: rowElementEventMap, listProps: additionalListProps, onGroupExpandStateChanged: this._onGroupExpandStateChanged, usePageCache: usePageCache, onShouldVirtualize: onShouldVirtualize, getGroupHeight: getGroupHeight, compact: compact })) : (createElement(List, Object.assign({ ref: this._list, role: "presentation", items: enableShimmer && !items.length ? SHIMMER_ITEMS : items, onRenderCell: this._onRenderListCell(0), usePageCache: usePageCache, onShouldVirtualize: onShouldVirtualize }, additionalListProps)));
        return (
        // If shouldApplyApplicationRole is true, role application will be applied to make arrow keys work
        // with JAWS.
        createElement("div", Object.assign({ ref: this._root, className: classNames.root, "data-automationid": "DetailsList", "data-is-scrollable": "false", "aria-label": ariaLabel }, (shouldApplyApplicationRole ? { role: 'application' } : {})),
            createElement("div", { role: "grid", "aria-label": ariaLabelForGrid, "aria-rowcount": rowCount, "aria-colcount": (selectAllVisibility !== SelectAllVisibility.none ? 1 : 0) + (adjustedColumns ? adjustedColumns.length : 0), "aria-readonly": "true" },
                createElement("div", { onKeyDown: this._onHeaderKeyDown, role: "presentation", className: classNames.headerWrapper }, isHeaderVisible &&
                    onRenderDetailsHeader({
                        componentRef: this._header,
                        selectionMode: selectionMode,
                        layoutMode: layoutMode,
                        selection: selection,
                        columns: adjustedColumns,
                        onColumnClick: onColumnHeaderClick,
                        onColumnContextMenu: onColumnHeaderContextMenu,
                        onColumnResized: this._onColumnResized,
                        onColumnIsSizingChanged: this._onColumnIsSizingChanged,
                        onColumnAutoResized: this._onColumnAutoResized,
                        groupNestingDepth: groupNestingDepth,
                        isAllCollapsed: isCollapsed,
                        onToggleCollapseAll: this._onToggleCollapse,
                        ariaLabel: ariaLabelForListHeader,
                        ariaLabelForSelectAllCheckbox: ariaLabelForSelectAllCheckbox,
                        ariaLabelForSelectionColumn: ariaLabelForSelectionColumn,
                        selectAllVisibility: selectAllVisibility,
                        collapseAllVisibility: groupProps && groupProps.collapseAllVisibility,
                        viewport: viewport,
                        columnReorderProps: columnReorderProps,
                        minimumPixelsForDrag: minimumPixelsForDrag,
                        cellStyleProps: cellStyleProps,
                        checkboxVisibility,
                        indentWidth
                    }, this._onRenderDetailsHeader)),
                createElement("div", { onKeyDown: this._onContentKeyDown, role: "presentation", className: classNames.contentWrapper },
                    createElement(FocusZone, { componentRef: this._focusZone, className: classNames.focusZone, direction: FocusZoneDirection.vertical, isInnerZoneKeystroke: isRightArrow, onActiveElementChanged: this._onActiveRowChanged, onBlur: this._onBlur }, !this.props.disableSelectionZone ? (createElement(SelectionZone, Object.assign({ ref: this._selectionZone, selection: selection, selectionPreservedOnEmptyClick: selectionPreservedOnEmptyClick, selectionMode: selectionMode, onItemInvoked: onItemInvoked, onItemContextMenu: onItemContextMenu, enterModalOnTouch: this.props.enterModalSelectionOnTouch }, selectionZoneProps || {}), list)) : (list))),
                onRenderDetailsFooter({
                    ...detailsFooterProps
                }, this._onRenderDetailsFooter))));
    }
    forceUpdate() {
        super.forceUpdate();
        this._forceListUpdates();
    }
    _onRenderCell(nestingDepth, item, index) {
        const { compact, dragDropEvents, rowElementEventMap: eventsToRegister, onRenderMissingItem, onRenderItemColumn, onRenderRow = this._onRenderRow, selectionMode = this._selection.mode, viewport, checkboxVisibility, getRowAriaLabel, getRowAriaDescribedBy, checkButtonAriaLabel, checkboxCellClassName, groupProps, useReducedRowRenderer, indentWidth, cellStyleProps = DEFAULT_CELL_STYLE_PROPS } = this.props;
        const collapseAllVisibility = groupProps && groupProps.collapseAllVisibility;
        const selection = this._selection;
        const dragDropHelper = this._dragDropHelper;
        const { adjustedColumns: columns } = this.state;
        const rowProps = {
            item: item,
            itemIndex: index,
            compact: compact,
            columns: columns,
            groupNestingDepth: nestingDepth,
            selectionMode: selectionMode,
            selection: selection,
            onDidMount: this._onRowDidMount,
            onWillUnmount: this._onRowWillUnmount,
            onRenderItemColumn: onRenderItemColumn,
            eventsToRegister: eventsToRegister,
            dragDropEvents: dragDropEvents,
            dragDropHelper: dragDropHelper,
            viewport: viewport,
            checkboxVisibility: checkboxVisibility,
            collapseAllVisibility: collapseAllVisibility,
            getRowAriaLabel: getRowAriaLabel,
            getRowAriaDescribedBy: getRowAriaDescribedBy,
            checkButtonAriaLabel: checkButtonAriaLabel,
            checkboxCellClassName: checkboxCellClassName,
            useReducedRowRenderer: useReducedRowRenderer,
            indentWidth,
            cellStyleProps: cellStyleProps
        };
        if (!item) {
            if (onRenderMissingItem) {
                return onRenderMissingItem(index, rowProps);
            }
            return null;
        }
        return onRenderRow(rowProps, this._onRenderRow);
    }
    _onGroupExpandStateChanged(isSomeGroupExpanded) {
        this.setState({ isSomeGroupExpanded: isSomeGroupExpanded });
    }
    _onColumnIsSizingChanged(column, isSizing) {
        this.setState({ isSizing: isSizing });
    }
    _onHeaderKeyDown(ev) {
        if (ev.which === KeyCodes.down) {
            if (this._focusZone.current && this._focusZone.current.focus()) {
                // select the first item in list after down arrow key event
                this._selection.setIndexSelected(0, true, false);
                ev.preventDefault();
                ev.stopPropagation();
            }
        }
    }
    _onContentKeyDown(ev) {
        if (ev.which === KeyCodes.up && !ev.altKey) {
            if (this._header.current && this._header.current.focus()) {
                ev.preventDefault();
                ev.stopPropagation();
            }
        }
    }
    _getGroupNestingDepth() {
        const { groups } = this.props;
        let level = 0;
        let groupsInLevel = groups;
        while (groupsInLevel && groupsInLevel.length > 0) {
            level++;
            groupsInLevel = groupsInLevel[0].children;
        }
        return level;
    }
    _onRowDidMount(row) {
        const { item, itemIndex } = row.props;
        const itemKey = this._getItemKey(item, itemIndex);
        this._activeRows[itemKey] = row; // this is used for column auto resize
        this._setFocusToRowIfPending(row);
        const { onRowDidMount } = this.props;
        if (onRowDidMount) {
            onRowDidMount(item, itemIndex);
        }
    }
    _setFocusToRowIfPending(row) {
        const { itemIndex } = row.props;
        if (this._initialFocusedIndex !== undefined && itemIndex === this._initialFocusedIndex) {
            this._setFocusToRow(row);
            delete this._initialFocusedIndex;
        }
    }
    _setFocusToRow(row, forceIntoFirstElement = false) {
        if (this._selectionZone.current) {
            this._selectionZone.current.ignoreNextFocus();
        }
        this._async.setTimeout(() => {
            row.focus(forceIntoFirstElement);
        }, 0);
    }
    _onRowWillUnmount(row) {
        const { onRowWillUnmount } = this.props;
        const { item, itemIndex } = row.props;
        const itemKey = this._getItemKey(item, itemIndex);
        delete this._activeRows[itemKey];
        if (onRowWillUnmount) {
            onRowWillUnmount(item, itemIndex);
        }
    }
    _onToggleCollapse(collapsed) {
        this.setState({
            isCollapsed: collapsed
        });
        if (this._groupedList.current) {
            this._groupedList.current.toggleCollapseAll(collapsed);
        }
    }
    _onColumnDragEnd(props, event) {
        const { columnReorderOptions } = this.props;
        let finalDropLocation = ColumnDragEndLocation.outside;
        if (columnReorderOptions && columnReorderOptions.onDragEnd) {
            if (props.dropLocation && props.dropLocation !== ColumnDragEndLocation.header) {
                finalDropLocation = props.dropLocation;
            }
            else if (this._root.current) {
                const clientRect = this._root.current.getBoundingClientRect();
                if (event.clientX > clientRect.left &&
                    event.clientX < clientRect.right &&
                    event.clientY > clientRect.top &&
                    event.clientY < clientRect.bottom) {
                    finalDropLocation = ColumnDragEndLocation.surface;
                }
            }
            columnReorderOptions.onDragEnd(finalDropLocation);
        }
    }
    _forceListUpdates() {
        this._pendingForceUpdate = false;
        if (this._groupedList.current) {
            this._groupedList.current.forceUpdate();
        }
        if (this._list.current) {
            this._list.current.forceUpdate();
        }
    }
    _notifyColumnsResized() {
        this.state.adjustedColumns.forEach(column => {
            if (column.onColumnResize) {
                column.onColumnResize(column.currentWidth);
            }
        });
    }
    _adjustColumns(newProps, forceUpdate, resizingColumnIndex) {
        const adjustedColumns = this._getAdjustedColumns(newProps, forceUpdate, resizingColumnIndex);
        const { width: viewportWidth } = this.props.viewport;
        if (adjustedColumns) {
            this.setState({
                adjustedColumns: adjustedColumns,
                lastWidth: viewportWidth
            }, this._notifyColumnsResized);
        }
    }
    /** Returns adjusted columns, given the viewport size and layout mode. */
    _getAdjustedColumns(newProps, forceUpdate, resizingColumnIndex) {
        const { items: newItems, layoutMode, selectionMode } = newProps;
        let { columns: newColumns } = newProps;
        let { width: viewportWidth } = newProps.viewport;
        const columns = this.props ? this.props.columns : [];
        const lastWidth = this.state ? this.state.lastWidth : -1;
        const lastSelectionMode = this.state ? this.state.lastSelectionMode : undefined;
        if (viewportWidth !== undefined) {
            if (!forceUpdate && lastWidth === viewportWidth && lastSelectionMode === selectionMode && (!columns || newColumns === columns)) {
                return [];
            }
        }
        else {
            viewportWidth = this.props.viewport.width;
        }
        newColumns = newColumns || buildColumns(newItems, true);
        let adjustedColumns;
        if (layoutMode === DetailsListLayoutMode.fixedColumns) {
            adjustedColumns = this._getFixedColumns(newColumns);
            // Preserve adjusted column calculated widths.
            adjustedColumns.forEach(column => {
                this._rememberCalculatedWidth(column, column.calculatedWidth);
            });
        }
        else {
            if (resizingColumnIndex !== undefined) {
                adjustedColumns = this._getJustifiedColumnsAfterResize(newColumns, viewportWidth, newProps, resizingColumnIndex);
            }
            else {
                adjustedColumns = this._getJustifiedColumns(newColumns, viewportWidth, newProps, 0);
            }
            adjustedColumns.forEach(column => {
                this._getColumnOverride(column.key).currentWidth = column.calculatedWidth;
            });
        }
        return adjustedColumns;
    }
    /** Builds a set of columns based on the given columns mixed with the current overrides. */
    _getFixedColumns(newColumns) {
        return newColumns.map(column => {
            const newColumn = assign({}, column, this._columnOverrides[column.key]);
            if (!newColumn.calculatedWidth) {
                newColumn.calculatedWidth = newColumn.maxWidth || newColumn.minWidth || MIN_COLUMN_WIDTH;
            }
            return newColumn;
        });
    }
    _getJustifiedColumnsAfterResize(newColumns, viewportWidth, props, resizingColumnIndex) {
        const fixedColumns = newColumns.slice(0, resizingColumnIndex);
        fixedColumns.forEach(column => (column.calculatedWidth = this._getColumnOverride(column.key).currentWidth));
        const fixedWidth = fixedColumns.reduce((total, column, i) => total + getPaddedWidth(column, i === 0, props), 0);
        const remainingColumns = newColumns.slice(resizingColumnIndex);
        const remainingWidth = viewportWidth - fixedWidth;
        return [...fixedColumns, ...this._getJustifiedColumns(remainingColumns, remainingWidth, props, resizingColumnIndex)];
    }
    /** Builds a set of columns to fix within the viewport width. */
    _getJustifiedColumns(newColumns, viewportWidth, props, firstIndex) {
        const { selectionMode = this._selection.mode, checkboxVisibility } = props;
        const rowCheckWidth = selectionMode !== SelectionMode.none && checkboxVisibility !== CheckboxVisibility.hidden ? CHECKBOX_WIDTH : 0;
        const groupExpandWidth = this._getGroupNestingDepth() * SPACER_WIDTH;
        let totalWidth = 0; // offset because we have one less inner padding.
        const availableWidth = viewportWidth - (rowCheckWidth + groupExpandWidth);
        const adjustedColumns = newColumns.map((column, i) => {
            const newColumn = {
                ...column,
                calculatedWidth: column.minWidth || MIN_COLUMN_WIDTH,
                ...this._columnOverrides[column.key]
            };
            const isFirst = i + firstIndex === 0;
            totalWidth += getPaddedWidth(newColumn, isFirst, props);
            return newColumn;
        });
        let lastIndex = adjustedColumns.length - 1;
        // Shrink or remove collapsable columns.
        while (lastIndex > 0 && totalWidth > availableWidth) {
            const column = adjustedColumns[lastIndex];
            const minWidth = column.minWidth || MIN_COLUMN_WIDTH;
            const overflowWidth = totalWidth - availableWidth;
            if (column.calculatedWidth - minWidth >= overflowWidth || !(column.isCollapsable || column.isCollapsible)) {
                column.calculatedWidth = Math.max(column.calculatedWidth - overflowWidth, minWidth);
                totalWidth = availableWidth;
            }
            else {
                totalWidth -= getPaddedWidth(column, false, props);
                adjustedColumns.splice(lastIndex, 1);
            }
            lastIndex--;
        }
        // Then expand columns starting at the beginning, until we've filled the width.
        for (let i = 0; i < adjustedColumns.length && totalWidth < availableWidth; i++) {
            const column = adjustedColumns[i];
            const isLast = i === adjustedColumns.length - 1;
            const overrides = this._columnOverrides[column.key];
            if (overrides && overrides.calculatedWidth && !isLast) {
                continue;
            }
            const spaceLeft = availableWidth - totalWidth;
            let increment;
            if (isLast) {
                increment = spaceLeft;
            }
            else {
                const maxWidth = column.maxWidth;
                const minWidth = column.minWidth || maxWidth || MIN_COLUMN_WIDTH;
                increment = maxWidth ? Math.min(spaceLeft, maxWidth - minWidth) : spaceLeft;
            }
            column.calculatedWidth = column.calculatedWidth + increment;
            totalWidth += increment;
        }
        return adjustedColumns;
    }
    _onColumnResized(resizingColumn, newWidth, resizingColumnIndex) {
        const newCalculatedWidth = Math.max(resizingColumn.minWidth || MIN_COLUMN_WIDTH, newWidth);
        if (this.props.onColumnResize) {
            this.props.onColumnResize(resizingColumn, newCalculatedWidth, resizingColumnIndex);
        }
        this._rememberCalculatedWidth(resizingColumn, newCalculatedWidth);
        this._adjustColumns(this.props, true, resizingColumnIndex);
        this._forceListUpdates();
    }
    _rememberCalculatedWidth(column, newCalculatedWidth) {
        const overrides = this._getColumnOverride(column.key);
        overrides.calculatedWidth = newCalculatedWidth;
        overrides.currentWidth = newCalculatedWidth;
    }
    _getColumnOverride(key) {
        return (this._columnOverrides[key] = this._columnOverrides[key] || {});
    }
    /**
     * Callback function when double clicked on the details header column resizer
     * which will measure the column cells of all the active rows and resize the
     * column to the max cell width.
     *
     * @private
     * @param {IColumn} column (double clicked column definition)
     * @param {number} columnIndex (double clicked column index)
     * @todo min width 100 should be changed to const value and should be consistent with the
     * value used on _onSizerMove method in DetailsHeader
     */
    _onColumnAutoResized(column, columnIndex) {
        let max = 0;
        let count = 0;
        const totalCount = Object.keys(this._activeRows).length;
        for (const key in this._activeRows) {
            if (this._activeRows.hasOwnProperty(key)) {
                const currentRow = this._activeRows[key];
                currentRow.measureCell(columnIndex, (width) => {
                    max = Math.max(max, width);
                    count++;
                    if (count === totalCount) {
                        this._onColumnResized(column, max, columnIndex);
                    }
                });
            }
        }
    }
    /**
     * Call back function when an element in FocusZone becomes active. It will translate it into item
     * and call onActiveItemChanged callback if specified.
     *
     * @private
     * @param {el} row element that became active in Focus Zone
     * @param {ev} focus event from Focus Zone
     */
    _onActiveRowChanged(el, ev) {
        const { items, onActiveItemChanged } = this.props;
        if (!el) {
            return;
        }
        // Check and assign index only if the event was raised from any DetailsRow element
        if (el.getAttribute('data-item-index')) {
            const index = Number(el.getAttribute('data-item-index'));
            if (index >= 0) {
                if (onActiveItemChanged) {
                    onActiveItemChanged(items[index], index, ev);
                }
                this.setState({
                    focusedItemIndex: index
                });
            }
        }
    }
    _onBlur(event) {
        this.setState({
            focusedItemIndex: -1
        });
    }
    _getItemKey(item, itemIndex) {
        const { getKey } = this.props;
        let itemKey = undefined;
        if (item) {
            itemKey = item.key;
        }
        if (getKey) {
            itemKey = getKey(item, itemIndex);
        }
        if (!itemKey) {
            itemKey = itemIndex;
        }
        return itemKey;
    }
    _getDetailsFooterProps() {
        const { adjustedColumns: columns } = this.state;
        const { viewport, checkboxVisibility, indentWidth, cellStyleProps = DEFAULT_CELL_STYLE_PROPS, selectionMode = this._selection.mode } = this.props;
        return {
            columns: columns,
            groupNestingDepth: this._getGroupNestingDepth(),
            selection: this._selection,
            selectionMode: selectionMode,
            viewport: viewport,
            checkboxVisibility,
            indentWidth,
            cellStyleProps
        };
    }
    _getColumnReorderProps() {
        const { columnReorderOptions } = this.props;
        if (columnReorderOptions) {
            return {
                ...columnReorderOptions,
                onColumnDragEnd: this._onColumnDragEnd
            };
        }
    }
    _getGroupProps(detailsGroupProps) {
        const { onRenderFooter: onRenderDetailsGroupFooter, onRenderHeader: onRenderDetailsGroupHeader } = detailsGroupProps;
        const { adjustedColumns: columns } = this.state;
        const { selectionMode = this._selection.mode, viewport, cellStyleProps = DEFAULT_CELL_STYLE_PROPS, checkboxVisibility, indentWidth } = this.props;
        const groupNestingDepth = this._getGroupNestingDepth();
        const onRenderFooter = onRenderDetailsGroupFooter
            ? (props, defaultRender) => {
                return onRenderDetailsGroupFooter({
                    ...props,
                    columns: columns,
                    groupNestingDepth: groupNestingDepth,
                    indentWidth,
                    selection: this._selection,
                    selectionMode: selectionMode,
                    viewport: viewport,
                    checkboxVisibility,
                    cellStyleProps
                }, defaultRender);
            }
            : undefined;
        const onRenderHeader = onRenderDetailsGroupHeader
            ? (props, defaultRender) => {
                return onRenderDetailsGroupHeader({
                    ...props,
                    columns: columns,
                    groupNestingDepth: groupNestingDepth,
                    indentWidth,
                    selection: this._selection,
                    selectionMode: selectionMode,
                    viewport: viewport,
                    checkboxVisibility,
                    cellStyleProps
                }, defaultRender);
            }
            : undefined;
        const groupProps = detailsGroupProps;
        return {
            ...groupProps,
            onRenderFooter,
            onRenderHeader
        };
    }
};
DetailsListBase.defaultProps = {
    layoutMode: DetailsListLayoutMode.justified,
    selectionMode: SelectionMode.multiple,
    constrainMode: ConstrainMode.horizontalConstrained,
    checkboxVisibility: CheckboxVisibility.onHover,
    isHeaderVisible: true,
    enableShimmer: false,
    compact: false
};
DetailsListBase = __decorate([
    withViewport
], DetailsListBase);
function buildColumns(items, canResizeColumns, onColumnClick, sortedColumnKey, isSortedDescending, groupedColumnKey, isMultiline) {
    const columns = [];
    if (items && items.length) {
        const firstItem = items[0];
        for (const propName in firstItem) {
            if (firstItem.hasOwnProperty(propName)) {
                columns.push({
                    key: propName,
                    name: propName,
                    fieldName: propName,
                    minWidth: MIN_COLUMN_WIDTH,
                    maxWidth: 300,
                    isCollapsable: !!columns.length,
                    isCollapsible: !!columns.length,
                    isMultiline: isMultiline === undefined ? false : isMultiline,
                    isSorted: sortedColumnKey === propName,
                    isSortedDescending: !!isSortedDescending,
                    isRowHeader: false,
                    columnActionsMode: ColumnActionsMode.clickable,
                    isResizable: canResizeColumns,
                    onColumnClick: onColumnClick,
                    isGrouped: groupedColumnKey === propName
                });
            }
        }
    }
    return columns;
}
function isRightArrow(event) {
    return event.which === getRTLSafeKeyCode(KeyCodes.right);
}
function getPaddedWidth(column, isFirst, props) {
    const { cellStyleProps = DEFAULT_CELL_STYLE_PROPS } = props;
    return (column.calculatedWidth +
        cellStyleProps.cellLeftPadding +
        cellStyleProps.cellRightPadding +
        (column.isPadded ? cellStyleProps.cellExtraRightPadding : 0));
}

const GlobalClassNames$q = {
    root: 'ms-DetailsList',
    compact: 'ms-DetailsList--Compact',
    contentWrapper: 'ms-DetailsList-contentWrapper',
    headerWrapper: 'ms-DetailsList-headerWrapper',
    isFixed: 'is-fixed',
    isHorizontalConstrained: 'is-horizontalConstrained',
    listCell: 'ms-List-cell'
};
const getStyles$K = (props) => {
    const { theme, className, isHorizontalConstrained, compact, isFixed } = props;
    const { semanticColors } = theme;
    const classNames = getGlobalClassNames(GlobalClassNames$q, theme);
    return {
        root: [
            classNames.root,
            theme.fonts.small,
            {
                position: 'relative',
                fontSize: FontSizes.small,
                background: semanticColors.listBackground,
                color: semanticColors.listText,
                selectors: {
                    [`& .${classNames.listCell}`]: {
                        minHeight: 38,
                        wordBreak: 'break-word'
                    }
                }
            },
            isFixed && [classNames.isFixed],
            compact && [
                classNames.compact,
                {
                    selectors: {
                        [`.${classNames.listCell}`]: {
                            minHeight: 32
                        }
                    }
                }
            ],
            isHorizontalConstrained && [
                classNames.isHorizontalConstrained,
                {
                    overflowX: 'auto',
                    overflowY: 'visible',
                    WebkitOverflowScrolling: 'touch'
                }
            ],
            className
        ],
        focusZone: [
            {
                display: 'inline-block',
                minWidth: '100%',
                minHeight: 1
            }
        ],
        headerWrapper: [classNames.headerWrapper],
        contentWrapper: [classNames.contentWrapper]
    };
};

//export { IDetailsListProps };
const DetailsList = styled(DetailsListBase, getStyles$K, undefined, {
    scope: 'DetailsList'
});

var DialogType;
(function (DialogType) {
    /** Standard dialog */
    DialogType[DialogType["normal"] = 0] = "normal";
    /** Dialog with large header banner */
    DialogType[DialogType["largeHeader"] = 1] = "largeHeader";
    /** Dialog with an 'x' close button in the upper-right corner */
    DialogType[DialogType["close"] = 2] = "close";
})(DialogType || (DialogType = {}));

const animationDuration = AnimationVariables.durationValue2;
const getOverlayStyles = {
    root: {
        selectors: {
            [HighContrastSelector]: {
                opacity: 0
            }
        }
    }
};
const globalClassNames$1 = {
    root: 'ms-Modal',
    main: 'ms-Dialog-main',
    scrollableContent: 'ms-Modal-scrollableContent',
    isOpen: 'is-open'
};
const getStyles$L = (props) => {
    const { className, containerClassName, scrollableContentClassName, isOpen, isVisible, hasBeenOpened, modalRectangleTop, theme, topOffsetFixed } = props;
    const { palette } = theme;
    const classNames = getGlobalClassNames(globalClassNames$1, theme);
    return {
        root: [
            classNames.root,
            theme.fonts.medium,
            {
                backgroundColor: 'transparent',
                position: 'fixed',
                height: '100%',
                width: '100%',
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
                opacity: 0,
                pointerEvents: 'none',
                transition: `opacity ${animationDuration}`
            },
            topOffsetFixed &&
                hasBeenOpened && {
                alignItems: 'flex-start'
            },
            isOpen && classNames.isOpen,
            isVisible && {
                opacity: 1,
                pointerEvents: 'auto'
            },
            className
        ],
        main: [
            classNames.main,
            {
                boxShadow: '0 0 5px 0 rgba(0, 0, 0, 0.4)',
                backgroundColor: palette.white,
                boxSizing: 'border-box',
                position: 'relative',
                textAlign: 'left',
                outline: '3px solid transparent',
                maxHeight: '100%',
                overflowY: 'auto'
            },
            topOffsetFixed &&
                hasBeenOpened && {
                top: modalRectangleTop
            },
            containerClassName
        ],
        scrollableContent: [
            classNames.scrollableContent,
            {
                overflowY: 'auto',
                flexGrow: 1
            },
            scrollableContentClassName
        ]
    };
};

const getClassNames$F = classNamesFunction();
class OverlayBase extends BaseComponent {
    componentDidMount() {
        disableBodyScroll();
    }
    componentWillUnmount() {
        enableBodyScroll();
    }
    render() {
        const { isDarkThemed: isDark, className, theme, styles } = this.props;
        const divProps = getNativeProps(this.props, divProperties);
        const classNames = getClassNames$F(styles, {
            theme: theme,
            className,
            isDark
        });
        return createElement("div", Object.assign({}, divProps, { className: classNames.root }));
    }
}

const GlobalClassNames$r = {
    root: 'ms-Overlay',
    rootDark: 'ms-Overlay--dark'
};
const getStyles$M = (props) => {
    const { className, theme, isNone, isDark } = props;
    const { palette } = theme;
    const classNames = getGlobalClassNames(GlobalClassNames$r, theme);
    return {
        root: [
            classNames.root,
            theme.fonts.medium,
            {
                backgroundColor: palette.whiteTranslucent40,
                top: 0,
                right: 0,
                bottom: 0,
                left: 0,
                position: 'absolute',
                selectors: {
                    [HighContrastSelector]: {
                        border: '1px solid WindowText'
                    }
                }
            },
            isNone && {
                visibility: 'hidden'
            },
            isDark && [
                classNames.rootDark,
                {
                    backgroundColor: palette.blackTranslucent40
                }
            ],
            className
        ]
    };
};

const Overlay = styled(OverlayBase, getStyles$M, undefined, {
    scope: 'Overlay'
});

// @TODO - need to change this to a panel whenever the breakpoint is under medium (verify the spec)
const DefaultLayerProps = {
    eventBubblingEnabled: false
};
const getClassNames$G = classNamesFunction();
let ModalBase = class ModalBase extends BaseComponent {
    constructor(props) {
        super(props);
        this._focusTrapZone = createRef();
        // Allow the user to scroll within the modal but not on the body
        this._allowScrollOnModal = (elt) => {
            if (elt) {
                allowScrollOnElement(elt, this._events);
            }
            else {
                this._events.off(this._scrollableContent);
            }
            this._scrollableContent = elt;
        };
        this.state = {
            id: getId('Modal'),
            isOpen: props.isOpen,
            isVisible: props.isOpen,
            hasBeenOpened: props.isOpen
        };
        this._warnDeprecations({
            onLayerDidMount: 'layerProps.onLayerDidMount'
        });
    }
    componentWillReceiveProps(newProps) {
        clearTimeout(this._onModalCloseTimer);
        // Opening the dialog
        if (newProps.isOpen) {
            if (!this.state.isOpen) {
                // First Open
                this.setState({
                    isOpen: true
                });
            }
            else {
                // Modal has been opened
                // Reopen during closing
                this.setState({
                    hasBeenOpened: true,
                    isVisible: true
                });
                if (newProps.topOffsetFixed) {
                    const dialogMain = document.getElementsByClassName('ms-Dialog-main');
                    let modalRectangle;
                    if (dialogMain.length > 0) {
                        modalRectangle = dialogMain[0].getBoundingClientRect();
                        this.setState({
                            modalRectangleTop: modalRectangle.top
                        });
                    }
                }
            }
        }
        // Closing the dialog
        if (!newProps.isOpen && this.state.isOpen) {
            this._onModalCloseTimer = this._async.setTimeout(this._onModalClose, parseFloat(animationDuration) * 1000);
            this.setState({
                isVisible: false
            });
        }
    }
    componentDidUpdate(prevProps, prevState) {
        if (!prevProps.isOpen && !prevState.isVisible) {
            this.setState({
                isVisible: true
            });
        }
    }
    render() {
        const { className, containerClassName, scrollableContentClassName, elementToFocusOnDismiss, firstFocusableSelector, forceFocusInsideTrap, ignoreExternalFocusing, isBlocking, isClickableOutsideFocusTrap, isDarkOverlay, onDismiss, layerProps, responsiveMode, titleAriaId, styles, subtitleAriaId, theme, topOffsetFixed, onLayerDidMount } = this.props;
        const { isOpen, isVisible, hasBeenOpened, modalRectangleTop } = this.state;
        const mergedLayerProps = {
            ...DefaultLayerProps,
            ...this.props.layerProps,
            onLayerDidMount: layerProps && layerProps.onLayerDidMount ? layerProps.onLayerDidMount : onLayerDidMount
        };
        if (!isOpen) {
            return null;
        }
        const classNames = getClassNames$G(styles, {
            theme: theme,
            className,
            containerClassName,
            scrollableContentClassName,
            isOpen,
            isVisible,
            hasBeenOpened,
            modalRectangleTop,
            topOffsetFixed
        });
        // @temp tuatology - Will adjust this to be a panel at certain breakpoints
        if (responsiveMode >= ResponsiveMode.small) {
            return (createElement(Layer, Object.assign({}, mergedLayerProps),
                createElement(Popup, { role: isBlocking ? 'alertdialog' : 'dialog', "aria-modal": "true", ariaLabelledBy: titleAriaId, ariaDescribedBy: subtitleAriaId, onDismiss: onDismiss },
                    createElement("div", { className: classNames.root },
                        createElement(Overlay, { isDarkThemed: isDarkOverlay, onClick: isBlocking ? undefined : onDismiss, styles: getOverlayStyles }),
                        createElement(FocusTrapZone, { componentRef: this._focusTrapZone, className: classNames.main, elementToFocusOnDismiss: elementToFocusOnDismiss, isClickableOutsideFocusTrap: isClickableOutsideFocusTrap ? isClickableOutsideFocusTrap : !isBlocking, ignoreExternalFocusing: ignoreExternalFocusing, forceFocusInsideTrap: forceFocusInsideTrap, firstFocusableSelector: firstFocusableSelector },
                            createElement("div", { ref: this._allowScrollOnModal, className: classNames.scrollableContent }, this.props.children))))));
        }
        return null;
    }
    focus() {
        if (this._focusTrapZone.current) {
            this._focusTrapZone.current.focus();
        }
    }
    // Watch for completed animations and set the state
    _onModalClose() {
        this.setState({
            isOpen: false
        });
        // Call the onDismiss callback
        if (this.props.onDismissed) {
            this.props.onDismissed();
        }
    }
};
ModalBase.defaultProps = {
    isOpen: false,
    isDarkOverlay: true,
    isBlocking: false,
    className: '',
    containerClassName: ''
};
ModalBase = __decorate([
    withResponsiveMode
], ModalBase);

const Modal = styled(ModalBase, getStyles$L, undefined, {
    scope: 'Modal'
});

const getClassNames$H = classNamesFunction();
class DialogFooterBase extends BaseComponent {
    render() {
        const { className, styles, theme } = this.props;
        this._classNames = getClassNames$H(styles, {
            theme: theme,
            className
        });
        return (createElement("div", { className: this._classNames.actions },
            createElement("div", { className: this._classNames.actionsRight }, this._renderChildrenAsActions())));
    }
    _renderChildrenAsActions() {
        return Children.map(this.props.children, child => (child ? createElement("span", { className: this._classNames.action }, child) : null));
    }
}

const GlobalClassNames$s = {
    actions: 'ms-Dialog-actions',
    action: 'ms-Dialog-action',
    actionsRight: 'ms-Dialog-actionsRight'
};
const getStyles$N = (props) => {
    const { className, theme } = props;
    const classNames = getGlobalClassNames(GlobalClassNames$s, theme);
    return {
        actions: [
            classNames.actions,
            {
                position: 'relative',
                width: '100%',
                minHeight: '24px',
                lineHeight: '24px',
                margin: '20px 0 0',
                fontSize: '0',
                selectors: {
                    '.ms-Button': {
                        lineHeight: 'normal'
                    }
                }
            },
            className
        ],
        action: [classNames.action],
        actionsRight: [
            classNames.actionsRight,
            {
                textAlign: 'right',
                marginRight: '-4px',
                fontSize: '0',
                selectors: {
                    $action: {
                        margin: '0 4px'
                    }
                }
            }
        ]
    };
};

const DialogFooter = styled(DialogFooterBase, getStyles$N, undefined, { scope: 'DialogFooter' });

const getClassNames$I = classNamesFunction();
const DialogFooterType = createElement(DialogFooter, null).type;
let DialogContentBase = class DialogContentBase extends BaseComponent {
    constructor(props) {
        super(props);
    }
    render() {
        const { showCloseButton, className, closeButtonAriaLabel, onDismiss, subTextId, subText, titleId, title, type, styles, theme } = this.props;
        const classNames = getClassNames$I(styles, {
            theme: theme,
            className,
            isLargeHeader: type === DialogType.largeHeader,
            isClose: type === DialogType.close
        });
        const groupings = this._groupChildren();
        let subTextContent;
        if (subText) {
            subTextContent = (createElement("p", { className: classNames.subText, id: subTextId }, subText));
        }
        return (createElement("div", { className: classNames.content },
            createElement("div", { className: classNames.header },
                createElement("p", { className: classNames.title, id: titleId, role: "heading", "aria-level": 2 }, title),
                createElement("div", { className: classNames.topButton },
                    this.props.topButtonsProps.map((props, index) => (createElement(IconButton, Object.assign({ key: props.uniqueId || index }, props)))),
                    (type === DialogType.close || (showCloseButton && type !== DialogType.largeHeader)) && (createElement(IconButton, { className: classNames.button, iconProps: { iconName: 'Cancel' }, ariaLabel: closeButtonAriaLabel, onClick: onDismiss })))),
            createElement("div", { className: classNames.inner },
                createElement("div", { className: classNames.innerContent },
                    subTextContent,
                    groupings.contents),
                groupings.footers)));
    }
    // @TODO - typing the footers as an array of DialogFooter is difficult because
    // casing "child as DialogFooter" causes a problem because
    // "Neither type 'ReactElement<any>' nor type 'DialogFooter' is assignable to the other."
    _groupChildren() {
        const groupings = {
            footers: [],
            contents: []
        };
        Children.map(this.props.children, child => {
            if (typeof child === 'object' && child !== null && child.type === DialogFooterType) {
                groupings.footers.push(child);
            }
            else {
                groupings.contents.push(child);
            }
        });
        return groupings;
    }
};
DialogContentBase.defaultProps = {
    showCloseButton: false,
    className: '',
    topButtonsProps: [],
    closeButtonAriaLabel: 'Close'
};
DialogContentBase = __decorate([
    withResponsiveMode
], DialogContentBase);

const GlobalClassNames$t = {
    contentLgHeader: 'ms-Dialog-lgHeader',
    close: 'ms-Dialog--close',
    subText: 'ms-Dialog-subText',
    header: 'ms-Dialog-header',
    headerLg: 'ms-Dialog--lgHeader',
    button: 'ms-Dialog-button ms-Dialog-button--close',
    inner: 'ms-Dialog-inner',
    content: 'ms-Dialog-content',
    title: 'ms-Dialog-title'
};
const getStyles$O = (props) => {
    const { className, theme, isLargeHeader, isClose, hidden, isMultiline } = props;
    const { palette, fonts } = theme;
    const classNames = getGlobalClassNames(GlobalClassNames$t, theme);
    return {
        content: [
            isLargeHeader && classNames.contentLgHeader,
            isClose && classNames.close,
            {
                flexGrow: 1,
                overflowY: 'auto' // required for IE11
            },
            className
        ],
        subText: [
            classNames.subText,
            isLargeHeader ? fonts.medium : fonts.small,
            {
                margin: '0 0 20px 0',
                paddingTop: '8px',
                color: palette.neutralPrimary,
                lineHeight: '1.5',
                wordWrap: 'break-word',
                fontWeight: FontWeights.semilight
            }
        ],
        header: [
            classNames.header,
            {
                position: 'relative',
                width: '100%',
                boxSizing: 'border-box'
            },
            isLargeHeader && [
                classNames.headerLg,
                {
                    backgroundColor: palette.themePrimary
                }
            ],
            isClose && classNames.close
        ],
        button: [
            classNames.button,
            hidden && {
                selectors: {
                    '.ms-Icon.ms-Icon--Cancel': {
                        color: palette.neutralSecondary,
                        fontSize: '16px'
                    }
                }
            }
        ],
        inner: [
            classNames.inner,
            {
                padding: isMultiline ? '0 20px 20px' : '0 28px 20px'
            }
        ],
        innerContent: [
            classNames.content,
            {
                position: 'relative',
                width: '100%',
                selectors: {
                    '.ms-Button.ms-Button--compount': {
                        marginBottom: '20px',
                        selectors: {
                            '&:last-child': {
                                marginBottom: '0'
                            }
                        }
                    }
                }
            },
            className
        ],
        title: [
            classNames.title,
            {
                color: palette.neutralPrimary,
                margin: '0',
                padding: '20px 36px 20px 28px'
            },
            fonts.xLarge,
            isLargeHeader && [
                {
                    color: palette.white,
                    marginBottom: '8px',
                    padding: '26px 28px 28px'
                },
                fonts.xxLarge
            ],
            isMultiline && fonts.xxLarge
        ],
        topButton: [
            {
                display: 'flex',
                flexDirection: 'row',
                flexWrap: 'nowrap',
                position: 'absolute',
                top: '0',
                right: '0',
                padding: '12px 12px 0 0',
                selectors: {
                    '> *': {
                        flex: '0 0 auto'
                    }
                }
            }
        ]
    };
};

const DialogContent = styled(DialogContentBase, getStyles$O, undefined, { scope: 'DialogContent' });

const getClassNames$J = classNamesFunction();
const DefaultModalProps = {
    isDarkOverlay: false,
    isBlocking: false,
    className: '',
    containerClassName: '',
    topOffsetFixed: false
};
const DefaultDialogContentProps = {
    type: DialogType.normal,
    className: '',
    topButtonsProps: []
};
let DialogBase = class DialogBase extends BaseComponent {
    constructor(props) {
        super(props);
        this._getSubTextId = () => {
            const { ariaDescribedById, modalProps, dialogContentProps, subText } = this.props;
            let id = ariaDescribedById || (modalProps && modalProps.subtitleAriaId);
            if (!id) {
                id = (subText || (dialogContentProps && dialogContentProps.subText)) && this._defaultSubTextId;
            }
            return id;
        };
        this._getTitleTextId = () => {
            const { ariaLabelledById, modalProps, dialogContentProps, title } = this.props;
            let id = ariaLabelledById || (modalProps && modalProps.titleAriaId);
            if (!id) {
                id = (title || (dialogContentProps && dialogContentProps.title)) && this._defaultTitleTextId;
            }
            return id;
        };
        this._id = getId('Dialog');
        this._defaultTitleTextId = this._id + '-title';
        this._defaultSubTextId = this._id + '-subText';
        this._warnDeprecations({
            isOpen: 'hidden',
            type: 'dialogContentProps.type',
            subText: 'dialogContentProps.subText',
            contentClassName: 'dialogContentProps.className',
            topButtonsProps: 'dialogContentProps.topButtonsProps',
            className: 'modalProps.className',
            isDarkOverlay: 'modalProps.isDarkOverlay',
            isBlocking: 'modalProps.isBlocking',
            containerClassName: 'modalProps.containerClassName',
            onDismissed: 'modalProps.onDismissed',
            onLayerDidMount: 'modalProps.layerProps.onLayerDidMount',
            ariaDescribedById: 'modalProps.subtitleAriaId',
            ariaLabelledById: 'modalProps.titleAriaId'
        });
    }
    render() {
        const { className, containerClassName, contentClassName, elementToFocusOnDismiss, firstFocusableSelector, forceFocusInsideTrap, styles, hidden, ignoreExternalFocusing, isBlocking, isClickableOutsideFocusTrap, isDarkOverlay, isOpen, onDismiss, onDismissed, onLayerDidMount, responsiveMode, subText, theme, title, topButtonsProps, type, minWidth, maxWidth, modalProps } = this.props;
        const mergedLayerProps = {
            ...(modalProps ? modalProps.layerProps : { onLayerDidMount })
        };
        if (onLayerDidMount && !mergedLayerProps.onLayerDidMount) {
            mergedLayerProps.onLayerDidMount = onLayerDidMount;
        }
        const mergedModalProps = {
            ...DefaultModalProps,
            ...modalProps,
            layerProps: mergedLayerProps
        };
        const dialogContentProps = {
            ...DefaultDialogContentProps,
            ...this.props.dialogContentProps
        };
        const classNames = getClassNames$J(styles, {
            theme: theme,
            className: className || mergedModalProps.className,
            containerClassName: containerClassName || mergedModalProps.containerClassName,
            hidden,
            dialogDefaultMinWidth: minWidth,
            dialogDefaultMaxWidth: maxWidth
        });
        return (createElement(Modal, Object.assign({ elementToFocusOnDismiss: elementToFocusOnDismiss, firstFocusableSelector: firstFocusableSelector, forceFocusInsideTrap: forceFocusInsideTrap, ignoreExternalFocusing: ignoreExternalFocusing, isClickableOutsideFocusTrap: isClickableOutsideFocusTrap, onDismissed: onDismissed, responsiveMode: responsiveMode }, mergedModalProps, { isDarkOverlay: isDarkOverlay !== undefined ? isDarkOverlay : mergedModalProps.isDarkOverlay, isBlocking: isBlocking !== undefined ? isBlocking : mergedModalProps.isBlocking, isOpen: isOpen !== undefined ? isOpen : !hidden, className: classNames.root, containerClassName: classNames.main, onDismiss: onDismiss ? onDismiss : mergedModalProps.onDismiss, subtitleAriaId: this._getSubTextId(), titleAriaId: this._getTitleTextId() }),
            createElement(DialogContent, Object.assign({ titleId: this._defaultTitleTextId, subTextId: this._defaultSubTextId, title: title, subText: subText, showCloseButton: isBlocking !== undefined ? !isBlocking : !mergedModalProps.isBlocking, topButtonsProps: topButtonsProps ? topButtonsProps : dialogContentProps.topButtonsProps, type: type !== undefined ? type : dialogContentProps.type, onDismiss: onDismiss ? onDismiss : dialogContentProps.onDismiss, className: contentClassName || dialogContentProps.className }, dialogContentProps), this.props.children)));
    }
};
DialogBase.defaultProps = {
    hidden: true
};
DialogBase = __decorate([
    withResponsiveMode
], DialogBase);

const GlobalClassNames$u = {
    root: 'ms-Dialog'
};
const getStyles$P = (props) => {
    const { className, containerClassName, dialogDefaultMinWidth = '288px', dialogDefaultMaxWidth = '340px', hidden, theme } = props;
    const classNames = getGlobalClassNames(GlobalClassNames$u, theme);
    return {
        root: [classNames.root, theme.fonts.medium, className],
        main: [
            {
                width: dialogDefaultMinWidth,
                outline: '3px solid transparent',
                selectors: {
                    [`@media (min-width: ${ScreenWidthMinMedium}px)`]: {
                        width: 'auto',
                        maxWidth: dialogDefaultMaxWidth,
                        minWidth: dialogDefaultMinWidth
                    }
                }
            },
            !hidden && { display: 'flex' },
            containerClassName
        ]
    };
};

const Dialog = styled(DialogBase, getStyles$P, undefined, { scope: 'Dialog' });

var DocumentCardType;
(function (DocumentCardType) {
    /**
     * Standard DocumentCard.
     */
    DocumentCardType[DocumentCardType["normal"] = 0] = "normal";
    /**
     * Compact layout. Displays the preview beside the details, rather than above.
     */
    DocumentCardType[DocumentCardType["compact"] = 1] = "compact";
})(DocumentCardType || (DocumentCardType = {}));

// import * as stylesImport from './DocumentCard.scss';
// const styles: any = stylesImport;
let styles$5;
class DocumentCard extends BaseComponent {
    constructor(props) {
        super(props);
        this._rootElement = createRef();
        this._onClick = (ev) => {
            this._onAction(ev);
        };
        this._onKeyDown = (ev) => {
            if (ev.which === KeyCodes.enter || ev.which === KeyCodes.space) {
                this._onAction(ev);
            }
        };
        this._onAction = (ev) => {
            const { onClick, onClickHref } = this.props;
            if (onClick) {
                onClick(ev);
            }
            else if (!onClick && onClickHref) {
                // If no onClick Function was provided and we do have an onClickHref, redirect to the onClickHref
                window.location.href = onClickHref;
                ev.preventDefault();
                ev.stopPropagation();
            }
        };
        this._warnDeprecations({
            accentColor: undefined
        });
    }
    render() {
        const { onClick, onClickHref, children, className, type, accentColor } = this.props;
        const actionable = onClick || onClickHref ? true : false;
        // Override the border color if an accent color was provided (compact card only)
        let style;
        if (type === DocumentCardType.compact && accentColor) {
            style = {
                borderBottomColor: accentColor
            };
        }
        // if this element is actionable it should have an aria role
        const role = this.props.role || (actionable ? (onClick ? 'button' : 'link') : undefined);
        const tabIndex = actionable ? 0 : undefined;
        return (createElement("div", { ref: this._rootElement, tabIndex: tabIndex, "data-is-focusable": actionable, role: role, className: css('ms-DocumentCard', styles$5.root, {
                ['ms-DocumentCard--actionable ' + styles$5.rootIsActionable]: actionable,
                ['ms-DocumentCard--compact ' + styles$5.rootIsCompact]: type === DocumentCardType.compact ? true : false
            }, className), onKeyDown: actionable ? this._onKeyDown : undefined, onClick: actionable ? this._onClick : undefined, style: style }, children));
    }
    focus() {
        if (this._rootElement.current) {
            this._rootElement.current.focus();
        }
    }
}
DocumentCard.defaultProps = {
    type: DocumentCardType.normal
};

// import * as stylesImport from './DocumentCard.scss';
// const styles: any = stylesImport;
let styles$6;
class DocumentCardActions extends BaseComponent {
    render() {
        const { actions, views } = this.props;
        return (createElement("div", { className: css('ms-DocumentCardActions', styles$6.actions) },
            actions &&
                actions.map((action, index) => {
                    return (createElement("div", { className: css('ms-DocumentCardActions-action', styles$6.action), key: index },
                        createElement(IconButton, Object.assign({}, action))));
                }),
            views > 0 && (createElement("div", { className: css('ms-DocumentCardActions-views', styles$6.views) },
                createElement(Icon, { iconName: "View", className: styles$6.viewsIcon }),
                views))));
    }
}

// import * as stylesImport from './DocumentCard.scss';
// const styles: any = stylesImport;
let styles$7;
class DocumentCardActivity extends BaseComponent {
    render() {
        const { activity, people } = this.props;
        if (!people || people.length === 0) {
            return null;
        }
        return (createElement("div", { className: css('ms-DocumentCardActivity', styles$7.activity, {
                ['ms-DocumentCardActivity--multiplePeople ' + styles$7.activityIsMultiplePeople]: people.length > 1
            }) },
            this._renderAvatars(people),
            createElement("div", { className: css('ms-DocumentCardActivity-details', styles$7.activityDetails) },
                createElement("span", { className: css('ms-DocumentCardActivity-name', styles$7.name) }, this._getNameString(people)),
                createElement("span", { className: css('ms-DocumentCardActivity-activity', styles$7.activityActivity) }, activity))));
    }
    _renderAvatars(people) {
        return (createElement("div", { className: css('ms-DocumentCardActivity-avatars', styles$7.avatars) },
            people.length > 1 ? this._renderAvatar(people[1]) : null,
            this._renderAvatar(people[0])));
    }
    _renderAvatar(person) {
        return (createElement("div", { className: css('ms-DocumentCardActivity-avatar', styles$7.avatar) },
            createElement(PersonaCoin, { imageInitials: person.initials, text: person.name, imageUrl: person.profileImageSrc, initialsColor: person.initialsColor, allowPhoneInitials: person.allowPhoneInitials, role: "presentation", size: PersonaSize.size32 })));
    }
    _getNameString(people) {
        let nameString = people[0].name;
        if (people.length >= 2) {
            nameString += ' +' + (people.length - 1);
        }
        return nameString;
    }
}

// import * as stylesImport from './DocumentCard.scss';
// const styles: any = stylesImport;
let styles$8;
class DocumentCardLocation extends BaseComponent {
    render() {
        const { location, locationHref, ariaLabel, onClick } = this.props;
        return (createElement("a", { className: css('ms-DocumentCardLocation', styles$8.location), href: locationHref, onClick: onClick, "aria-label": ariaLabel }, location));
    }
}

// import * as stylesImport from './DocumentCard.scss';
// const styles: any = stylesImport;
let styles$9;
const LIST_ITEM_COUNT = 3;
class DocumentCardPreview extends BaseComponent {
    constructor() {
        super(...arguments);
        this._renderPreviewList = (previewImages) => {
            const { getOverflowDocumentCountText } = this.props;
            // Determine how many documents we won't be showing
            const overflowDocumentCount = previewImages.length - LIST_ITEM_COUNT;
            // Determine the overflow text that will be rendered after the preview list.
            const overflowText = overflowDocumentCount
                ? getOverflowDocumentCountText
                    ? getOverflowDocumentCountText(overflowDocumentCount)
                    : '+' + overflowDocumentCount
                : null;
            // Create list items for the documents to be shown
            const fileListItems = previewImages.slice(0, LIST_ITEM_COUNT).map((file, fileIndex) => (createElement("li", { key: fileIndex },
                createElement(Image, { className: css('ms-DocumentCardPreview-fileListIcon', styles$9.fileListIcon), src: file.iconSrc, role: "presentation", alt: "", width: "16px", height: "16px" }),
                createElement(Link, Object.assign({}, (file.linkProps, { href: file.url || (file.linkProps && file.linkProps.href) })), file.name))));
            return (createElement("div", null,
                createElement("ul", { className: css('ms-DocumentCardPreview-fileList', styles$9.fileList) }, fileListItems),
                overflowText && createElement("span", { className: css('ms-DocumentCardPreview-fileListMore', styles$9.fileListMore) }, overflowText)));
        };
    }
    render() {
        const { previewImages } = this.props;
        let style, preview;
        let isFileList = false;
        if (previewImages.length > 1) {
            // Render a list of files
            preview = this._renderPreviewList(previewImages);
            isFileList = true;
        }
        else if (previewImages.length === 1) {
            // Render a single preview
            preview = this._renderPreviewImage(previewImages[0]);
            // Override the border color if an accent color was provided
            if (previewImages[0].accentColor) {
                style = {
                    borderBottomColor: previewImages[0].accentColor
                };
            }
        }
        return (createElement("div", { className: css('ms-DocumentCardPreview', styles$9.preview, isFileList && 'is-fileList ' + styles$9.previewIsFileList), style: style }, preview));
    }
    _renderPreviewImage(previewImage) {
        const { width, height, imageFit, previewIconProps, previewIconContainerClass } = previewImage;
        const iconContainerClass = previewIconContainerClass ? previewIconContainerClass : 'ms-DocumentCardPreview-iconContainer';
        if (previewIconProps) {
            return (createElement("div", { className: css(iconContainerClass, styles$9.previewIconContainer), style: { width: width, height: height } },
                createElement(Icon, Object.assign({}, previewIconProps))));
        }
        const image = createElement(Image, { width: width, height: height, imageFit: imageFit, src: previewImage.previewImageSrc, role: "presentation", alt: "" });
        let icon;
        if (previewImage.iconSrc) {
            icon = createElement(Image, { className: css('ms-DocumentCardPreview-icon', styles$9.icon), src: previewImage.iconSrc, role: "presentation", alt: "" });
        }
        return (createElement("div", null,
            image,
            icon));
    }
}

// import * as stylesImport from './DocumentCard.scss';
// const styles: any = stylesImport;
let styles$a;
const TRUNCATION_SEPARATOR = '&hellip;';
const TRUNCATION_MINIMUM_LENGTH = 40; // This is the length we know can fit into the min width of DocumentCard.
const TRUNCATION_MAXIMUM_LENGTH = 90 - TRUNCATION_SEPARATOR.length;
// This is the length we know can fit into the min width 2 lines of DocumentCard.
const TRUNCATION_MINI_LENGTH_SECONDARY = 80;
const TRUNCATION_MAX_LENGTH_SECONDARY = 130 - TRUNCATION_SEPARATOR.length;
const TRUNCATION_FIRST_PIECE_LONGER_BY = 10;
const TRUNCATION_VERTICAL_OVERFLOW_THRESHOLD = 5;
class DocumentCardTitle extends BaseComponent {
    constructor(props) {
        super(props);
        this._titleElement = createRef();
        this._startTruncation = (props) => {
            const originalTitle = props.title;
            this._isTruncated = false;
            const miniLength = props.showAsSecondaryTitle ? TRUNCATION_MINI_LENGTH_SECONDARY : TRUNCATION_MINIMUM_LENGTH;
            const maxLength = props.showAsSecondaryTitle ? TRUNCATION_MAX_LENGTH_SECONDARY : TRUNCATION_MAXIMUM_LENGTH;
            // If the title is really short, there's no need to truncate it
            if (originalTitle && originalTitle.length >= miniLength) {
                // Break the text into two pieces for assembly later
                if (originalTitle.length > maxLength) {
                    // The text is really long, so we can take a chunk out of the middle so the two pieces combine for the maximum length
                    this._isTruncated = true;
                    this.setState({
                        truncatedTitleFirstPiece: originalTitle.slice(0, maxLength / 2 + TRUNCATION_FIRST_PIECE_LONGER_BY),
                        truncatedTitleSecondPiece: originalTitle.slice(originalTitle.length - (maxLength / 2 - TRUNCATION_FIRST_PIECE_LONGER_BY))
                    });
                }
                else {
                    // The text is not so long, so we'll just break it into two pieces
                    this.setState({
                        truncatedTitleFirstPiece: originalTitle.slice(0, Math.ceil(originalTitle.length / 2) + TRUNCATION_FIRST_PIECE_LONGER_BY),
                        truncatedTitleSecondPiece: originalTitle.slice(originalTitle.length - Math.floor(originalTitle.length / 2) + TRUNCATION_FIRST_PIECE_LONGER_BY)
                    });
                }
            }
            // Save the width we just started truncation at, so that later we will only update truncation if necessary
            if (this._titleElement.current) {
                this._truncatedTitleAtWidth = this._titleElement.current.clientWidth;
            }
        };
        this.state = {
            truncatedTitleFirstPiece: '',
            truncatedTitleSecondPiece: ''
        };
    }
    componentDidMount() {
        const { title, shouldTruncate, showAsSecondaryTitle } = this.props;
        const miniLength = showAsSecondaryTitle ? TRUNCATION_MINI_LENGTH_SECONDARY : TRUNCATION_MINIMUM_LENGTH;
        if (shouldTruncate && title && title.length > miniLength) {
            if (this._doesTitleOverflow()) {
                this._startTruncation(this.props);
            }
            this._events.on(window, 'resize', this._updateTruncation);
        }
    }
    componentWillReceiveProps(newProps) {
        this._events.off(window, 'resize');
        this._isTruncated = false;
        const miniLength = newProps.showAsSecondaryTitle ? TRUNCATION_MINI_LENGTH_SECONDARY : TRUNCATION_MINIMUM_LENGTH;
        if (newProps.shouldTruncate && newProps.title && newProps.title.length > miniLength) {
            this._startTruncation(newProps);
            this._events.on(window, 'resize', this._updateTruncation);
        }
    }
    componentDidUpdate() {
        // If we're truncating, make sure the title fits
        if (this.props.shouldTruncate) {
            this._shrinkTitle();
        }
    }
    render() {
        const { title, shouldTruncate, showAsSecondaryTitle } = this.props;
        const { truncatedTitleFirstPiece, truncatedTitleSecondPiece } = this.state;
        let documentCardTitle;
        if (shouldTruncate && this._isTruncated) {
            documentCardTitle = (createElement("div", { className: css('ms-DocumentCardTitle', showAsSecondaryTitle ? styles$a.secondaryTitle : styles$a.title), ref: this._titleElement, title: title },
                truncatedTitleFirstPiece,
                "\u2026",
                truncatedTitleSecondPiece));
        }
        else {
            documentCardTitle = (createElement("div", { className: css('ms-DocumentCardTitle', showAsSecondaryTitle ? styles$a.secondaryTitle : styles$a.title), ref: this._titleElement, title: title }, title));
        }
        return documentCardTitle;
    }
    _shrinkTitle() {
        if (this._doesTitleOverflow()) {
            const { truncatedTitleFirstPiece, truncatedTitleSecondPiece } = this.state;
            this._isTruncated = true;
            if (truncatedTitleFirstPiece || truncatedTitleSecondPiece) {
                this.setState({
                    truncatedTitleFirstPiece: truncatedTitleFirstPiece.slice(0, truncatedTitleFirstPiece.length - 1),
                    truncatedTitleSecondPiece: truncatedTitleSecondPiece.slice(1)
                });
            }
        }
    }
    _doesTitleOverflow() {
        const titleElement = this._titleElement.current;
        if (!titleElement) {
            return false;
        }
        return (titleElement.scrollHeight > titleElement.clientHeight + TRUNCATION_VERTICAL_OVERFLOW_THRESHOLD ||
            titleElement.scrollWidth > titleElement.clientWidth);
    }
    _updateTruncation() {
        // Only update truncation if the title's size has changed since the last time we truncated
        if (this._titleElement.current && this._titleElement.current.clientWidth !== this._truncatedTitleAtWidth) {
            // Throttle truncation so that it doesn't happen during a window resize
            clearTimeout(this._scrollTimerId);
            this._scrollTimerId = this._async.setTimeout(this._startTruncation.bind(this, this.props), 250);
        }
    }
}

// import * as stylesImport from './DocumentCard.scss';
// const styles: any = stylesImport;
let styles$b;
class DocumentCardLogo extends BaseComponent {
    render() {
        const { logoIcon } = this.props;
        return (createElement("div", { className: css('ms-DocumentCardLogo', styles$b.logo) },
            createElement(Icon, { iconName: logoIcon })));
    }
}

// import * as stylesImport from './DocumentCard.scss';
// const styles: any = stylesImport;
let styles$c;
class DocumentCardStatus extends BaseComponent {
    constructor(props) {
        super(props);
    }
    render() {
        const { statusIcon, status } = this.props;
        const iconProps = {
            iconName: statusIcon,
            styles: {
                root: { padding: '8px' }
            }
        };
        return (createElement("div", { className: css('ms-DocumentCardStatus', styles$c.status) },
            statusIcon && createElement(Icon, Object.assign({}, iconProps)),
            status));
    }
}

/**
 * A utility class to cache size and position in cache.
 *
 * Dropdown options has non-selectable display types. It is therefore not cheap to determine
 * the total number of actual selectable options as well as the position an option is in the
 * list of options - O(n) cost for each lookup.
 *
 * Given that we potentially have to make this determination on every single render pass, this
 * cache should provide a little bit of relief.
 */
class DropdownSizePosCache {
    constructor() {
        this._size = 0;
    }
    /**
     * Invalidates the cache and recalculate the size of selectable options.
     */
    updateOptions(options) {
        const displayOnlyOptionsCache = [];
        let size = 0;
        for (let i = 0; i < options.length; i++) {
            if (options[i].itemType === SelectableOptionMenuItemType.Divider || options[i].itemType === SelectableOptionMenuItemType.Header) {
                displayOnlyOptionsCache.push(i);
            }
            else {
                size++;
            }
        }
        this._size = size;
        this._displayOnlyOptionsCache = displayOnlyOptionsCache;
    }
    /**
     * The size of all the selectable options.
     */
    get optionSetSize() {
        return this._size;
    }
    /**
     * Returns the position of this option element relative to the full set of selectable option elements.
     * Note: the first selectable element is position 1 in the set.
     * @param index The raw index of the option element.
     */
    positionInSet(index) {
        if (index === undefined) {
            return undefined;
        }
        // we could possibly memoize this too but this should be good enough, most of the time (the expectation is that
        // when you have a lot of options, the selectable options will heavily dominate over the non-selectable options.
        let offset = 0;
        while (index > this._displayOnlyOptionsCache[offset]) {
            offset++;
        }
        if (this._displayOnlyOptionsCache[offset] === index) {
            throw new Error(`Unexpected: Option at index ${index} is not a selectable element.`);
        }
        return index - offset + 1;
    }
}

var PanelType;
(function (PanelType) {
    /**
     * Renders the panel in 'small' mode, anchored to the far side (right in LTR mode), and has a fluid width.
     * Only used on Small screen breakpoints.
     * Small: 320-479px width (full screen), 16px Left/Right padding
     * Medium: \<unused\>
     * Large: \<unused\>
     * XLarge: \<unused\>
     * XXLarge: \<unused\>
     */
    PanelType[PanelType["smallFluid"] = 0] = "smallFluid";
    /**
     * Renders the panel in 'small' mode, anchored to the far side (right in LTR mode), and has a fixed width.
     * Small: 272px width, 16px Left/Right padding
     * Medium: 340px width, 16px Left/Right padding
     * Large: 340px width, 32px Left/Right padding
     * XLarge: 340px width, 32px Left/Right padding
     * XXLarge: 340px width, 40px Left/Right padding
     */
    PanelType[PanelType["smallFixedFar"] = 1] = "smallFixedFar";
    /**
     * Renders the panel in 'small' mode, anchored to the near side (left in LTR mode), and has a fixed width.
     * Small: 272px width, 16px Left/Right padding
     * Medium: 272px width, 16px Left/Right padding
     * Large: 272px width, 32px Left/Right padding
     * XLarge: 272px width, 32px Left/Right padding
     * XXLarge: 272px width, 32px Left/Right padding
     */
    PanelType[PanelType["smallFixedNear"] = 2] = "smallFixedNear";
    /**
     * Renders the panel in 'medium' mode, anchored to the far side (right in LTR mode).
     * Small: \<adapts to smallFluid\>
     * Medium: \<adapts to smallFixedFar\>
     * Large: 48px fixed left margin, 32px Left/Right padding
     * XLarge: 644px width, 32px Left/Right padding
     * XXLarge: 643px width, 40px Left/Right padding
     */
    PanelType[PanelType["medium"] = 3] = "medium";
    /**
     * Renders the panel in 'large' mode, anchored to the far side (right in LTR mode), and is fluid at XXX-Large breakpoint.
     * Small: \<adapts to smallFluid\>
     * Medium:  \<adapts to smallFixedFar\>
     * Large: \<adapts to medium\>
     * XLarge: 48px fixed left margin, 32px Left/Right padding
     * XXLarge: 48px fixed left margin, 32px Left/Right padding
     * XXXLarge: 48px fixed left margin, (no redlines for padding, assuming previous breakpoint)
     */
    PanelType[PanelType["large"] = 4] = "large";
    /**
     * Renders the panel in 'large' mode, anchored to the far side (right in LTR mode), and is fixed at XXX-Large breakpoint.
     * Small: \<adapts to smallFluid\>
     * Medium: \<adapts to smallFixedFar\>
     * Large: \<adapts to medium\>
     * XLarge: 48px fixed left margin, 32px Left/Right padding
     * XXLarge: 48px fixed left margin, 32px Left/Right padding
     * XXXLarge: 940px width, (no redlines for padding, assuming previous breakpoint)
     */
    PanelType[PanelType["largeFixed"] = 5] = "largeFixed";
    /**
     * Renders the panel in 'extra large' mode, anchored to the far side (right in LTR mode).
     * Small: \<adapts to smallFluid\>
     * Medium: \<adapts to smallFixedFar\>
     * Large: \<adapts to medium\>
     * XLarge: \<adapts to large\>
     * XXLarge: 176px fixed left margin, 40px Left/Right padding
     * XXXLarge: 176px fixed left margin, 40px Left/Right padding
     */
    PanelType[PanelType["extraLarge"] = 6] = "extraLarge";
    /**
     * Renders the panel in 'custom' mode using customWidth, anchored to the far side (right in LTR mode).
     * Small: \<adapts to smallFluid\>
     * Medium: \<adapts to smallFixedFar\>
     * Large: 48px fixed left margin, 32px Left/Right padding
     * XLarge: 644px width, 32px Left/Right padding
     * XXLarge: 643px width, 40px Left/Right padding
     */
    PanelType[PanelType["custom"] = 7] = "custom";
})(PanelType || (PanelType = {}));

const getClassNames$K = classNamesFunction();
class PanelBase extends BaseComponent {
    constructor(props) {
        super(props);
        this._panel = createRef();
        this.dismiss = (ev) => {
            if (this.state.isOpen) {
                if (this.props.onDismiss) {
                    this.props.onDismiss(ev);
                }
                if (!ev || (ev && !ev.defaultPrevented)) {
                    this.setState({
                        isOpen: false,
                        isAnimating: true
                    }, () => {
                        this._async.setTimeout(this._onTransitionComplete, 200);
                    });
                }
            }
        };
        // Allow the user to scroll within the panel but not on the body
        this._allowScrollOnPanel = (elt) => {
            if (elt) {
                allowScrollOnElement(elt, this._events);
            }
            else {
                this._events.off(this._scrollableContent);
            }
            this._scrollableContent = elt;
        };
        this._onRenderNavigation = (props) => {
            const { closeButtonAriaLabel, hasCloseButton } = props;
            const theme = getTheme();
            if (hasCloseButton) {
                // TODO -Issue #5689: Comment in once Button is converted to mergeStyles
                // const iconButtonStyles = this._classNames.subComponentStyles
                // ? (this._classNames.subComponentStyles.iconButton as IStyleFunctionOrObject<IButtonStyleProps, IButtonStyles>)
                // : undefined;
                return (createElement("div", { className: this._classNames.navigation },
                    createElement(IconButton
                    // TODO -Issue #5689: Comment in once Button is converted to mergeStyles
                    // className={iconButtonStyles}
                    , { 
                        // TODO -Issue #5689: Comment in once Button is converted to mergeStyles
                        // className={iconButtonStyles}
                        styles: {
                            root: {
                                height: 'auto',
                                width: '44px',
                                color: theme.palette.neutralSecondary,
                                fontSize: IconFontSizes.large
                            },
                            rootHovered: {
                                color: theme.palette.neutralPrimary
                            }
                        }, className: this._classNames.closeButton, onClick: this._onPanelClick, ariaLabel: closeButtonAriaLabel, "data-is-visible": true, iconProps: { iconName: 'Cancel' } })));
            }
            return null;
        };
        this._onRenderHeader = (props, defaultRender, headerTextId) => {
            const { headerText } = props;
            if (headerText) {
                return (createElement("div", { className: this._classNames.header },
                    createElement("p", { className: this._classNames.headerText, id: headerTextId, role: "heading", "aria-level": 2 }, headerText)));
            }
            return null;
        };
        this._onRenderBody = (props) => {
            return createElement("div", { className: this._classNames.content }, props.children);
        };
        this._onRenderFooter = (props) => {
            const { onRenderFooterContent = null } = this.props;
            if (onRenderFooterContent) {
                return (createElement("div", { className: this._classNames.footer },
                    createElement("div", { className: this._classNames.footerInner }, onRenderFooterContent())));
            }
            return null;
        };
        this._onPanelClick = (ev) => {
            this.dismiss(ev);
        };
        this._onTransitionComplete = () => {
            this._updateFooterPosition();
            this.setState({
                isAnimating: false
            });
            if (!this.state.isOpen && this.props.onDismissed) {
                this.props.onDismissed();
            }
        };
        this._warnDeprecations({
            ignoreExternalFocusing: 'focusTrapZoneProps',
            forceFocusInsideTrap: 'focusTrapZoneProps',
            firstFocusableSelector: 'focusTrapZoneProps'
        });
        this.state = {
            isFooterSticky: false,
            isOpen: false,
            isAnimating: false,
            id: getId('Panel')
        };
    }
    componentDidMount() {
        this._events.on(window, 'resize', this._updateFooterPosition);
        if (this._shouldListenForOuterClick(this.props)) {
            this._events.on(document.body, 'mousedown', this._dismissOnOuterClick, true);
        }
        if (this.props.isOpen) {
            this.open();
        }
    }
    componentDidUpdate(previousProps) {
        const shouldListenOnOuterClick = this._shouldListenForOuterClick(this.props);
        const previousShouldListenOnOuterClick = this._shouldListenForOuterClick(previousProps);
        if (shouldListenOnOuterClick && !previousShouldListenOnOuterClick) {
            this._events.on(document.body, 'mousedown', this._dismissOnOuterClick, true);
        }
        else if (!shouldListenOnOuterClick && previousShouldListenOnOuterClick) {
            this._events.off(document.body, 'mousedown', this._dismissOnOuterClick, true);
        }
    }
    componentWillReceiveProps(newProps) {
        if (newProps.isOpen !== this.state.isOpen) {
            if (newProps.isOpen) {
                this.open();
            }
            else {
                this.dismiss();
            }
        }
    }
    render() {
        const { className = '', elementToFocusOnDismiss, firstFocusableSelector, focusTrapZoneProps, forceFocusInsideTrap, hasCloseButton, headerText, headerClassName = '', ignoreExternalFocusing, isBlocking, isFooterAtBottom, isLightDismiss, isHiddenOnDismiss, layerProps, type, styles, theme, customWidth, onLightDismissClick = this._onPanelClick, onRenderNavigation = this._onRenderNavigation, onRenderHeader = this._onRenderHeader, onRenderBody = this._onRenderBody, onRenderFooter = this._onRenderFooter } = this.props;
        const { isFooterSticky, isOpen, isAnimating, id } = this.state;
        const isLeft = type === PanelType.smallFixedNear ? true : false;
        const isRTL = getRTL();
        const isOnRightSide = isRTL ? isLeft : !isLeft;
        const headerTextId = headerText && id + '-headerText';
        const customWidthStyles = type === PanelType.custom ? { width: customWidth } : {};
        const nativeProps = getNativeProps(this.props, divProperties);
        if (!isOpen && !isAnimating && !isHiddenOnDismiss) {
            return null;
        }
        this._classNames = getClassNames$K(styles, {
            theme: theme,
            className,
            focusTrapZoneClassName: focusTrapZoneProps ? focusTrapZoneProps.className : undefined,
            hasCloseButton,
            headerClassName,
            isAnimating: this.state.isAnimating,
            isFooterAtBottom,
            isFooterSticky,
            isOnRightSide,
            isOpen: this.state.isOpen,
            isHiddenOnDismiss,
            type
        });
        const { _classNames } = this;
        let overlay;
        if (isBlocking && isOpen) {
            overlay = createElement(Overlay, { className: _classNames.overlay, isDarkThemed: false, onClick: isLightDismiss ? onLightDismissClick : undefined });
        }
        const header = onRenderHeader(this.props, this._onRenderHeader, headerTextId);
        return (createElement(Layer, Object.assign({}, layerProps),
            createElement(Popup, { role: "dialog", ariaLabelledBy: header ? headerTextId : undefined, onDismiss: this.dismiss, className: _classNames.hiddenPanel },
                createElement("div", Object.assign({}, nativeProps, { ref: this._panel, className: _classNames.root }),
                    overlay,
                    createElement(FocusTrapZone, Object.assign({ ignoreExternalFocusing: ignoreExternalFocusing, forceFocusInsideTrap: isHiddenOnDismiss && !isOpen ? false : forceFocusInsideTrap, firstFocusableSelector: firstFocusableSelector, isClickableOutsideFocusTrap: true }, focusTrapZoneProps, { className: _classNames.main, style: customWidthStyles, elementToFocusOnDismiss: elementToFocusOnDismiss }),
                        createElement("div", { className: _classNames.commands, "data-is-visible": true }, onRenderNavigation(this.props, this._onRenderNavigation)),
                        createElement("div", { className: _classNames.contentInner },
                            header,
                            createElement("div", { ref: this._allowScrollOnPanel, className: _classNames.scrollableContent, "data-is-scrollable": true }, onRenderBody(this.props, this._onRenderBody)),
                            onRenderFooter(this.props, this._onRenderFooter)))))));
    }
    open() {
        if (!this.state.isOpen) {
            this.setState({
                isOpen: true,
                isAnimating: true
            }, () => {
                this._async.setTimeout(this._onTransitionComplete, 200);
            });
        }
    }
    _shouldListenForOuterClick(props) {
        return !!props.isBlocking && !!props.isOpen;
    }
    _updateFooterPosition() {
        const scrollableContent = this._scrollableContent;
        if (scrollableContent) {
            const height = scrollableContent.clientHeight;
            const innerHeight = scrollableContent.scrollHeight;
            this.setState({
                isFooterSticky: height < innerHeight ? true : false
            });
        }
    }
    _dismissOnOuterClick(ev) {
        const panel = this._panel.current;
        if (this.state.isOpen && panel) {
            if (!elementContains(panel, ev.target)) {
                if (this.props.onOuterClick) {
                    this.props.onOuterClick();
                    ev.preventDefault();
                }
                else {
                    this.dismiss();
                }
            }
        }
    }
}
PanelBase.defaultProps = {
    isHiddenOnDismiss: false,
    isOpen: false,
    isBlocking: true,
    hasCloseButton: true,
    type: PanelType.smallFixedFar
};

// TODO -Issue #5689: Comment in once Button is converted to mergeStyles
// import { IStyleFunctionOrObject } from '../../Utilities';
// import { IButtonStyles, IButtonStyleProps } from '../../Button';
const GlobalClassNames$v = {
    root: 'ms-Panel',
    main: 'ms-Panel-main',
    commands: 'ms-Panel-commands',
    contentInner: 'ms-Panel-contentInner',
    scrollableContent: 'ms-Panel-scrollableContent',
    navigation: 'ms-Panel-navigation',
    closeButton: 'ms-Panel-closeButton ms-PanelAction-close',
    header: 'ms-Panel-header',
    headerText: 'ms-Panel-headerText',
    content: 'ms-Panel-content',
    footer: 'ms-Panel-footer',
    footerInner: 'ms-Panel-footerInner',
    isOpen: 'is-open',
    hasCloseButton: 'ms-Panel--hasCloseButton',
    smallFluid: 'ms-Panel--smFluid',
    smallFixedNear: 'ms-Panel--smLeft',
    smallFixedFar: 'ms-Panel--sm',
    medium: 'ms-Panel--md',
    large: 'ms-Panel--lg',
    largeFixed: 'ms-Panel--fixed',
    extraLarge: 'ms-Panel--xl',
    custom: 'ms-Panel--custom'
};
const panelSize = {
    width: {
        xs: '272px',
        sm: '340px',
        md: '643px',
        lg: '940px'
    },
    margin: {
        md: '48px',
        lg: '428px',
        xl: '176px'
    }
};
const commandBarHeight = '44px';
const sharedPaddingStyles = {
    paddingLeft: '16px',
    paddingRight: '16px',
    selectors: {
        ['@media screen and (min-width: ' + ScreenWidthMinUhfMobile + 'px)']: {
            paddingLeft: '32px',
            paddingRight: '32px'
        },
        ['@media screen and (min-width: ' + ScreenWidthMinXXLarge + 'px)']: {
            paddingLeft: '40px',
            paddingRight: '40px'
        }
    }
};
// // TODO -Issue #5689: Comment in once Button is converted to mergeStyles
// function getIconButtonStyles(props: IPanelStyleProps): IStyleFunctionOrObject<IButtonStyleProps, IButtonStyles> {
//   const { theme } = props;
//   return () => ({
//     root: {
//       height: 'auto',
//       width: '44px',
//       color: theme.palette.neutralSecondary,
//       fontSize: IconFontSizes.large
//     },
//     rootHovered: {
//       color: theme.palette.neutralPrimary
//     }
//   });
// }
const getStyles$Q = (props) => {
    const { className, focusTrapZoneClassName, hasCloseButton, headerClassName, isAnimating, isFooterAtBottom, isFooterSticky, isOnRightSide, isOpen, isHiddenOnDismiss, theme, type } = props;
    const { palette } = theme;
    const classNames = getGlobalClassNames(GlobalClassNames$v, theme);
    const isCustomPanel = type === PanelType.custom;
    const windowHeight = typeof window !== 'undefined' ? window.innerHeight : '100%';
    return {
        root: [
            classNames.root,
            theme.fonts.medium,
            isOpen && classNames.isOpen,
            hasCloseButton && classNames.hasCloseButton,
            {
                pointerEvents: 'none',
                position: 'absolute',
                top: 0,
                left: 0,
                right: 0,
                bottom: 0
            },
            !isOpen &&
                !isAnimating &&
                isHiddenOnDismiss && {
                visibility: 'hidden'
            },
            isCustomPanel && classNames.custom,
            className
        ],
        overlay: [
            {
                pointerEvents: 'none',
                opacity: 1,
                cursor: 'pointer',
                transition: `opacity ${AnimationVariables.durationValue3} ${AnimationVariables.easeFunction1}`,
                selectors: {
                    '@media screen and (-ms-high-contrast: active), (-ms-high-contrast: none)': {
                        // For IE high contrast mode
                        backgroundColor: 'transparent'
                    }
                }
            },
            isOpen && {
                cursor: 'pointer',
                pointerEvents: 'auto'
            },
            isOpen && isAnimating && AnimationClassNames.fadeIn200,
            !isOpen && isAnimating && AnimationClassNames.fadeOut200
        ],
        hiddenPanel: [
            !isOpen &&
                !isAnimating &&
                isHiddenOnDismiss && {
                visibility: 'hidden'
            }
        ],
        main: [
            classNames.main,
            {
                backgroundColor: palette.white,
                position: 'absolute',
                right: 0,
                width: '100%',
                bottom: 0,
                top: 0,
                overflowX: 'hidden',
                overflowY: 'auto',
                WebkitOverflowScrolling: 'touch',
                selectors: {
                    ['@media (min-width: ' + ScreenWidthMinMedium + 'px)']: {
                        borderLeft: `1px solid ${palette.neutralLight}`,
                        borderRight: `1px solid ${palette.neutralLight}`,
                        pointerEvents: 'auto',
                        width: panelSize.width.sm,
                        boxShadow: '0px 0px 30px 0px rgba(0,0,0,0.2)',
                        left: 'auto'
                    },
                    '$root &': [
                        isOpen && {
                            pointerEvents: 'auto'
                        },
                        type === PanelType.smallFluid && {
                            width: '100%'
                        },
                        type === PanelType.smallFixedNear && {
                            right: 'auto',
                            left: 0,
                            width: panelSize.width.xs,
                            boxShadow: '0px 0px 30px 0px rgba(0,0,0,0.2)'
                        },
                        type === PanelType.smallFixedFar && {
                            width: panelSize.width.xs,
                            selectors: {
                                ['@media (min-width: ' + ScreenWidthMinMedium + 'px)']: {
                                    width: panelSize.width.sm
                                }
                            }
                        },
                        type === PanelType.medium && {
                            selectors: {
                                ['@media (min-width: ' + ScreenWidthMinUhfMobile + 'px)']: {
                                    left: panelSize.margin.md,
                                    width: 'auto'
                                },
                                ['@media (min-width: ' + ScreenWidthMinXLarge + 'px)']: {
                                    left: 'auto',
                                    width: panelSize.width.md
                                }
                            }
                        },
                        (type === PanelType.large || type === PanelType.largeFixed) && {
                            selectors: {
                                ['@media (min-width: ' + ScreenWidthMinUhfMobile + 'px)']: {
                                    left: panelSize.margin.md,
                                    width: 'auto'
                                },
                                ['@media (min-width: ' + ScreenWidthMinXXLarge + 'px)']: {
                                    left: panelSize.margin.lg
                                }
                            }
                        },
                        type === PanelType.largeFixed && {
                            selectors: {
                                ['@media (min-width: ' + ScreenWidthMinXXLarge + 'px)']: {
                                    left: 'auto',
                                    width: panelSize.width.lg
                                }
                            }
                        },
                        type === PanelType.extraLarge && {
                            selectors: {
                                ['@media (min-width: ' + ScreenWidthMinUhfMobile + 'px)']: {
                                    left: panelSize.margin.md,
                                    width: 'auto'
                                },
                                ['@media (min-width: ' + ScreenWidthMinXXLarge + 'px)']: {
                                    left: panelSize.margin.xl
                                }
                            }
                        },
                        isCustomPanel && {
                            maxWidth: '100vw'
                        }
                    ]
                }
            },
            {
                display: 'flex',
                flexDirection: 'column',
                maxHeight: '100%',
                selectors: {
                    ['@supports (-webkit-overflow-scrolling: touch)']: {
                        maxHeight: windowHeight
                    }
                }
            },
            isFooterAtBottom && {
                height: '100%',
                selectors: {
                    ['@supports (-webkit-overflow-scrolling: touch)']: {
                        height: windowHeight
                    }
                }
            },
            isOpen && isAnimating && !isOnRightSide && AnimationClassNames.slideRightIn40,
            isOpen && isAnimating && isOnRightSide && AnimationClassNames.slideLeftIn40,
            !isOpen && isAnimating && !isOnRightSide && AnimationClassNames.slideLeftOut40,
            !isOpen && isAnimating && isOnRightSide && AnimationClassNames.slideRightOut40,
            focusTrapZoneClassName
        ],
        commands: [classNames.commands],
        navigation: [
            classNames.navigation,
            {
                padding: '0 5px',
                height: commandBarHeight,
                display: 'flex',
                justifyContent: 'flex-end'
            }
        ],
        closeButton: [classNames.closeButton],
        contentInner: [
            classNames.contentInner,
            {
                display: 'flex',
                flexDirection: 'column',
                maxHeight: '100%',
                overflowY: 'hidden',
                selectors: {
                    ['@supports (-webkit-overflow-scrolling: touch)']: {
                        maxHeight: windowHeight
                    }
                }
            },
            isFooterAtBottom && {
                height: '100%',
                selectors: {
                    ['@supports (-webkit-overflow-scrolling: touch)']: {
                        height: windowHeight
                    }
                }
            }
        ],
        header: [
            classNames.header,
            sharedPaddingStyles,
            {
                margin: '14px 0',
                // Ensure that title doesn't shrink if screen is too small
                flexGrow: 0,
                selectors: {
                    ['@media (min-width: ' + ScreenWidthMinXLarge + 'px)']: {
                        marginTop: '30px'
                    }
                }
            }
        ],
        headerText: [
            classNames.headerText,
            DefaultFontStyles.xLarge,
            {
                color: palette.neutralPrimary,
                lineHeight: '32px',
                margin: 0
            },
            headerClassName
        ],
        scrollableContent: [
            classNames.scrollableContent,
            {
                overflowY: 'auto',
                height: '100%',
                selectors: {
                    ['@supports (-webkit-overflow-scrolling: touch)']: {
                        height: windowHeight
                    }
                }
            }
        ],
        content: [
            classNames.content,
            sharedPaddingStyles,
            {
                marginBottom: 0,
                paddingBottom: 20
            }
        ],
        footer: [
            classNames.footer,
            {
                // Ensure that footer doesn't shrink if screen is too small
                flexGrow: 0,
                borderTop: '1px solid transparent',
                transition: `opacity ${AnimationVariables.durationValue3} ${AnimationVariables.easeFunction2}`
            },
            isFooterSticky && {
                background: palette.white,
                borderTopColor: palette.neutralLight
            }
        ],
        footerInner: [
            classNames.footerInner,
            sharedPaddingStyles,
            {
                paddingBottom: '20px',
                paddingTop: '20px'
            }
        ]
        // subComponentStyles: {
        //   iconButton: getIconButtonStyles(props)
        // }
    };
};

/**
 * Panel description
 */
const Panel = styled(PanelBase, getStyles$Q, undefined, {
    scope: 'Panel'
});

const getClassNames$L = classNamesFunction();
let DropdownBase = class DropdownBase extends BaseComponent {
    constructor(props) {
        super(props);
        this._host = createRef();
        this._focusZone = createRef();
        this._dropDown = createRef();
        this._scrollIdleDelay = 250 /* ms */;
        this._sizePosCache = new DropdownSizePosCache();
        /** Render text in dropdown input */
        this._onRenderTitle = (item) => {
            const { multiSelectDelimiter = ', ' } = this.props;
            const displayTxt = item.map(i => i.text).join(multiSelectDelimiter);
            return createElement("span", null, displayTxt);
        };
        /** Render placeholder text in dropdown input */
        this._onRenderPlaceholder = (props) => {
            if (!this._placeholder) {
                return null;
            }
            return createElement("span", null, this._placeholder);
        };
        /** Render Callout or Panel container and pass in list */
        this._onRenderContainer = (props) => {
            const { responsiveMode, calloutProps, panelProps, dropdownWidth } = this.props;
            const isSmall = responsiveMode <= ResponsiveMode.medium;
            return isSmall ? (createElement(Panel, Object.assign({ className: this._classNames.panel, isOpen: true, isLightDismiss: true, onDismissed: this._onDismiss, hasCloseButton: false }, panelProps), this._renderFocusableList(props))) : (createElement(Callout, Object.assign({ isBeakVisible: false, gapSpace: 0, doNotLayer: false, directionalHintFixed: false, directionalHint: DirectionalHint.bottomLeftEdge }, calloutProps, { className: this._classNames.callout, target: this._dropDown.current, onDismiss: this._onDismiss, onScroll: this._onScroll, onPositioned: this._onPositioned, calloutWidth: dropdownWidth || (this._dropDown.current ? this._dropDown.current.clientWidth : 0) }), this._renderFocusableList(props)));
        };
        /** Render Caret Down Icon */
        this._onRenderCaretDown = (props) => {
            return createElement(Icon, { className: this._classNames.caretDown, iconName: "ChevronDown" });
        };
        /** Render List of items */
        this._onRenderList = (props) => {
            const { onRenderItem = this._onRenderItem } = this.props;
            return createElement(Fragment, null, this.props.options.map((item, index) => onRenderItem({ ...item, index }, this._onRenderItem)));
        };
        this._onRenderItem = (item) => {
            switch (item.itemType) {
                case SelectableOptionMenuItemType.Divider:
                    return this._renderSeparator(item);
                case SelectableOptionMenuItemType.Header:
                    return this._renderHeader(item);
                default:
                    return this._renderOption(item);
            }
        };
        this._renderOption = (item) => {
            const { onRenderOption = this._onRenderOption } = this.props;
            const { selectedIndices = [] } = this.state;
            const id = this._id;
            const isItemSelected = item.index !== undefined && selectedIndices ? selectedIndices.indexOf(item.index) > -1 : false;
            // select the right classname based on the combination of selected/disabled
            const itemClassName = isItemSelected && item.disabled === true // preciate: both selected and disabled
                ? this._classNames.dropdownItemSelectedAndDisabled
                : isItemSelected // preciate: selected only
                    ? this._classNames.dropdownItemSelected
                    : item.disabled === true // predicate: disabled only
                        ? this._classNames.dropdownItemDisabled
                        : this._classNames.dropdownItem;
            return !this.props.multiSelect ? (createElement(CommandButton, { id: id + '-list' + item.index, key: item.key, "data-index": item.index, "data-is-focusable": !item.disabled, disabled: item.disabled, className: itemClassName, onClick: this._onItemClick(item), onMouseEnter: this._onItemMouseEnter.bind(this, item), onMouseLeave: this._onMouseItemLeave.bind(this, item), onMouseMove: this._onItemMouseMove.bind(this, item), role: "option", "aria-selected": isItemSelected ? 'true' : 'false', ariaLabel: item.ariaLabel, title: item.title ? item.title : item.text }, onRenderOption(item, this._onRenderOption))) : (createElement(Checkbox, { id: id + '-list' + item.index, key: item.key, "data-index": item.index, "data-is-focusable": !item.disabled, disabled: item.disabled, onChange: this._onItemClick(item), inputProps: {
                    onMouseEnter: this._onItemMouseEnter.bind(this, item),
                    onMouseLeave: this._onMouseItemLeave.bind(this, item),
                    onMouseMove: this._onItemMouseMove.bind(this, item)
                }, label: item.text, title: item.title ? item.title : item.text, onRenderLabel: this._onRenderLabel.bind(this, item), className: itemClassName, role: "option", "aria-selected": isItemSelected ? 'true' : 'false', checked: isItemSelected }));
        };
        /** Render content of item (i.e. text/icon inside of button) */
        this._onRenderOption = (item) => {
            return createElement("span", { className: this._classNames.dropdownOptionText }, item.text);
        };
        /** Render custom label for drop down item */
        this._onRenderLabel = (item) => {
            const { onRenderOption = this._onRenderOption } = this.props;
            return onRenderOption(item, this._onRenderOption);
        };
        this._onPositioned = (positions) => {
            if (this._focusZone.current) {
                // Focusing an element can trigger a reflow. Making this wait until there is an animation
                // frame can improve perf significantly.
                this._async.requestAnimationFrame(() => {
                    const selectedIndices = this.state.selectedIndices;
                    if (selectedIndices && selectedIndices[0] && !this.props.options[selectedIndices[0]].disabled) {
                        const element = getDocument().querySelector(`#${this._id}-list${selectedIndices[0]}`);
                        this._focusZone.current.focusElement(element);
                    }
                    else {
                        this._focusZone.current.focus();
                    }
                });
            }
            if (!this.state.calloutRenderEdge || this.state.calloutRenderEdge !== positions.targetEdge) {
                this.setState({
                    calloutRenderEdge: positions.targetEdge
                });
            }
        };
        this._onItemClick = (item) => {
            return (event) => {
                if (!item.disabled) {
                    this.setSelectedIndex(event, item.index);
                    if (!this.props.multiSelect) {
                        // only close the callout when it's in single-select mode
                        this.setState({
                            isOpen: false
                        });
                    }
                }
            };
        };
        /**
         * Scroll handler for the callout to make sure the mouse events
         * for updating focus are not interacting during scroll
         */
        this._onScroll = () => {
            if (!this._isScrollIdle && this._scrollIdleTimeoutId !== undefined) {
                this._async.clearTimeout(this._scrollIdleTimeoutId);
                this._scrollIdleTimeoutId = undefined;
            }
            else {
                this._isScrollIdle = false;
            }
            this._scrollIdleTimeoutId = this._async.setTimeout(() => {
                this._isScrollIdle = true;
            }, this._scrollIdleDelay);
        };
        this._onMouseItemLeave = (item, ev) => {
            if (this._shouldIgnoreMouseEvent()) {
                return;
            }
            /**
             * IE11 focus() method forces parents to scroll to top of element.
             * Edge and IE expose a setActive() function for focusable divs that
             * sets the page focus but does not scroll the parent element.
             */
            if (this._host.current) {
                if (this._host.current.setActive) {
                    try {
                        this._host.current.setActive();
                    }
                    catch (e) {
                        /* no-op */
                    }
                }
                else {
                    this._host.current.focus();
                }
            }
        };
        this._onDismiss = () => {
            this.setState({ isOpen: false });
            if (this._dropDown.current) {
                this._dropDown.current.focus();
            }
        };
        this._onDropdownBlur = (ev) => {
            // If Dropdown disabled do not proceed with this logic.
            const disabled = this._isDisabled();
            if (disabled) {
                return;
            }
            // hasFocus tracks whether the root element has focus so always update the state.
            this.setState({ hasFocus: false });
            if (this.state.isOpen) {
                // Do not onBlur when the callout is opened
                return;
            }
            if (this.props.onBlur) {
                this.props.onBlur(ev);
            }
        };
        this._onDropdownKeyDown = (ev) => {
            // If Dropdown disabled do not process any keyboard events.
            const disabled = this._isDisabled();
            if (disabled) {
                return;
            }
            // Take note if we are processing an alt (option) or meta (command) keydown.
            // See comment in _shouldHandleKeyUp for reasoning.
            this._lastKeyDownWasAltOrMeta = this._isAltOrMeta(ev);
            if (this.props.onKeyDown) {
                this.props.onKeyDown(ev);
                if (ev.defaultPrevented) {
                    return;
                }
            }
            let newIndex;
            const selectedIndex = this.state.selectedIndices.length ? this.state.selectedIndices[0] : -1;
            const containsExpandCollapseModifier = ev.altKey || ev.metaKey;
            const isOpen = this.state.isOpen;
            switch (ev.which) {
                case KeyCodes.enter:
                    this.setState({
                        isOpen: !isOpen
                    });
                    break;
                case KeyCodes.escape:
                    if (!isOpen) {
                        return;
                    }
                    this.setState({
                        isOpen: false
                    });
                    break;
                case KeyCodes.up:
                    if (containsExpandCollapseModifier) {
                        if (isOpen) {
                            this.setState({ isOpen: false });
                            break;
                        }
                        return;
                    }
                    if (this.props.multiSelect) {
                        this.setState({ isOpen: true });
                    }
                    else if (!this._isDisabled()) {
                        newIndex = this._moveIndex(ev, -1, selectedIndex - 1, selectedIndex);
                    }
                    break;
                case KeyCodes.down:
                    if (containsExpandCollapseModifier) {
                        ev.stopPropagation();
                        ev.preventDefault();
                    }
                    if ((containsExpandCollapseModifier && !isOpen) || this.props.multiSelect) {
                        this.setState({ isOpen: true });
                    }
                    else if (!this._isDisabled()) {
                        newIndex = this._moveIndex(ev, 1, selectedIndex + 1, selectedIndex);
                    }
                    break;
                case KeyCodes.home:
                    if (!this.props.multiSelect) {
                        newIndex = this._moveIndex(ev, 1, 0, selectedIndex);
                    }
                    break;
                case KeyCodes.end:
                    if (!this.props.multiSelect) {
                        newIndex = this._moveIndex(ev, -1, this.props.options.length - 1, selectedIndex);
                    }
                    break;
                case KeyCodes.space:
                    // event handled in _onDropdownKeyUp
                    break;
                default:
                    return;
            }
            if (newIndex !== selectedIndex) {
                ev.stopPropagation();
                ev.preventDefault();
            }
        };
        this._onDropdownKeyUp = (ev) => {
            // If Dropdown disabled do not process any keyboard events.
            const disabled = this._isDisabled();
            if (disabled) {
                return;
            }
            const shouldHandleKey = this._shouldHandleKeyUp(ev);
            const isOpen = this.state.isOpen;
            if (this.props.onKeyUp) {
                this.props.onKeyUp(ev);
                if (ev.preventDefault) {
                    return;
                }
            }
            switch (ev.which) {
                case KeyCodes.space:
                    this.setState({
                        isOpen: !isOpen
                    });
                    break;
                default:
                    if (shouldHandleKey && isOpen) {
                        this.setState({ isOpen: false });
                    }
                    return;
            }
            ev.stopPropagation();
            ev.preventDefault();
        };
        this._onZoneKeyDown = (ev) => {
            let elementToFocus;
            // Take note if we are processing an alt (option) or meta (command) keydown.
            // See comment in _shouldHandleKeyUp for reasoning.
            this._lastKeyDownWasAltOrMeta = this._isAltOrMeta(ev);
            const containsExpandCollapseModifier = ev.altKey || ev.metaKey;
            switch (ev.which) {
                case KeyCodes.up:
                    if (containsExpandCollapseModifier) {
                        this.setState({ isOpen: false });
                    }
                    else {
                        if (this._host.current) {
                            elementToFocus = getLastFocusable(this._host.current, this._host.current.lastChild, true);
                        }
                    }
                    break;
                // All directional keystrokes should be canceled when the zone is rendered.
                // This avoids the body scroll from reacting and thus dismissing the dropdown.
                case KeyCodes.home:
                case KeyCodes.end:
                case KeyCodes.pageUp:
                case KeyCodes.pageDown:
                    break;
                case KeyCodes.down:
                    if (!containsExpandCollapseModifier && this._host.current) {
                        elementToFocus = getFirstFocusable(this._host.current, this._host.current.firstChild, true);
                    }
                    break;
                case KeyCodes.escape:
                    this.setState({ isOpen: false });
                    break;
                case KeyCodes.tab:
                    this.setState({ isOpen: false });
                    return;
                default:
                    return;
            }
            if (elementToFocus) {
                elementToFocus.focus();
            }
            ev.stopPropagation();
            ev.preventDefault();
        };
        this._onZoneKeyUp = (ev) => {
            const shouldHandleKey = this._shouldHandleKeyUp(ev);
            if (shouldHandleKey && this.state.isOpen) {
                this.setState({ isOpen: false });
                ev.preventDefault();
            }
        };
        this._onDropdownClick = (ev) => {
            if (this.props.onClick) {
                this.props.onClick(ev);
                if (ev.preventDefault) {
                    return;
                }
            }
            const { isOpen } = this.state;
            const disabled = this._isDisabled();
            if (!disabled) {
                this.setState({
                    isOpen: !isOpen
                });
            }
        };
        this._onFocus = (ev) => {
            const { isOpen, selectedIndices } = this.state;
            const { multiSelect } = this.props;
            const disabled = this._isDisabled();
            if (!disabled) {
                if (!isOpen && selectedIndices.length === 0 && !multiSelect) {
                    // Per aria
                    this._moveIndex(ev, 1, 0, -1);
                }
                if (this.props.onFocus) {
                    this.props.onFocus(ev);
                }
                this.setState({ hasFocus: true });
            }
        };
        /**
         * Because the isDisabled prop is deprecated, we have had to repeat this logic all over the place.
         * This helper method avoids all the repetition.
         */
        this._isDisabled = () => {
            let { disabled } = this.props;
            const { isDisabled } = this.props;
            // Remove this deprecation workaround at 1.0.0
            if (isDisabled !== undefined) {
                disabled = isDisabled;
            }
            return disabled;
        };
        this._warnDeprecations({
            isDisabled: 'disabled',
            onChanged: 'onChange',
            placeHolder: 'placeholder'
        });
        this._warnMutuallyExclusive({
            defaultSelectedKey: 'selectedKey',
            defaultSelectedKeys: 'selectedKeys',
            selectedKeys: 'selectedKey',
            multiSelect: 'defaultSelectedKey',
            selectedKey: 'multiSelect'
        });
        this._id = props.id || getId('Dropdown');
        this._isScrollIdle = true;
        let selectedIndices;
        if (this.props.multiSelect) {
            const selectedKeys = props.defaultSelectedKeys !== undefined ? props.defaultSelectedKeys : props.selectedKeys;
            selectedIndices = this._getSelectedIndexes(props.options, selectedKeys);
        }
        else {
            const selectedKey = props.defaultSelectedKey !== undefined ? props.defaultSelectedKey : props.selectedKey;
            selectedIndices = this._getSelectedIndexes(props.options, selectedKey);
            this._sizePosCache.updateOptions(props.options);
        }
        this.state = {
            isOpen: false,
            selectedIndices,
            hasFocus: false,
            calloutRenderEdge: undefined
        };
    }
    componentWillReceiveProps(newProps) {
        // In controlled component usage where selectedKey is provided, update the selectedIndex
        // state if the key or options change.
        let selectedKeyProp;
        // this does a shallow compare (assumes options are pure), for the purposes of determining whether
        // defaultSelectedKey/defaultSelectedKeys are respected.
        const didOptionsChange = newProps.options !== this.props.options;
        if (newProps.multiSelect) {
            if (didOptionsChange && newProps.defaultSelectedKeys !== undefined) {
                selectedKeyProp = 'defaultSelectedKeys';
            }
            else {
                selectedKeyProp = 'selectedKeys';
            }
        }
        else {
            if (didOptionsChange && newProps.defaultSelectedKey !== undefined) {
                selectedKeyProp = 'defaultSelectedKey';
            }
            else {
                selectedKeyProp = 'selectedKey';
            }
        }
        if (newProps[selectedKeyProp] !== undefined && (newProps[selectedKeyProp] !== this.props[selectedKeyProp] || didOptionsChange)) {
            this.setState({
                selectedIndices: this._getSelectedIndexes(newProps.options, newProps[selectedKeyProp])
            });
        }
        if (newProps.options !== this.props.options && // preexisting code assumes purity of the options...
            !newProps.multiSelect // only relevant in single selection
        ) {
            this._sizePosCache.updateOptions(newProps.options);
        }
    }
    componentDidUpdate(prevProps, prevState) {
        if (prevState.isOpen === true && this.state.isOpen === false) {
            this._gotMouseMove = false;
            if (this._dropDown.current) {
                this._dropDown.current.focus();
            }
            if (this.props.onDismiss) {
                this.props.onDismiss();
            }
        }
    }
    render() {
        const id = this._id;
        const { className, label, options, ariaLabel, required, errorMessage, multiSelect, keytipProps, styles: propStyles, theme, panelProps, calloutProps, onRenderTitle = this._onRenderTitle, onRenderContainer = this._onRenderContainer, onRenderPlaceHolder = this._onRenderPlaceholder, onRenderCaretDown = this._onRenderCaretDown } = this.props;
        const { isOpen, selectedIndices, hasFocus, calloutRenderEdge } = this.state;
        const selectedOptions = this._getAllSelectedOptions(options, selectedIndices);
        const divProps = getNativeProps(this.props, divProperties);
        const disabled = this._isDisabled();
        const optionId = id + '-option';
        const ariaAttrs = multiSelect || disabled
            ? {
                role: undefined,
                ariaActiveDescendant: undefined,
                childRole: undefined,
                ariaSetSize: undefined,
                ariaPosInSet: undefined,
                ariaSelected: undefined
            }
            : // single select
                {
                    role: 'listbox',
                    ariaActiveDescendant: isOpen && selectedIndices.length === 1 && selectedIndices[0] >= 0 ? this._id + '-list' + selectedIndices[0] : optionId,
                    childRole: 'option',
                    ariaSetSize: this._sizePosCache.optionSetSize,
                    ariaPosInSet: this._sizePosCache.positionInSet(selectedIndices[0]),
                    ariaSelected: selectedIndices[0] === undefined ? undefined : true
                };
        this._classNames = getClassNames$L(propStyles, {
            theme,
            className,
            hasError: Boolean(errorMessage && errorMessage.length > 0),
            isOpen,
            required,
            disabled,
            isRenderingPlaceholder: !selectedOptions.length,
            panelClassName: !!panelProps ? panelProps.className : undefined,
            calloutClassName: !!calloutProps ? calloutProps.className : undefined,
            calloutRenderEdge: calloutRenderEdge
        });
        const labelStyles = this._classNames.subComponentStyles
            ? this._classNames.subComponentStyles.label
            : undefined;
        return (createElement("div", { className: this._classNames.root },
            label && (createElement(Label, { className: this._classNames.label, id: id + '-label', htmlFor: id, required: required, styles: labelStyles }, label)),
            createElement(KeytipData, { keytipProps: keytipProps, disabled: disabled }, (keytipAttributes) => (createElement("div", Object.assign({}, keytipAttributes, { "data-is-focusable": !disabled, ref: this._dropDown, id: id, tabIndex: disabled ? -1 : 0, "aria-expanded": isOpen ? 'true' : 'false', role: ariaAttrs.role, "aria-label": ariaLabel, "aria-labelledby": label && !ariaLabel ? id + '-label' : undefined, "aria-describedby": mergeAriaAttributeValues(optionId, keytipAttributes['aria-describedby']), "aria-activedescendant": isOpen ? ariaAttrs.ariaActiveDescendant : undefined, "aria-required": required, "aria-disabled": disabled, "aria-owns": isOpen ? id + '-list' : undefined }, divProps, { className: this._classNames.dropdown, onBlur: this._onDropdownBlur, onKeyDown: this._onDropdownKeyDown, onKeyUp: this._onDropdownKeyUp, onClick: this._onDropdownClick, onFocus: this._onFocus }),
                createElement("span", { id: optionId, className: this._classNames.title, "aria-atomic": true, role: ariaAttrs.childRole, "aria-live": !hasFocus || disabled || multiSelect || isOpen ? 'off' : 'assertive', "aria-label": selectedOptions.length ? selectedOptions[0].text : this._placeholder, "aria-setsize": ariaAttrs.ariaSetSize, "aria-posinset": ariaAttrs.ariaPosInSet, "aria-selected": ariaAttrs.ariaSelected }, // If option is selected render title, otherwise render the placeholder text
                selectedOptions.length
                    ? onRenderTitle(selectedOptions, this._onRenderTitle)
                    : onRenderPlaceHolder(this.props, this._onRenderPlaceholder)),
                createElement("span", { className: this._classNames.caretDownWrapper }, onRenderCaretDown(this.props, this._onRenderCaretDown))))),
            isOpen && onRenderContainer(this.props, this._onRenderContainer),
            errorMessage && errorMessage.length > 0 && createElement("div", { className: this._classNames.errorMessage }, errorMessage)));
    }
    focus(shouldOpenOnFocus) {
        if (this._dropDown.current && this._dropDown.current.tabIndex !== -1) {
            this._dropDown.current.focus();
            if (shouldOpenOnFocus) {
                this.setState({
                    isOpen: true
                });
            }
        }
    }
    setSelectedIndex(event, index) {
        const { onChange, onChanged, options, selectedKey, selectedKeys, multiSelect, notifyOnReselect } = this.props;
        const { selectedIndices = [] } = this.state;
        const checked = selectedIndices ? selectedIndices.indexOf(index) > -1 : false;
        index = Math.max(0, Math.min(options.length - 1, index));
        if (!multiSelect && !notifyOnReselect && index === selectedIndices[0]) {
            return;
        }
        else if (!multiSelect && selectedKey === undefined) {
            // Set the selected option if this is an uncontrolled component
            this.setState({
                selectedIndices: [index]
            });
        }
        else if (multiSelect && selectedKeys === undefined) {
            const newIndexes = selectedIndices ? this._copyArray(selectedIndices) : [];
            if (checked) {
                const position = newIndexes.indexOf(index);
                if (position > -1) {
                    // unchecked the current one
                    newIndexes.splice(position, 1);
                }
            }
            else {
                // add the new selected index into the existing one
                newIndexes.push(index);
            }
            this.setState({
                selectedIndices: newIndexes
            });
        }
        if (onChange) {
            // for single-select, option passed in will always be selected.
            // for multi-select, flip the checked value
            const changedOpt = multiSelect ? { ...options[index], selected: !checked } : options[index];
            onChange(event, changedOpt, index);
        }
        if (onChanged) {
            // for single-select, option passed in will always be selected.
            // for multi-select, flip the checked value
            const changedOpt = multiSelect ? { ...options[index], selected: !checked } : options[index];
            onChanged(changedOpt, index);
        }
    }
    /** Get either props.placeholder (new name) or props.placeHolder (old name) */
    get _placeholder() {
        return this.props.placeholder || this.props.placeHolder;
    }
    _copyArray(array) {
        const newArray = [];
        for (const element of array) {
            newArray.push(element);
        }
        return newArray;
    }
    /**
     * Finds the next valid Dropdown option and sets the selected index to it.
     * @param stepValue Value of how many items the function should traverse.  Should be -1 or 1.
     * @param index Index of where the search should start
     * @param selectedIndex The selectedIndex Dropdown's state
     * @returns The next valid dropdown option's index
     */
    _moveIndex(event, stepValue, index, selectedIndex) {
        const { options } = this.props;
        // Return selectedIndex if nothing has changed or options is empty
        if (selectedIndex === index || options.length === 0) {
            return selectedIndex;
        }
        // Set starting index to 0 if index is < 0
        if (index < 0) {
            index = 0;
        }
        // Set starting index to last option index if greater than options.length
        if (index >= options.length) {
            index = options.length - 1;
        }
        let stepCounter = 0;
        // If current index is a header or divider, or disabled, increment by step
        while (options[index].itemType === SelectableOptionMenuItemType.Header ||
            options[index].itemType === SelectableOptionMenuItemType.Divider ||
            options[index].disabled) {
            // If stepCounter exceeds length of options, then return selectedIndex (-1)
            if (stepCounter >= options.length) {
                return selectedIndex;
            }
            // If index + stepValue is out of bounds, wrap around
            if (index + stepValue < 0) {
                index = options.length;
            }
            else if (index + stepValue >= options.length) {
                index = -1;
            }
            index = index + stepValue;
            stepCounter++;
        }
        this.setSelectedIndex(event, index);
        return index;
    }
    /** Wrap item list in a FocusZone */
    _renderFocusableList(props) {
        const { onRenderList = this._onRenderList, label } = props;
        const id = this._id;
        return (createElement("div", { className: this._classNames.dropdownItemsWrapper, onKeyDown: this._onZoneKeyDown, onKeyUp: this._onZoneKeyUp, ref: this._host, tabIndex: 0 },
            createElement(FocusZone, { ref: this._focusZone, direction: FocusZoneDirection.vertical, id: id + '-list', className: this._classNames.dropdownItems, "aria-labelledby": label ? id + '-label' : undefined, role: "listbox" }, onRenderList(props, this._onRenderList))));
    }
    _renderSeparator(item) {
        const { index, key } = item;
        if (index > 0) {
            return createElement("div", { role: "separator", key: key, className: this._classNames.dropdownDivider });
        }
        return null;
    }
    _renderHeader(item) {
        const { onRenderOption = this._onRenderOption } = this.props;
        const { key } = item;
        return (createElement("div", { key: key, className: this._classNames.dropdownItemHeader }, onRenderOption(item, this._onRenderOption)));
    }
    _onItemMouseEnter(item, ev) {
        if (this._shouldIgnoreMouseEvent()) {
            return;
        }
        const targetElement = ev.currentTarget;
        targetElement.focus();
    }
    _onItemMouseMove(item, ev) {
        const targetElement = ev.currentTarget;
        this._gotMouseMove = true;
        if (!this._isScrollIdle || document.activeElement === targetElement) {
            return;
        }
        targetElement.focus();
    }
    _shouldIgnoreMouseEvent() {
        return !this._isScrollIdle || !this._gotMouseMove;
    }
    /** Get all selected indexes for multi-select mode */
    _getSelectedIndexes(options, selectedKey) {
        if (selectedKey === undefined) {
            if (this.props.multiSelect) {
                return this._getAllSelectedIndices(options);
            }
            const selectedIndex = this._getSelectedIndex(options, null);
            return selectedIndex !== -1 ? [selectedIndex] : [];
        }
        else if (!Array.isArray(selectedKey)) {
            return [this._getSelectedIndex(options, selectedKey)];
        }
        const selectedIndices = [];
        for (const key of selectedKey) {
            selectedIndices.push(this._getSelectedIndex(options, key));
        }
        return selectedIndices;
    }
    /** Get all selected options for multi-select mode */
    _getAllSelectedOptions(options, selectedIndices) {
        const selectedOptions = [];
        for (const index of selectedIndices) {
            const option = options[index];
            if (option) {
                selectedOptions.push(option);
            }
        }
        return selectedOptions;
    }
    _getAllSelectedIndices(options) {
        return options.map((option, index) => (option.selected ? index : -1)).filter(index => index !== -1);
    }
    _getSelectedIndex(options, selectedKey) {
        return findIndex(options, option => {
            // tslint:disable-next-line:triple-equals
            if (selectedKey != null) {
                return option.key === selectedKey;
            }
            else {
                return !!option.isSelected || !!option.selected;
            }
        });
    }
    /**
     * Returns true if the key for the event is alt (Mac option) or meta (Mac command).
     */
    _isAltOrMeta(ev) {
        return ev.which === KeyCodes.alt || ev.key === 'Meta';
    }
    /**
     * We close the menu on key up only if ALL of the following are true:
     * - Most recent key down was alt or meta (command)
     * - The alt/meta key down was NOT followed by some other key (such as down/up arrow to
     *   expand/collapse the menu)
     * - We're not on a Mac (or iOS)
     *
     * This is because on Windows, pressing alt moves focus to the application menu bar or similar,
     * closing any open context menus. There is not a similar behavior on Macs.
     */
    _shouldHandleKeyUp(ev) {
        const keyPressIsAltOrMetaAlone = this._lastKeyDownWasAltOrMeta && this._isAltOrMeta(ev);
        this._lastKeyDownWasAltOrMeta = false;
        return !!keyPressIsAltOrMetaAlone && !(isMac() || isIOS());
    }
};
DropdownBase.defaultProps = {
    options: []
};
DropdownBase = __decorate([
    withResponsiveMode
], DropdownBase);

const GlobalClassNames$w = {
    root: 'ms-Dropdown-container',
    label: 'ms-Dropdown-label',
    dropdown: 'ms-Dropdown',
    title: 'ms-Dropdown-title',
    caretDownWrapper: 'ms-Dropdown-caretDownWrapper',
    caretDown: 'ms-Dropdown-caretDown',
    callout: 'ms-Dropdown-callout',
    panel: 'ms-Dropdown-panel',
    dropdownItems: 'ms-Dropdown-items',
    dropdownItem: 'ms-Dropdown-item',
    dropdownDivider: 'ms-Dropdown-divider',
    dropdownOptionText: 'ms-Dropdown-optionText',
    dropdownItemHeader: 'ms-Dropdown-header',
    titleIsPlaceHolder: 'ms-Dropdown-titleIsPlaceHolder',
    titleHasError: 'ms-Dropdown-title--hasError'
};
const DROPDOWN_HEIGHT = 32;
const DROPDOWN_ITEMHEIGHT = 32;
const highContrastAdjustMixin = {
    // highContrastAdjust mixin
    '@media screen and (-ms-high-contrast: active), screen and (-ms-high-contrast: black-on-white)': {
        MsHighContrastAdjust: 'none'
    }
};
const highContrastItemAndTitleStateMixin = {
    selectors: {
        [HighContrastSelector]: {
            backgroundColor: 'Highlight',
            borderColor: 'Highlight',
            color: 'HighlightText',
            selectors: {
                ':hover': {
                    color: 'HighlightText' // overrides the hover styling for buttons that are also selected
                }
            }
        },
        ...highContrastAdjustMixin
    }
};
const highContrastBorderState = {
    selectors: {
        [HighContrastSelector]: {
            borderColor: 'Highlight'
        }
    }
};
const getStyles$R = props => {
    const { theme, hasError, className, isOpen, disabled, required, isRenderingPlaceholder, panelClassName, calloutClassName } = props;
    if (!theme) {
        throw new Error('theme is undefined or null in base Dropdown getStyles function.');
    }
    const globalClassnames = getGlobalClassNames(GlobalClassNames$w, theme);
    const { palette, semanticColors } = theme;
    const rootHoverFocusActiveSelectorNeutralDarkMixin = {
        color: palette.neutralDark
    };
    const rootHoverFocusActiveSelectorBodySubtextMixin = {
        color: semanticColors.bodySubtext
    };
    const borderColorError = {
        borderColor: semanticColors.errorText
    };
    const dropdownItemStyle = [
        globalClassnames.dropdownItem,
        {
            backgroundColor: 'transparent',
            boxSizing: 'border-box',
            cursor: 'pointer',
            display: 'block',
            padding: '4px 16px',
            width: '100%',
            minHeight: DROPDOWN_ITEMHEIGHT,
            lineHeight: 20,
            height: 'auto',
            position: 'relative',
            border: '1px solid transparent',
            wordWrap: 'break-word',
            overflowWrap: 'break-word',
            textAlign: 'left'
        }
    ];
    const dropdownItemSelected = [
        ...dropdownItemStyle,
        {
            backgroundColor: palette.neutralQuaternaryAlt,
            color: palette.black
        },
        highContrastItemAndTitleStateMixin
    ];
    const dropdownItemDisabled = [
        ...dropdownItemStyle,
        {
            color: semanticColors.disabledText,
            cursor: 'default'
        }
    ];
    return {
        root: globalClassnames.root,
        label: globalClassnames.label,
        dropdown: [
            globalClassnames.dropdown,
            normalize,
            {
                ...theme.fonts.medium,
                color: palette.neutralPrimary,
                position: 'relative',
                outline: 0,
                userSelect: 'none',
                selectors: {
                    ['&:hover .' + globalClassnames.title]: [
                        !disabled && rootHoverFocusActiveSelectorNeutralDarkMixin,
                        { borderColor: palette.neutralDark },
                        highContrastBorderState
                    ],
                    ['&:focus .' + globalClassnames.title]: [
                        !disabled && rootHoverFocusActiveSelectorNeutralDarkMixin,
                        { borderColor: palette.themePrimary },
                        highContrastItemAndTitleStateMixin
                    ],
                    ['&:active .' + globalClassnames.title]: [
                        !disabled && rootHoverFocusActiveSelectorNeutralDarkMixin,
                        { borderColor: palette.themeDark },
                        highContrastBorderState
                    ],
                    ['&:hover .' + globalClassnames.caretDown]: !disabled && rootHoverFocusActiveSelectorNeutralDarkMixin,
                    ['&:focus .' + globalClassnames.caretDown]: [
                        !disabled && rootHoverFocusActiveSelectorNeutralDarkMixin,
                        { selectors: { [HighContrastSelector]: { color: 'HighlightText' }, ...highContrastAdjustMixin } }
                    ],
                    ['&:active .' + globalClassnames.caretDown]: !disabled && rootHoverFocusActiveSelectorNeutralDarkMixin,
                    ['&:hover .' + globalClassnames.titleIsPlaceHolder]: rootHoverFocusActiveSelectorBodySubtextMixin,
                    ['&:focus .' + globalClassnames.titleIsPlaceHolder]: rootHoverFocusActiveSelectorBodySubtextMixin,
                    ['&:active .' + globalClassnames.titleIsPlaceHolder]: rootHoverFocusActiveSelectorBodySubtextMixin,
                    ['&:hover .' + globalClassnames.titleHasError]: borderColorError,
                    ['&:active .' + globalClassnames.titleHasError]: borderColorError,
                    ['&:focus .' + globalClassnames.titleHasError]: borderColorError
                }
            },
            className,
            isOpen && 'is-open',
            disabled && 'is-disabled',
            required && 'is-required'
        ],
        title: [
            globalClassnames.title,
            normalize,
            {
                backgroundColor: semanticColors.inputBackground,
                borderWidth: 1,
                borderStyle: 'solid',
                borderColor: semanticColors.inputBorder,
                cursor: 'pointer',
                display: 'block',
                height: DROPDOWN_HEIGHT,
                lineHeight: DROPDOWN_HEIGHT - 2,
                padding: `0 ${DROPDOWN_HEIGHT}px 0 12px`,
                position: 'relative',
                overflow: 'hidden',
                whiteSpace: 'nowrap',
                textOverflow: 'ellipsis'
            },
            isRenderingPlaceholder && [globalClassnames.titleIsPlaceHolder, { color: semanticColors.inputPlaceholderText }],
            hasError && [globalClassnames.titleHasError, borderColorError],
            disabled && {
                backgroundColor: semanticColors.disabledBackground,
                border: 'none',
                color: semanticColors.disabledText,
                cursor: 'default',
                selectors: { [HighContrastSelector]: { border: '1px solid GrayText', color: 'GrayText' } }
            }
        ],
        caretDownWrapper: [
            globalClassnames.caretDownWrapper,
            {
                position: 'absolute',
                top: 1,
                right: 12,
                height: DROPDOWN_HEIGHT,
                lineHeight: DROPDOWN_HEIGHT - 2 // height minus the border
            }
        ],
        caretDown: [
            globalClassnames.caretDown,
            { color: palette.neutralSecondary, fontSize: FontSizes.small, pointerEvents: 'none' },
            disabled && { color: semanticColors.disabledText, selectors: { [HighContrastSelector]: { color: 'GrayText' } } }
        ],
        errorMessage: { color: semanticColors.errorText, ...theme.fonts.small, paddingTop: 5 },
        callout: [
            globalClassnames.callout,
            {
                boxShadow: '0 0 2px 0 rgba(0,0,0,0.2)',
                border: `1px solid ${palette.neutralLight}`
            },
            calloutClassName
        ],
        panel: [
            globalClassnames.panel,
            {
                // #5689: use subcomponentstyles when panel is converted to use js styling.
                selectors: {
                    '& .ms-Panel-main': {
                        // Force drop shadow even under medium breakpoint
                        boxShadow: '-30px 0px 30px -30px rgba(0,0,0,0.2)'
                    },
                    '& .ms-Panel-contentInner': { padding: '0 0 20px' }
                }
            },
            panelClassName
        ],
        dropdownItemsWrapper: { selectors: { '&:focus': { outline: 0 } } },
        dropdownItems: [globalClassnames.dropdownItems, { display: 'block' }],
        dropdownItem: [
            ...dropdownItemStyle,
            {
                selectors: {
                    [HighContrastSelector]: {
                        borderColor: 'Window'
                    },
                    '&:hover': {
                        color: 'inherit'
                    },
                    '&:focus': {
                        backgroundColor: semanticColors.listItemBackgroundHovered
                    },
                    '&:active': {
                        backgroundColor: semanticColors.listHeaderBackgroundHovered,
                        color: palette.black
                    }
                }
            }
        ],
        dropdownItemSelected: dropdownItemSelected,
        dropdownItemDisabled: dropdownItemDisabled,
        dropdownItemSelectedAndDisabled: [dropdownItemSelected, dropdownItemDisabled, { backgroundColor: 'transparent' }],
        dropdownDivider: [globalClassnames.dropdownDivider, { height: 1, backgroundColor: semanticColors.bodyDivider }],
        dropdownOptionText: [
            globalClassnames.dropdownOptionText,
            {
                overflow: 'hidden',
                whiteSpace: 'nowrap',
                textOverflow: 'ellipsis',
                minWidth: 0,
                maxWidth: '100%',
                wordWrap: 'break-word',
                overflowWrap: 'break-word',
                margin: '1px'
            }
        ],
        dropdownItemHeader: [
            globalClassnames.dropdownItemHeader,
            {
                ...theme.fonts.medium,
                fontWeight: FontWeights.semibold,
                color: semanticColors.menuHeader,
                background: 'none',
                backgroundColor: 'transparent',
                border: 'none',
                height: DROPDOWN_ITEMHEIGHT,
                lineHeight: DROPDOWN_ITEMHEIGHT,
                cursor: 'default',
                padding: '0px 16px',
                userSelect: 'none',
                textAlign: 'left'
            }
        ],
        subComponentStyles: { label: { root: { display: 'inline-block' } } }
    };
};

const Dropdown = styled(DropdownBase, getStyles$R, undefined, {
    scope: 'Dropdown'
});

// import * as stylesImport from './BaseExtendedPicker.scss';
// const styles: any = stylesImport;
let styles$e;
class BaseExtendedPicker extends BaseComponent {
    constructor(basePickerProps) {
        super(basePickerProps);
        this.floatingPicker = createRef();
        this.selectedItemsList = createRef();
        this.root = createRef();
        this.input = createRef();
        this.onSelectionChange = () => {
            this.forceUpdate();
        };
        this.onInputChange = (value) => {
            this.setState({ queryString: value });
            if (this.floatingPicker.current) {
                this.floatingPicker.current.onQueryStringChanged(value);
            }
        };
        this.onInputFocus = (ev) => {
            if (this.selectedItemsList.current) {
                this.selectedItemsList.current.unselectAll();
            }
            if (this.props.inputProps && this.props.inputProps.onFocus) {
                this.props.inputProps.onFocus(ev);
            }
        };
        this.onInputClick = (ev) => {
            if (this.selectedItemsList.current) {
                this.selectedItemsList.current.unselectAll();
            }
            if (this.floatingPicker.current && this.inputElement) {
                // Update the value if the input value is empty or it is different than the current inputText from the floatingPicker
                const shoudUpdateValue = this.inputElement.value === '' || this.inputElement.value !== this.floatingPicker.current.inputText;
                this.floatingPicker.current.showPicker(shoudUpdateValue);
            }
        };
        // This is protected because we may expect the backspace key to work differently in a different kind of picker.
        // This lets the subclass override it and provide it's own onBackspace. For an example see the BasePickerListBelow
        this.onBackspace = (ev) => {
            if (ev.which !== KeyCodes.backspace) {
                return;
            }
            if (this.selectedItemsList.current && this.items.length) {
                if (this.input.current &&
                    !this.input.current.isValueSelected &&
                    this.input.current.inputElement === document.activeElement &&
                    this.input.current.cursorLocation === 0) {
                    if (this.floatingPicker.current) {
                        this.floatingPicker.current.hidePicker();
                    }
                    ev.preventDefault();
                    this.selectedItemsList.current.removeItemAt(this.items.length - 1);
                    this._onSelectedItemsChanged();
                }
                else if (this.selectedItemsList.current.hasSelectedItems()) {
                    if (this.floatingPicker.current) {
                        this.floatingPicker.current.hidePicker();
                    }
                    ev.preventDefault();
                    this.selectedItemsList.current.removeSelectedItems();
                    this._onSelectedItemsChanged();
                }
            }
        };
        this.onCopy = (ev) => {
            if (this.selectedItemsList.current) {
                // Pass it down into the selected items list
                this.selectedItemsList.current.onCopy(ev);
            }
        };
        this.onPaste = (ev) => {
            if (this.props.onPaste) {
                const inputText = ev.clipboardData.getData('Text');
                ev.preventDefault();
                this.props.onPaste(inputText);
            }
        };
        this._onSuggestionSelected = (item) => {
            const currentRenderedQueryString = this.props.currentRenderedQueryString;
            const queryString = this.state.queryString;
            if (currentRenderedQueryString === undefined || currentRenderedQueryString === queryString) {
                const processedItem = this.props.onItemSelected ? this.props.onItemSelected(item) : item;
                if (processedItem === null) {
                    return;
                }
                const processedItemObject = processedItem;
                const processedItemPromiseLike = processedItem;
                let newItem;
                if (processedItemPromiseLike && processedItemPromiseLike.then) {
                    processedItemPromiseLike.then((resolvedProcessedItem) => {
                        newItem = resolvedProcessedItem;
                        this._addProcessedItem(newItem);
                    });
                }
                else {
                    newItem = processedItemObject;
                    this._addProcessedItem(newItem);
                }
            }
        };
        this._onSelectedItemsChanged = () => {
            this.focus();
        };
        this.selection = new Selection({ onSelectionChanged: () => this.onSelectionChange() });
        this.state = {
            queryString: '',
            suggestionItems: this.props.suggestionItems ? this.props.suggestionItems : null,
            selectedItems: this.props.defaultSelectedItems
                ? this.props.defaultSelectedItems
                : this.props.selectedItems
                    ? this.props.selectedItems
                    : null
        };
        this.floatingPickerProps = this.props.floatingPickerProps;
        this.selectedItemsListProps = this.props.selectedItemsListProps;
    }
    // tslint:disable-next-line:no-any
    get items() {
        return this.state.selectedItems
            ? this.state.selectedItems
            : this.selectedItemsList.current
                ? this.selectedItemsList.current.items
                : null;
    }
    componentDidMount() {
        this.forceUpdate();
    }
    componentWillReceiveProps(newProps) {
        if (newProps.floatingPickerProps) {
            this.floatingPickerProps = newProps.floatingPickerProps;
        }
        if (newProps.selectedItemsListProps) {
            this.selectedItemsListProps = newProps.selectedItemsListProps;
        }
        if (newProps.selectedItems) {
            this.setState({ selectedItems: newProps.selectedItems });
        }
    }
    focus() {
        if (this.input.current) {
            this.input.current.focus();
        }
    }
    clearInput() {
        if (this.input.current) {
            this.input.current.clear();
        }
    }
    get inputElement() {
        return this.input.current && this.input.current.inputElement;
    }
    get highlightedItems() {
        return this.selectedItemsList.current ? this.selectedItemsList.current.highlightedItems() : [];
    }
    render() {
        const { className, inputProps, disabled, focusZoneProps } = this.props;
        const activeDescendant = this.floatingPicker.current && this.floatingPicker.current.currentSelectedSuggestionIndex !== -1
            ? 'sug-' + this.floatingPicker.current.currentSelectedSuggestionIndex
            : undefined;
        return (createElement("div", { ref: this.root, className: css('ms-BasePicker ms-BaseExtendedPicker', className ? className : ''), onKeyDown: this.onBackspace, onCopy: this.onCopy },
            createElement(FocusZone, Object.assign({ direction: FocusZoneDirection.bidirectional }, focusZoneProps),
                createElement(SelectionZone, { selection: this.selection, selectionMode: SelectionMode.multiple },
                    createElement("div", { className: css('ms-BasePicker-text', styles$e.pickerText), role: 'list' },
                        this.props.headerComponent,
                        this.renderSelectedItemsList(),
                        this.canAddItems() && (createElement(Autofill, Object.assign({}, inputProps, { className: css('ms-BasePicker-input', styles$e.pickerInput), ref: this.input, onFocus: this.onInputFocus, onClick: this.onInputClick, onInputValueChange: this.onInputChange, "aria-activedescendant": activeDescendant, "aria-owns": "suggestion-list", "aria-expanded": this.floatingPicker.current ? this.floatingPicker.current.isSuggestionsShown : false, "aria-haspopup": "true", autoCapitalize: "off", autoComplete: "off", role: "combobox", disabled: disabled, onPaste: this.onPaste })))))),
            this.renderSuggestions()));
    }
    canAddItems() {
        const { itemLimit } = this.props;
        return itemLimit === undefined || this.items.length < itemLimit;
    }
    renderSuggestions() {
        const onRenderFloatingPicker = this.props.onRenderFloatingPicker;
        return onRenderFloatingPicker({
            componentRef: this.floatingPicker,
            onChange: this._onSuggestionSelected,
            inputElement: this.input.current ? this.input.current.inputElement : undefined,
            selectedItems: this.items,
            suggestionItems: this.props.suggestionItems ? this.props.suggestionItems : undefined,
            ...this.floatingPickerProps
        });
    }
    renderSelectedItemsList() {
        const onRenderSelectedItems = this.props.onRenderSelectedItems;
        return onRenderSelectedItems({
            componentRef: this.selectedItemsList,
            selection: this.selection,
            selectedItems: this.props.selectedItems ? this.props.selectedItems : undefined,
            onItemsDeleted: this.props.selectedItems ? this.props.onItemsRemoved : undefined,
            ...this.selectedItemsListProps
        });
    }
    _addProcessedItem(newItem) {
        // If this is a controlled component, call the on item selected callback
        // Otherwise add it to the selectedItemsList
        if (this.props.onItemAdded) {
            this.props.onItemAdded(newItem);
        }
        if (this.selectedItemsList.current) {
            this.selectedItemsList.current.addItems([newItem]);
        }
        if (this.input.current) {
            this.input.current.clear();
        }
        if (this.floatingPicker.current) {
            this.floatingPicker.current.hidePicker();
        }
        this.focus();
    }
}

//import './ExtendedPeoplePicker.scss';
class BaseExtendedPeoplePicker extends BaseExtendedPicker {
}
class ExtendedPeoplePicker extends BaseExtendedPeoplePicker {
}

var OverflowButtonType;
(function (OverflowButtonType) {
    /** No overflow */
    OverflowButtonType[OverflowButtonType["none"] = 0] = "none";
    /** +1 overflow icon */
    OverflowButtonType[OverflowButtonType["descriptive"] = 1] = "descriptive";
    /** More overflow icon */
    OverflowButtonType[OverflowButtonType["more"] = 2] = "more";
    /** Chevron overflow icon */
    OverflowButtonType[OverflowButtonType["downArrow"] = 3] = "downArrow";
})(OverflowButtonType || (OverflowButtonType = {}));

const getStyles$S = memoizeFunction((theme, className, customStyles) => {
    const baseButtonStyles = getStyles$d(theme);
    const customButtonStyles = concatStyleSets(baseButtonStyles, customStyles);
    return {
        ...customButtonStyles,
        root: [baseButtonStyles.root, className, theme.fonts.medium, customStyles && customStyles.root]
    };
});

let FacepileButton = class FacepileButton extends BaseComponent {
    constructor() {
        super(...arguments);
        /**
         * Tell BaseComponent to bypass resolution of componentRef.
         */
        this._skipComponentRefResolution = true;
    }
    render() {
        const { className, styles, ...rest } = this.props;
        const customStyles = getStyles$S(this.props.theme, className, styles);
        return createElement(BaseButton, Object.assign({}, rest, { variantClassName: "ms-Button--facepile", styles: customStyles, onRenderDescription: nullRender }));
    }
};
FacepileButton = __decorate([
    customizable('FacepileButton', ['theme', 'styles'], true)
], FacepileButton);

const getClassNames$M = classNamesFunction();
/**
 * FacePile with no default styles.
 * [Use the `styles` API to add your own styles.](https://github.com/OfficeDev/office-ui-fabric-react/wiki/Component-Styling)
 */
class FacepileBase extends BaseComponent {
    constructor(props) {
        super(props);
        this._classNames = getClassNames$M(this.props.styles, {
            theme: this.props.theme,
            className: this.props.className
        });
        this._ariaDescriptionId = getId();
    }
    render() {
        let { overflowButtonProps } = this.props;
        const { chevronButtonProps, maxDisplayablePersonas, personas, overflowPersonas, showAddButton } = this.props;
        const { _classNames } = this;
        const numPersonasToShow = Math.min(personas.length, maxDisplayablePersonas || personas.length);
        // Added for deprecating chevronButtonProps.  Can remove after v1.0
        if (chevronButtonProps && !overflowButtonProps) {
            overflowButtonProps = chevronButtonProps;
        }
        const hasOverflowPersonas = overflowPersonas && overflowPersonas.length > 0;
        const personasPrimary = hasOverflowPersonas ? personas : personas.slice(0, numPersonasToShow);
        const personasOverflow = (hasOverflowPersonas ? overflowPersonas : personas.slice(numPersonasToShow)) || [];
        return (createElement("div", { className: _classNames.root },
            this.onRenderAriaDescription(),
            createElement("div", { className: _classNames.itemContainer },
                showAddButton ? this._getAddNewElement() : null,
                createElement("ul", { className: _classNames.members }, this._onRenderVisiblePersonas(personasPrimary, personasOverflow.length === 0 && personas.length === 1)),
                overflowButtonProps ? this._getOverflowElement(personasOverflow) : null)));
    }
    onRenderAriaDescription() {
        const { ariaDescription } = this.props;
        const { _classNames } = this;
        // If ariaDescription is given, descriptionId will be assigned to ariaDescriptionSpan,
        // otherwise it will be assigned to descriptionSpan.
        return (ariaDescription && (createElement("span", { className: _classNames.screenReaderOnly, id: this._ariaDescriptionId }, ariaDescription)));
    }
    _onRenderVisiblePersonas(personas, singlePersona) {
        return personas.map((persona, index) => {
            const personaControl = singlePersona ? this._getPersonaControl(persona) : this._getPersonaCoinControl(persona);
            return (createElement("li", { key: `${singlePersona ? 'persona' : 'personaCoin'}-${index}`, className: this._classNames.member }, persona.onClick
                ? this._getElementWithOnClickEvent(personaControl, persona, index)
                : this._getElementWithoutOnClickEvent(personaControl, persona, index)));
        });
    }
    _getPersonaControl(persona) {
        const { getPersonaProps, personaSize: personaSize$$1 } = this.props;
        const personaStyles = {
            details: {
                flex: '1 0 auto'
            }
        };
        return (createElement(Persona, Object.assign({ imageInitials: persona.imageInitials, imageUrl: persona.imageUrl, initialsColor: persona.initialsColor, allowPhoneInitials: persona.allowPhoneInitials, text: persona.personaName, size: personaSize$$1 }, (getPersonaProps ? getPersonaProps(persona) : null), { styles: personaStyles })));
    }
    _getPersonaCoinControl(persona) {
        const { getPersonaProps, personaSize: personaSize$$1 } = this.props;
        return (createElement(PersonaCoin, Object.assign({ imageInitials: persona.imageInitials, imageUrl: persona.imageUrl, initialsColor: persona.initialsColor, allowPhoneInitials: persona.allowPhoneInitials, text: persona.personaName, size: personaSize$$1 }, (getPersonaProps ? getPersonaProps(persona) : null))));
    }
    _getElementWithOnClickEvent(personaControl, persona, index) {
        const { keytipProps } = persona;
        return (createElement(FacepileButton, Object.assign({}, getNativeProps(persona, buttonProperties), this._getElementProps(persona, index), { keytipProps: keytipProps, onClick: this._onPersonaClick.bind(this, persona) }), personaControl));
    }
    _getElementWithoutOnClickEvent(personaControl, persona, index) {
        return (createElement("div", Object.assign({}, getNativeProps(persona, buttonProperties), this._getElementProps(persona, index)), personaControl));
    }
    _getElementProps(persona, index) {
        const { _classNames } = this;
        return {
            key: (!!persona.imageUrl ? 'i' : '') + index,
            'data-is-focusable': true,
            role: 'option',
            className: _classNames.itemButton,
            title: persona.personaName,
            onMouseMove: this._onPersonaMouseMove.bind(this, persona),
            onMouseOut: this._onPersonaMouseOut.bind(this, persona)
        };
    }
    _getOverflowElement(personasOverflow) {
        switch (this.props.overflowButtonType) {
            case OverflowButtonType.descriptive:
                return this._getDescriptiveOverflowElement(personasOverflow);
            case OverflowButtonType.downArrow:
                return this._getIconElement('ChevronDown');
            case OverflowButtonType.more:
                return this._getIconElement('More');
            default:
                return null;
        }
    }
    _getDescriptiveOverflowElement(personasOverflow) {
        const { personaSize: personaSize$$1 } = this.props;
        if (!personasOverflow || personasOverflow.length < 1) {
            return null;
        }
        const personaNames = personasOverflow.map((p) => p.personaName).join(', ');
        const overflowButtonProps = { ...{ title: personaNames }, ...this.props.overflowButtonProps };
        const numPersonasNotPictured = Math.max(personasOverflow.length, 0);
        const { _classNames } = this;
        return (createElement(FacepileButton, Object.assign({}, overflowButtonProps, { ariaDescription: overflowButtonProps.title, className: _classNames.descriptiveOverflowButton }),
            createElement(PersonaCoin, { size: personaSize$$1, onRenderInitials: this._renderInitialsNotPictured(numPersonasNotPictured), initialsColor: PersonaInitialsColor.transparent })));
    }
    _getIconElement(icon) {
        const { overflowButtonProps, personaSize: personaSize$$1 } = this.props;
        const overflowInitialsIcon = true;
        const { _classNames } = this;
        return (createElement(FacepileButton, Object.assign({}, overflowButtonProps, { className: _classNames.overflowButton }),
            createElement(PersonaCoin, { size: personaSize$$1, onRenderInitials: this._renderInitials(icon, overflowInitialsIcon), initialsColor: PersonaInitialsColor.transparent })));
    }
    _getAddNewElement() {
        const { addButtonProps, personaSize: personaSize$$1 } = this.props;
        const { _classNames } = this;
        return (createElement(FacepileButton, Object.assign({}, addButtonProps, { className: _classNames.addButton }),
            createElement(PersonaCoin, { size: personaSize$$1, onRenderInitials: this._renderInitials('AddFriend') })));
    }
    _onPersonaClick(persona, ev) {
        persona.onClick(ev, persona);
        ev.preventDefault();
        ev.stopPropagation();
    }
    _onPersonaMouseMove(persona, ev) {
        if (!!persona.onMouseMove) {
            persona.onMouseMove(ev, persona);
        }
    }
    _onPersonaMouseOut(persona, ev) {
        if (!!persona.onMouseOut) {
            persona.onMouseOut(ev, persona);
        }
    }
    _renderInitials(iconName, overflowButton) {
        const { _classNames } = this;
        return () => {
            return createElement(Icon, { iconName: iconName, className: overflowButton ? _classNames.overflowInitialsIcon : '' });
        };
    }
    _renderInitialsNotPictured(numPersonasNotPictured) {
        const { _classNames } = this;
        return () => {
            return createElement("span", { className: _classNames.overflowInitialsIcon }, '+' + numPersonasNotPictured);
        };
    }
}
FacepileBase.defaultProps = {
    maxDisplayablePersonas: 5,
    personas: [],
    overflowPersonas: [],
    personaSize: PersonaSize.size32
};

const GlobalClassNames$x = {
    root: 'ms-Facepile',
    addButton: 'ms-Facepile-addButton ms-Facepile-itemButton',
    descriptiveOverflowButton: 'ms-Facepile-descriptiveOverflowButton ms-Facepile-itemButton',
    itemButton: 'ms-Facepile-itemButton ms-Facepile-person',
    itemContainer: 'ms-Facepile-itemContainer',
    members: 'ms-Facepile-members',
    member: 'ms-Facepile-member',
    overflowButton: 'ms-Facepile-overflowButton ms-Facepile-itemButton'
};
const styles$f = (props) => {
    const { className, theme, spacingAroundItemButton = 2 } = props;
    const { palette, fonts } = theme;
    const classNames = getGlobalClassNames(GlobalClassNames$x, theme);
    const ItemButtonStyles = {
        textAlign: 'center',
        padding: 0,
        borderRadius: '50%',
        verticalAlign: 'top',
        display: 'inline',
        backgroundColor: 'transparent',
        cursor: 'pointer',
        border: 'none',
        selectors: {
            '&::-moz-focus-inner': {
                padding: 0,
                border: 0
            }
        }
    };
    return {
        root: [
            classNames.root,
            theme.fonts.medium,
            {
                width: 'auto'
            },
            className
        ],
        addButton: [
            classNames.addButton,
            getFocusStyle(theme, -1),
            ItemButtonStyles,
            {
                fontSize: fonts.medium.fontSize,
                color: palette.white,
                backgroundColor: palette.themePrimary,
                marginRight: spacingAroundItemButton * 2 + 'px',
                selectors: {
                    '&:hover': {
                        backgroundColor: palette.themeDark
                    },
                    '&:focus': {
                        backgroundColor: palette.themeDark
                    },
                    '&:active': {
                        backgroundColor: palette.themeDarker
                    },
                    '&:disabled': {
                        backgroundColor: palette.neutralTertiaryAlt
                    }
                }
            }
        ],
        descriptiveOverflowButton: [
            classNames.descriptiveOverflowButton,
            getFocusStyle(theme, -1),
            ItemButtonStyles,
            {
                fontSize: fonts.small.fontSize,
                color: palette.neutralSecondary,
                backgroundColor: palette.neutralLight,
                marginLeft: `${spacingAroundItemButton * 2}px`
            }
        ],
        itemButton: [classNames.itemButton, ItemButtonStyles],
        itemContainer: [
            classNames.itemContainer,
            {
                display: 'flex'
            }
        ],
        members: [
            classNames.members,
            {
                display: 'flex',
                overflow: 'hidden',
                listStyleType: 'none',
                padding: 0,
                margin: `-${spacingAroundItemButton}px`
            }
        ],
        member: [
            classNames.member,
            {
                display: 'inline-flex',
                flex: '0 0 auto',
                margin: `${spacingAroundItemButton}px`
            }
        ],
        overflowButton: [
            classNames.overflowButton,
            getFocusStyle(theme, -1),
            ItemButtonStyles,
            {
                fontSize: fonts.medium.fontSize,
                color: palette.neutralSecondary,
                backgroundColor: palette.neutralLight,
                marginLeft: `${spacingAroundItemButton * 2}px`
            }
        ],
        overflowInitialsIcon: [
            {
                color: palette.neutralPrimary
            }
        ],
        screenReaderOnly: hiddenContentStyle
    };
};

/**
 * The Facepile shows a list of faces or initials in a horizontal lockup. Each circle represents a person.
 */
const Facepile = styled(FacepileBase, styles$f, undefined, {
    scope: 'Facepile'
});

/** Enum to help identify which suggestions action button is selected. */
var SuggestionActionType;
(function (SuggestionActionType) {
    /** None of the actions is selected. */
    SuggestionActionType[SuggestionActionType["none"] = 0] = "none";
    /** ForceResolve action is selected. */
    SuggestionActionType[SuggestionActionType["forceResolve"] = 1] = "forceResolve";
    /** SearchMore action is selected. */
    SuggestionActionType[SuggestionActionType["searchMore"] = 2] = "searchMore";
})(SuggestionActionType || (SuggestionActionType = {}));

// import * as stylesImport from './Suggestions.scss';
// const legacyStyles: any = stylesImport;
let legacyStyles;
const getClassNames$N = classNamesFunction();
class SuggestionsItem extends BaseComponent {
    render() {
        const { suggestionModel, RenderSuggestion, onClick, className, onRemoveItem, isSelectedOverride, removeButtonAriaLabel, styles, theme } = this.props;
        // TODO
        // Clean this up by leaving only the first part after removing support for SASS.
        // Currently we can not remove the SASS styles from SuggestionsItem class because it
        // might be used by consumers separately from pickers extending from BasePicker
        // and have not used the new 'styles' prop. Because it's expecting a type parameter,
        // we can not use the 'styled' function without adding some helpers which can break
        // downstream consumers who did not use the new helpers.
        // We check for 'styles' prop which is going to be injected by the 'styled' HOC
        // in Suggestions when the typed SuggestionsItem class is ready to be rendered. If the
        // check passes we can use the CSS-in-JS styles. If the check fails (ex: custom picker),
        // then we just use the old SASS styles instead.
        const classNames = styles
            ? getClassNames$N(styles, {
                theme: theme,
                className,
                suggested: suggestionModel.selected || isSelectedOverride
            })
            : {
                root: css('ms-Suggestions-item', legacyStyles.suggestionsItem, {
                    ['is-suggested ' + legacyStyles.suggestionsItemIsSuggested]: suggestionModel.selected || isSelectedOverride
                }, className),
                itemButton: css('ms-Suggestions-itemButton', legacyStyles.itemButton),
                closeButton: css('ms-Suggestions-closeButton', legacyStyles.closeButton)
            };
        return (createElement("div", { className: classNames.root },
            createElement(CommandButton, { onClick: onClick, className: classNames.itemButton }, RenderSuggestion(suggestionModel.item, this.props)),
            this.props.showRemoveButton ? (createElement(IconButton, { iconProps: { iconName: 'Cancel', styles: { root: { fontSize: '12px' } } }, title: removeButtonAriaLabel, ariaLabel: removeButtonAriaLabel, onClick: onRemoveItem, className: classNames.closeButton })) : null));
    }
}

const GlobalClassNames$y = {
    root: 'ms-Suggestions-item',
    itemButton: 'ms-Suggestions-itemButton',
    closeButton: 'ms-Suggestions-closeButton',
    isSuggested: 'is-suggested'
};
function getStyles$T(props) {
    const { className, theme, suggested } = props;
    const { palette } = theme;
    const classNames = getGlobalClassNames(GlobalClassNames$y, theme);
    return {
        root: [
            classNames.root,
            {
                display: 'flex',
                alignItems: 'stretch',
                boxSizing: 'border-box',
                width: '100%',
                position: 'relative',
                selectors: {
                    '&:hover': {
                        background: palette.neutralLighter
                    },
                    '&:hover .ms-Suggestions-closeButton': {
                        display: 'block'
                    }
                }
            },
            suggested && [
                classNames.isSuggested,
                {
                    background: palette.neutralLight,
                    selectors: {
                        ':hover': {
                            background: palette.neutralTertiaryAlt
                        },
                        [HighContrastSelector]: {
                            background: 'Highlight',
                            color: 'HighlightText',
                            MsHighContrastAdjust: 'none'
                        }
                    }
                }
            ],
            className
        ],
        itemButton: [
            classNames.itemButton,
            {
                width: '100%',
                padding: 0,
                height: '100%',
                selectors: {
                    [HighContrastSelector]: {
                        color: 'WindowText'
                    },
                    ':hover': {
                        color: palette.neutralDark
                    }
                }
            }
        ],
        closeButton: [
            classNames.closeButton,
            {
                display: 'none',
                color: palette.neutralSecondary,
                padding: '0 4px',
                height: 'auto',
                width: 32,
                selectors: {
                    ':hover, :active': {
                        background: palette.neutralTertiaryAlt,
                        color: palette.neutralDark
                    },
                    [HighContrastSelector]: {
                        color: 'WindowText'
                    }
                }
            },
            suggested && {
                selectors: {
                    ':hover, :active': {
                        background: palette.neutralTertiary,
                        color: palette.neutralPrimary
                    }
                }
            }
        ]
    };
}

// import * as stylesImport from './Suggestions.scss';
// const legacyStyles: any = stylesImport;
let legacyStyles$1;
const getClassNames$O = classNamesFunction();
class Suggestions extends BaseComponent {
    constructor(suggestionsProps) {
        super(suggestionsProps);
        this._forceResolveButton = createRef();
        this._searchForMoreButton = createRef();
        this._selectedElement = createRef();
        this.SuggestionsItemOfProperType = SuggestionsItem;
        /**
         * Returns true if the event was handled, false otherwise
         */
        this.tryHandleKeyDown = (keyCode, currentSuggestionIndex) => {
            let isEventHandled = false;
            let newSelectedActionType = null;
            const currentSelectedAction = this.state.selectedActionType;
            const suggestionLength = this.props.suggestions.length;
            if (keyCode === KeyCodes.down) {
                switch (currentSelectedAction) {
                    case SuggestionActionType.forceResolve:
                        if (suggestionLength > 0) {
                            this._refocusOnSuggestions(keyCode);
                            newSelectedActionType = SuggestionActionType.none;
                        }
                        else if (this._searchForMoreButton.current) {
                            newSelectedActionType = SuggestionActionType.searchMore;
                        }
                        else {
                            newSelectedActionType = SuggestionActionType.forceResolve;
                        }
                        break;
                    case SuggestionActionType.searchMore:
                        if (this._forceResolveButton.current) {
                            newSelectedActionType = SuggestionActionType.forceResolve;
                        }
                        else if (suggestionLength > 0) {
                            this._refocusOnSuggestions(keyCode);
                            newSelectedActionType = SuggestionActionType.none;
                        }
                        else {
                            newSelectedActionType = SuggestionActionType.searchMore;
                        }
                        break;
                    case SuggestionActionType.none:
                        if (currentSuggestionIndex === -1 && this._forceResolveButton.current) {
                            newSelectedActionType = SuggestionActionType.forceResolve;
                        }
                        break;
                }
            }
            else if (keyCode === KeyCodes.up) {
                switch (currentSelectedAction) {
                    case SuggestionActionType.forceResolve:
                        if (this._searchForMoreButton.current) {
                            newSelectedActionType = SuggestionActionType.searchMore;
                        }
                        else if (suggestionLength > 0) {
                            this._refocusOnSuggestions(keyCode);
                            newSelectedActionType = SuggestionActionType.none;
                        }
                        break;
                    case SuggestionActionType.searchMore:
                        if (suggestionLength > 0) {
                            this._refocusOnSuggestions(keyCode);
                            newSelectedActionType = SuggestionActionType.none;
                        }
                        else if (this._forceResolveButton.current) {
                            newSelectedActionType = SuggestionActionType.forceResolve;
                        }
                        break;
                    case SuggestionActionType.none:
                        if (currentSuggestionIndex === -1 && this._searchForMoreButton.current) {
                            newSelectedActionType = SuggestionActionType.searchMore;
                        }
                        break;
                }
            }
            if (newSelectedActionType !== null) {
                this.setState({ selectedActionType: newSelectedActionType });
                isEventHandled = true;
            }
            return isEventHandled;
        };
        this._getMoreResults = () => {
            if (this.props.onGetMoreResults) {
                this.props.onGetMoreResults();
            }
        };
        this._forceResolve = () => {
            if (this.props.createGenericItem) {
                this.props.createGenericItem();
            }
        };
        this._shouldShowForceResolve = () => {
            return this.props.showForceResolve ? this.props.showForceResolve() : false;
        };
        this._onClickTypedSuggestionsItem = (item, index) => {
            return (ev) => {
                this.props.onSuggestionClick(ev, item, index);
            };
        };
        this._refocusOnSuggestions = (keyCode) => {
            if (typeof this.props.refocusSuggestions === 'function') {
                this.props.refocusSuggestions(keyCode);
            }
        };
        this._onRemoveTypedSuggestionsItem = (item, index) => {
            return (ev) => {
                const onSuggestionRemove = this.props.onSuggestionRemove;
                onSuggestionRemove(ev, item, index);
                ev.stopPropagation();
            };
        };
        this.state = {
            selectedActionType: SuggestionActionType.none
        };
    }
    componentDidMount() {
        this.scrollSelected();
        this.activeSelectedElement = this._selectedElement ? this._selectedElement.current : null;
    }
    componentDidUpdate() {
        // Only scroll to selected element if the selected element has changed. Otherwise do nothing.
        // This prevents some odd behavior where scrolling the active element out of view and clicking on a selected element
        // will trigger a focus event and not give the clicked element the click.
        if (this._selectedElement.current && this.activeSelectedElement !== this._selectedElement.current) {
            this.scrollSelected();
            this.activeSelectedElement = this._selectedElement.current;
        }
    }
    render() {
        const { forceResolveText, mostRecentlyUsedHeaderText, searchForMoreText, className, moreSuggestionsAvailable, noResultsFoundText, suggestions, isLoading, isSearching, loadingText, onRenderNoResultFound, searchingText, isMostRecentlyUsedVisible, resultsMaximumNumber, resultsFooterFull, resultsFooter, isResultsFooterVisible = true, suggestionsAvailableAlertText, suggestionsHeaderText, suggestionsClassName, theme, styles } = this.props;
        // TODO
        // Clean this up by leaving only the first part after removing support for SASS.
        // Currently we can not remove the SASS styles from Suggestions class because it
        // might be used by consumers separately from pickers extending from BasePicker
        // and have not used the new 'styles' prop. Because it's expecting a type parameter,
        // we can not use the 'styled' function without adding some helpers which can break
        // downstream consumers who did not use the new helpers.
        // We check for 'styles' prop which is going to be injected by the 'styled' HOC
        // in BasePicker when the typed Suggestions class is ready to be rendered. If the check
        // passes we can use the CSS-in-JS styles. If the check fails (ex: custom picker),
        // then we just use the old SASS styles instead.
        this._classNames = styles
            ? getClassNames$O(styles, {
                theme: theme,
                className,
                suggestionsClassName,
                forceResolveButtonSelected: this.state.selectedActionType === SuggestionActionType.forceResolve,
                searchForMoreButtonSelected: this.state.selectedActionType === SuggestionActionType.searchMore
            })
            : {
                root: css('ms-Suggestions', className, legacyStyles$1.root),
                title: css('ms-Suggestions-title', legacyStyles$1.suggestionsTitle),
                searchForMoreButton: css('ms-SearchMore-button', legacyStyles$1.actionButton, {
                    ['is-selected ' + legacyStyles$1.buttonSelected]: this.state.selectedActionType === SuggestionActionType.searchMore
                }),
                forceResolveButton: css('ms-forceResolve-button', legacyStyles$1.actionButton, {
                    ['is-selected ' + legacyStyles$1.buttonSelected]: this.state.selectedActionType === SuggestionActionType.forceResolve
                }),
                suggestionsAvailable: css('ms-Suggestions-suggestionsAvailable', legacyStyles$1.suggestionsAvailable),
                suggestionsContainer: css('ms-Suggestions-container', legacyStyles$1.suggestionsContainer, suggestionsClassName),
                noSuggestions: css('ms-Suggestions-none', legacyStyles$1.suggestionsNone)
            };
        const spinnerStyles = this._classNames.subComponentStyles
            ? this._classNames.subComponentStyles.spinner
            : undefined;
        // TODO: cleanup after refactor of pickers to composition pattern and remove SASS support.
        const spinnerClassNameOrStyles = styles
            ? { styles: spinnerStyles }
            : { className: css('ms-Suggestions-spinner', legacyStyles$1.suggestionsSpinner) };
        const noResults = () => {
            return noResultsFoundText ? (createElement("div", { role: "alert", className: this._classNames.noSuggestions }, noResultsFoundText)) : null;
        };
        // MostRecently Used text should supercede the header text if it's there and available.
        let headerText = suggestionsHeaderText;
        if (isMostRecentlyUsedVisible && mostRecentlyUsedHeaderText) {
            headerText = mostRecentlyUsedHeaderText;
        }
        let footerTitle = undefined;
        if (isResultsFooterVisible) {
            footerTitle = suggestions.length >= resultsMaximumNumber ? resultsFooterFull : resultsFooter;
        }
        const hasNoSuggestions = (!suggestions || !suggestions.length) && !isLoading;
        return (createElement("div", { className: this._classNames.root },
            headerText ? createElement("div", { className: this._classNames.title }, headerText) : null,
            forceResolveText && this._shouldShowForceResolve() && (createElement(CommandButton, { componentRef: this._forceResolveButton, className: this._classNames.forceResolveButton, onClick: this._forceResolve }, forceResolveText)),
            isLoading && createElement(Spinner, Object.assign({}, spinnerClassNameOrStyles, { label: loadingText })),
            hasNoSuggestions ? (onRenderNoResultFound ? onRenderNoResultFound(undefined, noResults) : noResults()) : this._renderSuggestions(),
            searchForMoreText && moreSuggestionsAvailable && (createElement(CommandButton, { componentRef: this._searchForMoreButton, className: this._classNames.searchForMoreButton, iconProps: { iconName: 'Search' }, onClick: this._getMoreResults }, searchForMoreText)),
            isSearching ? createElement(Spinner, Object.assign({}, spinnerClassNameOrStyles, { label: searchingText })) : null,
            footerTitle && !moreSuggestionsAvailable && !isMostRecentlyUsedVisible && !isSearching ? (createElement("div", { className: this._classNames.title }, footerTitle(this.props))) : null,
            createElement("span", { role: "alert", "aria-live": "polite", className: this._classNames.suggestionsAvailable }, !isLoading && !isSearching && suggestions && suggestions.length > 0 && suggestionsAvailableAlertText
                ? suggestionsAvailableAlertText
                : null)));
    }
    hasSuggestedAction() {
        return this._searchForMoreButton.current !== undefined || this._forceResolveButton.current !== undefined;
    }
    hasSuggestedActionSelected() {
        return this.state.selectedActionType !== SuggestionActionType.none;
    }
    executeSelectedAction() {
        switch (this.state.selectedActionType) {
            case SuggestionActionType.forceResolve:
                this._forceResolve();
                break;
            case SuggestionActionType.searchMore:
                this._getMoreResults();
                break;
        }
    }
    focusAboveSuggestions() {
        if (this._forceResolveButton.current) {
            this.setState({ selectedActionType: SuggestionActionType.forceResolve });
        }
        else if (this._searchForMoreButton.current) {
            this.setState({ selectedActionType: SuggestionActionType.searchMore });
        }
    }
    focusBelowSuggestions() {
        if (this._searchForMoreButton.current) {
            this.setState({ selectedActionType: SuggestionActionType.searchMore });
        }
        else if (this._forceResolveButton.current) {
            this.setState({ selectedActionType: SuggestionActionType.forceResolve });
        }
    }
    focusSearchForMoreButton() {
        if (this._searchForMoreButton.current) {
            this._searchForMoreButton.current.focus();
        }
    }
    // TODO get the element to scroll into view properly regardless of direction.
    scrollSelected() {
        if (this._selectedElement.current && this._selectedElement.current.scrollIntoView !== undefined) {
            this._selectedElement.current.scrollIntoView(false);
        }
    }
    _renderSuggestions() {
        const { onRenderSuggestion, removeSuggestionAriaLabel, suggestionsItemClassName, resultsMaximumNumber, showRemoveButtons, suggestionsContainerAriaLabel, suggestionsListId } = this.props;
        let { suggestions } = this.props;
        const TypedSuggestionsItem = this.SuggestionsItemOfProperType;
        // TODO:
        // Move this styled component in a separate file and make it available to the public API.
        // This should be done after rewriting pickers to use a composition pattern instead of inheritance.
        const StyledTypedSuggestionsItem = styled(TypedSuggestionsItem, getStyles$T, undefined, {
            scope: 'SuggestionItem'
        });
        if (resultsMaximumNumber) {
            suggestions = suggestions.slice(0, resultsMaximumNumber);
        }
        if (suggestions.length === 0) {
            return null;
        }
        return (createElement("div", { className: this._classNames.suggestionsContainer, id: suggestionsListId, role: "listbox", "aria-label": suggestionsContainerAriaLabel }, suggestions.map((suggestion, index) => (createElement("div", { ref: suggestion.selected ? this._selectedElement : '', 
            // tslint:disable-next-line:no-string-literal
            key: suggestion.item['key'] ? suggestion.item['key'] : index, id: 'sug-' + index, "aria-selected": suggestion.selected, role: "option", "aria-label": suggestion.ariaLabel },
            createElement(StyledTypedSuggestionsItem, { suggestionModel: suggestion, RenderSuggestion: onRenderSuggestion, onClick: this._onClickTypedSuggestionsItem(suggestion.item, index), className: suggestionsItemClassName, showRemoveButton: showRemoveButtons, removeButtonAriaLabel: removeSuggestionAriaLabel, onRemoveItem: this._onRemoveTypedSuggestionsItem(suggestion.item, index) }))))));
    }
}

class SuggestionsController {
    constructor() {
        this._isSuggestionModel = (value) => {
            return value.item !== undefined;
        };
        this._ensureSuggestionModel = (suggestion) => {
            if (this._isSuggestionModel(suggestion)) {
                return suggestion;
            }
            else {
                return {
                    item: suggestion,
                    selected: false,
                    ariaLabel: suggestion.name || suggestion.primaryText
                };
            }
        };
        this.suggestions = [];
        this.currentIndex = -1;
    }
    updateSuggestions(newSuggestions, selectedIndex) {
        if (newSuggestions && newSuggestions.length > 0) {
            this.suggestions = this.convertSuggestionsToSuggestionItems(newSuggestions);
            this.currentIndex = selectedIndex ? selectedIndex : 0;
            if (selectedIndex === -1) {
                this.currentSuggestion = undefined;
            }
            else if (selectedIndex !== undefined) {
                this.suggestions[selectedIndex].selected = true;
                this.currentSuggestion = this.suggestions[selectedIndex];
            }
        }
        else {
            this.suggestions = [];
            this.currentIndex = -1;
            this.currentSuggestion = undefined;
        }
    }
    /**
     * Increments the suggestion index and gets the next suggestion in the list.
     */
    nextSuggestion() {
        if (this.suggestions && this.suggestions.length) {
            if (this.currentIndex < this.suggestions.length - 1) {
                this.setSelectedSuggestion(this.currentIndex + 1);
                return true;
            }
            else if (this.currentIndex === this.suggestions.length - 1) {
                this.setSelectedSuggestion(0);
                return true;
            }
        }
        return false;
    }
    /**
     * Decrements the suggestion index and gets the previous suggestion in the list.
     */
    previousSuggestion() {
        if (this.suggestions && this.suggestions.length) {
            if (this.currentIndex > 0) {
                this.setSelectedSuggestion(this.currentIndex - 1);
                return true;
            }
            else if (this.currentIndex === 0) {
                this.setSelectedSuggestion(this.suggestions.length - 1);
                return true;
            }
        }
        return false;
    }
    getSuggestions() {
        return this.suggestions;
    }
    getCurrentItem() {
        return this.currentSuggestion;
    }
    getSuggestionAtIndex(index) {
        return this.suggestions[index];
    }
    hasSelectedSuggestion() {
        return this.currentSuggestion ? true : false;
    }
    removeSuggestion(index) {
        this.suggestions.splice(index, 1);
    }
    createGenericSuggestion(itemToConvert) {
        const itemToAdd = this.convertSuggestionsToSuggestionItems([itemToConvert])[0];
        this.currentSuggestion = itemToAdd;
    }
    convertSuggestionsToSuggestionItems(suggestions) {
        return Array.isArray(suggestions) ? suggestions.map(this._ensureSuggestionModel) : [];
    }
    deselectAllSuggestions() {
        if (this.currentIndex > -1) {
            this.suggestions[this.currentIndex].selected = false;
            this.currentIndex = -1;
        }
    }
    setSelectedSuggestion(index) {
        if (index > this.suggestions.length - 1 || index < 0) {
            this.currentIndex = 0;
            this.currentSuggestion.selected = false;
            this.currentSuggestion = this.suggestions[0];
            this.currentSuggestion.selected = true;
        }
        else {
            if (this.currentIndex > -1) {
                this.suggestions[this.currentIndex].selected = false;
            }
            this.suggestions[index].selected = true;
            this.currentIndex = index;
            this.currentSuggestion = this.suggestions[index];
        }
    }
}

// Deprecated, import directly from the component folder now.

const GlobalClassNames$z = {
    root: 'ms-Suggestions',
    suggestionsContainer: 'ms-Suggestions-container',
    title: 'ms-Suggestions-title',
    forceResolveButton: 'ms-forceResolve-button',
    searchForMoreButton: 'ms-SearchMore-button',
    spinner: 'ms-Suggestions-spinner',
    noSuggestions: 'ms-Suggestions-none',
    suggestionsAvailable: 'ms-Suggestions-suggestionsAvailable',
    isSelected: 'is-selected'
};
function getStyles$U(props) {
    const { className, suggestionsClassName, theme, forceResolveButtonSelected, searchForMoreButtonSelected } = props;
    const { palette } = theme;
    const classNames = getGlobalClassNames(GlobalClassNames$z, theme);
    const actionButtonStyles = {
        background: 'none',
        backgroundColor: 'transparent',
        border: 0,
        cursor: 'pointer',
        margin: 0,
        paddingLeft: 8,
        position: 'relative',
        borderTop: `1px solid ${palette.neutralLight}`,
        height: 40,
        textAlign: 'left',
        width: '100%',
        fontSize: FontSizes.small,
        selectors: {
            ':hover': {
                backgroundColor: palette.neutralLight,
                cursor: 'pointer'
            },
            ':focus, :active': {
                backgroundColor: palette.themeLight
            },
            '.ms-Button-icon': {
                fontSize: FontSizes.icon,
                width: 25
            },
            '.ms-Button-label': {
                margin: '0 4px 0 9px'
            }
        }
    };
    const actionButtonSelectedStyles = {
        backgroundColor: palette.themeLight
    };
    return {
        root: [
            classNames.root,
            {
                minWidth: 260
            },
            className
        ],
        suggestionsContainer: [
            classNames.suggestionsContainer,
            {
                overflowY: 'auto',
                overflowX: 'hidden',
                maxHeight: 300,
                borderBottom: `1px solid ${palette.neutralLight}`
            },
            suggestionsClassName
        ],
        title: [
            classNames.title,
            {
                padding: '0 12px',
                fontSize: FontSizes.small,
                color: palette.themePrimary,
                lineHeight: 40,
                borderBottom: `1px solid ${palette.neutralLight}`
            }
        ],
        forceResolveButton: [
            classNames.forceResolveButton,
            actionButtonStyles,
            forceResolveButtonSelected && [classNames.isSelected, actionButtonSelectedStyles]
        ],
        searchForMoreButton: [
            classNames.searchForMoreButton,
            actionButtonStyles,
            searchForMoreButtonSelected && [classNames.isSelected, actionButtonSelectedStyles]
        ],
        noSuggestions: [
            classNames.noSuggestions,
            {
                textAlign: 'center',
                color: palette.neutralSecondary,
                fontSize: FontSizes.small,
                lineHeight: 30
            }
        ],
        suggestionsAvailable: [classNames.suggestionsAvailable, hiddenContentStyle],
        subComponentStyles: {
            spinner: {
                root: [
                    classNames.spinner,
                    {
                        margin: '5px 0',
                        paddingLeft: 14,
                        textAlign: 'left',
                        whiteSpace: 'nowrap',
                        lineHeight: 20,
                        fontSize: FontSizes.small
                    }
                ],
                circle: {
                    display: 'inline-block',
                    verticalAlign: 'middle'
                },
                label: {
                    display: 'inline-block',
                    verticalAlign: 'middle',
                    margin: '0 10px 0 16px'
                }
            }
        }
    };
}

/** Validation state of the user's input. */
var ValidationState;
(function (ValidationState) {
    /** User input is valid. */
    ValidationState[ValidationState["valid"] = 0] = "valid";
    /** User input could be valid or invalid, its state is not known yet. */
    ValidationState[ValidationState["warning"] = 1] = "warning";
    /** User input is invalid. */
    ValidationState[ValidationState["invalid"] = 2] = "invalid";
})(ValidationState || (ValidationState = {}));

// import * as stylesImport from './BasePicker.scss';
// const legacyStyles: any = stylesImport;
let legacyStyles$2;
const getClassNames$P = classNamesFunction();
class BasePicker extends BaseComponent {
    constructor(basePickerProps) {
        super(basePickerProps);
        // Refs
        this.root = createRef();
        this.input = createRef();
        this.focusZone = createRef();
        this.suggestionElement = createRef();
        this.SuggestionOfProperType = Suggestions;
        this.dismissSuggestions = (ev) => {
            const selectItemFunction = () => {
                if (this.props.onDismiss) {
                    this.props.onDismiss(ev, this.suggestionStore.currentSuggestion ? this.suggestionStore.currentSuggestion.item : undefined);
                }
                if (!ev || (ev && !ev.defaultPrevented)) {
                    // Select the first suggestion if one is available when user leaves.
                    if (this.canAddItems() && this.suggestionStore.hasSelectedSuggestion() && this.state.suggestedDisplayValue) {
                        this.addItemByIndex(0);
                    }
                }
            };
            if (this.currentPromise) {
                this.currentPromise.then(() => selectItemFunction());
            }
            else {
                selectItemFunction();
            }
            this.setState({ suggestionsVisible: false });
        };
        this.refocusSuggestions = (keyCode) => {
            this.resetFocus();
            if (this.suggestionStore.suggestions && this.suggestionStore.suggestions.length > 0) {
                if (keyCode === KeyCodes.up) {
                    this.suggestionStore.setSelectedSuggestion(this.suggestionStore.suggestions.length - 1);
                }
                else if (keyCode === KeyCodes.down) {
                    this.suggestionStore.setSelectedSuggestion(0);
                }
            }
        };
        this.onInputChange = (value) => {
            this.updateValue(value);
            this.setState({
                moreSuggestionsAvailable: true,
                isMostRecentlyUsedVisible: false
            });
        };
        this.onSuggestionClick = (ev, item, index) => {
            this.addItemByIndex(index);
            this.setState({ suggestionsVisible: false });
        };
        this.onSuggestionRemove = (ev, item, index) => {
            if (this.props.onRemoveSuggestion) {
                this.props.onRemoveSuggestion(item);
            }
            this.suggestionStore.removeSuggestion(index);
        };
        this.onInputFocus = (ev) => {
            // Only trigger all of the focus if this component isn't already focused.
            // For example when an item is selected or removed from the selected list it should be treated
            // as though the input is still focused.
            if (!this.state.isFocused) {
                this.setState({ isFocused: true });
                this.selection.setAllSelected(false);
                if (this.input.current && this.input.current.value === '' && this.props.onEmptyInputFocus) {
                    this.onEmptyInputFocus();
                    this.setState({
                        isMostRecentlyUsedVisible: true,
                        moreSuggestionsAvailable: false,
                        suggestionsVisible: true
                    });
                }
                else if (this.input.current && this.input.current.value) {
                    this.setState({
                        isMostRecentlyUsedVisible: false,
                        suggestionsVisible: true
                    });
                }
                if (this.props.inputProps && this.props.inputProps.onFocus) {
                    this.props.inputProps.onFocus(ev);
                }
            }
        };
        this.onInputBlur = (ev) => {
            if (this.props.inputProps && this.props.inputProps.onBlur) {
                this.props.inputProps.onBlur(ev);
            }
            // Only blur the entire component if an unrelated element gets focus. Otherwise treat it as though it still has focus.
            // Do nothing if the blur is coming from something
            // inside the comboBox root or the comboBox menu since
            // it we are not really bluring from the whole comboBox
            let relatedTarget = ev.relatedTarget;
            if (ev.relatedTarget === null) {
                // In IE11, due to lack of support, event.relatedTarget is always
                // null making every onBlur call to be "outside" of the ComboBox
                // even when it's not. Using document.activeElement is another way
                // for us to be able to get what the relatedTarget without relying
                // on the event
                relatedTarget = document.activeElement;
            }
            if (relatedTarget && !elementContains(this.root.current, relatedTarget)) {
                this.setState({ isFocused: false });
                if (this.props.onBlur) {
                    this.props.onBlur(ev);
                }
            }
        };
        this.onKeyDown = (ev) => {
            const keyCode = ev.which;
            switch (keyCode) {
                case KeyCodes.escape:
                    if (this.state.suggestionsVisible) {
                        this.setState({ suggestionsVisible: false });
                        ev.preventDefault();
                        ev.stopPropagation();
                    }
                    break;
                case KeyCodes.tab:
                case KeyCodes.enter:
                    if (this.suggestionElement.current && this.suggestionElement.current.hasSuggestedActionSelected()) {
                        this.suggestionElement.current.executeSelectedAction();
                    }
                    else if (!ev.shiftKey && this.suggestionStore.hasSelectedSuggestion() && this.state.suggestionsVisible) {
                        this.completeSuggestion();
                        ev.preventDefault();
                        ev.stopPropagation();
                    }
                    else {
                        this._onValidateInput();
                    }
                    break;
                case KeyCodes.backspace:
                    if (!this.props.disabled) {
                        this.onBackspace(ev);
                    }
                    ev.stopPropagation();
                    break;
                case KeyCodes.del:
                    if (!this.props.disabled) {
                        if (this.input.current &&
                            ev.target === this.input.current.inputElement &&
                            this.state.suggestionsVisible &&
                            this.suggestionStore.currentIndex !== -1) {
                            if (this.props.onRemoveSuggestion) {
                                this.props.onRemoveSuggestion(this.suggestionStore.currentSuggestion.item);
                            }
                            this.suggestionStore.removeSuggestion(this.suggestionStore.currentIndex);
                            this.forceUpdate();
                        }
                        else {
                            this.onBackspace(ev);
                        }
                    }
                    ev.stopPropagation();
                    break;
                case KeyCodes.up:
                    if (this.input.current && ev.target === this.input.current.inputElement && this.state.suggestionsVisible) {
                        if (this.suggestionElement.current &&
                            this.suggestionElement.current.tryHandleKeyDown(keyCode, this.suggestionStore.currentIndex)) {
                            ev.preventDefault();
                            ev.stopPropagation();
                        }
                        else {
                            if (this.suggestionElement.current &&
                                this.suggestionElement.current.hasSuggestedAction() &&
                                this.suggestionStore.currentIndex === 0) {
                                ev.preventDefault();
                                ev.stopPropagation();
                                this.suggestionElement.current.focusAboveSuggestions();
                                this.suggestionStore.deselectAllSuggestions();
                                this.forceUpdate();
                            }
                            else {
                                if (this.suggestionStore.previousSuggestion()) {
                                    ev.preventDefault();
                                    ev.stopPropagation();
                                    this.onSuggestionSelect();
                                }
                            }
                        }
                    }
                    break;
                case KeyCodes.down:
                    if (this.input.current && ev.target === this.input.current.inputElement && this.state.suggestionsVisible) {
                        if (this.suggestionElement.current &&
                            this.suggestionElement.current.tryHandleKeyDown(keyCode, this.suggestionStore.currentIndex)) {
                            ev.preventDefault();
                            ev.stopPropagation();
                        }
                        else {
                            if (this.suggestionElement.current &&
                                this.suggestionElement.current.hasSuggestedAction() &&
                                this.suggestionStore.currentIndex + 1 === this.suggestionStore.suggestions.length) {
                                ev.preventDefault();
                                ev.stopPropagation();
                                this.suggestionElement.current.focusBelowSuggestions();
                                this.suggestionStore.deselectAllSuggestions();
                                this.forceUpdate();
                            }
                            else {
                                if (this.suggestionStore.nextSuggestion()) {
                                    ev.preventDefault();
                                    ev.stopPropagation();
                                    this.onSuggestionSelect();
                                }
                            }
                        }
                    }
                    break;
            }
        };
        this.onItemChange = (changedItem, index) => {
            const { items } = this.state;
            if (index >= 0) {
                const newItems = items;
                newItems[index] = changedItem;
                this._updateSelectedItems(newItems);
            }
        };
        this.onGetMoreResults = () => {
            this.setState({
                isSearching: true
            }, () => {
                if (this.props.onGetMoreResults && this.input.current) {
                    const suggestions = this.props.onGetMoreResults(this.input.current.value, this.state.items);
                    const suggestionsArray = suggestions;
                    const suggestionsPromiseLike = suggestions;
                    if (Array.isArray(suggestionsArray)) {
                        this.updateSuggestions(suggestionsArray);
                        this.setState({ isSearching: false });
                    }
                    else if (suggestionsPromiseLike.then) {
                        suggestionsPromiseLike.then((newSuggestions) => {
                            this.updateSuggestions(newSuggestions);
                            this.setState({ isSearching: false });
                        });
                    }
                }
                else {
                    this.setState({ isSearching: false });
                }
                if (this.input.current) {
                    this.input.current.focus();
                }
                this.setState({
                    moreSuggestionsAvailable: false,
                    isResultsFooterVisible: true
                });
            });
        };
        this.addItemByIndex = (index) => {
            this.addItem(this.suggestionStore.getSuggestionAtIndex(index).item);
            if (this.input.current) {
                this.input.current.clear();
            }
            this.updateValue('');
        };
        this.addItem = (item) => {
            const processedItem = this.props.onItemSelected ? this.props.onItemSelected(item) : item;
            if (processedItem === null) {
                return;
            }
            const processedItemObject = processedItem;
            const processedItemPromiseLike = processedItem;
            if (processedItemPromiseLike && processedItemPromiseLike.then) {
                processedItemPromiseLike.then((resolvedProcessedItem) => {
                    const newItems = this.state.items.concat([resolvedProcessedItem]);
                    this._updateSelectedItems(newItems);
                });
            }
            else {
                const newItems = this.state.items.concat([processedItemObject]);
                this._updateSelectedItems(newItems);
            }
            this.setState({ suggestedDisplayValue: '' });
        };
        this.removeItem = (item, focusNextItem) => {
            const { items } = this.state;
            const index = items.indexOf(item);
            if (index >= 0) {
                const newItems = items.slice(0, index).concat(items.slice(index + 1));
                this._updateSelectedItems(newItems, focusNextItem ? index : undefined);
            }
        };
        this.removeItems = (itemsToRemove) => {
            const { items } = this.state;
            const newItems = items.filter((item) => itemsToRemove.indexOf(item) === -1);
            const firstItemToRemove = itemsToRemove[0];
            const index = items.indexOf(firstItemToRemove);
            this._updateSelectedItems(newItems, index);
        };
        this._isFocusZoneInnerKeystroke = (ev) => {
            // If suggestions are shown const up/down keys control them, otherwise allow them through to control the focusZone.
            if (this.state.suggestionsVisible) {
                switch (ev.which) {
                    case KeyCodes.up:
                    case KeyCodes.down:
                        return true;
                }
            }
            if (ev.which === KeyCodes.enter) {
                return true;
            }
            return false;
        };
        const items = basePickerProps.selectedItems || basePickerProps.defaultSelectedItems || [];
        this._id = getId();
        this._ariaMap = {
            selectedItems: `selected-items-${this._id}`,
            selectedSuggestionAlert: `selected-suggestion-alert-${this._id}`,
            suggestionList: `suggestion-list-${this._id}`
        };
        this.suggestionStore = new SuggestionsController();
        this.selection = new Selection({ onSelectionChanged: () => this.onSelectionChange() });
        this.selection.setItems(items);
        this.state = {
            items: items,
            suggestedDisplayValue: '',
            isMostRecentlyUsedVisible: false,
            moreSuggestionsAvailable: false,
            isFocused: false,
            isSearching: false,
            selectedIndices: []
        };
    }
    get items() {
        return this.state.items;
    }
    componentWillUpdate(newProps, newState) {
        if (newState.items && newState.items !== this.state.items) {
            this.selection.setItems(newState.items);
        }
    }
    componentDidMount() {
        this.selection.setItems(this.state.items);
        this._onResolveSuggestions = this._async.debounce(this._onResolveSuggestions, this.props.resolveDelay);
    }
    componentWillReceiveProps(newProps) {
        const newItems = newProps.selectedItems;
        if (newItems) {
            let focusIndex;
            // If there are less new items than old items then something was removed and we
            // should try to keep focus consistent
            if (newItems.length < this.state.items.length) {
                focusIndex = this.state.items.indexOf(this.selection.getSelection()[0]);
            }
            this.setState({
                items: newProps.selectedItems
            }, () => {
                // Only update the focus if this component is currently focused to ensure that the basepicker
                // doesn't steal focus from something else.
                if (this.state.isFocused) {
                    // Need to reset focus in the same that way that we do if an item is selected by a non-controlled component
                    // See _onSelectedItemsUpdated.
                    this.resetFocus(focusIndex);
                }
            });
        }
    }
    componentWillUnmount() {
        super.componentWillUnmount();
        if (this.currentPromise) {
            this.currentPromise = undefined;
        }
    }
    focus() {
        if (this.focusZone.current) {
            this.focusZone.current.focus();
        }
    }
    focusInput() {
        if (this.input.current) {
            this.input.current.focus();
        }
    }
    completeSuggestion() {
        if (this.suggestionStore.hasSelectedSuggestion() && this.input.current) {
            this.addItem(this.suggestionStore.currentSuggestion.item);
            this.updateValue('');
            this.input.current.clear();
        }
    }
    render() {
        const { suggestedDisplayValue, isFocused } = this.state;
        const { className, inputProps, disabled, theme, styles } = this.props;
        const selectedSuggestionAlertId = this.props.enableSelectedSuggestionAlert ? this._ariaMap.selectedSuggestionAlert : '';
        const suggestionsAvailable = this.state.suggestionsVisible ? this._ariaMap.suggestionList : '';
        // TODO
        // Clean this up by leaving only the first part after removing support for SASS.
        // Currently we can not remove the SASS styles from BasePicker class because it
        // might be used by consumers who created custom pickers from extending from
        // this base class and have not used the new 'styles' prop.
        // We check for 'styles' prop which is going to be injected by the 'styled' HOC
        // for every other already existing picker variant (PeoplePicker, TagPicker)
        // so that we can use the CSS-in-JS styles. If the check fails (ex: custom picker),
        // then we just use the old SASS styles instead.
        const classNames = styles
            ? getClassNames$P(styles, {
                theme,
                className,
                isFocused,
                inputClassName: inputProps && inputProps.className
            })
            : {
                root: css('ms-BasePicker', className ? className : ''),
                text: css('ms-BasePicker-text', legacyStyles$2.pickerText, this.state.isFocused && legacyStyles$2.inputFocused),
                itemsWrapper: legacyStyles$2.pickerItems,
                input: css('ms-BasePicker-input', legacyStyles$2.pickerInput, inputProps && inputProps.className),
                screenReaderText: legacyStyles$2.screenReaderOnly
            };
        return (createElement("div", { ref: this.root, className: classNames.root, onKeyDown: this.onKeyDown },
            createElement(FocusZone, { componentRef: this.focusZone, direction: FocusZoneDirection.bidirectional, isInnerZoneKeystroke: this._isFocusZoneInnerKeystroke },
                this.getSuggestionsAlert(classNames.screenReaderText),
                createElement(SelectionZone, { selection: this.selection, selectionMode: SelectionMode.multiple },
                    createElement("div", { className: classNames.text },
                        createElement("span", { id: this._ariaMap.selectedItems, className: classNames.itemsWrapper, role: 'list' }, this.renderItems()),
                        this.canAddItems() && (createElement(Autofill, Object.assign({ spellCheck: false }, inputProps, { className: classNames.input, componentRef: this.input, onFocus: this.onInputFocus, onBlur: this.onInputBlur, onInputValueChange: this.onInputChange, suggestedDisplayValue: suggestedDisplayValue, "aria-activedescendant": this.getActiveDescendant(), "aria-expanded": !!this.state.suggestionsVisible, "aria-haspopup": "true", "aria-describedby": this._ariaMap.selectedItems, autoCapitalize: "off", autoComplete: "off", role: 'combobox', disabled: disabled, "aria-controls": `${suggestionsAvailable} ${selectedSuggestionAlertId}` || undefined, "aria-owns": suggestionsAvailable || undefined, "aria-autocomplete": 'both', onInputChange: this.props.onInputChange })))))),
            this.renderSuggestions()));
    }
    canAddItems() {
        const { items } = this.state;
        const { itemLimit } = this.props;
        return itemLimit === undefined || items.length < itemLimit;
    }
    renderSuggestions() {
        const TypedSuggestions = this.SuggestionOfProperType;
        // TODO:
        // Move this styled component in a separate file and make it available to the public API.
        // This should be done after rewriting pickers to use a composition pattern instead of inheritance.
        const StyledTypedSuggestions = styled(TypedSuggestions, getStyles$U, undefined, { scope: 'Suggestions' });
        return this.state.suggestionsVisible && this.input ? (createElement(Callout, Object.assign({ isBeakVisible: false, gapSpace: 5, target: this.input.current ? this.input.current.inputElement : undefined, onDismiss: this.dismissSuggestions, directionalHint: DirectionalHint.bottomLeftEdge, directionalHintForRTL: DirectionalHint.bottomRightEdge }, this.props.pickerCalloutProps),
            createElement(StyledTypedSuggestions, Object.assign({ onRenderSuggestion: this.props.onRenderSuggestionsItem, onSuggestionClick: this.onSuggestionClick, onSuggestionRemove: this.onSuggestionRemove, suggestions: this.suggestionStore.getSuggestions(), componentRef: this.suggestionElement, onGetMoreResults: this.onGetMoreResults, moreSuggestionsAvailable: this.state.moreSuggestionsAvailable, isLoading: this.state.suggestionsLoading, isSearching: this.state.isSearching, isMostRecentlyUsedVisible: this.state.isMostRecentlyUsedVisible, isResultsFooterVisible: this.state.isResultsFooterVisible, refocusSuggestions: this.refocusSuggestions, removeSuggestionAriaLabel: this.props.removeButtonAriaLabel, suggestionsListId: this._ariaMap.suggestionList }, this.props.pickerSuggestionsProps)))) : null;
    }
    renderItems() {
        const { disabled, removeButtonAriaLabel } = this.props;
        const onRenderItem = this.props.onRenderItem;
        const { items, selectedIndices } = this.state;
        return items.map((item, index) => onRenderItem({
            item,
            index,
            key: item.key ? item.key : index,
            selected: selectedIndices.indexOf(index) !== -1,
            onRemoveItem: () => this.removeItem(item, true),
            disabled: disabled,
            onItemChange: this.onItemChange,
            removeButtonAriaLabel: removeButtonAriaLabel
        }));
    }
    resetFocus(index) {
        const { items } = this.state;
        if (items.length && index >= 0) {
            const newEl = this.root.current &&
                this.root.current.querySelectorAll('[data-selection-index]')[Math.min(index, items.length - 1)];
            if (newEl && this.focusZone.current) {
                this.focusZone.current.focusElement(newEl);
            }
        }
        else if (!this.canAddItems()) {
            this.resetFocus(items.length - 1);
        }
        else {
            if (this.input.current) {
                this.input.current.focus();
            }
        }
    }
    onSuggestionSelect() {
        if (this.suggestionStore.currentSuggestion) {
            const currentValue = this.input.current ? this.input.current.value : '';
            const itemValue = this._getTextFromItem(this.suggestionStore.currentSuggestion.item, currentValue);
            this.setState({ suggestedDisplayValue: itemValue });
        }
    }
    onSelectionChange() {
        this.setState({
            selectedIndices: this.selection.getSelectedIndices()
        });
    }
    updateSuggestions(suggestions) {
        this.suggestionStore.updateSuggestions(suggestions, 0);
        this.forceUpdate();
    }
    onEmptyInputFocus() {
        const onEmptyInputFocus = this.props.onEmptyInputFocus;
        const suggestions = onEmptyInputFocus(this.state.items);
        this.updateSuggestionsList(suggestions);
    }
    updateValue(updatedValue) {
        this._onResolveSuggestions(updatedValue);
    }
    updateSuggestionsList(suggestions, updatedValue) {
        const suggestionsArray = suggestions;
        const suggestionsPromiseLike = suggestions;
        // Check to see if the returned value is an array, if it is then just pass it into the next function .
        // If the returned value is not an array then check to see if it's a promise or PromiseLike. If it is then resolve it asynchronously.
        if (Array.isArray(suggestionsArray)) {
            this._updateAndResolveValue(updatedValue, suggestionsArray);
        }
        else if (suggestionsPromiseLike && suggestionsPromiseLike.then) {
            this.setState({
                suggestionsLoading: true
            });
            // Clear suggestions
            this.suggestionStore.updateSuggestions([]);
            if (updatedValue !== undefined) {
                this.setState({
                    suggestionsVisible: this.input.current
                        ? this.input.current.value !== '' && this.input.current.inputElement === document.activeElement
                        : false
                });
            }
            else {
                this.setState({
                    suggestionsVisible: this.input.current ? this.input.current.inputElement === document.activeElement : false
                });
            }
            // Ensure that the promise will only use the callback if it was the most recent one.
            const promise = (this.currentPromise = suggestionsPromiseLike);
            promise.then((newSuggestions) => {
                if (promise === this.currentPromise) {
                    this._updateAndResolveValue(updatedValue, newSuggestions);
                }
            });
        }
    }
    resolveNewValue(updatedValue, suggestions) {
        this.updateSuggestions(suggestions);
        let itemValue = undefined;
        if (this.suggestionStore.currentSuggestion) {
            itemValue = this._getTextFromItem(this.suggestionStore.currentSuggestion.item, updatedValue);
        }
        // Only set suggestionloading to false after there has been time for the new suggestions to flow
        // to the suggestions list. This is to ensure that the suggestions are available before aria-activedescendant
        // is set so that screen readers will read out the first selected option.
        this.setState({
            suggestedDisplayValue: itemValue,
            suggestionsVisible: this.input.current
                ? this.input.current.value !== '' && this.input.current.inputElement === document.activeElement
                : false
        }, () => this.setState({ suggestionsLoading: false }));
    }
    onChange(items) {
        if (this.props.onChange) {
            this.props.onChange(items);
        }
    }
    // This is protected because we may expect the backspace key to work differently in a different kind of picker.
    // This lets the subclass override it and provide it's own onBackspace. For an example see the BasePickerListBelow
    onBackspace(ev) {
        if ((this.state.items.length && !this.input.current) ||
            (this.input.current && (!this.input.current.isValueSelected && this.input.current.cursorLocation === 0))) {
            if (this.selection.getSelectedCount() > 0) {
                this.removeItems(this.selection.getSelection());
            }
            else {
                this.removeItem(this.state.items[this.state.items.length - 1]);
            }
        }
    }
    getActiveDescendant() {
        const currentIndex = this.suggestionStore.currentIndex;
        return currentIndex > -1 && !this.state.suggestionsLoading ? 'sug-' + currentIndex : undefined;
    }
    getSuggestionsAlert(suggestionAlertClassName = legacyStyles$2.screenReaderOnly) {
        const currentIndex = this.suggestionStore.currentIndex;
        if (this.props.enableSelectedSuggestionAlert) {
            const selectedSuggestion = currentIndex > -1 ? this.suggestionStore.getSuggestionAtIndex(this.suggestionStore.currentIndex) : undefined;
            const selectedSuggestionAlertText = selectedSuggestion ? selectedSuggestion.ariaLabel : undefined;
            return (createElement("div", { className: suggestionAlertClassName, role: "alert", id: this._ariaMap.selectedSuggestionAlert, "aria-live": "assertive" },
                selectedSuggestionAlertText,
                ' '));
        }
    }
    /**
     * Takes in the current updated value and either resolves it with the new suggestions
     * or if updated value is undefined then it clears out currently suggested items
     */
    _updateAndResolveValue(updatedValue, newSuggestions) {
        if (updatedValue !== undefined) {
            this.resolveNewValue(updatedValue, newSuggestions);
        }
        else {
            this.suggestionStore.updateSuggestions(newSuggestions, -1);
            if (this.state.suggestionsLoading) {
                this.setState({
                    suggestionsLoading: false
                });
            }
        }
    }
    /**
     * Controls what happens whenever there is an action that impacts the selected items.
     * If selectedItems is provided as a property then this will act as a controlled component and it will not update it's own state.
     */
    _updateSelectedItems(items, focusIndex) {
        if (this.props.selectedItems) {
            // If the component is a controlled component then the controlling component will need to add or remove the items.
            this.onChange(items);
        }
        else {
            this.setState({ items: items }, () => {
                this._onSelectedItemsUpdated(items, focusIndex);
            });
        }
    }
    _onSelectedItemsUpdated(items, focusIndex) {
        this.resetFocus(focusIndex);
        this.onChange(items);
    }
    _onResolveSuggestions(updatedValue) {
        const suggestions = this.props.onResolveSuggestions(updatedValue, this.state.items);
        if (suggestions !== null) {
            this.updateSuggestionsList(suggestions, updatedValue);
        }
    }
    _onValidateInput() {
        if (this.props.onValidateInput &&
            this.input.current &&
            this.props.onValidateInput(this.input.current.value) !== ValidationState.invalid &&
            this.props.createGenericItem) {
            const itemToConvert = this.props.createGenericItem(this.input.current.value, this.props.onValidateInput(this.input.current.value));
            this.suggestionStore.createGenericSuggestion(itemToConvert);
            this.completeSuggestion();
        }
    }
    _getTextFromItem(item, currentValue) {
        if (this.props.getTextFromItem) {
            return this.props.getTextFromItem(item, currentValue);
        }
        else {
            return '';
        }
    }
}
class BasePickerListBelow extends BasePicker {
    render() {
        const { suggestedDisplayValue, isFocused } = this.state;
        const { className, inputProps, disabled, theme, styles } = this.props;
        const selectedSuggestionAlertId = this.props.enableSelectedSuggestionAlert
            ? this._ariaMap.selectedSuggestionAlert
            : '';
        const suggestionsAvailable = this.state.suggestionsVisible ? this._ariaMap.suggestionList : '';
        // TODO
        // Clean this up by leaving only the first part after removing support for SASS.
        // Currently we can not remove the SASS styles from BasePicker class because it
        // might be used by consumers who created custom pickers from extending from
        // this base class and have not used the new 'styles' prop.
        // We check for 'styles' prop which is going to be injected by the 'styled' HOC
        // for every other already existing picker variant (PeoplePicker, TagPicker)
        // so that we can use the CSS-in-JS styles. If the check fails (ex: custom picker),
        // then we just use the old SASS styles instead.
        const classNames = styles
            ? getClassNames$P(styles, {
                theme,
                className,
                isFocused,
                inputClassName: inputProps && inputProps.className
            })
            : {
                root: css('ms-BasePicker', className ? className : ''),
                text: css('ms-BasePicker-text', legacyStyles$2.pickerText, this.state.isFocused && legacyStyles$2.inputFocused),
                input: css('ms-BasePicker-input', legacyStyles$2.pickerInput, inputProps && inputProps.className),
                screenReaderText: legacyStyles$2.screenReaderOnly
            };
        return (createElement("div", { ref: this.root },
            createElement("div", { className: classNames.root, onKeyDown: this.onKeyDown },
                this.getSuggestionsAlert(classNames.screenReaderText),
                createElement("div", { className: classNames.text },
                    createElement(Autofill, Object.assign({}, inputProps, { className: classNames.input, componentRef: this.input, onFocus: this.onInputFocus, onBlur: this.onInputBlur, onInputValueChange: this.onInputChange, suggestedDisplayValue: suggestedDisplayValue, "aria-activedescendant": this.getActiveDescendant(), "aria-expanded": !!this.state.suggestionsVisible, "aria-haspopup": "true", autoCapitalize: "off", autoComplete: "off", role: "combobox", disabled: disabled, "aria-controls": `${suggestionsAvailable} ${selectedSuggestionAlertId}` || undefined, "aria-owns": suggestionsAvailable || undefined, onInputChange: this.props.onInputChange })))),
            this.renderSuggestions(),
            createElement(SelectionZone, { selection: this.selection, selectionMode: SelectionMode.single },
                createElement(FocusZone, { componentRef: this.focusZone, className: "ms-BasePicker-selectedItems" // just a className hook without any styles applied to it.
                    , isCircularNavigation: true, direction: FocusZoneDirection.bidirectional, isInnerZoneKeystroke: this._isFocusZoneInnerKeystroke, id: this._ariaMap.selectedItems }, this.renderItems()))));
    }
    onBackspace(ev) {
        // override the existing backspace method to not do anything because the list items appear below.
    }
}

const GlobalClassNames$A = {
    root: 'ms-PickerPersona-container',
    itemContent: 'ms-PickerItem-content',
    removeButton: 'ms-PickerItem-removeButton',
    isSelected: 'is-selected',
    isInvalid: 'is-invalid'
};
const REMOVE_BUTTON_SIZE = 28;
function getStyles$V(props) {
    const { className, theme, selected, invalid } = props;
    const { palette } = theme;
    const classNames = getGlobalClassNames(GlobalClassNames$A, theme);
    const personaPrimaryTextStyles = [
        selected &&
            !invalid && {
            color: palette.white,
            selectors: {
                [HighContrastSelector]: {
                    color: 'HighlightText'
                }
            }
        },
        invalid &&
            !selected && {
            color: palette.redDark,
            borderBottom: `2px dotted ${palette.redDark}`,
            selectors: {
                '$root:hover &': {
                    // override Persona root:hover selector
                    color: palette.redDark
                }
            }
        },
        invalid &&
            selected && {
            color: palette.white,
            borderBottom: `2px dotted ${palette.white}`
        }
    ];
    const personaCoinInitialsStyles = [
        invalid && {
            fontSize: 20 // does not exist on the FontSizes type ramp.
        }
    ];
    return {
        root: [
            classNames.root,
            getFocusStyle(theme, -2),
            {
                borderRadius: 15,
                display: 'inline-flex',
                alignItems: 'center',
                background: palette.neutralLighter,
                margin: '1px 2px',
                cursor: 'default',
                userSelect: 'none',
                maxWidth: 300,
                verticalAlign: 'middle',
                selectors: {
                    ':hover': {
                        background: !selected ? palette.neutralLight : ''
                    },
                    [HighContrastSelector]: {
                        border: '1px solid WindowText'
                    }
                }
            },
            selected && [
                classNames.isSelected,
                {
                    background: palette.themePrimary,
                    selectors: {
                        [HighContrastSelector]: {
                            borderColor: 'HighLight',
                            background: 'Highlight',
                            MsHighContrastAdjust: 'none'
                        }
                    }
                }
            ],
            invalid && [classNames.isInvalid],
            invalid &&
                selected && {
                background: palette.redDark
            },
            className
        ],
        itemContent: [
            classNames.itemContent,
            {
                flex: '0 1 auto',
                minWidth: 0,
                // CSS below is needed for IE 11 to properly truncate long persona names in the picker
                // and to clip the presence indicator (in all browsers)
                maxWidth: '100%',
                overflow: 'hidden'
            }
        ],
        removeButton: [
            classNames.removeButton,
            {
                borderRadius: 15,
                flex: '0 0 auto',
                width: REMOVE_BUTTON_SIZE,
                height: REMOVE_BUTTON_SIZE,
                flexBasis: REMOVE_BUTTON_SIZE,
                selectors: {
                    ':hover': {
                        background: palette.neutralTertiaryAlt,
                        color: palette.neutralDark
                    }
                }
            },
            selected && [
                {
                    color: palette.white,
                    selectors: {
                        ':hover': {
                            color: palette.white,
                            background: palette.themeDark
                        },
                        [HighContrastSelector]: {
                            color: 'HighlightText'
                        }
                    }
                },
                invalid && {
                    selectors: {
                        ':hover': {
                            background: palette.red
                        }
                    }
                }
            ]
        ],
        subComponentStyles: {
            persona: {
                primaryText: personaPrimaryTextStyles
            },
            personaCoin: {
                initials: personaCoinInitialsStyles
            }
        }
    };
}

const getClassNames$Q = classNamesFunction();
const PeoplePickerItemBase = (props) => {
    const { item, onRemoveItem, index, selected, removeButtonAriaLabel, styles, theme, className } = props;
    const itemId = getId();
    const classNames = getClassNames$Q(styles, {
        theme: theme,
        className,
        selected,
        invalid: item.ValidationState === ValidationState.warning
    });
    const personaStyles = classNames.subComponentStyles
        ? classNames.subComponentStyles.persona
        : undefined;
    const personaCoinStyles = classNames.subComponentStyles
        ? classNames.subComponentStyles.personaCoin
        : undefined;
    return (createElement("div", { className: classNames.root, "data-is-focusable": true, "data-is-sub-focuszone": true, "data-selection-index": index, role: 'listitem', "aria-labelledby": 'selectedItemPersona-' + itemId },
        createElement("div", { className: classNames.itemContent, id: 'selectedItemPersona-' + itemId },
            createElement(Persona, Object.assign({ size: PersonaSize.size28, styles: personaStyles, coinProps: { styles: personaCoinStyles } }, item))),
        createElement(IconButton, { onClick: onRemoveItem, iconProps: { iconName: 'Cancel', styles: { root: { fontSize: '12px' } } }, className: classNames.removeButton, ariaLabel: removeButtonAriaLabel })));
};
const PeoplePickerItem = styled(PeoplePickerItemBase, getStyles$V, undefined, { scope: 'PeoplePickerItem' });

const GlobalClassNames$B = {
    root: 'ms-PeoplePicker-personaContent',
    personaWrapper: 'ms-PeoplePicker-Persona'
};
function getStyles$W(props) {
    const { className, theme } = props;
    const classNames = getGlobalClassNames(GlobalClassNames$B, theme);
    return {
        root: [
            classNames.root,
            {
                width: '100%',
                padding: '7px 12px'
            },
            className
        ],
        personaWrapper: [
            classNames.personaWrapper,
            {
                width: 180
            }
        ]
    };
}

const getClassNames$R = classNamesFunction();
const PeoplePickerItemSuggestionBase = (props) => {
    const { personaProps, suggestionsProps, compact, styles, theme, className } = props;
    const classNames = getClassNames$R(styles, {
        theme: theme,
        className: (suggestionsProps && suggestionsProps.suggestionsItemClassName) || className
    });
    return (createElement("div", { className: classNames.root },
        createElement(Persona, Object.assign({ size: PersonaSize.size24, className: classNames.personaWrapper, showSecondaryText: !compact }, personaProps))));
};
const PeoplePickerItemSuggestion = styled(PeoplePickerItemSuggestionBase, getStyles$W, undefined, { scope: 'PeoplePickerItemSuggestion' });

const GlobalClassNames$C = {
    root: 'ms-BasePicker',
    text: 'ms-BasePicker-text',
    itemsWrapper: 'ms-BasePicker-itemsWrapper',
    input: 'ms-BasePicker-input'
};
function getStyles$X(props) {
    const { className, theme, isFocused, inputClassName } = props;
    if (!theme) {
        throw new Error('theme is undefined or null in base BasePicker getStyles function.');
    }
    const { semanticColors } = theme;
    const { inputBorder, inputBorderHovered, inputFocusBorderAlt } = semanticColors;
    const classNames = getGlobalClassNames(GlobalClassNames$C, theme);
    return {
        root: [classNames.root, className],
        text: [
            classNames.text,
            {
                display: 'flex',
                flexWrap: 'wrap',
                alignItems: 'center',
                boxSizing: 'border-box',
                minWidth: 180,
                minHeight: 30,
                border: `1px solid ${inputBorder}`
            },
            !isFocused && {
                selectors: {
                    ':hover': {
                        borderColor: inputBorderHovered
                    }
                }
            },
            isFocused && {
                borderColor: inputFocusBorderAlt
            }
        ],
        itemsWrapper: [
            classNames.itemsWrapper,
            {
                display: 'flex',
                flexWrap: 'wrap'
            }
        ],
        input: [
            classNames.input,
            {
                height: 34,
                border: 'none',
                flexGrow: 1,
                outline: 'none',
                padding: '0 6px 0',
                alignSelf: 'flex-end'
            },
            inputClassName
        ],
        screenReaderText: hiddenContentStyle
    };
}

class BasePeoplePicker extends BasePicker {
}
class MemberListPeoplePicker extends BasePickerListBelow {
}
/**
 * Standard People Picker.
 */
class NormalPeoplePickerBase extends BasePeoplePicker {
}
/** Default props for NormalPeoplePicker. */
NormalPeoplePickerBase.defaultProps = {
    onRenderItem: (props) => createElement(PeoplePickerItem, Object.assign({}, props)),
    onRenderSuggestionsItem: (personaProps, suggestionsProps) => (createElement(PeoplePickerItemSuggestion, { personaProps: personaProps, suggestionsProps: suggestionsProps })),
    createGenericItem: createGenericItem
};
/**
 * Compact layout. It uses personas without secondary text when displaying search results.
 */
class CompactPeoplePickerBase extends BasePeoplePicker {
}
/** Default props for CompactPeoplePicker. */
CompactPeoplePickerBase.defaultProps = {
    onRenderItem: (props) => createElement(PeoplePickerItem, Object.assign({}, props)),
    onRenderSuggestionsItem: (personaProps, suggestionsProps) => (createElement(PeoplePickerItemSuggestion, { personaProps: personaProps, suggestionsProps: suggestionsProps, compact: true })),
    createGenericItem: createGenericItem
};
/**
 * MemberList layout. The selected people show up below the search box.
 */
class ListPeoplePickerBase extends MemberListPeoplePicker {
}
/** Default props for ListPeoplePicker. */
ListPeoplePickerBase.defaultProps = {
    onRenderItem: (props) => createElement(PeoplePickerItem, Object.assign({}, props)),
    onRenderSuggestionsItem: (personaProps, suggestionsProps) => (createElement(PeoplePickerItemSuggestion, { personaProps: personaProps, suggestionsProps: suggestionsProps })),
    createGenericItem: createGenericItem
};
function createGenericItem(name, currentValidationState) {
    const personaToConvert = {
        key: name,
        primaryText: name,
        imageInitials: '!',
        ValidationState: currentValidationState
    };
    if (currentValidationState !== ValidationState.warning) {
        personaToConvert.imageInitials = getInitials(name, getRTL());
    }
    return personaToConvert;
}
const NormalPeoplePicker = styled(NormalPeoplePickerBase, getStyles$X, undefined, {
    scope: 'NormalPeoplePicker'
});
const CompactPeoplePicker = styled(CompactPeoplePickerBase, getStyles$X, undefined, {
    scope: 'CompactPeoplePicker'
});
const ListPeoplePicker = styled(ListPeoplePickerBase, getStyles$X, undefined, {
    scope: 'ListPeoplePickerBase'
});

const GlobalClassNames$D = {
    root: 'ms-TagItem',
    text: 'ms-TagItem-text',
    close: 'ms-TagItem-close',
    isSelected: 'is-selected'
};
const TAG_HEIGHT = 26;
function getStyles$Y(props) {
    const { className, theme, selected } = props;
    const { palette } = theme;
    const classNames = getGlobalClassNames(GlobalClassNames$D, theme);
    return {
        root: [
            classNames.root,
            getFocusStyle(theme),
            {
                boxSizing: 'content-box',
                flexShrink: '1',
                margin: 2,
                height: TAG_HEIGHT,
                lineHeight: TAG_HEIGHT,
                cursor: 'default',
                userSelect: 'none',
                display: 'flex',
                flexWrap: 'nowrap',
                maxWidth: 300,
                background: !selected ? palette.neutralLighter : palette.neutralQuaternary,
                selectors: {
                    ':hover': {
                        background: !selected ? palette.neutralLight : palette.neutralQuaternaryAlt
                    },
                    [HighContrastSelector]: {
                        border: `1px solid ${!selected ? 'WindowText' : 'WindowFrame'}`
                    }
                }
            },
            selected && [classNames.isSelected],
            className
        ],
        text: [
            classNames.text,
            {
                overflow: 'hidden',
                textOverflow: 'ellipsis',
                whiteSpace: 'nowrap',
                minWidth: 30,
                margin: '0 8px'
            }
        ],
        close: [
            classNames.close,
            {
                cursor: 'pointer',
                color: palette.neutralSecondary,
                fontSize: FontSizes.small,
                display: 'inline-block',
                textAlign: 'center',
                verticalAlign: 'top',
                width: 30,
                height: '100%',
                flexShrink: 0
            }
        ]
    };
}

const getClassNames$S = classNamesFunction();
const TagItemBase = (props) => {
    const { theme, styles, selected, disabled, enableTagFocusInDisabledPicker, children, className, index, onRemoveItem } = props;
    const classNames = getClassNames$S(styles, {
        theme: theme,
        className,
        selected
    });
    return (createElement("div", { className: classNames.root, role: 'listitem', key: index, "data-selection-index": index, "data-is-focusable": (enableTagFocusInDisabledPicker || !disabled) && true },
        createElement("span", { className: classNames.text, "aria-label": children }, children),
        !disabled && (createElement("span", { className: classNames.close, onClick: onRemoveItem },
            createElement(Icon, { iconName: "Cancel" })))));
};
const TagItem = styled(TagItemBase, getStyles$Y, undefined, { scope: 'TagItem' });

const GlobalClassNames$E = {
    suggestionTextOverflow: 'ms-TagItem-TextOverflow'
};
function getStyles$Z(props) {
    const { className, theme } = props;
    const classNames = getGlobalClassNames(GlobalClassNames$E, theme);
    return {
        suggestionTextOverflow: [
            classNames.suggestionTextOverflow,
            {
                overflow: 'hidden',
                textOverflow: 'ellipsis',
                maxWidth: '60vw',
                padding: '7px 12px'
            },
            className
        ]
    };
}

const getClassNames$T = classNamesFunction();
const TagItemSuggestionBase = (props) => {
    const { styles, theme, children } = props;
    const classNames = getClassNames$T(styles, {
        theme: theme
    });
    return createElement("div", { className: classNames.suggestionTextOverflow },
        " ",
        children,
        " ");
};
const TagItemSuggestion = styled(TagItemSuggestionBase, getStyles$Z, undefined, { scope: 'TagItemSuggestion' });

/* tslint:disable */
class TagPickerBase extends BasePicker {
}
TagPickerBase.defaultProps = {
    onRenderItem: (props) => createElement(TagItem, Object.assign({}, props), props.item.name),
    onRenderSuggestionsItem: (props) => createElement(TagItemSuggestion, null, props.name)
};
const TagPicker = styled(TagPickerBase, getStyles$X, undefined, {
    scope: 'TagPicker'
});

// import * as stylesImport from './SuggestionsCore.scss';
// const styles: any = stylesImport;
let styles$j;
/**
 * Class when used with SuggestionsStore, renders a basic suggestions control
 */
class SuggestionsCore extends BaseComponent {
    constructor(suggestionsProps) {
        super(suggestionsProps);
        this.SuggestionsItemOfProperType = SuggestionsItem;
        this.currentIndex = -1;
    }
    /**
     * Increments the selected suggestion index
     */
    nextSuggestion() {
        const { suggestions } = this.props;
        if (suggestions && suggestions.length > 0) {
            if (this.currentIndex === -1) {
                this.setSelectedSuggestion(0);
                return true;
            }
            else if (this.currentIndex < suggestions.length - 1) {
                this.setSelectedSuggestion(this.currentIndex + 1);
                return true;
            }
            else if (this.props.shouldLoopSelection && this.currentIndex === suggestions.length - 1) {
                this.setSelectedSuggestion(0);
                return true;
            }
        }
        return false;
    }
    /**
     * Decrements the selected suggestion index
     */
    previousSuggestion() {
        const { suggestions } = this.props;
        if (suggestions && suggestions.length > 0) {
            if (this.currentIndex === -1) {
                this.setSelectedSuggestion(suggestions.length - 1);
                return true;
            }
            else if (this.currentIndex > 0) {
                this.setSelectedSuggestion(this.currentIndex - 1);
                return true;
            }
            else if (this.props.shouldLoopSelection && this.currentIndex === 0) {
                this.setSelectedSuggestion(suggestions.length - 1);
                return true;
            }
        }
        return false;
    }
    get selectedElement() {
        return this._selectedElement;
    }
    getCurrentItem() {
        return this.props.suggestions[this.currentIndex];
    }
    getSuggestionAtIndex(index) {
        return this.props.suggestions[index];
    }
    hasSuggestionSelected() {
        return this.currentIndex !== -1 && this.currentIndex < this.props.suggestions.length;
    }
    removeSuggestion(index) {
        this.props.suggestions.splice(index, 1);
    }
    deselectAllSuggestions() {
        if (this.currentIndex > -1 && this.props.suggestions[this.currentIndex]) {
            this.props.suggestions[this.currentIndex].selected = false;
            this.currentIndex = -1;
            this.forceUpdate();
        }
    }
    setSelectedSuggestion(index) {
        const { suggestions } = this.props;
        if (index > suggestions.length - 1 || index < 0) {
            this.currentIndex = 0;
            this.currentSuggestion.selected = false;
            this.currentSuggestion = suggestions[0];
            this.currentSuggestion.selected = true;
        }
        else {
            if (this.currentIndex > -1 && suggestions[this.currentIndex]) {
                suggestions[this.currentIndex].selected = false;
            }
            suggestions[index].selected = true;
            this.currentIndex = index;
            this.currentSuggestion = suggestions[index];
        }
        this.forceUpdate();
    }
    componentDidUpdate() {
        this.scrollSelected();
    }
    render() {
        const { onRenderSuggestion, suggestionsItemClassName, resultsMaximumNumber, showRemoveButtons, suggestionsContainerAriaLabel } = this.props;
        const TypedSuggestionsItem = this.SuggestionsItemOfProperType;
        let { suggestions } = this.props;
        if (resultsMaximumNumber) {
            suggestions = suggestions.slice(0, resultsMaximumNumber);
        }
        return (createElement("div", { className: css('ms-Suggestions-container', styles$j.suggestionsContainer), id: "suggestion-list", role: "list", "aria-label": suggestionsContainerAriaLabel }, suggestions.map((suggestion, index) => (createElement("div", { ref: this._resolveRef(suggestion.selected || index === this.currentIndex ? '_selectedElement' : ''), 
            // tslint:disable
            key: suggestion.item['key'] ? suggestion.item['key'] : index, 
            // tslint:enable
            id: 'sug-' + index, role: "listitem", "aria-label": suggestion.ariaLabel },
            createElement(TypedSuggestionsItem, { id: 'sug-item' + index, suggestionModel: suggestion, 
                // tslint:disable-next-line:no-any
                RenderSuggestion: onRenderSuggestion, onClick: this._onClickTypedSuggestionsItem(suggestion.item, index), className: suggestionsItemClassName, showRemoveButton: showRemoveButtons, onRemoveItem: this._onRemoveTypedSuggestionsItem(suggestion.item, index), isSelectedOverride: index === this.currentIndex }))))));
    }
    // TODO get the element to scroll into view properly regardless of direction.
    scrollSelected() {
        if (this._selectedElement && this._selectedElement.scrollIntoView !== undefined) {
            this._selectedElement.scrollIntoView(false);
        }
    }
    _onClickTypedSuggestionsItem(item, index) {
        return (ev) => {
            this.props.onSuggestionClick(ev, item, index);
        };
    }
    _onRemoveTypedSuggestionsItem(item, index) {
        return (ev) => {
            const onSuggestionRemove = this.props.onSuggestionRemove;
            onSuggestionRemove(ev, item, index);
            ev.stopPropagation();
        };
    }
}
__decorate([
    autobind
], SuggestionsCore.prototype, "_onClickTypedSuggestionsItem", null);
__decorate([
    autobind
], SuggestionsCore.prototype, "_onRemoveTypedSuggestionsItem", null);

var styles$k;
var SuggestionItemType;
(function (SuggestionItemType) {
    SuggestionItemType[SuggestionItemType["header"] = 0] = "header";
    SuggestionItemType[SuggestionItemType["suggestion"] = 1] = "suggestion";
    SuggestionItemType[SuggestionItemType["footer"] = 2] = "footer";
})(SuggestionItemType || (SuggestionItemType = {}));
class SuggestionsHeaderFooterItem extends BaseComponent {
    render() {
        const { renderItem, onExecute, isSelected, id } = this.props;
        return onExecute ? (createElement("div", { id: id, onClick: onExecute, className: css('ms-Suggestions-sectionButton', styles$k.actionButton, {
                ['is-selected ' + styles$k.buttonSelected]: isSelected
            }) }, renderItem())) : (createElement("div", { id: id, className: css('ms-Suggestions-section', styles$k.suggestionsTitle) }, renderItem()));
    }
}
/**
 * Class when used with SuggestionsStore, renders a suggestions control with customizable headers and footers
 */
class SuggestionsControl extends BaseComponent {
    constructor(suggestionsProps) {
        super(suggestionsProps);
        this.SuggestionsOfProperType = SuggestionsCore;
        this.state = {
            selectedHeaderIndex: -1,
            selectedFooterIndex: -1,
            suggestions: suggestionsProps.suggestions
        };
    }
    componentDidMount() {
        this.resetSelectedItem();
    }
    componentDidUpdate() {
        this.scrollSelected();
    }
    componentWillReceiveProps(newProps) {
        if (newProps.suggestions) {
            this.setState({ suggestions: newProps.suggestions }, () => {
                this.resetSelectedItem();
            });
        }
    }
    componentWillUnmount() {
        this._suggestions.deselectAllSuggestions();
    }
    render() {
        const { className, headerItemsProps, footerItemsProps } = this.props;
        return (createElement("div", { className: css('ms-Suggestions', className ? className : '', styles$k.root) },
            headerItemsProps && this.renderHeaderItems(),
            this._renderSuggestions(),
            footerItemsProps && this.renderFooterItems()));
    }
    get currentSuggestion() {
        return this._suggestions && this._suggestions.getCurrentItem();
    }
    get currentSuggestionIndex() {
        return this._suggestions ? this._suggestions.currentIndex : -1;
    }
    get selectedElement() {
        return this._selectedElement ? this._selectedElement : this._suggestions.selectedElement;
    }
    hasSuggestionSelected() {
        return this._suggestions && this._suggestions.hasSuggestionSelected();
    }
    hasSelection() {
        const { selectedHeaderIndex, selectedFooterIndex } = this.state;
        return selectedHeaderIndex !== -1 || this.hasSuggestionSelected() || selectedFooterIndex !== -1;
    }
    executeSelectedAction() {
        const { headerItemsProps, footerItemsProps } = this.props;
        const { selectedHeaderIndex, selectedFooterIndex } = this.state;
        if (headerItemsProps && selectedHeaderIndex !== -1 && selectedHeaderIndex < headerItemsProps.length) {
            const selectedHeaderItem = headerItemsProps[selectedHeaderIndex];
            if (selectedHeaderItem.onExecute) {
                selectedHeaderItem.onExecute();
            }
        }
        else if (this._suggestions.hasSuggestionSelected()) {
            this.props.completeSuggestion();
        }
        else if (footerItemsProps && selectedFooterIndex !== -1 && selectedFooterIndex < footerItemsProps.length) {
            const selectedFooterItem = footerItemsProps[selectedFooterIndex];
            if (selectedFooterItem.onExecute) {
                selectedFooterItem.onExecute();
            }
        }
    }
    removeSuggestion(index) {
        this._suggestions.removeSuggestion(index ? index : this._suggestions.currentIndex);
    }
    /**
     * Handles the key down, returns true, if the event was handled, false otherwise
     * @param keyCode - The keyCode to handle
     */
    handleKeyDown(keyCode) {
        const { selectedHeaderIndex, selectedFooterIndex } = this.state;
        let isKeyDownHandled = false;
        if (keyCode === KeyCodes.down) {
            if (selectedHeaderIndex === -1 && !this._suggestions.hasSuggestionSelected() && selectedFooterIndex === -1) {
                this.selectFirstItem();
            }
            else if (selectedHeaderIndex !== -1) {
                this.selectNextItem(SuggestionItemType.header);
                isKeyDownHandled = true;
            }
            else if (this._suggestions.hasSuggestionSelected()) {
                this.selectNextItem(SuggestionItemType.suggestion);
                isKeyDownHandled = true;
            }
            else if (selectedFooterIndex !== -1) {
                this.selectNextItem(SuggestionItemType.footer);
                isKeyDownHandled = true;
            }
        }
        else if (keyCode === KeyCodes.up) {
            if (selectedHeaderIndex === -1 && !this._suggestions.hasSuggestionSelected() && selectedFooterIndex === -1) {
                this.selectLastItem();
            }
            else if (selectedHeaderIndex !== -1) {
                this.selectPreviousItem(SuggestionItemType.header);
                isKeyDownHandled = true;
            }
            else if (this._suggestions.hasSuggestionSelected()) {
                this.selectPreviousItem(SuggestionItemType.suggestion);
                isKeyDownHandled = true;
            }
            else if (selectedFooterIndex !== -1) {
                this.selectPreviousItem(SuggestionItemType.footer);
                isKeyDownHandled = true;
            }
        }
        else if (keyCode === KeyCodes.enter || keyCode === KeyCodes.tab) {
            if (this.hasSelection()) {
                this.executeSelectedAction();
                isKeyDownHandled = true;
            }
        }
        return isKeyDownHandled;
    }
    // TODO get the element to scroll into view properly regardless of direction.
    scrollSelected() {
        if (this._selectedElement) {
            this._selectedElement.scrollIntoView(false);
        }
    }
    renderHeaderItems() {
        const { headerItemsProps, suggestionsHeaderContainerAriaLabel } = this.props;
        const { selectedHeaderIndex } = this.state;
        return headerItemsProps ? (createElement("div", { className: css('ms-Suggestions-headerContainer', styles$k.suggestionsContainer), id: "suggestionHeader-list", role: "list", "aria-label": suggestionsHeaderContainerAriaLabel }, headerItemsProps.map((headerItemProps, index) => {
            const isSelected = selectedHeaderIndex !== -1 && selectedHeaderIndex === index;
            return headerItemProps.shouldShow() ? (createElement("div", { ref: this._resolveRef(isSelected ? '_selectedElement' : ''), id: 'sug-header' + index, key: 'sug-header' + index, role: "listitem", "aria-label": headerItemProps.ariaLabel },
                createElement(SuggestionsHeaderFooterItem, { id: 'sug-header-item' + index, isSelected: isSelected, renderItem: headerItemProps.renderItem, onExecute: headerItemProps.onExecute, className: headerItemProps.className }))) : null;
        }))) : null;
    }
    renderFooterItems() {
        const { footerItemsProps, suggestionsFooterContainerAriaLabel } = this.props;
        const { selectedFooterIndex } = this.state;
        return footerItemsProps ? (createElement("div", { className: css('ms-Suggestions-footerContainer', styles$k.suggestionsContainer), id: "suggestionFooter-list", role: "list", "aria-label": suggestionsFooterContainerAriaLabel }, footerItemsProps.map((footerItemProps, index) => {
            const isSelected = selectedFooterIndex !== -1 && selectedFooterIndex === index;
            return footerItemProps.shouldShow() ? (createElement("div", { ref: this._resolveRef(isSelected ? '_selectedElement' : ''), id: 'sug-footer' + index, key: 'sug-footer' + index, role: "listitem", "aria-label": footerItemProps.ariaLabel },
                createElement(SuggestionsHeaderFooterItem, { id: 'sug-footer-item' + index, isSelected: isSelected, renderItem: footerItemProps.renderItem, onExecute: footerItemProps.onExecute, className: footerItemProps.className }))) : null;
        }))) : null;
    }
    _renderSuggestions() {
        const TypedSuggestions = this.SuggestionsOfProperType;
        return (createElement(TypedSuggestions, Object.assign({ ref: this._resolveRef('_suggestions') }, this.props, { suggestions: this.state.suggestions })));
    }
    /**
     * Selects the next selectable item
     */
    selectNextItem(itemType, originalItemType) {
        // If the recursive calling has not found a selectable item in the other suggestion item type groups
        // And the method is being called again with the original item type,
        // Select the first selectable item of this suggestion item type group (could be the currently selected item)
        if (itemType === originalItemType) {
            this._selectNextItemOfItemType(itemType);
            return;
        }
        const startedItemType = originalItemType !== undefined ? originalItemType : itemType;
        // Try to set the selection to the next selectable item, of the same suggestion item type group
        // If this is the original item type, use the current index
        const selectionChanged = this._selectNextItemOfItemType(itemType, startedItemType === itemType ? this._getCurrentIndexForType(itemType) : undefined);
        // If the selection did not change, try to select from the next suggestion type group
        if (!selectionChanged) {
            this.selectNextItem(this._getNextItemSectionType(itemType), startedItemType);
        }
    }
    /**
     * Selects the previous selectable item
     */
    selectPreviousItem(itemType, originalItemType) {
        // If the recursive calling has not found a selectable item in the other suggestion item type groups
        // And the method is being called again with the original item type,
        // Select the last selectable item of this suggestion item type group (could be the currently selected item)
        if (itemType === originalItemType) {
            this._selectPreviousItemOfItemType(itemType);
            return;
        }
        const startedItemType = originalItemType !== undefined ? originalItemType : itemType;
        // Try to set the selection to the previous selectable item, of the same suggestion item type group
        const selectionChanged = this._selectPreviousItemOfItemType(itemType, startedItemType === itemType ? this._getCurrentIndexForType(itemType) : undefined);
        // If the selection did not change, try to select from the previous suggestion type group
        if (!selectionChanged) {
            this.selectPreviousItem(this._getPreviousItemSectionType(itemType), startedItemType);
        }
    }
    /**
     * Resets the selected state and selects the first selectable item
     */
    resetSelectedItem() {
        this.setState({ selectedHeaderIndex: -1, selectedFooterIndex: -1 });
        this._suggestions.deselectAllSuggestions();
        // Select the first item if the shouldSelectFirstItem prop is not set or it is set and it returns true
        if (this.props.shouldSelectFirstItem === undefined || this.props.shouldSelectFirstItem()) {
            this.selectFirstItem();
        }
    }
    /**
     * Selects the first item
     */
    selectFirstItem() {
        if (this._selectNextItemOfItemType(SuggestionItemType.header)) {
            return;
        }
        if (this._selectNextItemOfItemType(SuggestionItemType.suggestion)) {
            return;
        }
        this._selectNextItemOfItemType(SuggestionItemType.footer);
    }
    /**
     * Selects the last item
     */
    selectLastItem() {
        if (this._selectPreviousItemOfItemType(SuggestionItemType.footer)) {
            return;
        }
        if (this._selectPreviousItemOfItemType(SuggestionItemType.suggestion)) {
            return;
        }
        this._selectPreviousItemOfItemType(SuggestionItemType.header);
    }
    /**
     * Selects the next item in the suggestion item type group, given the current index
     * If none is able to be selected, returns false, otherwise returns true
     * @param itemType - The suggestion item type
     * @param currentIndex - The current index, default is -1
     */
    _selectNextItemOfItemType(itemType, currentIndex = -1) {
        if (itemType === SuggestionItemType.suggestion) {
            if (this.state.suggestions.length > currentIndex + 1) {
                this._suggestions.setSelectedSuggestion(currentIndex + 1);
                this.setState({ selectedHeaderIndex: -1, selectedFooterIndex: -1 });
                return true;
            }
        }
        else {
            const isHeader = itemType === SuggestionItemType.header;
            const itemProps = isHeader ? this.props.headerItemsProps : this.props.footerItemsProps;
            if (itemProps && itemProps.length > currentIndex + 1) {
                for (let i = currentIndex + 1; i < itemProps.length; i++) {
                    const item = itemProps[i];
                    if (item.onExecute && item.shouldShow()) {
                        this.setState({ selectedHeaderIndex: isHeader ? i : -1 });
                        this.setState({ selectedFooterIndex: isHeader ? -1 : i });
                        this._suggestions.deselectAllSuggestions();
                        return true;
                    }
                }
            }
        }
        return false;
    }
    /**
     * Selects the previous item in the suggestion item type group, given the current index
     * If none is able to be selected, returns false, otherwise returns true
     * @param itemType - The suggestion item type
     * @param currentIndex - The current index. If none is provided, the default is the items length of specified type
     */
    _selectPreviousItemOfItemType(itemType, currentIndex) {
        if (itemType === SuggestionItemType.suggestion) {
            const index = currentIndex !== undefined ? currentIndex : this.state.suggestions.length;
            if (index > 0) {
                this._suggestions.setSelectedSuggestion(index - 1);
                this.setState({ selectedHeaderIndex: -1, selectedFooterIndex: -1 });
                return true;
            }
        }
        else {
            const isHeader = itemType === SuggestionItemType.header;
            const itemProps = isHeader ? this.props.headerItemsProps : this.props.footerItemsProps;
            if (itemProps) {
                const index = currentIndex !== undefined ? currentIndex : itemProps.length;
                if (index > 0) {
                    for (let i = index - 1; i >= 0; i--) {
                        const item = itemProps[i];
                        if (item.onExecute && item.shouldShow()) {
                            this.setState({ selectedHeaderIndex: isHeader ? i : -1 });
                            this.setState({ selectedFooterIndex: isHeader ? -1 : i });
                            this._suggestions.deselectAllSuggestions();
                            return true;
                        }
                    }
                }
            }
        }
        return false;
    }
    _getCurrentIndexForType(itemType) {
        switch (itemType) {
            case SuggestionItemType.header:
                return this.state.selectedHeaderIndex;
            case SuggestionItemType.suggestion:
                return this._suggestions.currentIndex;
            case SuggestionItemType.footer:
                return this.state.selectedFooterIndex;
        }
    }
    _getNextItemSectionType(itemType) {
        switch (itemType) {
            case SuggestionItemType.header:
                return SuggestionItemType.suggestion;
            case SuggestionItemType.suggestion:
                return SuggestionItemType.footer;
            case SuggestionItemType.footer:
                return SuggestionItemType.header;
        }
    }
    _getPreviousItemSectionType(itemType) {
        switch (itemType) {
            case SuggestionItemType.header:
                return SuggestionItemType.footer;
            case SuggestionItemType.suggestion:
                return SuggestionItemType.header;
            case SuggestionItemType.footer:
                return SuggestionItemType.suggestion;
        }
    }
}

// import * as stylesImport from './BaseFloatingPicker.scss';
// const styles: any = stylesImport;
let styles$l;
class BaseFloatingPicker extends BaseComponent {
    constructor(basePickerProps) {
        super(basePickerProps);
        this.root = createRef();
        this.SuggestionsControlOfProperType = SuggestionsControl;
        this.onQueryStringChanged = (queryString) => {
            if (queryString !== this.state.queryString) {
                this.setState({
                    queryString: queryString
                });
                if (this.props.onInputChanged) {
                    this.props.onInputChanged(queryString);
                }
                this.updateValue(queryString);
            }
        };
        this.hidePicker = () => {
            if (this.props.onSuggestionsHidden && this.isSuggestionsShown) {
                this.props.onSuggestionsHidden();
            }
            this.setState({
                suggestionsVisible: false
            });
        };
        this.showPicker = (updateValue = false) => {
            if (this.props.onSuggestionsShown && !this.isSuggestionsShown) {
                this.props.onSuggestionsShown();
            }
            this.setState({
                suggestionsVisible: true
            });
            // Update the suggestions if updateValue == true
            const value = this.props.inputElement ? this.props.inputElement.value : '';
            if (updateValue) {
                this.updateValue(value);
            }
        };
        this.completeSuggestion = () => {
            if (this.suggestionsControl && this.suggestionsControl.hasSuggestionSelected()) {
                this.onChange(this.suggestionsControl.currentSuggestion.item);
            }
        };
        this.onSuggestionClick = (ev, item, index) => {
            this.onChange(item);
            this._updateSuggestionsVisible(false /*shouldShow*/);
        };
        this.onSuggestionRemove = (ev, item, index) => {
            if (this.props.onRemoveSuggestion) {
                this.props.onRemoveSuggestion(item);
            }
            if (this.suggestionsControl) {
                this.suggestionsControl.removeSuggestion(index);
            }
        };
        this.onKeyDown = (ev) => {
            if (!this.state.suggestionsVisible ||
                (this.props.inputElement && !this.props.inputElement.contains(ev.target))) {
                return;
            }
            const keyCode = ev.which;
            switch (keyCode) {
                case KeyCodes.escape:
                    this.hidePicker();
                    ev.preventDefault();
                    ev.stopPropagation();
                    break;
                case KeyCodes.tab:
                case KeyCodes.enter:
                    if (!ev.shiftKey && !ev.ctrlKey && this.suggestionsControl && this.suggestionsControl.handleKeyDown(keyCode)) {
                        ev.preventDefault();
                        ev.stopPropagation();
                    }
                    else {
                        this._onValidateInput();
                    }
                    break;
                case KeyCodes.del:
                    if (this.props.onRemoveSuggestion &&
                        this.suggestionsControl &&
                        this.suggestionsControl.hasSuggestionSelected &&
                        this.suggestionsControl.currentSuggestion &&
                        ev.shiftKey) {
                        this.props.onRemoveSuggestion(this.suggestionsControl.currentSuggestion.item);
                        this.suggestionsControl.removeSuggestion();
                        this.forceUpdate();
                        ev.stopPropagation();
                    }
                    break;
                case KeyCodes.up:
                    if (this.suggestionsControl && this.suggestionsControl.handleKeyDown(keyCode)) {
                        ev.preventDefault();
                        ev.stopPropagation();
                        this._updateActiveDescendant();
                    }
                    break;
                case KeyCodes.down:
                    if (this.suggestionsControl && this.suggestionsControl.handleKeyDown(keyCode)) {
                        ev.preventDefault();
                        ev.stopPropagation();
                        this._updateActiveDescendant();
                    }
                    break;
            }
        };
        this._onValidateInput = () => {
            if (this.state.queryString && this.props.onValidateInput && this.props.createGenericItem) {
                const itemToConvert = this.props.createGenericItem(this.state.queryString, this.props.onValidateInput(this.state.queryString));
                const convertedItems = this.suggestionStore.convertSuggestionsToSuggestionItems([itemToConvert]);
                this.onChange(convertedItems[0].item);
            }
        };
        this.suggestionStore = basePickerProps.suggestionsStore;
        this.state = {
            queryString: '',
            didBind: false
        };
    }
    get inputText() {
        return this.state.queryString;
    }
    // tslint:disable-next-line:no-any
    get suggestions() {
        return this.suggestionStore.suggestions;
    }
    forceResolveSuggestion() {
        if (this.suggestionsControl && this.suggestionsControl.hasSuggestionSelected()) {
            this.completeSuggestion();
        }
        else {
            this._onValidateInput();
        }
    }
    get currentSelectedSuggestionIndex() {
        return this.suggestionsControl ? this.suggestionsControl.currentSuggestionIndex : -1;
    }
    get isSuggestionsShown() {
        return this.state.suggestionsVisible === undefined ? false : this.state.suggestionsVisible;
    }
    componentDidMount() {
        this._bindToInputElement();
        this._onResolveSuggestions = this._async.debounce(this._onResolveSuggestions, this.props.resolveDelay);
    }
    componentDidUpdate() {
        this._bindToInputElement();
    }
    componentWillUnmount() {
        this._unbindFromInputElement();
    }
    componentWillReceiveProps(newProps) {
        if (newProps.suggestionItems) {
            this.updateSuggestions(newProps.suggestionItems);
        }
    }
    updateSuggestions(suggestions, forceUpdate = false) {
        this.suggestionStore.updateSuggestions(suggestions);
        if (forceUpdate) {
            this.forceUpdate();
        }
    }
    render() {
        const { className } = this.props;
        return (createElement("div", { ref: this.root, className: css('ms-BasePicker ms-BaseFloatingPicker', className ? className : '') }, this.renderSuggestions()));
    }
    renderSuggestions() {
        const TypedSuggestionsControl = this.SuggestionsControlOfProperType;
        return this.state.suggestionsVisible ? (createElement(Callout, { className: styles$l.callout, isBeakVisible: false, gapSpace: 5, target: this.props.inputElement, onDismiss: this.hidePicker, directionalHint: DirectionalHint.bottomLeftEdge, directionalHintForRTL: DirectionalHint.bottomRightEdge, calloutWidth: this.props.calloutWidth ? this.props.calloutWidth : 0 },
            createElement(TypedSuggestionsControl, Object.assign({ onRenderSuggestion: this.props.onRenderSuggestionsItem, onSuggestionClick: this.onSuggestionClick, onSuggestionRemove: this.onSuggestionRemove, suggestions: this.suggestionStore.getSuggestions(), ref: this._resolveRef('suggestionsControl'), completeSuggestion: this.completeSuggestion, shouldLoopSelection: false }, this.props.pickerSuggestionsProps)))) : null;
    }
    onSelectionChange() {
        this.forceUpdate();
    }
    updateValue(updatedValue) {
        if (updatedValue === '') {
            this.updateSuggestionWithZeroState();
        }
        else {
            this._onResolveSuggestions(updatedValue);
        }
    }
    updateSuggestionWithZeroState() {
        if (this.props.onZeroQuerySuggestion) {
            const onEmptyInputFocus = this.props.onZeroQuerySuggestion;
            const suggestions = onEmptyInputFocus(this.props.selectedItems);
            this.updateSuggestionsList(suggestions);
        }
        else {
            this.hidePicker();
        }
    }
    updateSuggestionsList(suggestions) {
        const suggestionsArray = suggestions;
        const suggestionsPromiseLike = suggestions;
        // Check to see if the returned value is an array, if it is then just pass it into the next function.
        // If the returned value is not an array then check to see if it's a promise or PromiseLike. If it is then resolve it asynchronously.
        if (Array.isArray(suggestionsArray)) {
            this.updateSuggestions(suggestionsArray, true /*forceUpdate*/);
        }
        else if (suggestionsPromiseLike && suggestionsPromiseLike.then) {
            // Ensure that the promise will only use the callback if it was the most recent one.
            const promise = (this.currentPromise = suggestionsPromiseLike);
            promise.then((newSuggestions) => {
                if (promise === this.currentPromise) {
                    this.updateSuggestions(newSuggestions, true /*forceUpdate*/);
                }
            });
        }
    }
    onChange(item) {
        if (this.props.onChange) {
            this.props.onChange(item);
        }
    }
    _updateActiveDescendant() {
        if (this.props.inputElement && this.suggestionsControl && this.suggestionsControl.selectedElement) {
            const selectedElId = this.suggestionsControl.selectedElement.getAttribute('id');
            if (selectedElId) {
                this.props.inputElement.setAttribute('aria-activedescendant', selectedElId);
            }
        }
    }
    _onResolveSuggestions(updatedValue) {
        const suggestions = this.props.onResolveSuggestions(updatedValue, this.props.selectedItems);
        this._updateSuggestionsVisible(true /*shouldShow*/);
        if (suggestions !== null) {
            this.updateSuggestionsList(suggestions);
        }
    }
    _updateSuggestionsVisible(shouldShow) {
        if (shouldShow) {
            this.showPicker();
        }
        else {
            this.hidePicker();
        }
    }
    _bindToInputElement() {
        if (this.props.inputElement && !this.state.didBind) {
            this.props.inputElement.addEventListener('keydown', this.onKeyDown);
            this.setState({ didBind: true });
        }
    }
    _unbindFromInputElement() {
        if (this.props.inputElement && this.state.didBind) {
            this.props.inputElement.removeEventListener('keydown', this.onKeyDown);
            this.setState({ didBind: false });
        }
    }
}

/* tslint:disable */
var styles$m;
const SuggestionItemNormal = (personaProps, suggestionItemProps) => {
    return (createElement("div", { className: css('ms-PeoplePicker-personaContent', styles$m.peoplePickerPersonaContent) },
        createElement(Persona, Object.assign({ presence: personaProps.presence !== undefined ? personaProps.presence : PersonaPresence.none, size: PersonaSize.size40, className: css('ms-PeoplePicker-Persona', styles$m.peoplePickerPersona), showSecondaryText: true }, personaProps))));
};

class BaseFloatingPeoplePicker extends BaseFloatingPicker {
}
class FloatingPeoplePicker extends BaseFloatingPeoplePicker {
}
// tslint:disable-next-line:no-any
FloatingPeoplePicker.defaultProps = {
    onRenderSuggestionsItem: (props, itemProps) => SuggestionItemNormal({ ...props }, { ...itemProps }),
    createGenericItem: createItem
};
function createItem(name, isValid) {
    // tslint:disable-next-line:no-any
    const personaToConvert = {
        key: name,
        primaryText: name,
        imageInitials: '!',
        isValid: isValid
    };
    if (!isValid) {
        personaToConvert.imageInitials = getInitials(name, getRTL());
    }
    return personaToConvert;
}

class SuggestionsStore {
    constructor() {
        this.suggestions = [];
    }
    updateSuggestions(newSuggestions) {
        if (newSuggestions && newSuggestions.length > 0) {
            this.suggestions = this.convertSuggestionsToSuggestionItems(newSuggestions);
        }
        else {
            this.suggestions = [];
        }
    }
    getSuggestions() {
        return this.suggestions;
    }
    getSuggestionAtIndex(index) {
        return this.suggestions[index];
    }
    removeSuggestion(index) {
        this.suggestions.splice(index, 1);
    }
    convertSuggestionsToSuggestionItems(suggestions) {
        return Array.isArray(suggestions) ? suggestions.map(this._ensureSuggestionModel) : [];
    }
    _isSuggestionModel(value) {
        return value.item !== undefined;
    }
    _ensureSuggestionModel(suggestion) {
        if (this._isSuggestionModel(suggestion)) {
            return suggestion;
        }
        else {
            return {
                item: suggestion,
                selected: false,
                // tslint:disable-next-line:no-any
                ariaLabel: suggestion.name || suggestion.primaryText
            };
        }
    }
}
__decorate([
    autobind
], SuggestionsStore.prototype, "_isSuggestionModel", null);
__decorate([
    autobind
], SuggestionsStore.prototype, "_ensureSuggestionModel", null);

const getClassNames$U = classNamesFunction();
class GridBase extends BaseComponent {
    constructor(props) {
        super(props);
        this._id = getId();
    }
    render() {
        const { items, columnCount, onRenderItem, positionInSet, setSize, styles } = this.props;
        const htmlProps = getNativeProps(this.props, htmlElementProperties, ['onBlur, aria-posinset, aria-setsize']);
        const classNames = getClassNames$U(styles, { theme: this.props.theme });
        // Array to store the cells in the correct row index
        const rowsOfItems = toMatrix(items, columnCount);
        const content = (createElement("table", Object.assign({}, htmlProps, { "aria-posinset": positionInSet, "aria-setsize": setSize, id: this._id, role: 'grid', className: classNames.root }),
            createElement("tbody", null, rowsOfItems.map((rows, rowIndex) => {
                return (createElement("tr", { role: 'row', key: this._id + '-' + rowIndex + '-row' }, rows.map((cell, cellIndex) => {
                    return (createElement("td", { role: 'presentation', key: this._id + '-' + cellIndex + '-cell', className: classNames.tableCell }, onRenderItem(cell, cellIndex)));
                })));
            }))));
        // Create the table/grid
        return this.props.doNotContainWithinFocusZone ? (content) : (createElement(FocusZone, { isCircularNavigation: this.props.shouldFocusCircularNavigate, className: classNames.focusedContainer, onBlur: this.props.onBlur }, content));
    }
}

const getStyles$_ = (props) => {
    return {
        root: {
            padding: 2,
            outline: 'none'
        },
        tableCell: {
            padding: 0
        }
    };
};

const Grid = styled(GridBase, getStyles$_);

class GridCell extends Component {
    constructor() {
        super(...arguments);
        this._onClick = () => {
            const { onClick, disabled, item } = this.props;
            if (onClick && !disabled) {
                onClick(item);
            }
        };
        this._onMouseEnter = (ev) => {
            const { onHover, disabled, item, onMouseEnter } = this.props;
            const didUpdateOnEnter = onMouseEnter && onMouseEnter(ev);
            if (!didUpdateOnEnter && onHover && !disabled) {
                onHover(item);
            }
        };
        this._onMouseMove = (ev) => {
            const { onHover, disabled, item, onMouseMove } = this.props;
            const didUpdateOnMove = onMouseMove && onMouseMove(ev);
            if (!didUpdateOnMove && onHover && !disabled) {
                onHover(item);
            }
        };
        this._onMouseLeave = (ev) => {
            const { onHover, disabled, onMouseLeave } = this.props;
            const didUpdateOnLeave = onMouseLeave && onMouseLeave(ev);
            //@ts-ignore
            if (!didUpdateOnLeave && onHover && !disabled) {
                onHover();
            }
        };
        this._onFocus = () => {
            const { onFocus, disabled, item } = this.props;
            if (onFocus && !disabled) {
                onFocus(item);
            }
        };
    }
    render() {
        const { item, id, className, role, selected, disabled, onRenderItem, cellDisabledStyle, cellIsSelectedStyle, index, label, getClassNames } = this.props;
        return (createElement(CommandButton, { id: id, "data-index": index, "data-is-focusable": true, disabled: disabled, className: css(className, {
                ['' + cellIsSelectedStyle]: selected,
                ['' + cellDisabledStyle]: disabled
            }), onClick: this._onClick, onMouseEnter: this._onMouseEnter, onMouseMove: this._onMouseMove, onMouseLeave: this._onMouseLeave, onFocus: this._onFocus, role: role, "aria-selected": selected, ariaLabel: label, title: label, getClassNames: getClassNames }, onRenderItem(item)));
    }
}
GridCell.defaultProps = {
    disabled: false,
    id: getId('gridCell')
};

const GlobalClassNames$F = {
    host: 'ms-HoverCard-host'
};
function getStyles$10(props) {
    const { className, theme } = props;
    const classNames = getGlobalClassNames(GlobalClassNames$F, theme);
    return {
        host: [classNames.host, className]
    };
}

var OpenCardMode;
(function (OpenCardMode) {
    /**
     * Open card by hover
     */
    OpenCardMode[OpenCardMode["hover"] = 0] = "hover";
    /**
     * Open card by hot key
     */
    OpenCardMode[OpenCardMode["hotKey"] = 1] = "hotKey";
})(OpenCardMode || (OpenCardMode = {}));
var HoverCardType;
(function (HoverCardType) {
    /**
     * Plain card consisting of one part responsive to the size of content.
     */
    HoverCardType["plain"] = "PlainCard";
    /**
     * File card consisting of two parts: compact and expanded. Has some default sizes if not specified.
     */
    HoverCardType["expanding"] = "ExpandingCard";
})(HoverCardType || (HoverCardType = {}));

const GlobalClassNames$G = {
    root: 'ms-ExpandingCard-root',
    compactCard: 'ms-ExpandingCard-compactCard',
    expandedCard: 'ms-ExpandingCard-expandedCard',
    expandedCardScroll: 'ms-ExpandingCard-expandedCardScrollRegion'
};
function getStyles$11(props) {
    const { theme, needsScroll, expandedCardFirstFrameRendered, compactCardHeight, expandedCardHeight, className } = props;
    const { palette } = theme;
    const classNames = getGlobalClassNames(GlobalClassNames$G, theme);
    return {
        root: [
            classNames.root,
            {
                width: '340px',
                pointerEvents: 'none',
                boxShadow: '0 0 20px rgba(0, 0, 0, .2)',
                border: 'none',
                selectors: {
                    [HighContrastSelector]: {
                        border: '1px solid WindowText'
                    }
                }
            },
            className
        ],
        compactCard: [
            classNames.compactCard,
            {
                pointerEvents: 'auto',
                position: 'relative',
                height: compactCardHeight
            }
        ],
        expandedCard: [
            classNames.expandedCard,
            {
                height: '1px',
                overflowY: 'hidden',
                pointerEvents: 'auto',
                transition: 'height 0.467s cubic-bezier(0.5, 0, 0, 1)',
                selectors: {
                    ':before': {
                        content: '""',
                        position: 'relative',
                        display: 'block',
                        top: '0',
                        left: '24px',
                        width: '292px',
                        height: '1px',
                        backgroundColor: palette.neutralLighter
                    }
                }
            },
            expandedCardFirstFrameRendered && {
                height: expandedCardHeight
            }
        ],
        expandedCardScroll: [
            classNames.expandedCardScroll,
            needsScroll && {
                height: '100%',
                boxSizing: 'border-box',
                overflowY: 'auto'
            }
        ]
    };
}

var ExpandingCardMode;
(function (ExpandingCardMode) {
    /**
     * To have top compact card only
     */
    ExpandingCardMode[ExpandingCardMode["compact"] = 0] = "compact";
    /**
     * To have both top compact and bottom expanded card
     */
    ExpandingCardMode[ExpandingCardMode["expanded"] = 1] = "expanded";
})(ExpandingCardMode || (ExpandingCardMode = {}));

const CardCallout = (props) => {
    const { gapSpace = 0, directionalHint = DirectionalHint.bottomLeftEdge, directionalHintFixed, targetElement, firstFocus, trapFocus, onLeave, className, finalHeight, content } = props;
    const calloutProps = {
        ...getNativeProps(props, divProperties),
        className: className,
        target: targetElement,
        isBeakVisible: false,
        directionalHint: directionalHint,
        directionalHintFixed: directionalHintFixed,
        finalHeight: finalHeight,
        minPagePadding: 24,
        onDismiss: onLeave,
        gapSpace: gapSpace
    };
    return (createElement(Fragment, null, trapFocus ? (createElement(FocusTrapCallout, Object.assign({}, calloutProps, { focusTrapProps: {
            forceFocusInsideTrap: false,
            isClickableOutsideFocusTrap: true,
            disableFirstFocus: !firstFocus
        } }), content)) : (createElement(Callout, Object.assign({}, calloutProps), content))));
};

const getClassNames$V = classNamesFunction();
class ExpandingCardBase extends BaseComponent {
    constructor(props) {
        super(props);
        this._expandedElem = createRef();
        this._onKeyDown = (ev) => {
            if (ev.which === KeyCodes.escape) {
                this.props.onLeave && this.props.onLeave(ev);
            }
        };
        this._onRenderCompactCard = () => {
            return createElement("div", { className: this._classNames.compactCard }, this.props.onRenderCompactCard(this.props.renderData));
        };
        this._onRenderExpandedCard = () => {
            // firstFrameRendered helps in initially setting height of expanded card to 1px, even if
            // mode prop is set to ExpandingCardMode.expanded on first render. This is to make sure transition animation takes place.
            !this.state.firstFrameRendered &&
                this._async.requestAnimationFrame(() => {
                    this.setState({
                        firstFrameRendered: true
                    });
                });
            return (createElement("div", { className: this._classNames.expandedCard, ref: this._expandedElem },
                createElement("div", { className: this._classNames.expandedCardScroll }, this.props.onRenderExpandedCard && this.props.onRenderExpandedCard(this.props.renderData))));
        };
        this._checkNeedsScroll = () => {
            const { expandedCardHeight } = this.props;
            this._async.requestAnimationFrame(() => {
                if (this._expandedElem.current && this._expandedElem.current.scrollHeight >= expandedCardHeight) {
                    this.setState({
                        needsScroll: true
                    });
                }
            });
        };
        this.state = {
            firstFrameRendered: false,
            needsScroll: false
        };
    }
    componentDidMount() {
        this._checkNeedsScroll();
    }
    componentWillUnmount() {
        this._async.dispose();
    }
    render() {
        const { styles, compactCardHeight, expandedCardHeight, theme, mode, className } = this.props;
        const { needsScroll, firstFrameRendered } = this.state;
        const finalHeight = compactCardHeight + expandedCardHeight;
        this._classNames = getClassNames$V(styles, {
            theme: theme,
            compactCardHeight,
            className,
            expandedCardHeight,
            needsScroll: needsScroll,
            expandedCardFirstFrameRendered: mode === ExpandingCardMode.expanded && firstFrameRendered
        });
        const content = (createElement("div", { onMouseEnter: this.props.onEnter, onMouseLeave: this.props.onLeave, onKeyDown: this._onKeyDown },
            this._onRenderCompactCard(),
            this._onRenderExpandedCard()));
        return createElement(CardCallout, Object.assign({}, this.props, { content: content, finalHeight: finalHeight, className: this._classNames.root }));
    }
}
ExpandingCardBase.defaultProps = {
    compactCardHeight: 156,
    expandedCardHeight: 384,
    directionalHintFixed: true
};

const ExpandingCard = styled(ExpandingCardBase, getStyles$11, undefined, {
    scope: 'ExpandingCard'
});

const GlobalClassNames$H = {
    root: 'ms-PlainCard-root'
};
function getStyles$12(props) {
    const { theme, className } = props;
    const classNames = getGlobalClassNames(GlobalClassNames$H, theme);
    return {
        root: [
            classNames.root,
            {
                pointerEvents: 'auto',
                boxShadow: '0 0 20px rgba(0, 0, 0, .2)',
                border: 'none',
                selectors: {
                    [HighContrastSelector]: {
                        border: '1px solid WindowText'
                    }
                }
            },
            className
        ]
    };
}

const getClassNames$W = classNamesFunction();
class PlainCardBase extends BaseComponent {
    constructor() {
        super(...arguments);
        this._onKeyDown = (ev) => {
            if (ev.which === KeyCodes.escape) {
                this.props.onLeave && this.props.onLeave(ev);
            }
        };
    }
    render() {
        const { styles, theme, className } = this.props;
        this._classNames = getClassNames$W(styles, {
            theme: theme,
            className
        });
        const content = (createElement("div", { onMouseEnter: this.props.onEnter, onMouseLeave: this.props.onLeave, onKeyDown: this._onKeyDown }, this.props.onRenderPlainCard(this.props.renderData)));
        return createElement(CardCallout, Object.assign({}, this.props, { content: content, className: this._classNames.root }));
    }
}

const PlainCard = styled(PlainCardBase, getStyles$12, undefined, {
    scope: 'PlainCard'
});

const getClassNames$X = classNamesFunction();
class HoverCardBase extends BaseComponent {
    // Constructor
    constructor(props) {
        super(props);
        // The wrapping div that gets the hover events
        this._hoverCard = createRef$1();
        // Show HoverCard
        this._cardOpen = (ev) => {
            if (this._shouldBlockHoverCard() || (ev.type === 'keydown' && !(ev.which === this.props.openHotKey))) {
                return;
            }
            this._async.clearTimeout(this._dismissTimerId);
            if (ev.type === 'mouseenter') {
                this._currentMouseTarget = ev.currentTarget;
            }
            this._executeCardOpen(ev);
        };
        this._executeCardOpen = (ev) => {
            this._async.clearTimeout(this._openTimerId);
            this._openTimerId = this._async.setTimeout(() => {
                this.setState((prevState) => {
                    if (!prevState.isHoverCardVisible) {
                        return {
                            isHoverCardVisible: true,
                            mode: ExpandingCardMode.compact,
                            openMode: ev.type === 'keydown' ? OpenCardMode.hotKey : OpenCardMode.hover
                        };
                    }
                    return prevState;
                });
            }, this.props.cardOpenDelay);
        };
        // Hide HoverCard
        this._cardDismiss = (ev) => {
            if (ev.type === 'keydown' && ev.which !== KeyCodes.escape) {
                return;
            }
            // Dismiss if not sticky and currentTarget is the same element that mouse last entered
            if (!this.props.sticky && (this._currentMouseTarget === ev.currentTarget || ev.which === KeyCodes.escape)) {
                this._executeCardDismiss();
            }
        };
        this._executeCardDismiss = () => {
            this._async.clearTimeout(this._openTimerId);
            this._async.clearTimeout(this._dismissTimerId);
            this._dismissTimerId = this._async.setTimeout(() => {
                this.setState({
                    isHoverCardVisible: false,
                    mode: ExpandingCardMode.compact,
                    openMode: OpenCardMode.hover
                });
            }, this.props.cardDismissDelay);
        };
        this._instantOpenAsExpanded = (ev) => {
            this._async.clearTimeout(this._dismissTimerId);
            this.setState((prevState) => {
                if (!prevState.isHoverCardVisible) {
                    return {
                        isHoverCardVisible: true,
                        mode: ExpandingCardMode.expanded
                    };
                }
                return prevState;
            });
        };
        this.state = {
            isHoverCardVisible: false,
            mode: ExpandingCardMode.compact,
            openMode: OpenCardMode.hover
        };
    }
    componentDidMount() {
        const target = this._getTargetElement();
        this._events.on(target, 'mouseenter', this._cardOpen);
        this._events.on(target, 'mouseleave', this._cardDismiss);
        if (this.props.trapFocus) {
            this._events.on(target, 'keydown', this._cardOpen);
        }
        else {
            this._events.on(target, 'focus', this._cardOpen);
            this._events.on(target, 'blur', this._cardDismiss);
        }
        if (this.props.instantOpenOnClick) {
            this._events.on(target, 'click', this._instantOpenAsExpanded);
        }
        else {
            this._events.on(target, 'mousedown', this._cardDismiss);
            this._events.on(target, 'keydown', this._cardDismiss);
        }
    }
    componentDidUpdate(prevProps, prevState) {
        if (prevState.isHoverCardVisible !== this.state.isHoverCardVisible) {
            if (this.state.isHoverCardVisible) {
                this._async.setTimeout(() => {
                    this.setState({
                        mode: ExpandingCardMode.expanded
                    }, () => {
                        this.props.onCardExpand && this.props.onCardExpand();
                    });
                }, this.props.expandedCardOpenDelay);
                this.props.onCardVisible && this.props.onCardVisible();
            }
            else {
                this.setState({
                    mode: ExpandingCardMode.compact
                });
                this.props.onCardHide && this.props.onCardHide();
            }
        }
    }
    // Render
    render() {
        const { expandingCardProps, children, id, setAriaDescribedBy = true, styles: customStyles, theme, className, type, plainCardProps, trapFocus, setInitialFocus } = this.props;
        const { isHoverCardVisible, mode, openMode } = this.state;
        const hoverCardId = id || getId('hoverCard');
        this._classNames = getClassNames$X(customStyles, {
            theme: theme,
            className
        });
        // Common props for both card types.
        const commonCardProps = {
            ...getNativeProps(this.props, divProperties),
            id: hoverCardId,
            trapFocus: !!trapFocus,
            firstFocus: setInitialFocus || openMode === OpenCardMode.hotKey,
            targetElement: this._getTargetElement(),
            onEnter: this._cardOpen,
            onLeave: this._executeCardDismiss
        };
        const finalExpandedCardProps = { ...expandingCardProps, ...commonCardProps, mode };
        const finalPlainCardProps = { ...plainCardProps, ...commonCardProps };
        return (createElement("div", { className: this._classNames.host, ref: this._hoverCard, "aria-describedby": setAriaDescribedBy && isHoverCardVisible ? hoverCardId : undefined, "data-is-focusable": !Boolean(this.props.target) },
            children,
            isHoverCardVisible &&
                (type === HoverCardType.expanding ? createElement(ExpandingCard, Object.assign({}, finalExpandedCardProps)) : createElement(PlainCard, Object.assign({}, finalPlainCardProps)))));
    }
    _getTargetElement() {
        const { target } = this.props;
        switch (typeof target) {
            case 'string':
                return getDocument().querySelector(target);
            case 'object':
                return target;
            default:
                return this._hoverCard.current || undefined;
        }
    }
    _shouldBlockHoverCard() {
        //@ts-ignore
        return !!(this.props.shouldBlockHoverCard && this.props.shouldBlockHoverCard());
    }
}
HoverCardBase.defaultProps = {
    cardOpenDelay: 500,
    cardDismissDelay: 100,
    expandedCardOpenDelay: 1500,
    instantOpenOnClick: false,
    setInitialFocus: false,
    openHotKey: KeyCodes.c,
    type: HoverCardType.expanding
};

const HoverCard = styled(HoverCardBase, getStyles$10, undefined, {
    scope: 'HoverCard'
});

/**
 * A component corresponding the the content rendered inside the callout of the keytip component.
 *
 * @export
 * @class KeytipContent
 * @extends {BaseComponent<IKeytipProps>}
 */
class KeytipContentBase extends BaseComponent {
    render() {
        const { content, styles, theme, disabled, visible } = this.props;
        const getClassNames = classNamesFunction();
        const classNames = getClassNames(styles, {
            theme: theme,
            disabled,
            visible
        });
        return (createElement("div", { className: classNames.container },
            createElement("span", { className: classNames.root }, content)));
    }
}

const getStyles$13 = (props) => {
    const { theme, disabled, visible } = props;
    return {
        container: [
            {
                backgroundColor: theme.palette.neutralDark
            },
            disabled && {
                opacity: 0.5,
                selectors: {
                    [HighContrastSelector]: {
                        color: 'GrayText',
                        opacity: 1
                    }
                }
            },
            !visible && {
                visibility: 'hidden'
            }
        ],
        root: [
            theme.fonts.medium,
            {
                textAlign: 'center',
                paddingLeft: '3px',
                paddingRight: '3px',
                backgroundColor: theme.palette.neutralDark,
                color: theme.palette.neutralLight,
                minWidth: '11px',
                lineHeight: '17px',
                height: '17px',
                display: 'inline-block'
            },
            disabled && {
                color: theme.palette.neutralTertiaryAlt
            }
        ]
    };
};
const getCalloutStyles = (props) => {
    return {
        container: [],
        root: [
            {
                border: 'none',
                boxShadow: 'none'
            }
        ],
        beak: [],
        beakCurtain: [],
        calloutMain: [
            {
                backgroundColor: 'transparent'
            }
        ]
    };
};
const getCalloutOffsetStyles = (offset) => {
    return (props) => {
        return mergeStyleSets(getCalloutStyles(props), {
            root: [
                {
                    marginLeft: offset.x,
                    marginTop: offset.y
                }
            ]
        });
    };
};

const KeytipContent = styled(KeytipContentBase, getStyles$13, undefined, {
    scope: 'KeytipContent'
});

/**
 * A callout corresponding to another Fabric component to describe a key sequence that will activate that component
 */
class Keytip extends BaseComponent {
    render() {
        const { keySequences, offset, overflowSetSequence } = this.props;
        let { calloutProps } = this.props;
        let keytipTarget;
        // Take into consideration the overflow sequence
        if (overflowSetSequence) {
            keytipTarget = ktpTargetFromSequences(mergeOverflows(keySequences, overflowSetSequence));
        }
        else {
            keytipTarget = ktpTargetFromSequences(keySequences);
        }
        if (offset) {
            // Set callout to top-left corner, will be further positioned in
            // getCalloutOffsetStyles
            calloutProps = {
                ...calloutProps,
                coverTarget: true,
                directionalHint: DirectionalHint.topLeftEdge
            };
        }
        if (!calloutProps || calloutProps.directionalHint === undefined) {
            // Default callout directional hint to BottomCenter
            calloutProps = {
                ...calloutProps,
                directionalHint: DirectionalHint.bottomCenter
            };
        }
        return (createElement(Callout, Object.assign({}, calloutProps, { isBeakVisible: false, doNotLayer: true, minPagePadding: 0, styles: offset ? getCalloutOffsetStyles(offset) : getCalloutStyles, preventDismissOnScroll: true, target: keytipTarget }),
            createElement(KeytipContent, Object.assign({}, this.props))));
    }
}

const getLayerStyles = (props) => {
    return {
        root: [
            {
                // Prioritize the Keytips above all other Layers
                zIndex: ZIndexes.KeytipLayer
            }
        ]
    };
};
const getStyles$14 = (props) => {
    return {
        innerContent: [
            {
                position: 'absolute',
                width: 0,
                height: 0,
                margin: 0,
                padding: 0,
                border: 0,
                overflow: 'hidden',
                visibility: 'hidden'
            }
        ]
    };
};

/**
 * This class is responsible for handling the parent/child relationships between keytips
 */
class KeytipTree {
    /**
     * KeytipTree constructor
     */
    constructor() {
        this.nodeMap = {};
        // Root has no keytipSequence
        this.root = {
            id: KTP_LAYER_ID,
            children: [],
            parent: '',
            keySequences: []
        };
        this.nodeMap[this.root.id] = this.root;
    }
    /**
     * Add a keytip node to this KeytipTree
     *
     * @param keytipProps - Keytip to add to the Tree
     * @param uniqueID - Unique ID for this keytip
     * @param persisted - T/F if this keytip should be marked as persisted
     */
    addNode(keytipProps, uniqueID, persisted) {
        const fullSequence = this._getFullSequence(keytipProps);
        const nodeID = sequencesToID(fullSequence);
        // Take off the last item to calculate the parent sequence
        fullSequence.pop();
        // Parent ID is the root if there aren't any more sequences
        const parentID = this._getParentID(fullSequence);
        // Create node and add to map
        const node = this._createNode(nodeID, parentID, [], keytipProps, persisted);
        this.nodeMap[uniqueID] = node;
        // Try to add self to parents children, if they exist
        const parent = this.getNode(parentID);
        if (parent) {
            parent.children.push(nodeID);
        }
    }
    /**
     * Updates a node in the tree
     *
     * @param keytipProps - Keytip props to update
     * @param uniqueID - Unique ID for this keytip
     */
    updateNode(keytipProps, uniqueID) {
        const fullSequence = this._getFullSequence(keytipProps);
        const nodeID = sequencesToID(fullSequence);
        // Take off the last item to calculate the parent sequence
        fullSequence.pop();
        // Parent ID is the root if there aren't any more sequences
        const parentID = this._getParentID(fullSequence);
        const node = this.nodeMap[uniqueID];
        if (node) {
            // Update values
            node.id = nodeID;
            node.keySequences = keytipProps.keySequences;
            node.overflowSetSequence = keytipProps.overflowSetSequence;
            node.onExecute = keytipProps.onExecute;
            node.onReturn = keytipProps.onReturn;
            node.hasDynamicChildren = keytipProps.hasDynamicChildren;
            node.hasMenu = keytipProps.hasMenu;
            node.parent = parentID;
            node.disabled = keytipProps.disabled;
        }
    }
    /**
     * Removes a node from the KeytipTree
     *
     * @param sequence - full string of the node to remove
     */
    removeNode(keytipProps, uniqueID) {
        const fullSequence = this._getFullSequence(keytipProps);
        const nodeID = sequencesToID(fullSequence);
        // Take off the last sequence to calculate the parent ID
        fullSequence.pop();
        // Parent ID is the root if there aren't any more sequences
        const parentID = this._getParentID(fullSequence);
        const parent = this.getNode(parentID);
        if (parent) {
            // Remove node from its parent's children
            parent.children.splice(parent.children.indexOf(nodeID), 1);
        }
        if (this.nodeMap[uniqueID]) {
            // Remove the node from the nodeMap
            delete this.nodeMap[uniqueID];
        }
    }
    /**
     * Searches the currentKeytip's children to exactly match a sequence. Will not match disabled nodes but
     * will match persisted nodes
     *
     * @param keySequence - string to match
     * @param currentKeytip - The keytip whose children will try to match
     * @returns The node that exactly matched the keySequence, or undefined if none matched
     */
    getExactMatchedNode(keySequence, currentKeytip) {
        const possibleNodes = this.getNodes(currentKeytip.children);
        return find(possibleNodes, (node) => {
            return this._getNodeSequence(node) === keySequence && !node.disabled;
        });
    }
    /**
     * Searches the currentKeytip's children to find nodes that start with the given sequence. Will not match
     * disabled nodes but will match persisted nodes
     *
     * @param keySequence - string to partially match
     * @param currentKeytip - The keytip whose children will try to partially match
     * @returns List of tree nodes that partially match the given sequence
     */
    getPartiallyMatchedNodes(keySequence, currentKeytip) {
        // Get children that are persisted
        const possibleNodes = this.getNodes(currentKeytip.children);
        return possibleNodes.filter((node) => {
            return this._getNodeSequence(node).indexOf(keySequence) === 0 && !node.disabled;
        });
    }
    /**
     * Get the non-persisted children of the give node
     * If no node is given, will use the 'currentKeytip'
     *
     * @param node - Node to get the children for
     * @returns List of node IDs that are the children of the node
     */
    getChildren(node) {
        if (!node) {
            node = this.currentKeytip;
            if (!node) {
                return [];
            }
        }
        const children = node.children;
        return Object.keys(this.nodeMap).reduce((nodes, key) => {
            if (children.indexOf(this.nodeMap[key].id) >= 0 && !this.nodeMap[key].persisted) {
                nodes.push(this.nodeMap[key].id);
            }
            return nodes;
        }, []);
    }
    /**
     * Gets all nodes from their IDs
     *
     * @param ids List of keytip IDs
     * @returns Array of nodes that match the given IDs, can be empty
     */
    getNodes(ids) {
        return Object.keys(this.nodeMap).reduce((nodes, key) => {
            if (ids.indexOf(this.nodeMap[key].id) >= 0) {
                nodes.push(this.nodeMap[key]);
            }
            return nodes;
        }, []);
    }
    /**
     * Gets a single node from its ID
     *
     * @param id - ID of the node to get
     * @returns Node with the given ID, if found
     */
    getNode(id) {
        const nodeMapValues = values(this.nodeMap);
        return find(nodeMapValues, (node) => {
            return node.id === id;
        });
    }
    /**
     * Tests if the currentKeytip in this.keytipTree is the parent of 'keytipProps'
     *
     * @param keytipProps - Keytip to test the parent for
     * @returns T/F if the currentKeytip is this keytipProps' parent
     */
    isCurrentKeytipParent(keytipProps) {
        if (this.currentKeytip) {
            let fullSequence = [...keytipProps.keySequences];
            if (keytipProps.overflowSetSequence) {
                fullSequence = mergeOverflows(fullSequence, keytipProps.overflowSetSequence);
            }
            // Take off the last sequence to calculate the parent ID
            fullSequence.pop();
            // Parent ID is the root if there aren't any more sequences
            const parentID = fullSequence.length === 0 ? this.root.id : sequencesToID(fullSequence);
            let matchesCurrWithoutOverflow = false;
            if (this.currentKeytip.overflowSetSequence) {
                const currKeytipIdWithoutOverflow = sequencesToID(this.currentKeytip.keySequences);
                matchesCurrWithoutOverflow = currKeytipIdWithoutOverflow === parentID;
            }
            return matchesCurrWithoutOverflow || this.currentKeytip.id === parentID;
        }
        return false;
    }
    _getParentID(fullSequence) {
        return fullSequence.length === 0 ? this.root.id : sequencesToID(fullSequence);
    }
    _getFullSequence(keytipProps) {
        let fullSequence = [...keytipProps.keySequences];
        if (keytipProps.overflowSetSequence) {
            fullSequence = mergeOverflows(fullSequence, keytipProps.overflowSetSequence);
        }
        return fullSequence;
    }
    _getNodeSequence(node) {
        let fullSequence = [...node.keySequences];
        if (node.overflowSetSequence) {
            fullSequence = mergeOverflows(fullSequence, node.overflowSetSequence);
        }
        return fullSequence[fullSequence.length - 1];
    }
    _createNode(id, parentId, children, keytipProps, persisted) {
        const { keySequences, hasDynamicChildren, overflowSetSequence, hasMenu, onExecute, onReturn, disabled } = keytipProps;
        const node = {
            id,
            keySequences,
            overflowSetSequence,
            parent: parentId,
            children,
            onExecute,
            onReturn,
            hasDynamicChildren,
            hasMenu,
            disabled,
            persisted
        };
        node.children = Object.keys(this.nodeMap).reduce((array, nodeMapKey) => {
            if (this.nodeMap[nodeMapKey].parent === id) {
                array.push(this.nodeMap[nodeMapKey].id);
            }
            return array;
        }, []);
        return node;
    }
}

var KeytipTransitionModifier;
(function (KeytipTransitionModifier) {
    KeytipTransitionModifier[KeytipTransitionModifier["shift"] = KeyCodes.shift] = "shift";
    KeytipTransitionModifier[KeytipTransitionModifier["ctrl"] = KeyCodes.ctrl] = "ctrl";
    KeytipTransitionModifier[KeytipTransitionModifier["alt"] = KeyCodes.alt] = "alt";
    KeytipTransitionModifier[KeytipTransitionModifier["meta"] = KeyCodes.leftWindow] = "meta";
})(KeytipTransitionModifier || (KeytipTransitionModifier = {}));
/**
 * Tests for equality between two IKeytipTransitionKeys.
 *
 * @param key1 - First IKeytipTransitionKey.
 * @param key2 - Second IKeytipTransitionKey.
 * @returns {boolean} T/F if the transition keys are equal.
 */
function transitionKeysAreEqual(key1, key2) {
    if (key1.key !== key2.key) {
        return false;
    }
    let mod1 = key1.modifierKeys;
    let mod2 = key2.modifierKeys;
    if ((!mod1 && mod2) || (mod1 && !mod2)) {
        // Not equal if one modifier is defined and the other isn't
        return false;
    }
    if (mod1 && mod2) {
        if (mod1.length !== mod2.length) {
            return false;
        }
        // Sort both arrays
        mod1 = mod1.sort();
        mod2 = mod2.sort();
        for (let i = 0; i < mod1.length; i++) {
            if (mod1[i] !== mod2[i]) {
                return false;
            }
        }
    }
    return true;
}
/**
 * Tests if 'key' is present in 'keys'.
 *
 * @param keys - Array of IKeytipTransitionKey.
 * @param key - IKeytipTransitionKey to find in 'keys'.
 * @returns {boolean} T/F if 'keys' contains 'key'.
 */
function transitionKeysContain(keys, key) {
    return !!find(keys, (transitionKey) => {
        return transitionKeysAreEqual(transitionKey, key);
    });
}

// Default sequence is Alt-Windows (Alt-Meta) in Windows, Option-Control (Alt-Control) in Mac
const defaultStartSequence = {
    key: isMac() ? 'Control' : 'Meta',
    modifierKeys: [KeytipTransitionModifier.alt]
};
// Default exit sequence is the same as the start sequence
const defaultExitSequence = defaultStartSequence;
// Default return sequence is Escape
const defaultReturnSequence = {
    key: 'Escape'
};
const getClassNames$Y = classNamesFunction();
/**
 * A layer that holds all keytip items
 */
class KeytipLayerBase extends BaseComponent {
    // tslint:disable-next-line:no-any
    constructor(props, context) {
        super(props, context);
        this._keytipManager = KeytipManager.getInstance();
        this._delayedKeytipQueue = [];
        this._keyHandled = false;
        this._onDismiss = (ev) => {
            // if we are in keytip mode, then exit keytip mode
            if (this.state.inKeytipMode) {
                this._exitKeytipMode(ev);
            }
        };
        this._onKeyDown = (ev) => {
            this._keyHandled = false;
            // using key since which has been deprecated and key is now widely suporrted.
            // See: https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/which
            let key = ev.key;
            switch (key) {
                case 'Alt':
                    // ALT puts focus in the browser bar, so it should not be used as a key for keytips.
                    // It can be used as a modifier
                    break;
                case 'Tab':
                case 'Enter':
                case 'Spacebar':
                case ' ':
                case 'ArrowUp':
                case 'Up':
                case 'ArrowDown':
                case 'Down':
                case 'ArrowLeft':
                case 'Left':
                case 'ArrowRight':
                case 'Right':
                    if (this.state.inKeytipMode) {
                        this._keyHandled = true;
                        this._exitKeytipMode(ev);
                    }
                    break;
                default:
                    // Special cases for browser-specific keys that are not at standard
                    // (according to http://www.w3.org/TR/uievents-key/#keys-navigation)
                    if (key === 'Esc') {
                        // Edge: https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/5290772/
                        key = 'Escape';
                    }
                    else if (key === 'OS' || key === 'Win') {
                        // Firefox: https://bugzilla.mozilla.org/show_bug.cgi?id=1232918
                        // Edge: https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/8860571/
                        // and https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/16424492/
                        key = 'Meta';
                    }
                    const transitionKey = { key };
                    transitionKey.modifierKeys = this._getModifierKey(key, ev);
                    this.processTransitionInput(transitionKey, ev);
                    break;
            }
        };
        this._onKeyPress = (ev) => {
            if (this.state.inKeytipMode && !this._keyHandled) {
                // Call processInput
                this.processInput(ev.key.toLocaleLowerCase(), ev);
                ev.preventDefault();
                ev.stopPropagation();
            }
        };
        this._onKeytipAdded = (eventArgs) => {
            const keytipProps = eventArgs.keytip;
            const uniqueID = eventArgs.uniqueID;
            this._keytipTree.addNode(keytipProps, uniqueID);
            this._setKeytips();
            // Add the keytip to the queue to show later
            if (this._keytipTree.isCurrentKeytipParent(keytipProps)) {
                this._addKeytipToQueue(sequencesToID(keytipProps.keySequences));
            }
            if (this._newCurrentKeytipSequences && arraysEqual(keytipProps.keySequences, this._newCurrentKeytipSequences)) {
                this._triggerKeytipImmediately(keytipProps);
            }
            if (this._isCurrentKeytipAnAlias(keytipProps)) {
                let keytipSequence = keytipProps.keySequences;
                if (keytipProps.overflowSetSequence) {
                    keytipSequence = mergeOverflows(keytipSequence, keytipProps.overflowSetSequence);
                }
                this._keytipTree.currentKeytip = this._keytipTree.getNode(sequencesToID(keytipSequence));
            }
        };
        this._onKeytipUpdated = (eventArgs) => {
            const keytipProps = eventArgs.keytip;
            const uniqueID = eventArgs.uniqueID;
            this._keytipTree.updateNode(keytipProps, uniqueID);
            this._setKeytips();
        };
        this._onKeytipRemoved = (eventArgs) => {
            const keytipProps = eventArgs.keytip;
            const uniqueID = eventArgs.uniqueID;
            // Remove keytip from the delayed queue
            this._removeKeytipFromQueue(sequencesToID(keytipProps.keySequences));
            // Remove the node from the Tree
            this._keytipTree.removeNode(keytipProps, uniqueID);
            this._setKeytips();
        };
        this._onPersistedKeytipAdded = (eventArgs) => {
            const keytipProps = eventArgs.keytip;
            const uniqueID = eventArgs.uniqueID;
            this._keytipTree.addNode(keytipProps, uniqueID, true);
        };
        this._onPersistedKeytipRemoved = (eventArgs) => {
            const keytipProps = eventArgs.keytip;
            const uniqueID = eventArgs.uniqueID;
            this._keytipTree.removeNode(keytipProps, uniqueID);
        };
        this._onPersistedKeytipExecute = (eventArgs) => {
            this._persistedKeytipExecute(eventArgs.overflowButtonSequences, eventArgs.keytipSequences);
        };
        /**
         * Sets if we are in keytip mode.
         * Note, this sets both the state for the layer as well as
         * the value that the manager will expose externally.
         * @param inKeytipMode - Boolean so set whether we are in keytip mode or not
         */
        this._setInKeytipMode = (inKeytipMode) => {
            this.setState({ inKeytipMode: inKeytipMode });
            this._keytipManager.inKeytipMode = inKeytipMode;
        };
        /**
         * Emits a warning if duplicate keytips are found for the children of the current keytip
         */
        this._warnIfDuplicateKeytips = () => {
            const duplicateKeytips = this._getDuplicateIds(this._keytipTree.getChildren());
            if (duplicateKeytips.length) {
                warn('Duplicate keytips found for ' + duplicateKeytips.join(', '));
            }
        };
        /**
         * Returns duplicates among keytip IDs
         * If the returned array is empty, no duplicates were found
         *
         * @param keytipIds - Array of keytip IDs to find duplicates for
         * @returns - Array of duplicates that were found. If multiple duplicates were found it will only be added once to this array
         */
        this._getDuplicateIds = (keytipIds) => {
            const seenIds = {};
            return keytipIds.filter(keytipId => {
                seenIds[keytipId] = seenIds[keytipId] ? seenIds[keytipId] + 1 : 1;
                // Only add the first duplicate keytip seen
                return seenIds[keytipId] === 2;
            });
        };
        const managerKeytips = [...this._keytipManager.getKeytips()];
        this.state = {
            inKeytipMode: false,
            // Get the initial set of keytips
            keytips: managerKeytips,
            visibleKeytips: this._getVisibleKeytips(managerKeytips)
        };
        this._keytipTree = new KeytipTree();
        // Add regular and persisted keytips to the tree
        for (const uniqueKeytip of this._keytipManager.keytips.concat(this._keytipManager.persistedKeytips)) {
            this._keytipTree.addNode(uniqueKeytip.keytip, uniqueKeytip.uniqueID);
        }
        this._currentSequence = '';
        // Add keytip listeners
        this._events.on(this._keytipManager, KeytipEvents.KEYTIP_ADDED, this._onKeytipAdded);
        this._events.on(this._keytipManager, KeytipEvents.KEYTIP_UPDATED, this._onKeytipUpdated);
        this._events.on(this._keytipManager, KeytipEvents.KEYTIP_REMOVED, this._onKeytipRemoved);
        this._events.on(this._keytipManager, KeytipEvents.PERSISTED_KEYTIP_ADDED, this._onPersistedKeytipAdded);
        this._events.on(this._keytipManager, KeytipEvents.PERSISTED_KEYTIP_REMOVED, this._onPersistedKeytipRemoved);
        this._events.on(this._keytipManager, KeytipEvents.PERSISTED_KEYTIP_EXECUTE, this._onPersistedKeytipExecute);
    }
    render() {
        const { content, styles } = this.props;
        const { keytips, visibleKeytips } = this.state;
        this._classNames = getClassNames$Y(styles, {});
        return (createElement(Layer, { styles: getLayerStyles },
            createElement("span", { id: KTP_LAYER_ID, className: this._classNames.innerContent }, `${content}${KTP_ARIA_SEPARATOR}`),
            keytips &&
                keytips.map((keytipProps, index) => {
                    return (createElement("span", { key: index, id: sequencesToID(keytipProps.keySequences), className: this._classNames.innerContent }, keytipProps.keySequences.join(KTP_ARIA_SEPARATOR)));
                }),
            visibleKeytips &&
                visibleKeytips.map((visibleKeytipProps) => {
                    return createElement(Keytip, Object.assign({ key: sequencesToID(visibleKeytipProps.keySequences) }, visibleKeytipProps));
                })));
    }
    componentDidMount() {
        // Add window listeners
        this._events.on(window, 'mouseup', this._onDismiss, true /* useCapture */);
        this._events.on(window, 'pointerup', this._onDismiss, true /* useCapture */);
        this._events.on(window, 'resize', this._onDismiss);
        this._events.on(window, 'keydown', this._onKeyDown, true /* useCapture */);
        this._events.on(window, 'keypress', this._onKeyPress, true /* useCapture */);
        this._events.on(window, 'scroll', this._onDismiss, true /* useCapture */);
        // Add keytip listeners
        this._events.on(this._keytipManager, KeytipEvents.ENTER_KEYTIP_MODE, this._enterKeytipMode);
        this._events.on(this._keytipManager, KeytipEvents.EXIT_KEYTIP_MODE, this._exitKeytipMode);
    }
    componentWillUnmount() {
        // Remove window listeners
        this._events.off(window, 'mouseup', this._onDismiss, true /* useCapture */);
        this._events.off(window, 'pointerup', this._onDismiss, true /* useCapture */);
        this._events.off(window, 'resize', this._onDismiss);
        this._events.off(window, 'keydown', this._onKeyDown, true /* useCapture */);
        this._events.off(window, 'keypress', this._onKeyPress, true /* useCapture */);
        this._events.off(window, 'scroll', this._onDismiss, true /* useCapture */);
        // Remove keytip listeners
        this._events.off(this._keytipManager, KeytipEvents.KEYTIP_ADDED, this._onKeytipAdded);
        this._events.off(this._keytipManager, KeytipEvents.KEYTIP_UPDATED, this._onKeytipUpdated);
        this._events.off(this._keytipManager, KeytipEvents.KEYTIP_REMOVED, this._onKeytipRemoved);
        this._events.off(this._keytipManager, KeytipEvents.PERSISTED_KEYTIP_ADDED, this._onPersistedKeytipAdded);
        this._events.off(this._keytipManager, KeytipEvents.PERSISTED_KEYTIP_REMOVED, this._onPersistedKeytipRemoved);
        this._events.off(this._keytipManager, KeytipEvents.PERSISTED_KEYTIP_EXECUTE, this._onPersistedKeytipExecute);
        this._events.off(this._keytipManager, KeytipEvents.ENTER_KEYTIP_MODE, this._enterKeytipMode);
        this._events.off(this._keytipManager, KeytipEvents.EXIT_KEYTIP_MODE, this._exitKeytipMode);
    }
    // The below public functions are only public for testing purposes
    // They are not intended to be used in app code by using a KeytipLayer reference
    getCurrentSequence() {
        return this._currentSequence;
    }
    getKeytipTree() {
        return this._keytipTree;
    }
    /**
     * Processes an IKeytipTransitionKey entered by the user
     *
     * @param transitionKey - IKeytipTransitionKey received by the layer to process
     */
    processTransitionInput(transitionKey, ev) {
        const currKtp = this._keytipTree.currentKeytip;
        if (transitionKeysContain(this.props.keytipExitSequences, transitionKey) && currKtp) {
            // If key sequence is in 'exit sequences', exit keytip mode
            this._keyHandled = true;
            this._exitKeytipMode(ev);
        }
        else if (transitionKeysContain(this.props.keytipReturnSequences, transitionKey)) {
            // If key sequence is in return sequences, move currentKeytip to parent (or if currentKeytip is the root, exit)
            if (currKtp) {
                this._keyHandled = true;
                if (currKtp.id === this._keytipTree.root.id) {
                    // We are at the root, exit keytip mode
                    this._exitKeytipMode(ev);
                }
                else {
                    // If this keytip has a onReturn prop, we execute the func.
                    if (currKtp.onReturn) {
                        currKtp.onReturn(this._getKtpExecuteTarget(currKtp), this._getKtpTarget(currKtp));
                    }
                    // Reset currentSequence
                    this._currentSequence = '';
                    // Return pointer to its parent
                    this._keytipTree.currentKeytip = this._keytipTree.getNode(currKtp.parent);
                    // Show children keytips of the new currentKeytip
                    this.showKeytips(this._keytipTree.getChildren());
                    this._warnIfDuplicateKeytips();
                }
            }
        }
        else if (transitionKeysContain(this.props.keytipStartSequences, transitionKey) && !currKtp) {
            // If key sequence is in 'entry sequences' and currentKeytip is null, we enter keytip mode
            this._keyHandled = true;
            this._enterKeytipMode();
            this._warnIfDuplicateKeytips();
        }
    }
    /**
     * Processes inputs from the document listener and traverse the keytip tree
     *
     * @param key - Key pressed by the user
     */
    processInput(key, ev) {
        // Concat the input key with the current sequence
        const currSequence = this._currentSequence + key;
        let currKtp = this._keytipTree.currentKeytip;
        // currentKeytip must be defined, otherwise we haven't entered keytip mode yet
        if (currKtp) {
            const node = this._keytipTree.getExactMatchedNode(currSequence, currKtp);
            if (node) {
                this._keytipTree.currentKeytip = currKtp = node;
                const currKtpChildren = this._keytipTree.getChildren();
                // Execute this node's onExecute if defined
                if (currKtp.onExecute) {
                    currKtp.onExecute(this._getKtpExecuteTarget(currKtp), this._getKtpTarget(currKtp));
                    // Reset currKtp, this might have changed from the onExecute
                    currKtp = this._keytipTree.currentKeytip;
                }
                // To exit keytipMode after executing the keytip it must not have a menu or have dynamic children
                if (currKtpChildren.length === 0 && !(currKtp.hasDynamicChildren || currKtp.hasMenu)) {
                    this._exitKeytipMode(ev);
                }
                else {
                    // Show all children keytips
                    this.showKeytips(currKtpChildren);
                    this._warnIfDuplicateKeytips();
                }
                // Clear currentSequence
                this._currentSequence = '';
                return;
            }
            const partialNodes = this._keytipTree.getPartiallyMatchedNodes(currSequence, currKtp);
            if (partialNodes.length > 0) {
                // We found nodes that partially match the sequence, so we show only those
                // Omit showing persisted nodes here
                const ids = partialNodes
                    .filter((partialNode) => {
                    return !partialNode.persisted;
                })
                    .map((partialNode) => {
                    return partialNode.id;
                });
                this.showKeytips(ids);
                // Save currentSequence
                this._currentSequence = currSequence;
            }
        }
    }
    /**
     * Show the given keytips and hide all others
     *
     * @param ids - Keytip IDs to show
     */
    showKeytips(ids) {
        // Update the visible prop in the manager
        for (const keytip of this._keytipManager.getKeytips()) {
            const keytipId = sequencesToID(keytip.keySequences);
            if (ids.indexOf(keytipId) >= 0) {
                keytip.visible = true;
            }
            else if (keytip.overflowSetSequence &&
                ids.indexOf(sequencesToID(mergeOverflows(keytip.keySequences, keytip.overflowSetSequence))) >= 0) {
                // Check if the ID with the overflow is the keytip we're looking for
                keytip.visible = true;
            }
            else {
                keytip.visible = false;
            }
        }
        // Apply the manager changes to the Layer state
        this._setKeytips();
    }
    /**
     * Enters keytip mode for this layer
     */
    _enterKeytipMode() {
        if (this._keytipManager.shouldEnterKeytipMode) {
            this._keytipTree.currentKeytip = this._keytipTree.root;
            // Show children of root
            this.showKeytips(this._keytipTree.getChildren());
            this._setInKeytipMode(true /* inKeytipMode */);
            if (this.props.onEnterKeytipMode) {
                this.props.onEnterKeytipMode();
            }
        }
    }
    /**
     * Exits keytip mode for this layer
     */
    _exitKeytipMode(ev) {
        this._keytipTree.currentKeytip = undefined;
        this._currentSequence = '';
        // Hide all keytips
        this.showKeytips([]);
        // Reset the delayed keytips if any
        this._delayedQueueTimeout && this._async.clearTimeout(this._delayedQueueTimeout);
        this._delayedKeytipQueue = [];
        this._setInKeytipMode(false /* inKeytipMode */);
        if (this.props.onExitKeytipMode) {
            this.props.onExitKeytipMode(ev);
        }
    }
    /**
     * Sets the keytips state property
     *
     * @param keytipProps - Keytips to set in this layer
     */
    _setKeytips(keytipProps = this._keytipManager.getKeytips()) {
        this.setState({ keytips: keytipProps, visibleKeytips: this._getVisibleKeytips(keytipProps) });
    }
    /**
     * Callback function to use for persisted keytips
     *
     * @param overflowButtonSequences - The overflow button sequence to execute
     * @param keytipSequences - The keytip that should become the 'currentKeytip' when it is registered
     */
    _persistedKeytipExecute(overflowButtonSequences, keytipSequences) {
        // Save newCurrentKeytip for later
        this._newCurrentKeytipSequences = keytipSequences;
        // Execute the overflow button's onExecute
        const overflowKeytipNode = this._keytipTree.getNode(sequencesToID(overflowButtonSequences));
        if (overflowKeytipNode && overflowKeytipNode.onExecute) {
            overflowKeytipNode.onExecute(this._getKtpExecuteTarget(overflowKeytipNode), this._getKtpTarget(overflowKeytipNode));
        }
    }
    _getVisibleKeytips(keytips) {
        // Filter out non-visible keytips and duplicates
        const seenIds = {};
        return keytips.filter(keytip => {
            const keytipId = sequencesToID(keytip.keySequences);
            seenIds[keytipId] = seenIds[keytipId] ? seenIds[keytipId] + 1 : 1;
            return keytip.visible && seenIds[keytipId] === 1;
        });
    }
    /**
     * Gets the ModifierKeyCodes based on the keyboard event
     *
     * @param ev - React.KeyboardEvent
     * @returns List of ModifierKeyCodes that were pressed
     */
    _getModifierKey(key, ev) {
        const modifierKeys = [];
        if (ev.altKey && key !== 'Alt') {
            modifierKeys.push(KeytipTransitionModifier.alt);
        }
        if (ev.ctrlKey && key !== 'Control') {
            modifierKeys.push(KeytipTransitionModifier.ctrl);
        }
        if (ev.shiftKey && key !== 'Shift') {
            modifierKeys.push(KeytipTransitionModifier.shift);
        }
        if (ev.metaKey && key !== 'Meta') {
            modifierKeys.push(KeytipTransitionModifier.meta);
        }
        return modifierKeys.length ? modifierKeys : undefined;
    }
    /**
     * Trigger a keytip immediately and set it as the current keytip
     *
     * @param keytipProps - Keytip to trigger immediately
     */
    _triggerKeytipImmediately(keytipProps) {
        // This keytip should become the currentKeytip and should execute right away
        let keytipSequence = [...keytipProps.keySequences];
        if (keytipProps.overflowSetSequence) {
            keytipSequence = mergeOverflows(keytipSequence, keytipProps.overflowSetSequence);
        }
        // Set currentKeytip
        this._keytipTree.currentKeytip = this._keytipTree.getNode(sequencesToID(keytipSequence));
        if (this._keytipTree.currentKeytip) {
            // Show all children keytips if any
            const children = this._keytipTree.getChildren();
            if (children.length) {
                this.showKeytips(children);
            }
            if (this._keytipTree.currentKeytip.onExecute) {
                this._keytipTree.currentKeytip.onExecute(this._getKtpExecuteTarget(this._keytipTree.currentKeytip), this._getKtpTarget(this._keytipTree.currentKeytip));
            }
        }
        // Unset _newCurrKtpSequences
        this._newCurrentKeytipSequences = undefined;
    }
    _addKeytipToQueue(keytipID) {
        // Add keytip
        this._delayedKeytipQueue.push(keytipID);
        // Clear timeout
        this._delayedQueueTimeout && this._async.clearTimeout(this._delayedQueueTimeout);
        // Reset timeout
        this._delayedQueueTimeout = this._async.setTimeout(() => {
            if (this._delayedKeytipQueue.length) {
                this.showKeytips(this._delayedKeytipQueue);
                this._delayedKeytipQueue = [];
            }
        }, 300);
    }
    _removeKeytipFromQueue(keytipID) {
        const index = this._delayedKeytipQueue.indexOf(keytipID);
        if (index >= 0) {
            // Remove keytip
            this._delayedKeytipQueue.splice(index, 1);
            // Clear timeout
            this._delayedQueueTimeout && this._async.clearTimeout(this._delayedQueueTimeout);
            // Reset timeout
            this._delayedQueueTimeout = this._async.setTimeout(() => {
                if (this._delayedKeytipQueue.length) {
                    this.showKeytips(this._delayedKeytipQueue);
                    this._delayedKeytipQueue = [];
                }
            }, 300);
        }
    }
    _getKtpExecuteTarget(currKtp) {
        return getDocument().querySelector(ktpTargetFromId(currKtp.id));
    }
    _getKtpTarget(currKtp) {
        return getDocument().querySelector(ktpTargetFromSequences(currKtp.keySequences));
    }
    /**
     * Returns T/F if the keytipProps keySequences match the currentKeytip, and the currentKeytip is in an overflow well
     * This will make 'keytipProps' the new currentKeytip
     *
     * @param keytipProps - Keytip props to check
     * @returns - T/F if this keytip should become the currentKeytip
     */
    _isCurrentKeytipAnAlias(keytipProps) {
        const currKtp = this._keytipTree.currentKeytip;
        if (currKtp && (currKtp.overflowSetSequence || currKtp.persisted) && arraysEqual(keytipProps.keySequences, currKtp.keySequences)) {
            return true;
        }
        return false;
    }
}
KeytipLayerBase.defaultProps = {
    keytipStartSequences: [defaultStartSequence],
    keytipExitSequences: [defaultExitSequence],
    keytipReturnSequences: [defaultReturnSequence],
    content: ''
};

const KeytipLayer = styled(KeytipLayerBase, getStyles$14, undefined, {
    scope: 'KeytipLayer'
});

const getClassNames$Z = classNamesFunction();
// We want to make the marquee selection start when the user drags a minimum distance. Otherwise we'd start
// the drag even if they just click an item without moving.
const MIN_DRAG_DISTANCE = 5;
/**
 * MarqueeSelection component abstracts managing a draggable rectangle which sets items selected/not selected.
 * Elements which have data-selectable-index attributes are queried and measured once to determine if they
 * fall within the bounds of the rectangle. The measure is memoized during the drag as a performance optimization
 * so if the items change sizes while dragging, that could cause incorrect results.
 */
class MarqueeSelectionBase extends BaseComponent {
    constructor(props) {
        super(props);
        this._root = createRef();
        this._onMouseDown = (ev) => {
            const { isEnabled, onShouldStartSelection } = this.props;
            // Ensure the mousedown is within the boundaries of the target. If not, it may have been a click on a scrollbar.
            if (this._isMouseEventOnScrollbar(ev)) {
                return;
            }
            if (this._isInSelectionToggle(ev)) {
                return;
            }
            if (!this._isTouch && isEnabled && !this._isDragStartInSelection(ev) && (!onShouldStartSelection || onShouldStartSelection(ev))) {
                if (this._scrollableSurface && ev.button === 0 && this._root.current) {
                    this._selectedIndicies = {};
                    this._preservedIndicies = undefined;
                    this._events.on(window, 'mousemove', this._onAsyncMouseMove);
                    this._events.on(this._scrollableParent, 'scroll', this._onAsyncMouseMove);
                    this._events.on(window, 'click', this._onMouseUp, true);
                    this._autoScroll = new AutoScroll(this._root.current);
                    this._scrollTop = this._scrollableSurface.scrollTop;
                    this._rootRect = this._root.current.getBoundingClientRect();
                    this._onMouseMove(ev);
                }
            }
        };
        this._onTouchStart = (ev) => {
            this._isTouch = true;
            this._async.setTimeout(() => {
                this._isTouch = false;
            }, 0);
        };
        this._onPointerDown = (ev) => {
            if (ev.pointerType === 'touch') {
                this._isTouch = true;
                this._async.setTimeout(() => {
                    this._isTouch = false;
                }, 0);
            }
        };
        this.state = {
            dragRect: undefined
        };
    }
    componentDidMount() {
        this._scrollableParent = findScrollableParent(this._root.current);
        this._scrollableSurface = this._scrollableParent === window ? document.body : this._scrollableParent;
        // When scroll events come from window, we need to read scrollTop values from the body.
        const hitTarget = this.props.isDraggingConstrainedToRoot ? this._root.current : this._scrollableSurface;
        this._events.on(hitTarget, 'mousedown', this._onMouseDown);
        this._events.on(hitTarget, 'touchstart', this._onTouchStart, true);
        this._events.on(hitTarget, 'pointerdown', this._onPointerDown, true);
    }
    componentWillUnmount() {
        if (this._autoScroll) {
            this._autoScroll.dispose();
        }
    }
    render() {
        const { rootProps, children, theme, className, styles } = this.props;
        const { dragRect } = this.state;
        const classNames = getClassNames$Z(styles, {
            theme: theme,
            className
        });
        return (createElement("div", Object.assign({}, rootProps, { className: classNames.root, ref: this._root }),
            children,
            dragRect && createElement("div", { className: classNames.dragMask }),
            dragRect && (createElement("div", { className: classNames.box, style: dragRect },
                createElement("div", { className: classNames.boxFill })))));
    }
    /** Determine if the mouse event occured on a scrollbar of the target element. */
    _isMouseEventOnScrollbar(ev) {
        const targetElement = ev.target;
        const targetScrollbarWidth = targetElement.offsetWidth - targetElement.clientWidth;
        if (targetScrollbarWidth) {
            const targetRect = targetElement.getBoundingClientRect();
            // Check vertical scroll
            if (getRTL()) {
                if (ev.clientX < targetRect.left + targetScrollbarWidth) {
                    return true;
                }
            }
            else {
                if (ev.clientX > targetRect.left + targetElement.clientWidth) {
                    return true;
                }
            }
            // Check horizontal scroll
            if (ev.clientY > targetRect.top + targetElement.clientHeight) {
                return true;
            }
        }
        return false;
    }
    _getRootRect() {
        return {
            left: this._rootRect.left,
            top: this._rootRect.top + (this._scrollTop - this._scrollableSurface.scrollTop),
            width: this._rootRect.width,
            height: this._rootRect.height
        };
    }
    _onAsyncMouseMove(ev) {
        this._async.requestAnimationFrame(() => {
            this._onMouseMove(ev);
        });
        ev.stopPropagation();
        ev.preventDefault();
    }
    _onMouseMove(ev) {
        if (!this._autoScroll) {
            return;
        }
        if (ev.clientX !== undefined) {
            this._lastMouseEvent = ev;
        }
        const rootRect = this._getRootRect();
        const currentPoint = { x: ev.clientX - rootRect.left, y: ev.clientY - rootRect.top };
        if (!this._dragOrigin) {
            this._dragOrigin = currentPoint;
        }
        if (ev.buttons !== undefined && ev.buttons === 0) {
            this._onMouseUp(ev);
        }
        else {
            if (this.state.dragRect || getDistanceBetweenPoints(this._dragOrigin, currentPoint) > MIN_DRAG_DISTANCE) {
                if (!this.state.dragRect) {
                    const { selection } = this.props;
                    this._preservedIndicies = selection && selection.getSelectedIndices && selection.getSelectedIndices();
                }
                // We need to constrain the current point to the rootRect boundaries.
                const constrainedPoint = this.props.isDraggingConstrainedToRoot
                    ? {
                        x: Math.max(0, Math.min(rootRect.width, this._lastMouseEvent.clientX - rootRect.left)),
                        y: Math.max(0, Math.min(rootRect.height, this._lastMouseEvent.clientY - rootRect.top))
                    }
                    : {
                        x: this._lastMouseEvent.clientX - rootRect.left,
                        y: this._lastMouseEvent.clientY - rootRect.top
                    };
                const dragRect = {
                    left: Math.min(this._dragOrigin.x, constrainedPoint.x),
                    top: Math.min(this._dragOrigin.y, constrainedPoint.y),
                    width: Math.abs(constrainedPoint.x - this._dragOrigin.x),
                    height: Math.abs(constrainedPoint.y - this._dragOrigin.y)
                };
                this._evaluateSelection(dragRect, rootRect);
                this.setState({ dragRect });
            }
        }
        return false;
    }
    _onMouseUp(ev) {
        this._events.off(window);
        this._events.off(this._scrollableParent, 'scroll');
        if (this._autoScroll) {
            this._autoScroll.dispose();
        }
        this._autoScroll = this._dragOrigin = this._lastMouseEvent = this._selectedIndicies = this._itemRectCache = undefined;
        if (this.state.dragRect) {
            this.setState({
                dragRect: undefined
            });
            ev.preventDefault();
            ev.stopPropagation();
        }
    }
    _isPointInRectangle(rectangle, point) {
        return rectangle.top < point.y && rectangle.bottom > point.y && rectangle.left < point.x && rectangle.right > point.x;
    }
    /**
     * We do not want to start the marquee if we're trying to marquee
     * from within an existing marquee selection.
     */
    _isDragStartInSelection(ev) {
        const selection = this.props.selection;
        if (!this._root.current || (selection && selection.getSelectedCount() === 0)) {
            return false;
        }
        const allElements = this._root.current.querySelectorAll('[data-selection-index]');
        for (let i = 0; i < allElements.length; i++) {
            const element = allElements[i];
            const index = Number(element.getAttribute('data-selection-index'));
            if (selection.isIndexSelected(index)) {
                const itemRect = element.getBoundingClientRect();
                if (this._isPointInRectangle(itemRect, { x: ev.clientX, y: ev.clientY })) {
                    return true;
                }
            }
        }
        return false;
    }
    _isInSelectionToggle(ev) {
        let element = ev.target;
        while (element && element !== this._root.current) {
            if (element.getAttribute('data-selection-toggle') === 'true') {
                return true;
            }
            element = element.parentElement;
        }
        return false;
    }
    _evaluateSelection(dragRect, rootRect) {
        // Break early if we don't need to evaluate.
        if (!dragRect || !this._root.current) {
            return;
        }
        const { selection } = this.props;
        const allElements = this._root.current.querySelectorAll('[data-selection-index]');
        if (!this._itemRectCache) {
            this._itemRectCache = {};
        }
        // Stop change events, clear selection to re-populate.
        selection.setChangeEvents(false);
        selection.setAllSelected(false);
        for (let i = 0; i < allElements.length; i++) {
            const element = allElements[i];
            const index = element.getAttribute('data-selection-index');
            // Pull the memoized rectangle for the item, or the get the rect and memoize.
            let itemRect = this._itemRectCache[index];
            if (!itemRect) {
                itemRect = element.getBoundingClientRect();
                // Normalize the item rect to the dragRect coordinates.
                itemRect = {
                    left: itemRect.left - rootRect.left,
                    top: itemRect.top - rootRect.top,
                    width: itemRect.width,
                    height: itemRect.height,
                    right: itemRect.left - rootRect.left + itemRect.width,
                    bottom: itemRect.top - rootRect.top + itemRect.height
                };
                if (itemRect.width > 0 && itemRect.height > 0) {
                    this._itemRectCache[index] = itemRect;
                }
            }
            if (itemRect.top < dragRect.top + dragRect.height &&
                itemRect.bottom > dragRect.top &&
                itemRect.left < dragRect.left + dragRect.width &&
                itemRect.right > dragRect.left) {
                this._selectedIndicies[index] = true;
            }
            else {
                delete this._selectedIndicies[index];
            }
        }
        for (const index in this._selectedIndicies) {
            if (this._selectedIndicies.hasOwnProperty(index)) {
                selection.setIndexSelected(Number(index), true, false);
            }
        }
        if (this._preservedIndicies) {
            for (const index of this._preservedIndicies) {
                selection.setIndexSelected(index, true, false);
            }
        }
        selection.setChangeEvents(true);
    }
}
MarqueeSelectionBase.defaultProps = {
    rootTagName: 'div',
    rootProps: {},
    isEnabled: true
};

const getStyles$15 = (props) => {
    const { theme, className } = props;
    const { palette } = theme;
    return {
        root: [
            className,
            {
                position: 'relative',
                cursor: 'default'
            }
        ],
        dragMask: [
            {
                position: 'absolute',
                background: 'rgba(255, 0, 0, 0)',
                left: 0,
                top: 0,
                right: 0,
                bottom: 0,
                selectors: {
                    [HighContrastSelector]: {
                        background: 'none',
                        backgroundColor: 'transparent'
                    }
                }
            }
        ],
        box: [
            {
                position: 'absolute',
                boxSizing: 'border-box',
                border: `1px solid ${palette.themePrimary}`,
                pointerEvents: 'none',
                zIndex: 10,
                selectors: {
                    [HighContrastSelector]: {
                        borderColor: 'Highlight'
                    }
                }
            }
        ],
        boxFill: [
            {
                position: 'absolute',
                boxSizing: 'border-box',
                backgroundColor: palette.themePrimary,
                opacity: 0.1,
                left: 0,
                top: 0,
                right: 0,
                bottom: 0,
                selectors: {
                    [HighContrastSelector]: {
                        background: 'none',
                        backgroundColor: 'transparent'
                    }
                }
            }
        ]
    };
};

const MarqueeSelection = styled(MarqueeSelectionBase, getStyles$15, undefined, {
    scope: 'MarqueeSelection'
});

var MessageBarType;
(function (MessageBarType) {
    /** Info styled MessageBar */
    MessageBarType[MessageBarType["info"] = 0] = "info";
    /** Error styled MessageBar */
    MessageBarType[MessageBarType["error"] = 1] = "error";
    /** Blocked styled MessageBar */
    MessageBarType[MessageBarType["blocked"] = 2] = "blocked";
    /** SevereWarning styled MessageBar */
    MessageBarType[MessageBarType["severeWarning"] = 3] = "severeWarning";
    /** Success styled MessageBar */
    MessageBarType[MessageBarType["success"] = 4] = "success";
    /** Warning styled MessageBar */
    MessageBarType[MessageBarType["warning"] = 5] = "warning";
    /**
     * Deprecated at v0.48.0, to be removed at \>= v1.0.0. Use `blocked` instead.
     * @deprecated Use `blocked` instead.
     */
    MessageBarType[MessageBarType["remove"] = 90000] = "remove";
})(MessageBarType || (MessageBarType = {}));

const getClassNames$_ = classNamesFunction();
class MessageBarBase extends BaseComponent {
    constructor(props) {
        super(props);
        this.ICON_MAP = {
            [MessageBarType.info]: 'Info',
            [MessageBarType.warning]: 'Info',
            [MessageBarType.error]: 'ErrorBadge',
            [MessageBarType.blocked]: 'Blocked2',
            [MessageBarType.remove]: 'Blocked',
            [MessageBarType.severeWarning]: 'Warning',
            [MessageBarType.success]: 'Completed'
        };
        this._onClick = (ev) => {
            this.setState({ expandSingleLine: !this.state.expandSingleLine });
        };
        this.state = {
            labelId: getId('MessageBar'),
            showContent: false,
            expandSingleLine: false
        };
    }
    render() {
        const { isMultiline } = this.props;
        this._classNames = this._getClassNames();
        return isMultiline ? this._renderMultiLine() : this._renderSingleLine();
    }
    _getActionsDiv() {
        if (this.props.actions) {
            return createElement("div", { className: this._classNames.actions }, this.props.actions);
        }
        return null;
    }
    _getDismissDiv() {
        if (this.props.onDismiss) {
            return (createElement(IconButton, { disabled: false, className: this._classNames.dismissal, onClick: this.props.onDismiss, iconProps: { iconName: 'Clear' }, ariaLabel: this.props.dismissButtonAriaLabel }));
        }
        return null;
    }
    _getDismissSingleLine() {
        if (this.props.onDismiss) {
            return createElement("div", { className: this._classNames.dismissSingleLine }, this._getDismissDiv());
        }
        return null;
    }
    _getExpandSingleLine() {
        if (!this.props.actions && this.props.truncated) {
            return (createElement("div", { className: this._classNames.expandSingleLine },
                createElement(IconButton, { disabled: false, className: this._classNames.expand, onClick: this._onClick, iconProps: { iconName: this.state.expandSingleLine ? 'DoubleChevronUp' : 'DoubleChevronDown' }, ariaLabel: this.props.overflowButtonAriaLabel, "aria-expanded": this.state.expandSingleLine, "aria-controls": this.state.labelId })));
        }
        return null;
    }
    _getIconSpan() {
        return (createElement("div", { className: this._classNames.iconContainer },
            createElement(Icon, { iconName: this.ICON_MAP[this.props.messageBarType], className: this._classNames.icon })));
    }
    _renderMultiLine() {
        return (createElement("div", { className: this._classNames.root, "aria-live": this._getAnnouncementPriority() },
            createElement("div", { className: this._classNames.content },
                this._getIconSpan(),
                this._renderInnerText(),
                this._getDismissDiv()),
            this._getActionsDiv()));
    }
    _renderSingleLine() {
        return (createElement("div", { className: this._classNames.root },
            createElement("div", { className: this._classNames.content },
                this._getIconSpan(),
                this._renderInnerText(),
                this._getExpandSingleLine(),
                this._getActionsDiv(),
                this._getDismissSingleLine())));
    }
    _renderInnerText() {
        return (createElement("div", { className: this._classNames.text, id: this.state.labelId },
            createElement("span", { className: this._classNames.innerText, role: "status", "aria-live": this._getAnnouncementPriority() },
                createElement(DelayedRender, null,
                    createElement("span", null, this.props.children)))));
    }
    _getClassNames() {
        const { theme, className, messageBarType, onDismiss, actions, truncated, isMultiline } = this.props;
        const { expandSingleLine } = this.state;
        return getClassNames$_(this.props.styles, {
            theme: theme,
            messageBarType: messageBarType || MessageBarType.info,
            onDismiss: onDismiss !== undefined,
            actions: actions !== undefined,
            truncated: truncated,
            isMultiline: isMultiline,
            expandSingleLine: expandSingleLine,
            className
        });
    }
    _getAnnouncementPriority() {
        switch (this.props.messageBarType) {
            case MessageBarType.blocked:
            case MessageBarType.error:
            case MessageBarType.severeWarning:
                return 'assertive';
        }
        return 'polite';
    }
}
MessageBarBase.defaultProps = {
    messageBarType: MessageBarType.info,
    onDismiss: undefined,
    isMultiline: true
};

const GlobalClassNames$I = {
    root: 'ms-MessageBar',
    error: 'ms-MessageBar--error',
    blocked: 'ms-MessageBar--blocked',
    severeWarning: 'ms-MessageBar--severeWarning',
    success: 'ms-MessageBar--success',
    warning: 'ms-MessageBar--warning',
    multiline: 'ms-MessageBar-multiline',
    singleline: 'ms-MessageBar-singleline',
    dismissalSingleLine: 'ms-MessageBar-dismissalSingleLine',
    expandingSingleLine: 'ms-MessageBar-expandingSingleLine',
    content: 'ms-MessageBar-content',
    iconContainer: 'ms-MessageBar-icon',
    text: 'ms-MessageBar-text',
    innerText: 'ms-MessageBar-innerText',
    dismissSingleLine: 'ms-MessageBar-dismissSingleLine',
    expandSingleLine: 'ms-MessageBar-expandSingleLine',
    dismissal: 'ms-MessageBar-dismissal',
    expand: 'ms-MessageBar-expand',
    actions: 'ms-MessageBar-actions',
    actionsSingleline: 'ms-MessageBar-actionsSingleLine'
};
// Returns the background color of the MessageBar root element based on the type of MessageBar.
const getRootBackground = (messageBarType, palette, semanticColors) => {
    switch (messageBarType) {
        case MessageBarType.error:
        case MessageBarType.blocked:
            return semanticColors.errorBackground;
        case MessageBarType.severeWarning:
            return semanticColors.blockingBackground;
        case MessageBarType.success:
            return semanticColors.successBackground;
        case MessageBarType.warning:
            return semanticColors.warningBackground;
    }
    return palette.neutralLighter;
};
// Returns the icon color based on the type of MessageBar.
const getIconColor = (messageBarType, palette, semanticColors) => {
    switch (messageBarType) {
        case MessageBarType.error:
        case MessageBarType.blocked:
        case MessageBarType.severeWarning:
            return semanticColors.errorText;
        case MessageBarType.success:
            return palette.green;
        case MessageBarType.warning:
            return semanticColors.warningText;
    }
    return palette.neutralSecondary;
};
const getStyles$16 = (props) => {
    const { theme, className, messageBarType, onDismiss, actions, truncated, isMultiline, expandSingleLine } = props;
    const { semanticColors, palette, fonts } = theme;
    const SmallScreenSelector = getScreenSelector(0, ScreenWidthMaxSmall);
    const classNames = getGlobalClassNames(GlobalClassNames$I, theme);
    const dismissalAndExpandIconStyle = {
        fontSize: 12,
        height: 12,
        lineHeight: '12px',
        color: palette.neutralPrimary
    };
    const dismissalAndExpandSingleLineStyle = {
        display: 'flex',
        selectors: {
            '& .ms-Button-icon': dismissalAndExpandIconStyle
        }
    };
    const dismissalAndExpandStyle = {
        flexShrink: 0,
        margin: 8,
        marginLeft: 0,
        selectors: {
            '& .ms-Button-icon': dismissalAndExpandIconStyle,
            [SmallScreenSelector]: {
                margin: '0px 0px 0px 8px'
            },
            [HighContrastSelector]: {
                MsHighContrastAdjust: 'none'
            }
        }
    };
    const focusStyle = getFocusStyle(theme, 0, 'relative', undefined, palette.black);
    return {
        root: [
            classNames.root,
            theme.fonts.medium,
            messageBarType === MessageBarType.error && classNames.error,
            messageBarType === MessageBarType.blocked && classNames.blocked,
            messageBarType === MessageBarType.severeWarning && classNames.severeWarning,
            messageBarType === MessageBarType.success && classNames.success,
            messageBarType === MessageBarType.warning && classNames.warning,
            isMultiline ? classNames.multiline : classNames.singleline,
            !isMultiline && onDismiss && classNames.dismissalSingleLine,
            !isMultiline && truncated && classNames.expandingSingleLine,
            {
                background: getRootBackground(messageBarType, palette, semanticColors),
                color: palette.neutralPrimary,
                minHeight: 32,
                width: '100%',
                boxSizing: 'border-box',
                display: 'flex',
                position: 'relative',
                wordBreak: 'break-word',
                selectors: {
                    '& .ms-Link': {
                        color: palette.themeDark,
                        ...fonts.small
                    }
                }
            },
            isMultiline && {
                flexDirection: 'column'
            },
            !isMultiline && {
                selectors: {
                    [SmallScreenSelector]: {
                        flexDirection: 'column'
                    }
                }
            },
            truncated && {
                flexDirection: 'column',
                selectors: {
                    '& .ms-Button-icon': {
                        fontSize: 12,
                        height: 12,
                        lineHeight: 12,
                        color: palette.neutralPrimary
                    }
                }
            },
            className
        ],
        content: [
            classNames.content,
            {
                display: 'flex',
                lineHeight: 'normal',
                width: '100%',
                boxSizing: 'border-box',
                selectors: {
                    '&:before': {
                        pointerEvents: 'none',
                        position: 'absolute',
                        right: 0,
                        bottom: 0,
                        left: 0,
                        top: 0,
                        margin: 0,
                        selectors: {
                            [HighContrastSelector]: {
                                border: '1px solid WindowText',
                                content: ' '
                            }
                        }
                    }
                }
            },
            !isMultiline && {
                selectors: {
                    [SmallScreenSelector]: {
                        flexDirection: 'row'
                    }
                }
            },
            (truncated || isMultiline) && {
                flexDirection: 'row'
            }
        ],
        iconContainer: [
            classNames.iconContainer,
            {
                fontSize: 16,
                minWidth: 16,
                minHeight: 16,
                display: 'flex',
                color: palette.neutralSecondary,
                flexShrink: 0,
                margin: 16,
                marginRight: 0,
                selectors: {
                    [SmallScreenSelector]: {
                        margin: '8px 0px 8px 8px'
                    }
                }
            }
        ],
        icon: {
            color: getIconColor(messageBarType, palette, semanticColors)
        },
        text: [
            classNames.text,
            {
                minWidth: 0,
                display: 'flex',
                flexGrow: 1,
                margin: '16px 8px',
                ...fonts.small,
                selectors: {
                    [SmallScreenSelector]: {
                        margin: '8px 0px 8px 8px'
                    }
                }
            },
            !onDismiss && {
                marginRight: 16,
                selectors: {
                    [SmallScreenSelector]: {
                        marginRight: 8
                    }
                }
            },
            isMultiline &&
                actions && {
                marginBottom: 8,
                selectors: {
                    [SmallScreenSelector]: {
                        marginBottom: 0
                    }
                }
            },
            !isMultiline &&
                actions && {
                selectors: {
                    [SmallScreenSelector]: {
                        marginBottom: 0
                    }
                }
            }
        ],
        innerText: [
            classNames.innerText,
            {
                lineHeight: 16,
                selectors: {
                    '& span': {
                        selectors: {
                            '& a': {
                                paddingLeft: 4
                            }
                        }
                    }
                }
            },
            truncated && {
                overflow: 'visible',
                whiteSpace: 'pre-wrap'
            },
            !isMultiline && {
                overflow: 'hidden',
                textOverflow: 'ellipsis',
                whiteSpace: 'nowrap'
            },
            !isMultiline &&
                !truncated && {
                selectors: {
                    [SmallScreenSelector]: {
                        overflow: 'visible',
                        whiteSpace: 'pre-wrap'
                    }
                }
            },
            expandSingleLine && {
                overflow: 'visible',
                whiteSpace: 'pre-wrap'
            }
        ],
        dismissSingleLine: [classNames.dismissSingleLine, dismissalAndExpandSingleLineStyle],
        expandSingleLine: [classNames.expandSingleLine, dismissalAndExpandSingleLineStyle],
        dismissal: [classNames.dismissal, dismissalAndExpandStyle, focusStyle],
        expand: [classNames.expand, dismissalAndExpandStyle, focusStyle],
        actions: [
            isMultiline ? classNames.actions : classNames.actionsSingleline,
            {
                display: 'flex',
                flexGrow: 0,
                flexShrink: 0,
                flexBasis: 'auto',
                flexDirection: 'row-reverse',
                alignItems: 'center',
                margin: '8px 8px 8px 0',
                selectors: {
                    '& button:nth-child(n+2)': {
                        marginLeft: 8
                    }
                }
            },
            isMultiline && {
                margin: '0px 12px 12px 0',
                selectors: {
                    '& button:nth-child(n+2)': {
                        marginLeft: 12
                    }
                }
            }
        ]
    };
};

const MessageBar = styled(MessageBarBase, getStyles$16, undefined, {
    scope: 'MessageBar'
});

const GlobalClassNames$J = {
    root: 'ms-Nav',
    linkText: 'ms-Nav-linkText',
    compositeLink: 'ms-Nav-compositeLink',
    link: 'ms-Nav-link',
    chevronButton: 'ms-Nav-chevronButton',
    chevronIcon: 'ms-Nav-chevron',
    navItem: 'ms-Nav-navItem',
    navItems: 'ms-Nav-navItems',
    group: 'ms-Nav-group',
    groupContent: 'ms-Nav-groupContent'
};
const buttonStyles = {
    textContainer: {
        overflow: 'hidden'
    },
    label: {
        whiteSpace: 'nowrap',
        textOverflow: 'ellipsis',
        overflow: 'hidden',
        lineHeight: '36px'
    }
};
const getStyles$17 = (props) => {
    const { className, theme, isOnTop, isExpanded, isGroup, isLink, isSelected, isButtonEntry, navHeight = 36, position, leftPadding = 20, leftPaddingExpanded = 28, rightPadding = 20 } = props;
    const { palette, semanticColors } = theme;
    const classNames = getGlobalClassNames(GlobalClassNames$J, theme);
    return {
        root: [
            classNames.root,
            className,
            theme.fonts.medium,
            {
                overflowY: 'auto',
                userSelect: 'none',
                WebkitOverflowScrolling: 'touch'
            },
            isOnTop && [
                {
                    position: 'absolute'
                },
                AnimationClassNames.slideRightIn40
            ]
        ],
        linkText: [
            classNames.linkText,
            {
                margin: '0 4px',
                overflow: 'hidden',
                verticalAlign: 'middle',
                textOverflow: 'ellipsis'
            }
        ],
        compositeLink: [
            classNames.compositeLink,
            {
                display: 'block',
                position: 'relative',
                color: semanticColors.bodyText,
                backgroundColor: semanticColors.bodyBackground
            },
            isExpanded && 'is-expanded',
            isSelected && 'is-selected'
        ],
        link: [
            classNames.link,
            getFocusStyle(theme),
            {
                display: 'block',
                position: 'relative',
                height: `${navHeight}px`,
                width: '100%',
                lineHeight: `${navHeight}px`,
                textDecoration: 'none',
                cursor: 'pointer',
                textOverflow: 'ellipsis',
                whiteSpace: 'nowrap',
                overflow: 'hidden',
                paddingLeft: leftPadding,
                paddingRight: rightPadding,
                selectors: {
                    '.ms-Nav-compositeLink:hover &': {
                        backgroundColor: palette.neutralLighterAlt,
                        color: semanticColors.bodyText
                    }
                }
            },
            isSelected && {
                color: palette.themePrimary,
                backgroundColor: palette.neutralLighter,
                selectors: {
                    '&:after': {
                        borderLeft: `2px solid ${palette.themePrimary}`,
                        content: '""',
                        position: 'absolute',
                        top: 0,
                        right: 0,
                        bottom: 0,
                        left: 0,
                        pointerEvents: 'none'
                    }
                }
            },
            isButtonEntry && {
                color: palette.themePrimary
            }
        ],
        chevronButton: [
            classNames.chevronButton,
            getFocusStyle(theme),
            {
                display: 'block',
                fontWeight: FontWeights.regular,
                fontSize: FontSizes.small,
                textAlign: 'left',
                lineHeight: `${navHeight}px`,
                margin: '5px 0',
                padding: `0px, ${rightPadding}px, 0px, ${leftPaddingExpanded}px`,
                border: 'none',
                textOverflow: 'ellipsis',
                whiteSpace: 'nowrap',
                overflow: 'hidden',
                cursor: 'pointer',
                color: semanticColors.bodyText,
                backgroundColor: 'transparent',
                selectors: {
                    '&:visited': {
                        color: 'inherit'
                    },
                    '&:hover': {
                        color: semanticColors.bodyText,
                        backgroundColor: palette.neutralLighterAlt
                    },
                    '$compositeLink:hover &': {
                        color: semanticColors.bodyText,
                        backgroundColor: palette.neutralLighterAlt
                    }
                }
            },
            isGroup && [
                {
                    width: '100%',
                    height: `${navHeight}px`,
                    borderBottom: `1px solid ${semanticColors.bodyDivider}`
                },
                DefaultFontStyles.large
            ],
            isLink && [
                {
                    display: 'block',
                    width: `${leftPaddingExpanded - 2}px`,
                    height: `${navHeight - 2}px`,
                    position: 'absolute',
                    top: '1px',
                    left: `${position}px`,
                    zIndex: ZIndexes.Nav,
                    padding: 0,
                    margin: 0
                }
            ],
            isSelected && {
                color: palette.themePrimary,
                backgroundColor: palette.neutralLighterAlt,
                selectors: {
                    '&:after': {
                        borderLeft: `2px solid ${palette.themePrimary}`,
                        content: '""',
                        position: 'absolute',
                        top: 0,
                        right: 0,
                        bottom: 0,
                        left: 0,
                        pointerEvents: 'none'
                    }
                }
            }
        ],
        chevronIcon: [
            classNames.chevronIcon,
            {
                position: 'absolute',
                left: '8px',
                height: `${navHeight}px`,
                lineHeight: `${navHeight}px`,
                fontSize: '12px',
                transition: 'transform .1s linear'
            },
            isExpanded && {
                transform: 'rotate(-180deg)'
            },
            isLink && {
                top: 0
            }
        ],
        navItem: [
            classNames.navItem,
            {
                padding: 0
            }
        ],
        navItems: [
            classNames.navItems,
            {
                listStyleType: 'none',
                padding: 0
            }
        ],
        group: [classNames.group, isExpanded && 'is-expanded'],
        groupContent: [
            classNames.groupContent,
            {
                display: 'none',
                marginBottom: '40px'
            },
            AnimationClassNames.slideDownIn20,
            isExpanded && {
                display: 'block'
            }
        ]
    };
};

// The number pixels per indentation level for Nav links.
const _indentationSize = 14;
// The number of pixels of left margin
const _baseIndent = 3;
// global var used in _isLinkSelectedKey
let _urlResolver;
function isRelativeUrl(url) {
    // A URL is relative if it has no protocol.
    return !!url && !/^[a-z0-9+-.]:\/\//i.test(url);
}
const getClassNames$10 = classNamesFunction();
class NavBase extends BaseComponent {
    constructor(props) {
        super(props);
        this._onRenderLink = (link) => {
            const { styles, groups, theme } = this.props;
            const classNames = getClassNames$10(styles, { theme: theme, groups });
            return createElement("div", { className: classNames.linkText }, link.name);
        };
        this._renderGroup = (group, groupIndex) => {
            const { styles, groups, theme, onRenderGroupHeader = this._renderGroupHeader } = this.props;
            const classNames = getClassNames$10(styles, {
                theme: theme,
                isGroup: true,
                isExpanded: !this.state.isGroupCollapsed[group.name],
                groups
            });
            return (createElement("div", { key: groupIndex, className: classNames.group },
                group.name ? onRenderGroupHeader(group, this._renderGroupHeader) : null,
                createElement("div", { className: classNames.groupContent }, this._renderLinks(group.links, 0 /* nestingLevel */))));
        };
        this._renderGroupHeader = (group) => {
            const { styles, groups, theme, expandButtonAriaLabel } = this.props;
            const classNames = getClassNames$10(styles, {
                theme: theme,
                isGroup: true,
                isExpanded: !this.state.isGroupCollapsed[group.name],
                groups
            });
            return (createElement("button", { className: classNames.chevronButton, onClick: this._onGroupHeaderClicked.bind(this, group), "aria-label": expandButtonAriaLabel, "aria-expanded": !this.state.isGroupCollapsed[group.name] },
                createElement(Icon, { className: classNames.chevronIcon, iconName: "ChevronDown" }),
                group.name));
        };
        this.state = {
            isGroupCollapsed: {},
            isLinkExpandStateChanged: false,
            selectedKey: props.initialSelectedKey || props.selectedKey
        };
        if (props.groups) {
            for (const group of props.groups) {
                if (group.collapseByDefault && group.name) {
                    this.state.isGroupCollapsed[group.name] = true;
                }
            }
        }
    }
    componentWillReceiveProps(newProps) {
        const newGroups = newProps.groups || [];
        const isGroupCollapsed = this.state.isGroupCollapsed;
        // If the component's props were updated, new groups may have been added, which may have
        // collapseByDefault set. Ensure that setting is respected for any new groups.
        // (If isGroupCollapsed is already set for a group, don't overwrite that.)
        let hasUpdated = false;
        for (const newGroup of newGroups) {
            if (newGroup.name && newGroup.collapseByDefault && !isGroupCollapsed.hasOwnProperty(newGroup.name)) {
                isGroupCollapsed[newGroup.name] = true;
                hasUpdated = true;
            }
        }
        if (hasUpdated) {
            this.setState({
                isGroupCollapsed: isGroupCollapsed
            });
        }
    }
    render() {
        const { styles, groups, className, isOnTop, theme } = this.props;
        if (!groups) {
            return null;
        }
        const groupElements = groups.map(this._renderGroup);
        const classNames = getClassNames$10(styles, { theme: theme, className, isOnTop, groups });
        return (createElement(FocusZone, { direction: FocusZoneDirection.vertical },
            createElement("nav", { role: "navigation", className: classNames.root, "aria-label": this.props.ariaLabel }, groupElements)));
    }
    get selectedKey() {
        return this.state.selectedKey;
    }
    _renderNavLink(link, linkIndex, nestingLevel) {
        const { styles, groups, theme, onRenderLink = this._onRenderLink, linkAs: LinkAs = ActionButton } = this.props;
        const classNames = getClassNames$10(styles, {
            theme: theme,
            isSelected: this._isLinkSelected(link),
            isButtonEntry: link.onClick && !link.forceAnchor,
            leftPadding: _indentationSize * nestingLevel + _baseIndent,
            groups
        });
        // Prevent hijacking of the parent window if link.target is defined
        const rel = link.url && link.target && !isRelativeUrl(link.url) ? 'noopener noreferrer' : undefined;
        return (createElement(LinkAs, { className: classNames.link, styles: buttonStyles, href: link.url || (link.forceAnchor ? 'javascript:' : undefined), iconProps: link.iconProps || { iconName: link.icon || '' }, onClick: link.onClick ? this._onNavButtonLinkClicked.bind(this, link) : this._onNavAnchorLinkClicked.bind(this, link), title: link.title || link.name, target: link.target, rel: rel, "aria-label": link.ariaLabel }, onRenderLink(link, this._onRenderLink)));
    }
    _renderCompositeLink(link, linkIndex, nestingLevel) {
        const divProps = { ...getNativeProps(link, divProperties, ['onClick']) };
        const { styles, groups, theme } = this.props;
        const classNames = getClassNames$10(styles, {
            theme: theme,
            isExpanded: !!link.isExpanded,
            isSelected: this._isLinkSelected(link),
            isLink: true,
            position: _indentationSize * nestingLevel + 1,
            groups
        });
        return (createElement("div", Object.assign({}, divProps, { key: link.key || linkIndex, className: classNames.compositeLink }),
            link.links && link.links.length > 0 ? (createElement("button", { className: classNames.chevronButton, onClick: this._onLinkExpandClicked.bind(this, link), "aria-label": this.props.expandButtonAriaLabel, "aria-expanded": link.isExpanded ? 'true' : 'false' },
                createElement(Icon, { className: classNames.chevronIcon, iconName: "ChevronDown" }))) : null,
            this._renderNavLink(link, linkIndex, nestingLevel)));
    }
    _renderLink(link, linkIndex, nestingLevel) {
        const { styles, groups, theme } = this.props;
        const classNames = getClassNames$10(styles, { theme: theme, groups });
        return (createElement("li", { key: link.key || linkIndex, role: "listitem", className: classNames.navItem },
            this._renderCompositeLink(link, linkIndex, nestingLevel),
            link.isExpanded ? this._renderLinks(link.links, ++nestingLevel) : null));
    }
    _renderLinks(links, nestingLevel) {
        if (!links || !links.length) {
            return null;
        }
        const linkElements = links.map((link, linkIndex) => this._renderLink(link, linkIndex, nestingLevel));
        const { styles, groups, theme } = this.props;
        const classNames = getClassNames$10(styles, { theme: theme, groups });
        return (createElement("ul", { role: "list", className: classNames.navItems }, linkElements));
    }
    _onGroupHeaderClicked(group, ev) {
        const { isGroupCollapsed } = this.state;
        const groupKey = group.name;
        const isCollapsed = !isGroupCollapsed[groupKey];
        if (group.onHeaderClick) {
            group.onHeaderClick(ev, isCollapsed);
        }
        isGroupCollapsed[groupKey] = isCollapsed;
        this.setState({ isGroupCollapsed: isGroupCollapsed });
        ev.preventDefault();
        ev.stopPropagation();
    }
    _onLinkExpandClicked(link, ev) {
        const { onLinkExpandClick } = this.props;
        if (onLinkExpandClick) {
            onLinkExpandClick(ev, link);
        }
        if (!ev.defaultPrevented) {
            link.isExpanded = !link.isExpanded;
            this.setState({ isLinkExpandStateChanged: true });
        }
        ev.preventDefault();
        ev.stopPropagation();
    }
    _onNavAnchorLinkClicked(link, ev) {
        if (this.props.onLinkClick) {
            this.props.onLinkClick(ev, link);
        }
        if (!link.url && link.links && link.links.length > 0) {
            this._onLinkExpandClicked(link, ev);
        }
        this.setState({ selectedKey: link.key });
    }
    _onNavButtonLinkClicked(link, ev) {
        if (link.onClick) {
            link.onClick(ev, link);
        }
        if (!link.url && link.links && link.links.length > 0) {
            this._onLinkExpandClicked(link, ev);
        }
        this.setState({ selectedKey: link.key });
    }
    _isLinkSelected(link) {
        // if caller passes in selectedKey, use it as first choice or
        // if current state.selectedKey (from addressbar) is match to the link
        if (this.props.selectedKey !== undefined) {
            return link.key === this.props.selectedKey;
        }
        else if (this.state.selectedKey !== undefined && link.key === this.state.selectedKey) {
            return true;
        }
        // resolve is not supported for ssr
        if (typeof window === 'undefined') {
            return false;
        }
        if (!link.url) {
            return false;
        }
        _urlResolver = _urlResolver || document.createElement('a');
        _urlResolver.href = link.url || '';
        const target = _urlResolver.href;
        if (location.href === target) {
            return true;
        }
        if (location.protocol + '//' + location.host + location.pathname === target) {
            return true;
        }
        if (location.hash) {
            // Match the hash to the url.
            if (location.hash === link.url) {
                return true;
            }
            // Match a rebased url. (e.g. #foo becomes http://hostname/foo)
            _urlResolver.href = location.hash.substring(1);
            return _urlResolver.href === target;
        }
        return false;
    }
}
NavBase.defaultProps = {
    groups: null
};

const Nav = styled(NavBase, getStyles$17, undefined, { scope: 'Nav' });

class PivotItem extends BaseComponent {
    render() {
        return createElement("div", Object.assign({}, getNativeProps(this.props, divProperties)), this.props.children);
    }
}

var PivotLinkFormat;
(function (PivotLinkFormat) {
    /**
     * Display Pivot Links as links
     */
    PivotLinkFormat[PivotLinkFormat["links"] = 0] = "links";
    /**
     * Display Pivot Links as Tabs
     */
    PivotLinkFormat[PivotLinkFormat["tabs"] = 1] = "tabs";
})(PivotLinkFormat || (PivotLinkFormat = {}));
var PivotLinkSize;
(function (PivotLinkSize) {
    /**
     * Display Link using normal font size
     */
    PivotLinkSize[PivotLinkSize["normal"] = 0] = "normal";
    /**
     * Display links using large font size
     */
    PivotLinkSize[PivotLinkSize["large"] = 1] = "large";
})(PivotLinkSize || (PivotLinkSize = {}));

const getClassNames$11 = classNamesFunction();
const PivotItemType = createElement(PivotItem, null).type;
class PivotBase extends BaseComponent {
    constructor(props) {
        super(props);
        this.focusZone = createRef();
        this._renderPivotLink = (link) => {
            const { itemKey, headerButtonProps } = link;
            const tabId = this._keyToTabIds[itemKey];
            const { onRenderItemLink } = link;
            let linkContent;
            const isSelected = this.state.selectedKey === itemKey;
            if (onRenderItemLink) {
                linkContent = onRenderItemLink(link, this._renderLinkContent);
            }
            else {
                linkContent = this._renderLinkContent(link);
            }
            return (createElement(CommandButton, Object.assign({}, headerButtonProps, { id: tabId, key: itemKey, className: isSelected ? this._classNames.linkIsSelected : this._classNames.link, onClick: this._onLinkClick.bind(this, itemKey), onKeyPress: this._onKeyPress.bind(this, itemKey), ariaLabel: link.ariaLabel, role: "tab", "aria-selected": this.state.selectedKey === itemKey, name: link.headerText, keytipProps: link.keytipProps }), linkContent));
        };
        this._renderLinkContent = (link) => {
            const { itemCount, itemIcon, headerText } = link;
            return (createElement("span", { className: this._classNames.linkContent },
                itemIcon !== undefined && (createElement("span", { className: this._classNames.icon },
                    createElement(Icon, { iconName: itemIcon }))),
                headerText !== undefined && createElement("span", { className: this._classNames.text },
                    " ",
                    link.headerText),
                itemCount !== undefined && createElement("span", { className: this._classNames.count },
                    " (",
                    itemCount,
                    ")")));
        };
        /**
         * Renders the current Pivot Item
         */
        this._renderPivotItem = () => {
            if (this.props.headersOnly) {
                return null;
            }
            const itemKey = this.state.selectedKey;
            const index = this._keyToIndexMapping[itemKey];
            const { selectedTabId } = this.state;
            return (createElement("div", { role: "tabpanel", "aria-labelledby": selectedTabId }, Children.toArray(this.props.children)[index]));
        };
        this._pivotId = getId('Pivot');
        const links = this._getPivotLinks(this.props);
        let selectedKey;
        if (props.initialSelectedKey) {
            selectedKey = props.initialSelectedKey;
        }
        else if (props.initialSelectedIndex) {
            selectedKey = links[props.initialSelectedIndex].itemKey;
        }
        else if (props.selectedKey) {
            selectedKey = props.selectedKey;
        }
        else if (links.length) {
            selectedKey = links[0].itemKey;
        }
        this.state = {
            links,
            selectedKey: selectedKey,
            selectedTabId: this._keyToTabIds[selectedKey]
        };
        this._renderPivotLink = this._renderPivotLink.bind(this);
    }
    componentWillReceiveProps(nextProps) {
        const links = this._getPivotLinks(nextProps);
        this.setState((prevState, props) => {
            let selectedKey;
            if (this._isKeyValid(nextProps.selectedKey)) {
                selectedKey = nextProps.selectedKey;
            }
            else if (this._isKeyValid(prevState.selectedKey)) {
                selectedKey = prevState.selectedKey;
            }
            else if (links.length) {
                selectedKey = links[0].itemKey;
            }
            return {
                links: links,
                selectedKey,
                selectedTabId: this._keyToTabIds[selectedKey]
            };
        });
    }
    /**
     * Sets focus to the first pivot tab.
     */
    focus() {
        if (this.focusZone.current) {
            this.focusZone.current.focus();
        }
    }
    render() {
        const divProps = getNativeProps(this.props, divProperties);
        this._classNames = this._getClassNames(this.props);
        return (createElement("div", Object.assign({}, divProps),
            this._renderPivotLinks(),
            this._renderPivotItem()));
    }
    /**
     * Renders the set of links to route between pivots
     */
    _renderPivotLinks() {
        const items = this.state.links.map(this._renderPivotLink);
        return (createElement(FocusZone, { componentRef: this.focusZone, direction: FocusZoneDirection.horizontal },
            createElement("div", { className: this._classNames.root, role: "tablist" }, items)));
    }
    /**
     * Gets the set of PivotLinks as arrary of IPivotItemProps
     * The set of Links is determined by child components of type PivotItem
     */
    _getPivotLinks(props) {
        const links = [];
        this._keyToIndexMapping = {};
        this._keyToTabIds = {};
        Children.map(props.children, (child, index) => {
            if (typeof child === 'object' && child.type === PivotItemType) {
                const pivotItem = child;
                const itemKey = pivotItem.props.itemKey || index.toString();
                links.push({
                    headerText: pivotItem.props.headerText || pivotItem.props.linkText,
                    headerButtonProps: pivotItem.props.headerButtonProps,
                    ariaLabel: pivotItem.props.ariaLabel,
                    itemKey: itemKey,
                    itemCount: pivotItem.props.itemCount,
                    itemIcon: pivotItem.props.itemIcon,
                    onRenderItemLink: pivotItem.props.onRenderItemLink,
                    keytipProps: pivotItem.props.keytipProps
                });
                this._keyToIndexMapping[itemKey] = index;
                this._keyToTabIds[itemKey] = this._getTabId(itemKey, index);
            }
            else {
                warn('The children of a Pivot component must be of type PivotItem to be rendered.');
            }
        });
        return links;
    }
    /**
     * Generates the Id for the tab button.
     */
    _getTabId(itemKey, index) {
        if (this.props.getTabId) {
            return this.props.getTabId(itemKey, index);
        }
        return this._pivotId + `-Tab${index}`;
    }
    /**
     * whether the key exists in the pivot items.
     */
    _isKeyValid(itemKey) {
        return itemKey !== undefined && this._keyToIndexMapping[itemKey] !== undefined;
    }
    /**
     * Handles the onClick event on PivotLinks
     */
    _onLinkClick(itemKey, ev) {
        ev.preventDefault();
        this._updateSelectedItem(itemKey, ev);
    }
    /**
     * Handle the onKeyPress eventon the PivotLinks
     */
    _onKeyPress(itemKey, ev) {
        if (ev.which === KeyCodes.enter) {
            ev.preventDefault();
            this._updateSelectedItem(itemKey);
        }
    }
    /**
     * Updates the state with the new selected index
     */
    _updateSelectedItem(itemKey, ev) {
        this.setState({
            selectedKey: itemKey,
            selectedTabId: this._keyToTabIds[itemKey]
        });
        if (this.props.onLinkClick && this._keyToIndexMapping[itemKey] >= 0) {
            const index = this._keyToIndexMapping[itemKey];
            // React.Element<any> cannot directly convert to PivotItem.
            const item = Children.toArray(this.props.children)[index];
            if (typeof item === 'object' && item.type === PivotItemType) {
                this.props.onLinkClick(item, ev);
            }
        }
    }
    _getClassNames(props) {
        const { theme } = props;
        const rootIsLarge = props.linkSize === PivotLinkSize.large;
        const rootIsTabs = props.linkFormat === PivotLinkFormat.tabs;
        return getClassNames$11(props.styles, {
            theme: theme,
            rootIsLarge,
            rootIsTabs
        });
    }
}

const globalClassNames$2 = {
    count: 'ms-Pivot-count',
    icon: 'ms-Pivot-icon',
    linkIsSelected: 'is-selected',
    link: 'ms-Pivot-link',
    linkContent: 'ms-Pivot-linkContent',
    root: 'ms-Pivot',
    rootIsLarge: 'ms-Pivot--large',
    rootIsTabs: 'ms-Pivot--tabs',
    text: 'ms-Pivot-text'
};
const linkStyles = (props) => {
    const { rootIsLarge, rootIsTabs, theme } = props;
    const { palette, semanticColors } = props.theme;
    return [
        {
            color: semanticColors.actionLink,
            display: 'inline-block',
            fontSize: FontSizes.medium,
            fontWeight: FontWeights.regular,
            lineHeight: '40px',
            marginRight: '8px',
            padding: '0 8px',
            textAlign: 'center',
            position: 'relative',
            backgroundColor: 'transparent',
            border: 0,
            selectors: {
                ':before': {
                    backgroundColor: 'transparent',
                    bottom: 0,
                    content: '""',
                    height: '2px',
                    left: '8px',
                    position: 'absolute',
                    right: '8px',
                    transition: `background-color ${AnimationVariables.durationValue2} ${AnimationVariables.easeFunction2}`
                },
                ':after': {
                    color: 'transparent',
                    content: 'attr(title)',
                    display: 'block',
                    fontWeight: FontWeights.bold,
                    height: '1px',
                    overflow: 'hidden',
                    visibility: 'hidden'
                },
                ':hover': {
                    color: semanticColors.actionLinkHovered,
                    cursor: 'pointer'
                },
                ':focus': {
                    outline: 'none'
                },
                [`.${IsFocusVisibleClassName} &:focus`]: {
                    outline: `1px solid ${semanticColors.focusBorder}`
                }
            }
        },
        rootIsLarge && {
            fontSize: FontSizes.large
        },
        rootIsTabs && [
            getFocusStyle(theme),
            {
                marginRight: 0,
                height: '40px',
                lineHeight: '40px',
                backgroundColor: palette.neutralLighter,
                padding: '0 10px',
                verticalAlign: 'top',
                selectors: {
                    ':focus': {
                        outlineOffset: '-1px'
                    },
                    [`.${IsFocusVisibleClassName} &:focus::before`]: {
                        height: 'auto',
                        background: 'transparent',
                        transition: 'none'
                    }
                }
            }
        ]
    ];
};
const getStyles$18 = (props) => {
    const { className, rootIsLarge, rootIsTabs, theme } = props;
    const { palette, semanticColors } = theme;
    const classNames = getGlobalClassNames(globalClassNames$2, theme);
    return {
        root: [
            classNames.root,
            theme.fonts.medium,
            normalize,
            {
                fontSize: FontSizes.medium,
                fontWeight: FontWeights.regular,
                position: 'relative',
                color: palette.themePrimary,
                whiteSpace: 'nowrap'
            },
            rootIsLarge && classNames.rootIsLarge,
            rootIsTabs && classNames.rootIsTabs,
            className
        ],
        link: [
            classNames.link,
            ...linkStyles(props),
            {
                selectors: {
                    ':hover::before': {
                        boxSizing: 'border-box',
                        borderBottom: '2px solid transparent'
                    }
                }
            },
            rootIsTabs && {
                selectors: {
                    '&:hover, &:focus': {
                        color: palette.black
                    },
                    ':active': {
                        backgroundColor: palette.themePrimary
                    }
                }
            }
        ],
        linkIsSelected: [
            classNames.link,
            classNames.linkIsSelected,
            ...linkStyles(props),
            {
                fontWeight: FontWeights.semibold,
                selectors: {
                    ':before': {
                        boxSizing: 'border-box',
                        borderBottom: `2px solid ${semanticColors.inputBackgroundChecked}`,
                        selectors: {
                            [HighContrastSelector]: {
                                borderBottomColor: 'Highlight'
                            }
                        }
                    },
                    [HighContrastSelector]: {
                        color: 'Highlight'
                    }
                }
            },
            rootIsTabs && {
                backgroundColor: palette.themePrimary,
                color: palette.white,
                fontWeight: FontWeights.semilight,
                selectors: {
                    ':before': {
                        backgroundColor: 'transparent',
                        transition: 'none',
                        position: 'absolute',
                        top: 0,
                        left: 0,
                        right: 0,
                        bottom: 0,
                        content: '""',
                        height: 'auto'
                    },
                    '&:active, &:hover': {
                        color: palette.white
                    },
                    [HighContrastSelector]: {
                        fontWeight: FontWeights.semibold,
                        color: 'HighlightText',
                        background: 'Highlight',
                        MsHighContrastAdjust: 'none'
                    }
                }
            }
        ],
        linkContent: [classNames.linkContent],
        text: [
            classNames.text,
            {
                display: 'inline-block',
                verticalAlign: 'top'
            }
        ],
        count: [
            classNames.count,
            {
                marginLeft: '4px',
                display: 'inline-block',
                verticalAlign: 'top'
            }
        ],
        icon: [
            classNames.icon,
            {
                selectors: {
                    '& + $text': {
                        marginLeft: '4px'
                    }
                }
            }
        ]
    };
};

/**
 * The Pivot control and related tabs pattern are used for navigating frequently accessed,
 * distinct content categories. Pivots allow for navigation between two or more content
 * views and relies on text headers to articulate the different sections of content.
 */
const Pivot = styled(PivotBase, getStyles$18, undefined, {
    scope: 'Pivot'
});

const getClassNames$12 = classNamesFunction();
// if the percentComplete is near 0, don't animate it.
// This prevents animations on reset to 0 scenarios
const ZERO_THRESHOLD = 0.01;
/**
 * ProgressIndicator with no default styles.
 * [Use the `styles` API to add your own styles.](https://github.com/OfficeDev/office-ui-fabric-react/wiki/Styling)
 */
class ProgressIndicatorBase extends BaseComponent {
    constructor(props) {
        super(props);
        this._onRenderProgress = (props) => {
            const { ariaValueText, barHeight, className, styles, theme } = this.props;
            const percentComplete = typeof this.props.percentComplete === 'number' ? Math.min(100, Math.max(0, this.props.percentComplete * 100)) : undefined;
            const classNames = getClassNames$12(styles, {
                theme: theme,
                className,
                barHeight,
                indeterminate: percentComplete === undefined ? true : false
            });
            const progressBarStyles = {
                width: percentComplete !== undefined ? percentComplete + '%' : undefined,
                transition: percentComplete !== undefined && percentComplete < ZERO_THRESHOLD ? 'none' : undefined
            };
            const ariaValueMin = percentComplete !== undefined ? 0 : undefined;
            const ariaValueMax = percentComplete !== undefined ? 100 : undefined;
            const ariaValueNow = percentComplete !== undefined ? Math.floor(percentComplete) : undefined;
            return (createElement("div", { className: classNames.itemProgress },
                createElement("div", { className: classNames.progressTrack }),
                createElement("div", { className: classNames.progressBar, style: progressBarStyles, role: "progressbar", "aria-valuemin": ariaValueMin, "aria-valuemax": ariaValueMax, "aria-valuenow": ariaValueNow, "aria-valuetext": ariaValueText })));
        };
        this._warnDeprecations({
            title: 'label'
        });
    }
    render() {
        const { barHeight, className, label = this.props.title, // Fall back to deprecated value.
        description, styles, theme, progressHidden, onRenderProgress = this._onRenderProgress } = this.props;
        const percentComplete = typeof this.props.percentComplete === 'number' ? Math.min(100, Math.max(0, this.props.percentComplete * 100)) : undefined;
        const classNames = getClassNames$12(styles, {
            theme: theme,
            className,
            barHeight,
            indeterminate: percentComplete === undefined ? true : false
        });
        return (createElement("div", { className: classNames.root },
            label ? createElement("div", { className: classNames.itemName }, label) : null,
            !progressHidden
                ? onRenderProgress({
                    ...this.props,
                    percentComplete: percentComplete
                }, this._onRenderProgress)
                : null,
            description ? createElement("div", { className: classNames.itemDescription }, description) : null));
    }
}
ProgressIndicatorBase.defaultProps = {
    label: '',
    description: '',
    width: 180
};

const GlobalClassNames$K = {
    root: 'ms-ProgressIndicator',
    itemName: 'ms-ProgressIndicator-itemName',
    itemDescription: 'ms-ProgressIndicator-itemDescription',
    itemProgress: 'ms-ProgressIndicator-itemProgress',
    progressTrack: 'ms-ProgressIndicator-progressTrack',
    progressBar: 'ms-ProgressIndicator-progressBar'
};
const IndeterminateProgress = keyframes({
    '0%': {
        left: '-30%'
    },
    '100%': {
        left: '100%'
    }
});
const IndeterminateProgressRTL = keyframes({
    '100%': {
        right: '-30%'
    },
    '0%': {
        right: '100%'
    }
});
const getStyles$19 = (props) => {
    const isRTL = getRTL();
    const { className, indeterminate, theme, barHeight = 2 } = props;
    const { palette, semanticColors } = theme;
    const classNames = getGlobalClassNames(GlobalClassNames$K, theme);
    const marginBetweenText = 8;
    const textHeight = 18;
    const progressTrackColor = palette.neutralLight;
    return {
        root: [
            classNames.root,
            theme.fonts.medium,
            {
                fontWeight: FontWeights.regular
            },
            className
        ],
        itemName: [
            classNames.itemName,
            noWrap,
            {
                color: semanticColors.bodyText,
                fontSize: FontSizes.medium,
                paddingTop: marginBetweenText / 2,
                lineHeight: textHeight + 2
            }
        ],
        itemDescription: [
            classNames.itemDescription,
            {
                color: semanticColors.bodySubtext,
                fontSize: FontSizes.xSmall,
                lineHeight: textHeight
            }
        ],
        itemProgress: [
            classNames.itemProgress,
            {
                position: 'relative',
                overflow: 'hidden',
                height: barHeight,
                padding: `${marginBetweenText}px 0`
            }
        ],
        progressTrack: [
            classNames.progressTrack,
            {
                position: 'absolute',
                width: '100%',
                height: barHeight,
                backgroundColor: progressTrackColor,
                selectors: {
                    [HighContrastSelector]: {
                        borderBottom: '1px solid WindowText'
                    }
                }
            }
        ],
        progressBar: [
            {
                backgroundColor: palette.themePrimary,
                height: barHeight,
                position: 'absolute',
                transition: 'width .3s ease',
                width: 0,
                selectors: {
                    [HighContrastSelector]: {
                        backgroundColor: 'WindowText'
                    }
                }
            },
            indeterminate
                ? {
                    position: 'absolute',
                    minWidth: '33%',
                    background: `linear-gradient(to right, ${progressTrackColor} 0%, ${palette.themePrimary} 50%, ${progressTrackColor} 100%)`,
                    animation: `${isRTL ? IndeterminateProgressRTL : IndeterminateProgress} 3s infinite`
                }
                : {
                    transition: 'width .15s linear'
                },
            classNames.progressBar
        ]
    };
};

/**
 * ProgressIndicator description
 */
const ProgressIndicator = styled(ProgressIndicatorBase, getStyles$19, undefined, { scope: 'ProgressIndicator' });

const GlobalClassNames$L = {
    root: 'ms-RatingStar-root',
    rootIsSmall: 'ms-RatingStar-root--small',
    rootIsLarge: 'ms-RatingStar-root--large',
    ratingStar: 'ms-RatingStar-container',
    ratingStarBack: 'ms-RatingStar-back',
    ratingStarFront: 'ms-RatingStar-front',
    ratingButton: 'ms-Rating-button',
    ratingStarIsSmall: 'ms-Rating--small',
    ratingStartIsLarge: 'ms-Rating--large',
    labelText: 'ms-Rating-labelText',
    ratingFocusZone: 'ms-Rating-focuszone'
};
function _getColorWithHighContrast(color, highContrastColor) {
    return {
        color: color,
        selectors: {
            [HighContrastSelector]: {
                color: highContrastColor
            }
        }
    };
}
function getStyles$1a(props) {
    const { disabled, readOnly, theme } = props;
    const { semanticColors, palette } = theme;
    const classNames = getGlobalClassNames(GlobalClassNames$L, theme);
    const ratingSmallIconSize = 16;
    const ratingLargeIconSize = 20;
    const ratingVerticalPadding = 8;
    const ratingHorizontalPadding = 2;
    const ratingStarUncheckedColor = palette.neutralTertiary;
    const ratingStarUncheckedHoverColor = palette.themePrimary;
    const ratingStarUncheckedHoverSelectedColor = palette.themeDark;
    const ratingStarCheckedColor = semanticColors.bodyTextChecked;
    const ratingStarDisabledColor = semanticColors.disabledBodySubtext;
    return {
        root: [
            classNames.root,
            theme.fonts.medium,
            !disabled &&
                !readOnly && {
                selectors: {
                    // This is part 1 of highlighting all stars up to the one the user is hovering over
                    '&:hover': {
                        selectors: {
                            '.ms-RatingStar-back': _getColorWithHighContrast(ratingStarCheckedColor, 'Highlight')
                        }
                    }
                }
            }
        ],
        rootIsSmall: [
            classNames.rootIsSmall,
            {
                height: ratingSmallIconSize + ratingVerticalPadding * 2 + 'px'
            }
        ],
        rootIsLarge: [
            classNames.rootIsLarge,
            {
                height: ratingLargeIconSize + ratingVerticalPadding * 2 + 'px'
            }
        ],
        ratingStar: [
            classNames.ratingStar,
            {
                display: 'inline-block',
                position: 'relative',
                height: 'inherit'
            }
        ],
        ratingStarBack: [
            classNames.ratingStarBack,
            {
                // TODO: Use a proper semantic color for this
                color: ratingStarUncheckedColor,
                width: '100%'
            },
            disabled && _getColorWithHighContrast(ratingStarDisabledColor, 'GrayText')
        ],
        ratingStarFront: [
            classNames.ratingStarFront,
            {
                position: 'absolute',
                height: '100 %',
                left: '0',
                top: '0',
                textAlign: 'center',
                verticalAlign: 'middle',
                overflow: 'hidden'
            },
            _getColorWithHighContrast(ratingStarCheckedColor, 'Highlight')
        ],
        ratingButton: [
            getFocusStyle(theme, 0),
            classNames.ratingButton,
            {
                backgroundColor: 'transparent',
                padding: `${ratingVerticalPadding}px ${ratingHorizontalPadding}px`,
                boxSizing: 'content-box',
                margin: '0px',
                border: 'none',
                cursor: 'pointer',
                selectors: {
                    '&:disabled': {
                        cursor: 'default'
                    },
                    '&[disabled]': {
                        cursor: 'default'
                    }
                }
            },
            !disabled &&
                !readOnly && {
                selectors: {
                    // This is part 2 of highlighting all stars up to the one the user is hovering over
                    '&:hover ~ .ms-Rating-button': {
                        selectors: {
                            '.ms-RatingStar-back': _getColorWithHighContrast(ratingStarUncheckedColor, 'WindowText'),
                            '.ms-RatingStar-front': _getColorWithHighContrast(ratingStarUncheckedColor, 'WindowText')
                        }
                    },
                    '&:hover': {
                        selectors: {
                            '.ms-RatingStar-back': {
                                color: ratingStarUncheckedHoverColor
                            },
                            '.ms-RatingStar-front': {
                                color: ratingStarUncheckedHoverSelectedColor
                            }
                        }
                    }
                }
            },
            disabled && {
                cursor: 'default'
            }
        ],
        ratingStarIsSmall: [
            classNames.ratingStarIsSmall,
            {
                fontSize: ratingSmallIconSize + 'px',
                lineHeight: ratingSmallIconSize + 'px',
                height: ratingSmallIconSize + 'px'
            }
        ],
        ratingStarIsLarge: [
            classNames.ratingStartIsLarge,
            {
                fontSize: ratingLargeIconSize + 'px',
                lineHeight: ratingLargeIconSize + 'px',
                height: ratingLargeIconSize + 'px'
            }
        ],
        labelText: [classNames.labelText, hiddenContentStyle],
        ratingFocusZone: [
            classNames.ratingFocusZone,
            {
                display: 'inline-block'
            }
        ]
    };
}

var RatingSize;
(function (RatingSize) {
    RatingSize[RatingSize["Small"] = 0] = "Small";
    RatingSize[RatingSize["Large"] = 1] = "Large";
})(RatingSize || (RatingSize = {}));

const getClassNames$13 = classNamesFunction();
const RatingStar = (props) => {
    const icon = props.icon || 'FavoriteStarFill';
    return (createElement("div", { className: props.classNames.ratingStar, key: props.id },
        createElement(Icon, { className: props.classNames.ratingStarBack, iconName: icon }),
        !props.disabled && (createElement(Icon, { className: props.classNames.ratingStarFront, iconName: icon, style: { width: props.fillPercentage + '%' } }))));
};
class RatingBase extends BaseComponent {
    constructor(props) {
        super(props);
        this._warnDeprecations({
            onChanged: 'onChange'
        });
        this._id = getId('Rating');
        this._min = this.props.allowZeroStars ? 0 : 1;
        if (this.props.min !== undefined && this.props.min !== 1) {
            this._min = this.props.min;
        }
        this._labelId = getId('RatingLabel');
        this.state = {
            rating: this._getInitialValue(props)
        };
    }
    componentWillReceiveProps(nextProps) {
        if (typeof nextProps.rating !== 'undefined' && nextProps.rating !== this.state.rating) {
            this.setState({
                rating: this._getClampedRating(nextProps.rating)
            });
        }
    }
    render() {
        const id = this._id;
        const stars = [];
        const starIds = [];
        const { disabled, getAriaLabel, styles, max, rating, readOnly, size, theme, icon, unselectedIcon = icon } = this.props;
        this._classNames = getClassNames$13(styles, {
            disabled,
            readOnly,
            theme: theme
        });
        for (let i = this._min; i <= max; i++) {
            if (i !== 0) {
                const fillPercentage = this._getFillingPercentage(i);
                const ratingStarProps = {
                    fillPercentage,
                    disabled: disabled ? true : false,
                    readOnly: readOnly ? true : false,
                    classNames: this._classNames,
                    icon: fillPercentage > 0 ? icon : unselectedIcon
                };
                starIds.push(this._getStarId(i - 1));
                stars.push(createElement("button", Object.assign({ className: css(this._classNames.ratingButton, {
                        [this._classNames.ratingStarIsLarge]: size === RatingSize.Large,
                        [this._classNames.ratingStarIsSmall]: size !== RatingSize.Large
                    }), id: starIds[i - 1], key: i }, (i === Math.ceil(this.state.rating) ? { 'data-is-current': true } : {}), { onFocus: this._onFocus.bind(this, i), onClick: this._onFocus.bind(this, i), disabled: disabled || readOnly ? true : false, role: "presentation", type: "button" }),
                    this._getLabel(i),
                    createElement(RatingStar, Object.assign({ key: i + 'rating' }, ratingStarProps))));
            }
        }
        return (createElement("div", { className: css('ms-Rating-star', this._classNames.root, {
                [this._classNames.rootIsLarge]: size === RatingSize.Large,
                [this._classNames.rootIsSmall]: size !== RatingSize.Large
            }), "aria-label": getAriaLabel ? getAriaLabel(this.state.rating ? this.state.rating : 0, this.props.max) : '', id: id },
            createElement(FocusZone, { direction: FocusZoneDirection.horizontal, tabIndex: readOnly ? 0 : -1, className: css(this._classNames.ratingFocusZone, {
                    [this._classNames.rootIsLarge]: size === RatingSize.Large,
                    [this._classNames.rootIsSmall]: size !== RatingSize.Large
                }), "data-is-focusable": readOnly ? true : false, defaultActiveElement: rating ? starIds[rating - 1] && '#' + starIds[rating - 1] : undefined }, stars)));
    }
    _getStarId(index) {
        return this._id + '-star-' + index;
    }
    _onFocus(value, ev) {
        if (this.state.rating !== value) {
            this.setState({
                rating: value
            });
            const { onChange, onChanged } = this.props;
            if (onChange) {
                onChange(ev, value);
            }
            if (onChanged) {
                onChanged(value);
            }
        }
    }
    _getLabel(rating) {
        const text = this.props.ariaLabelFormat || '';
        return (createElement("span", { id: `${this._labelId}-${rating}`, className: this._classNames.labelText }, format(text, rating, this.props.max)));
    }
    _getInitialValue(props) {
        if (typeof props.rating === 'undefined') {
            return this._min;
        }
        if (props.rating === null) {
            return undefined;
        }
        return this._getClampedRating(props.rating);
    }
    _getClampedRating(rating) {
        return Math.min(Math.max(rating, this._min), this.props.max);
    }
    _getFillingPercentage(starPosition) {
        const ceilValue = Math.ceil(this.state.rating);
        let fillPercentage = 100;
        if (starPosition === this.state.rating) {
            fillPercentage = 100;
        }
        else if (starPosition === ceilValue) {
            fillPercentage = 100 * (this.state.rating % 1);
        }
        else if (starPosition > ceilValue) {
            fillPercentage = 0;
        }
        return fillPercentage;
    }
}
RatingBase.defaultProps = {
    min: 1,
    max: 5
};

const Rating = styled(RatingBase, getStyles$1a, undefined, { scope: 'Rating' });

const getClassNames$14 = classNamesFunction();
class ScrollablePaneBase extends BaseComponent {
    constructor(props) {
        super(props);
        this._root = createRef();
        this._stickyAboveRef = createRef();
        this._stickyBelowRef = createRef();
        this._contentContainer = createRef();
        this.subscribe = (handler) => {
            this._subscribers.add(handler);
        };
        this.unsubscribe = (handler) => {
            this._subscribers.delete(handler);
        };
        this.addSticky = (sticky) => {
            this._stickies.add(sticky);
            // If ScrollablePane is mounted, then sort sticky in correct place
            if (this.contentContainer) {
                sticky.setDistanceFromTop(this.contentContainer);
                this.sortSticky(sticky);
            }
            this.notifySubscribers();
        };
        this.removeSticky = (sticky) => {
            this._stickies.delete(sticky);
            this._removeStickyFromContainers(sticky);
            this.notifySubscribers();
        };
        this.sortSticky = (sticky, sortAgain) => {
            if (this.stickyAbove && this.stickyBelow) {
                if (sortAgain) {
                    this._removeStickyFromContainers(sticky);
                }
                if (sticky.canStickyTop && sticky.stickyContentTop) {
                    this._addToStickyContainer(sticky, this.stickyAbove, sticky.stickyContentTop);
                }
                if (sticky.canStickyBottom && sticky.stickyContentBottom) {
                    this._addToStickyContainer(sticky, this.stickyBelow, sticky.stickyContentBottom);
                }
            }
        };
        this.updateStickyRefHeights = () => {
            const stickyItems = this._stickies;
            let stickyTopHeight = 0;
            let stickyBottomHeight = 0;
            stickyItems.forEach((sticky) => {
                const { isStickyTop, isStickyBottom } = sticky.state;
                if (sticky.nonStickyContent) {
                    if (isStickyTop) {
                        stickyTopHeight += sticky.nonStickyContent.offsetHeight;
                    }
                    if (isStickyBottom) {
                        stickyBottomHeight += sticky.nonStickyContent.offsetHeight;
                    }
                    this._checkStickyStatus(sticky);
                }
            });
            this.setState({
                stickyTopHeight: stickyTopHeight,
                stickyBottomHeight: stickyBottomHeight
            });
        };
        this.notifySubscribers = () => {
            if (this.contentContainer) {
                this._subscribers.forEach(handle => {
                    // this.stickyBelow is passed in for calculating distance to determine Sticky status
                    handle(this.contentContainer, this.stickyBelow);
                });
            }
        };
        this.getScrollPosition = () => {
            if (this.contentContainer) {
                return this.contentContainer.scrollTop;
            }
            return 0;
        };
        this.syncScrollSticky = (sticky) => {
            if (sticky && this.contentContainer) {
                sticky.syncScroll(this.contentContainer);
            }
        };
        this._addToStickyContainer = (sticky, stickyContainer, stickyContentToAdd) => {
            // If there's no children, append child to list, otherwise, sort though array and append at correct position
            if (!stickyContainer.children.length) {
                stickyContainer.appendChild(stickyContentToAdd);
            }
            else {
                // If stickyContentToAdd isn't a child element of target container, then append
                if (!stickyContainer.contains(stickyContentToAdd)) {
                    const stickyChildrenElements = [].slice.call(stickyContainer.children);
                    const stickyList = [];
                    // Get stickies.  Filter by canStickyTop/Bottom, then sort by distance from top, and then
                    // filter by elements that are in the stickyContainer already.
                    this._stickies.forEach(stickyItem => {
                        if (stickyContainer === this.stickyAbove && sticky.canStickyTop) {
                            stickyList.push(stickyItem);
                        }
                        else if (sticky.canStickyBottom) {
                            stickyList.push(stickyItem);
                        }
                    });
                    const stickyListSorted = stickyList
                        .sort((a, b) => {
                        return a.distanceFromTop - b.distanceFromTop;
                    })
                        .filter(item => {
                        const stickyContent = stickyContainer === this.stickyAbove ? item.stickyContentTop : item.stickyContentBottom;
                        if (stickyContent) {
                            return stickyChildrenElements.indexOf(stickyContent) > -1;
                        }
                    });
                    // Get first element that has a distance from top that is further than our sticky that is being added
                    let targetStickyToAppendBefore = undefined;
                    for (const i in stickyListSorted) {
                        if (stickyListSorted[i].distanceFromTop >= sticky.distanceFromTop) {
                            targetStickyToAppendBefore = stickyListSorted[i];
                            break;
                        }
                    }
                    // If target element to append before is known, then grab respective stickyContentTop/Bottom element and insert before
                    let targetContainer = null;
                    if (targetStickyToAppendBefore) {
                        targetContainer =
                            stickyContainer === this.stickyAbove
                                ? targetStickyToAppendBefore.stickyContentTop
                                : targetStickyToAppendBefore.stickyContentBottom;
                    }
                    stickyContainer.insertBefore(stickyContentToAdd, targetContainer);
                }
            }
        };
        this._removeStickyFromContainers = (sticky) => {
            if (this.stickyAbove && sticky.stickyContentTop && this.stickyAbove.contains(sticky.stickyContentTop)) {
                this.stickyAbove.removeChild(sticky.stickyContentTop);
            }
            if (this.stickyBelow && sticky.stickyContentBottom && this.stickyBelow.contains(sticky.stickyContentBottom)) {
                this.stickyBelow.removeChild(sticky.stickyContentBottom);
            }
        };
        this._onWindowResize = () => {
            const scrollbarWidth = this._getScrollbarWidth();
            const scrollbarHeight = this._getScrollbarHeight();
            this.setState({
                scrollbarWidth,
                scrollbarHeight
            });
            this.notifySubscribers();
        };
        this._getStickyContainerStyle = (height, isTop) => {
            return {
                height: height,
                ...(getRTL()
                    ? {
                        right: '0',
                        left: `${this.state.scrollbarWidth || this._getScrollbarWidth() || 0}px`
                    }
                    : {
                        left: '0',
                        right: `${this.state.scrollbarWidth || this._getScrollbarWidth() || 0}px`
                    }),
                ...(isTop
                    ? {
                        top: '0'
                    }
                    : {
                        bottom: `${this.state.scrollbarHeight || this._getScrollbarHeight() || 0}px`
                    })
            };
        };
        this._onScroll = () => {
            const { contentContainer } = this;
            if (contentContainer) {
                this._stickies.forEach((sticky) => {
                    sticky.syncScroll(contentContainer);
                });
            }
            this._notifyThrottled();
        };
        this._subscribers = new Set();
        this._stickies = new Set();
        this.state = {
            stickyTopHeight: 0,
            stickyBottomHeight: 0,
            scrollbarWidth: undefined,
            scrollbarHeight: undefined
        };
        this._notifyThrottled = this._async.throttle(this.notifySubscribers, 50);
    }
    get root() {
        return this._root.current;
    }
    get stickyAbove() {
        return this._stickyAboveRef.current;
    }
    get stickyBelow() {
        return this._stickyBelowRef.current;
    }
    get contentContainer() {
        return this._contentContainer.current;
    }
    getChildContext() {
        return {
            scrollablePane: {
                subscribe: this.subscribe,
                unsubscribe: this.unsubscribe,
                addSticky: this.addSticky,
                removeSticky: this.removeSticky,
                updateStickyRefHeights: this.updateStickyRefHeights,
                sortSticky: this.sortSticky,
                notifySubscribers: this.notifySubscribers,
                syncScrollSticky: this.syncScrollSticky
            }
        };
    }
    componentDidMount() {
        const { initialScrollPosition } = this.props;
        this._events.on(this.contentContainer, 'scroll', this._onScroll);
        this._events.on(window, 'resize', this._onWindowResize);
        if (this.contentContainer && initialScrollPosition) {
            this.contentContainer.scrollTop = initialScrollPosition;
        }
        // Set sticky distances from top property, then sort in correct order and notify subscribers
        this.setStickiesDistanceFromTop();
        this._stickies.forEach(sticky => {
            this.sortSticky(sticky);
        });
        this.notifySubscribers();
        if ('MutationObserver' in window) {
            this._mutationObserver = new MutationObserver(mutation => {
                // Function to check if mutation is occuring in stickyAbove or stickyBelow
                function checkIfMutationIsSticky(mutationRecord) {
                    if (this.stickyAbove !== null && this.stickyBelow !== null) {
                        return this.stickyAbove.contains(mutationRecord.target) || this.stickyBelow.contains(mutationRecord.target);
                    }
                    return false;
                }
                // Compute the scrollbar height which might have changed due to change in width of the content which might cause overflow
                const scrollbarHeight = this._getScrollbarHeight();
                // check if the scroll bar height has changed and update the state so that it's postioned correctly below sticky footer
                if (scrollbarHeight !== this.state.scrollbarHeight) {
                    this.setState({
                        scrollbarHeight: scrollbarHeight
                    });
                }
                // Notify subscribers again to re-check whether Sticky should be Sticky'd or not
                this.notifySubscribers();
                // If mutation occurs in sticky header or footer, then update sticky top/bottom heights
                if (mutation.some(checkIfMutationIsSticky.bind(this))) {
                    this.updateStickyRefHeights();
                }
                else {
                    // If mutation occurs in scrollable region, then find Sticky it belongs to and force update
                    const stickyList = [];
                    this._stickies.forEach(sticky => {
                        if (sticky.root && sticky.root.contains(mutation[0].target)) {
                            stickyList.push(sticky);
                        }
                    });
                    if (stickyList.length) {
                        stickyList.forEach(sticky => {
                            sticky.forceUpdate();
                        });
                    }
                }
            });
            if (this.root) {
                this._mutationObserver.observe(this.root, {
                    childList: true,
                    attributes: true,
                    subtree: true,
                    characterData: true
                });
            }
        }
    }
    componentWillUnmount() {
        this._events.off(this.contentContainer);
        this._events.off(window);
        if (this._mutationObserver) {
            this._mutationObserver.disconnect();
        }
    }
    // Only updates if props/state change, just to prevent excessive setState with updateStickyRefHeights
    shouldComponentUpdate(nextProps, nextState) {
        return (this.props.children !== nextProps.children ||
            this.props.initialScrollPosition !== nextProps.initialScrollPosition ||
            this.props.className !== nextProps.className ||
            this.state.stickyTopHeight !== nextState.stickyTopHeight ||
            this.state.stickyBottomHeight !== nextState.stickyBottomHeight ||
            this.state.scrollbarWidth !== nextState.scrollbarWidth ||
            this.state.scrollbarHeight !== nextState.scrollbarHeight);
    }
    componentDidUpdate(prevProps, prevState) {
        const initialScrollPosition = this.props.initialScrollPosition;
        if (this.contentContainer && typeof initialScrollPosition === 'number' && prevProps.initialScrollPosition !== initialScrollPosition) {
            this.contentContainer.scrollTop = initialScrollPosition;
        }
        // Update subscribers when stickyTopHeight/stickyBottomHeight changes
        if (prevState.stickyTopHeight !== this.state.stickyTopHeight || prevState.stickyBottomHeight !== this.state.stickyBottomHeight) {
            this.notifySubscribers();
        }
        this._async.setTimeout(this._onWindowResize, 0);
    }
    render() {
        const { className, theme, styles } = this.props;
        const { stickyTopHeight, stickyBottomHeight } = this.state;
        const classNames = getClassNames$14(styles, {
            theme: theme,
            className,
            scrollbarVisibility: this.props.scrollbarVisibility
        });
        return (createElement("div", Object.assign({}, getNativeProps(this.props, divProperties), { ref: this._root, className: classNames.root }),
            createElement("div", { ref: this._contentContainer, className: classNames.contentContainer, "data-is-scrollable": true }, this.props.children),
            createElement("div", { ref: this._stickyAboveRef, className: classNames.stickyAbove, style: this._getStickyContainerStyle(stickyTopHeight, true) }),
            createElement("div", { className: classNames.stickyBelow, style: this._getStickyContainerStyle(stickyBottomHeight, false) },
                createElement("div", { ref: this._stickyBelowRef, className: classNames.stickyBelowItems }))));
    }
    setStickiesDistanceFromTop() {
        if (this.contentContainer) {
            this._stickies.forEach(sticky => {
                sticky.setDistanceFromTop(this.contentContainer);
            });
        }
    }
    forceLayoutUpdate() {
        this._onWindowResize();
    }
    _checkStickyStatus(sticky) {
        if (this.stickyAbove && this.stickyBelow && this.contentContainer && sticky.nonStickyContent) {
            // If sticky is sticky, then append content to appropriate container
            if (sticky.state.isStickyTop || sticky.state.isStickyBottom) {
                if (sticky.state.isStickyTop && !this.stickyAbove.contains(sticky.nonStickyContent) && sticky.stickyContentTop) {
                    sticky.addSticky(sticky.stickyContentTop);
                }
                if (sticky.state.isStickyBottom && !this.stickyBelow.contains(sticky.nonStickyContent) && sticky.stickyContentBottom) {
                    sticky.addSticky(sticky.stickyContentBottom);
                }
            }
            else if (!this.contentContainer.contains(sticky.nonStickyContent)) {
                // Reset sticky if it's not sticky and not in the contentContainer element
                sticky.resetSticky();
            }
        }
    }
    _getScrollbarWidth() {
        const { contentContainer } = this;
        return contentContainer ? contentContainer.offsetWidth - contentContainer.clientWidth : undefined;
    }
    _getScrollbarHeight() {
        const { contentContainer } = this;
        return contentContainer ? contentContainer.offsetHeight - contentContainer.clientHeight : undefined;
    }
}
ScrollablePaneBase.childContextTypes = {
    //@ts-ignore
    scrollablePane: object
};

const GlobalClassNames$M = {
    root: 'ms-ScrollablePane',
    contentContainer: 'ms-ScrollablePane--contentContainer'
};
const getStyles$1b = (props) => {
    const { className, theme } = props;
    const classNames = getGlobalClassNames(GlobalClassNames$M, theme);
    const AboveAndBelowStyles = {
        position: 'absolute',
        pointerEvents: 'auto',
        zIndex: ZIndexes.ScrollablePane
    };
    const positioningStyle = {
        zIndex: ZIndexes.ScrollablePane,
        position: 'absolute',
        top: 0,
        right: 0,
        bottom: 0,
        left: 0,
        WebkitOverflowScrolling: 'touch'
    };
    return {
        root: [classNames.root, theme.fonts.medium, positioningStyle, className],
        contentContainer: [
            classNames.contentContainer,
            {
                overflowY: props.scrollbarVisibility === 'always' ? 'scroll' : 'auto'
            },
            positioningStyle
        ],
        stickyAbove: [
            {
                top: 0,
                selectors: {
                    [HighContrastSelector]: {
                        borderBottom: '1px solid WindowText'
                    }
                }
            },
            AboveAndBelowStyles
        ],
        stickyBelow: [
            {
                bottom: 0,
                selectors: {
                    [HighContrastSelector]: {
                        borderTop: '1px solid WindowText'
                    }
                }
            },
            AboveAndBelowStyles
        ],
        stickyBelowItems: [
            {
                bottom: 0
            },
            AboveAndBelowStyles,
            {
                width: '100%'
            }
        ]
    };
};

const ScrollablePane = styled(ScrollablePaneBase, getStyles$1b, undefined, { scope: 'ScrollablePane' });

const ScrollbarVisibility = {
    auto: 'auto',
    always: 'always'
};

const getClassNames$15 = classNamesFunction();
class SearchBoxBase extends BaseComponent {
    constructor(props) {
        super(props);
        this._rootElement = createRef();
        this._inputElement = createRef();
        this._onClickFocus = () => {
            const inputElement = this._inputElement.current;
            if (inputElement) {
                this.focus();
                inputElement.selectionStart = inputElement.selectionEnd = 0;
            }
        };
        this._onFocusCapture = (ev) => {
            this.setState({
                hasFocus: true
            });
            this._events.on(ev.currentTarget, 'blur', this._onBlur, true);
            if (this.props.onFocus) {
                this.props.onFocus(ev);
            }
        };
        this._onClearClick = (ev) => {
            const { clearButtonProps } = this.props;
            if (clearButtonProps && clearButtonProps.onClick) {
                clearButtonProps.onClick(ev);
            }
            if (!ev.defaultPrevented) {
                this._onClear(ev);
            }
        };
        this._onKeyDown = (ev) => {
            switch (ev.which) {
                case KeyCodes.escape:
                    this.props.onEscape && this.props.onEscape(ev);
                    if (!ev.defaultPrevented) {
                        this._onClear(ev);
                    }
                    break;
                case KeyCodes.enter:
                    if (this.props.onSearch) {
                        this.props.onSearch(this.state.value);
                    }
                    break;
                default:
                    this.props.onKeyDown && this.props.onKeyDown(ev);
                    if (!ev.defaultPrevented) {
                        return;
                    }
            }
            // We only get here if the keypress has been handled,
            // or preventDefault was called in case of default keyDown handler
            ev.preventDefault();
            ev.stopPropagation();
        };
        this._onBlur = (ev) => {
            this._events.off(this._rootElement.current, 'blur');
            this.setState({
                hasFocus: false
            });
            if (this.props.onBlur) {
                this.props.onBlur(ev);
            }
        };
        this._onInputChange = (ev) => {
            const value = ev.target.value;
            if (value === this._latestValue) {
                return;
            }
            this._latestValue = value;
            this.setState({ value });
            this._callOnChange(value);
        };
        this._warnDeprecations({
            labelText: 'placeholder',
            defaultValue: 'value'
        });
        this._latestValue = props.value || '';
        this.state = {
            value: this._latestValue,
            hasFocus: false,
            id: getId('SearchBox')
        };
    }
    componentWillReceiveProps(newProps) {
        if (newProps.value !== undefined) {
            this._latestValue = newProps.value;
            // If the user passes in null, substitute an empty string
            // (passing null is not allowed per typings, but users might do it anyway)
            this.setState({
                value: newProps.value || ''
            });
        }
    }
    render() {
        const { ariaLabel, placeholder, className, disabled, underlined, styles, labelText, theme, clearButtonProps, disableAnimation, iconProps } = this.props;
        const { value, hasFocus, id } = this.state;
        const placeholderValue = labelText === undefined ? placeholder : labelText;
        const classNames = getClassNames$15(styles, {
            theme: theme,
            className,
            underlined,
            hasFocus,
            disabled,
            hasInput: value.length > 0,
            disableAnimation
        });
        const nativeProps = getNativeProps(this.props, inputProperties, ['id', 'className', 'placeholder', 'onFocus', 'onBlur', 'value']);
        return (createElement("div", { ref: this._rootElement, className: classNames.root, onFocusCapture: this._onFocusCapture },
            createElement("div", { className: classNames.iconContainer, onClick: this._onClickFocus, "aria-hidden": true },
                createElement(Icon, Object.assign({ iconName: "Search" }, iconProps, { className: classNames.icon }))),
            createElement("input", Object.assign({}, nativeProps, { id: id, className: classNames.field, placeholder: placeholderValue, onChange: this._onInputChange, onInput: this._onInputChange, onKeyDown: this._onKeyDown, value: value, disabled: disabled, "aria-label": ariaLabel ? ariaLabel : placeholder, ref: this._inputElement })),
            value.length > 0 && (createElement("div", { className: classNames.clearButton },
                createElement(IconButton, Object.assign({ styles: { root: { height: 'auto' }, icon: { fontSize: '12px' } }, iconProps: { iconName: 'Clear' } }, clearButtonProps, { onClick: this._onClearClick }))))));
    }
    /**
     * Sets focus to the search box input field
     */
    focus() {
        if (this._inputElement.current) {
            this._inputElement.current.focus();
        }
    }
    /**
     * Returns whether or not the SearchBox has focus
     */
    hasFocus() {
        return !!this.state.hasFocus;
    }
    _onClear(ev) {
        this.props.onClear && this.props.onClear(ev);
        if (!ev.defaultPrevented) {
            this._latestValue = '';
            this.setState({
                value: ''
            });
            this._callOnChange('');
            ev.stopPropagation();
            ev.preventDefault();
            this.focus();
        }
    }
    _callOnChange(newValue) {
        const { onChange, onChanged } = this.props;
        // Call @deprecated method.
        if (onChanged) {
            onChanged(newValue);
        }
        if (onChange) {
            onChange(newValue);
        }
    }
}
SearchBoxBase.defaultProps = {
    disableAnimation: false,
    clearButtonProps: { ariaLabel: 'Clear text' }
};

function getStyles$1c(props) {
    const { theme, underlined, disabled, hasFocus, className, hasInput, disableAnimation } = props;
    const { palette, fonts, semanticColors } = theme;
    return {
        root: [
            'ms-SearchBox',
            fonts.medium,
            normalize,
            {
                color: palette.neutralPrimary,
                backgroundColor: semanticColors.inputBackground,
                display: 'flex',
                flexDirection: 'row',
                flexWrap: 'nowrap',
                alignItems: 'stretch',
                // The 1px top and bottom padding ensure the input field does not overlap the border
                padding: '1px 0 1px 4px',
                border: `1px solid ${palette.neutralTertiary}`,
                height: 32,
                selectors: {
                    [HighContrastSelector]: {
                        border: '1px solid WindowText'
                    },
                    ':hover': {
                        borderColor: palette.neutralDark,
                        selectors: {
                            [HighContrastSelector]: {
                                borderColor: 'Highlight'
                            }
                        }
                    },
                    ':hover $iconContainer': {
                        color: palette.themeDark
                    }
                }
            },
            hasFocus && [
                'is-active',
                {
                    borderColor: palette.themePrimary,
                    selectors: {
                        ':hover': {
                            borderColor: palette.themePrimary
                        },
                        [HighContrastSelector]: {
                            borderColor: 'Highlight'
                        }
                    }
                }
            ],
            disabled && [
                'is-disabled',
                {
                    borderColor: palette.neutralLighter,
                    backgroundColor: palette.neutralLighter,
                    pointerEvents: 'none',
                    cursor: 'default'
                }
            ],
            underlined && [
                'is-underlined',
                {
                    borderWidth: '0 0 1px 0',
                    // Underlined SearchBox has a larger padding left to vertically align with the waffle in product
                    padding: '1px 0 1px 8px'
                }
            ],
            underlined &&
                disabled && {
                backgroundColor: 'transparent'
            },
            hasInput && 'can-clear',
            className
        ],
        iconContainer: [
            'ms-SearchBox-iconContainer',
            {
                display: 'flex',
                flexDirection: 'column',
                justifyContent: 'center',
                flexShrink: 0,
                fontSize: 16,
                width: 32,
                textAlign: 'center',
                color: palette.themePrimary,
                cursor: 'text'
            },
            hasFocus && {
                width: 4
            },
            disabled && {
                color: palette.neutralTertiary
            },
            !disableAnimation && {
                transition: `width ${AnimationVariables.durationValue1}`
            }
        ],
        icon: [
            'ms-SearchBox-icon',
            {
                opacity: 1
            },
            hasFocus && {
                opacity: 0
            },
            !disableAnimation && {
                transition: `opacity ${AnimationVariables.durationValue1} 0s`
            }
        ],
        clearButton: [
            'ms-SearchBox-clearButton',
            {
                display: 'flex',
                flexDirection: 'row',
                alignItems: 'stretch',
                cursor: 'pointer',
                flexBasis: '32px',
                flexShrink: 0,
                padding: 1,
                color: palette.themePrimary
            }
        ],
        field: [
            'ms-SearchBox-field',
            normalize,
            {
                backgroundColor: 'transparent',
                border: 'none',
                outline: 'none',
                fontWeight: 'inherit',
                fontFamily: 'inherit',
                fontSize: 'inherit',
                color: palette.neutralPrimary,
                flex: '1 1 0px',
                // The default implicit value of 'auto' prevents the input from shrinking. Setting min-width to
                // 0px allows the input element to shrink to fit the container.
                minWidth: '0px',
                overflow: 'hidden',
                textOverflow: 'ellipsis',
                // This padding forces the text placement to round up.
                paddingBottom: 0.5,
                // This removes the IE specific clear button in the input since we implimented our own
                selectors: {
                    '::-ms-clear': {
                        display: 'none'
                    },
                    '::placeholder': {
                        color: semanticColors.inputPlaceholderText,
                        opacity: 1
                    },
                    ':-ms-input-placeholder': {
                        color: semanticColors.inputPlaceholderText
                    }
                }
            },
            disabled && {
                color: palette.neutralTertiary
            }
        ]
    };
}

const SearchBox = styled(SearchBoxBase, getStyles$1c, undefined, { scope: 'SearchBox' });

class BaseSelectedItemsList extends BaseComponent {
    constructor(basePickerProps) {
        super(basePickerProps);
        this.addItems = (items) => {
            // tslint:disable-next-line:no-any
            const processedItems = this.props.onItemSelected ? this.props.onItemSelected(items) : items;
            const processedItemObjects = processedItems;
            const processedItemPromiseLikes = processedItems;
            if (processedItemPromiseLikes && processedItemPromiseLikes.then) {
                processedItemPromiseLikes.then((resolvedProcessedItems) => {
                    const newItems = this.state.items.concat(resolvedProcessedItems);
                    this.updateItems(newItems);
                });
            }
            else {
                const newItems = this.state.items.concat(processedItemObjects);
                this.updateItems(newItems);
            }
        };
        this.removeItemAt = (index) => {
            const { items } = this.state;
            if (this._canRemoveItem(items[index])) {
                if (index > -1) {
                    if (this.props.onItemsDeleted) {
                        this.props.onItemsDeleted([items[index]]);
                    }
                    const newItems = items.slice(0, index).concat(items.slice(index + 1));
                    this.updateItems(newItems);
                }
            }
        };
        this.removeItem = (item) => {
            const { items } = this.state;
            const index = items.indexOf(item);
            this.removeItemAt(index);
        };
        // tslint:disable-next-line:no-any
        this.removeItems = (itemsToRemove) => {
            const { items } = this.state;
            const itemsCanRemove = itemsToRemove.filter((item) => this._canRemoveItem(item));
            // tslint:disable-next-line:no-any
            const newItems = items.filter((item) => itemsCanRemove.indexOf(item) === -1);
            const firstItemToRemove = itemsCanRemove[0];
            const index = items.indexOf(firstItemToRemove);
            if (this.props.onItemsDeleted) {
                this.props.onItemsDeleted(itemsCanRemove);
            }
            this.updateItems(newItems, index);
        };
        this.onCopy = (ev) => {
            if (this.props.onCopyItems && this.selection.getSelectedCount() > 0) {
                const selectedItems = this.selection.getSelection();
                this.copyItems(selectedItems);
            }
        };
        this.renderItems = () => {
            const { removeButtonAriaLabel } = this.props;
            const onRenderItem = this.props.onRenderItem;
            const { items } = this.state;
            // tslint:disable-next-line:no-any
            return items.map((item, index) => onRenderItem({
                item,
                index,
                key: item.key ? item.key : index,
                selected: this.selection.isIndexSelected(index),
                onRemoveItem: () => this.removeItem(item),
                onItemChange: this.onItemChange,
                removeButtonAriaLabel: removeButtonAriaLabel,
                onCopyItem: (itemToCopy) => this.copyItems([itemToCopy])
            }));
        };
        this.onSelectionChanged = () => {
            this.forceUpdate();
        };
        this.onItemChange = (changedItem, index) => {
            const { items } = this.state;
            if (index >= 0) {
                const newItems = items;
                newItems[index] = changedItem;
                this.updateItems(newItems);
            }
        };
        const items = basePickerProps.selectedItems || basePickerProps.defaultSelectedItems || [];
        this.state = {
            items: items
        };
        // Create a new selection if one is not specified
        this.selection = this.props.selection
            ? this.props.selection
            : new Selection({ onSelectionChanged: this.onSelectionChanged });
    }
    get items() {
        return this.state.items;
    }
    removeSelectedItems() {
        if (this.state.items.length && this.selection.getSelectedCount() > 0) {
            this.removeItems(this.selection.getSelection());
        }
    }
    /**
     * Controls what happens whenever there is an action that impacts the selected items.
     * If selectedItems is provided as a property then this will act as a controlled component and it will not update it's own state.
     */
    updateItems(items, focusIndex) {
        if (this.props.selectedItems) {
            // If the component is a controlled component then the controlling component will need to pass the new props
            this.onChange(items);
        }
        else {
            this.setState({ items: items }, () => {
                this._onSelectedItemsUpdated(items, focusIndex);
            });
        }
    }
    hasSelectedItems() {
        return this.selection.getSelectedCount() > 0;
    }
    unselectAll() {
        this.selection.setAllSelected(false);
    }
    highlightedItems() {
        return this.selection.getSelection();
    }
    componentWillUpdate(newProps, newState) {
        if (newState.items && newState.items !== this.state.items) {
            this.selection.setItems(newState.items);
        }
    }
    componentDidMount() {
        this.selection.setItems(this.state.items);
    }
    componentWillReceiveProps(newProps) {
        const newItems = newProps.selectedItems;
        if (newItems) {
            this.setState({ items: newProps.selectedItems });
        }
        if (newProps.selection) {
            this.selection = newProps.selection;
        }
    }
    // tslint:disable-next-line:no-any
    render() {
        return this.renderItems();
    }
    onChange(items) {
        if (this.props.onChange) {
            this.props.onChange(items);
        }
    }
    copyItems(items) {
        if (this.props.onCopyItems) {
            // tslint:disable-next-line:no-any
            const copyText = this.props.onCopyItems(items);
            const copyInput = document.createElement('input');
            document.body.appendChild(copyInput);
            try {
                // Try to copy the text directly to the clipboard
                copyInput.value = copyText;
                copyInput.select();
                if (!document.execCommand('copy')) {
                    // The command failed. Fallback to the method below.
                    throw new Error();
                }
            }
            catch (err) {
                // no op
            }
            finally {
                document.body.removeChild(copyInput);
            }
        }
    }
    _onSelectedItemsUpdated(items, focusIndex) {
        this.onChange(items);
    }
    _canRemoveItem(item) {
        return !this.props.canRemoveItem || this.props.canRemoveItem(item);
    }
}

/* tslint:disable */
var styles$n;
class ExtendedSelectedItem extends BaseComponent {
    constructor(props) {
        super(props);
        this.persona = createRef();
        this.state = { contextualMenuVisible: false };
    }
    render() {
        const { item, onExpandItem, onRemoveItem, removeButtonAriaLabel, index, selected } = this.props;
        const itemId = getId();
        return (createElement("div", { ref: this.persona, className: css('ms-PickerPersona-container', styles$n.personaContainer, { ['is-selected ' + styles$n.personaContainerIsSelected]: selected }, { ['is-invalid ' + styles$n.validationError]: !item.isValid }), "data-is-focusable": true, "data-is-sub-focuszone": true, "data-selection-index": index, role: 'listitem', "aria-labelledby": 'selectedItemPersona-' + itemId },
            createElement("div", { hidden: !item.canExpand || onExpandItem === undefined },
                createElement(IconButton, { onClick: this._onClickIconButton(onExpandItem), iconProps: { iconName: 'Add', style: { fontSize: '14px' } }, className: css('ms-PickerItem-removeButton', styles$n.expandButton, styles$n.actionButton), ariaLabel: removeButtonAriaLabel })),
            createElement("div", { className: css(styles$n.personaWrapper) },
                createElement("div", { className: css('ms-PickerItem-content', styles$n.itemContent), id: 'selectedItemPersona-' + itemId },
                    createElement(Persona, Object.assign({}, item, { onRenderCoin: this.props.renderPersonaCoin, onRenderPrimaryText: this.props.renderPrimaryText, size: PersonaSize.size32 }))),
                createElement(IconButton, { onClick: this._onClickIconButton(onRemoveItem), iconProps: { iconName: 'Cancel', style: { fontSize: '14px' } }, className: css('ms-PickerItem-removeButton', styles$n.removeButton, styles$n.actionButton), ariaLabel: removeButtonAriaLabel }))));
    }
    _onClickIconButton(action) {
        return (ev) => {
            ev.stopPropagation();
            ev.preventDefault();
            if (action) {
                action();
            }
        };
    }
}

/* tslint:disable */
class SelectedItemWithContextMenu extends BaseComponent {
    constructor(props) {
        super(props);
        this.itemElement = createRef();
        this._onClick = (ev) => {
            ev.preventDefault();
            if (this.props.beginEditing && !this.props.item.isValid) {
                this.props.beginEditing(this.props.item);
            }
            else {
                this.setState({ contextualMenuVisible: true });
            }
        };
        this._onCloseContextualMenu = (ev) => {
            this.setState({ contextualMenuVisible: false });
        };
        this.state = { contextualMenuVisible: false };
    }
    render() {
        return (createElement("div", { ref: this.itemElement, onContextMenu: this._onClick },
            this.props.renderedItem,
            this.state.contextualMenuVisible ? (createElement(ContextualMenu, { items: this.props.menuItems, shouldFocusOnMount: true, target: this.itemElement.current, onDismiss: this._onCloseContextualMenu, directionalHint: DirectionalHint.bottomLeftEdge })) : null));
    }
}

/* tslint:disable */
// import * as stylesImport from './EditingItem.scss';
// const styles: any = stylesImport;
let styles$o;
class EditingItem extends BaseComponent {
    constructor(props) {
        super(props);
        this._editingFloatingPicker = createRef();
        this._renderEditingSuggestions = () => {
            const onRenderFloatingPicker = this._onRenderFloatingPicker;
            return onRenderFloatingPicker({
                componentRef: this._editingFloatingPicker,
                onChange: this._onSuggestionSelected,
                inputElement: this._editingInput,
                selectedItems: [],
                ...this._floatingPickerProps
            });
        };
        this._resolveInputRef = (ref) => {
            this._editingInput = ref;
            this.forceUpdate(() => {
                this._editingInput.focus();
            });
        };
        this._onInputClick = () => {
            this._editingFloatingPicker.current && this._editingFloatingPicker.current.showPicker(true /*updatevalue*/);
        };
        this._onInputBlur = (ev) => {
            if (this._editingFloatingPicker.current && ev.relatedTarget !== null) {
                const target = ev.relatedTarget;
                if (target.className.indexOf('ms-Suggestions-itemButton') === -1 && target.className.indexOf('ms-Suggestions-sectionButton') === -1) {
                    this._editingFloatingPicker.current.forceResolveSuggestion();
                }
            }
        };
        this._onInputChange = (ev) => {
            const value = ev.target.value;
            if (value === '') {
                if (this.props.onRemoveItem) {
                    this.props.onRemoveItem();
                }
            }
            else {
                this._editingFloatingPicker.current && this._editingFloatingPicker.current.onQueryStringChanged(value);
            }
        };
        this._onSuggestionSelected = (item) => {
            this.props.onEditingComplete(this.props.item, item);
        };
        this.state = { contextualMenuVisible: false };
        this._onRenderFloatingPicker = this.props.onRenderFloatingPicker;
        this._floatingPickerProps = this.props.floatingPickerProps;
    }
    componentDidMount() {
        const getEditingItemText = this.props.getEditingItemText;
        const itemText = getEditingItemText(this.props.item);
        this._editingFloatingPicker.current && this._editingFloatingPicker.current.onQueryStringChanged(itemText);
        this._editingInput.value = itemText;
        this._editingInput.focus();
    }
    render() {
        const itemId = getId();
        const nativeProps = getNativeProps(this.props, inputProperties);
        return (createElement("div", { "aria-labelledby": 'editingItemPersona-' + itemId, className: css('ms-EditingItem', styles$o.editingContainer) },
            createElement("input", Object.assign({}, nativeProps, { ref: this._resolveInputRef, autoCapitalize: 'off', autoComplete: 'off', onChange: this._onInputChange, onKeyDown: this._onInputKeyDown, onBlur: this._onInputBlur, onClick: this._onInputClick, "data-lpignore": true, className: styles$o.editingInput, id: itemId })),
            this._renderEditingSuggestions()));
    }
    _onInputKeyDown(ev) {
        if (ev.which === KeyCodes.backspace || ev.which === KeyCodes.del) {
            ev.stopPropagation();
        }
    }
}

/* tslint:disable */
class BasePeopleSelectedItemsList extends BaseSelectedItemsList {
}
/**
 * Standard People Picker.
 */
class SelectedPeopleList extends BasePeopleSelectedItemsList {
    constructor() {
        super(...arguments);
        this.replaceItem = (itemToReplace, itemsToReplaceWith) => {
            const { items } = this.state;
            const index = items.indexOf(itemToReplace);
            if (index > -1) {
                const newItems = items
                    .slice(0, index)
                    .concat(itemsToReplaceWith)
                    .concat(items.slice(index + 1));
                this.updateItems(newItems);
            }
        };
        this.renderItems = () => {
            const { items } = this.state;
            // tslint:disable-next-line:no-any
            return items.map((item, index) => this._renderItem(item, index));
        };
        this._beginEditing = (item) => {
            item.isEditing = true;
            this.forceUpdate();
        };
        // tslint:disable-next-line:no-any
        this._completeEditing = (oldItem, newItem) => {
            oldItem.isEditing = false;
            this.replaceItem(oldItem, newItem);
        };
    }
    // tslint:disable-next-line:no-any
    _renderItem(item, index) {
        const { removeButtonAriaLabel } = this.props;
        const props = {
            item,
            index,
            key: item.key ? item.key : index,
            selected: this.selection.isIndexSelected(index),
            onRemoveItem: () => this.removeItem(item),
            onItemChange: this.onItemChange,
            removeButtonAriaLabel: removeButtonAriaLabel,
            onCopyItem: (itemToCopy) => this.copyItems([itemToCopy]),
            onExpandItem: this.props.onExpandGroup ? () => this.props.onExpandGroup(item) : undefined,
            menuItems: this._createMenuItems(item)
        };
        const hasContextMenu = props.menuItems.length > 0;
        if (item.isEditing && hasContextMenu) {
            return (createElement(EditingItem, Object.assign({}, props, { onRenderFloatingPicker: this.props.onRenderFloatingPicker, floatingPickerProps: this.props.floatingPickerProps, onEditingComplete: this._completeEditing, getEditingItemText: this.props.getEditingItemText })));
        }
        else {
            const onRenderItem = this.props.onRenderItem;
            const renderedItem = onRenderItem(props);
            return hasContextMenu ? (createElement(SelectedItemWithContextMenu, { renderedItem: renderedItem, beginEditing: this._beginEditing, menuItems: this._createMenuItems(props.item), item: props.item })) : (renderedItem);
        }
    }
    // tslint:disable-next-line:no-any
    _createMenuItems(item) {
        const menuItems = [];
        if (this.props.editMenuItemText && this.props.getEditingItemText) {
            menuItems.push({
                key: 'Edit',
                text: this.props.editMenuItemText,
                onClick: (ev, menuItem) => {
                    this._beginEditing(menuItem.data);
                },
                data: item
            });
        }
        if (this.props.removeMenuItemText) {
            menuItems.push({
                key: 'Remove',
                text: this.props.removeMenuItemText,
                onClick: (ev, menuItem) => {
                    this.removeItem(menuItem.data);
                },
                data: item
            });
        }
        if (this.props.copyMenuItemText) {
            menuItems.push({
                key: 'Copy',
                text: this.props.copyMenuItemText,
                onClick: (ev, menuItem) => {
                    if (this.props.onCopyItems) {
                        this.copyItems([menuItem.data]);
                    }
                },
                data: item
            });
        }
        return menuItems;
    }
}
// tslint:disable-next-line:no-any
SelectedPeopleList.defaultProps = {
    onRenderItem: (props) => createElement(ExtendedSelectedItem, Object.assign({}, props))
};

const GlobalClassNames$N = {
    root: 'ms-Shimmer-container',
    shimmerWrapper: 'ms-Shimmer-shimmerWrapper',
    dataWrapper: 'ms-Shimmer-dataWrapper'
};
const BACKGROUND_OFF_SCREEN_POSITION = '1000%';
const shimmerAnimation = keyframes({
    '0%': {
        backgroundPosition: `-${BACKGROUND_OFF_SCREEN_POSITION}`
    },
    '100%': {
        backgroundPosition: BACKGROUND_OFF_SCREEN_POSITION
    }
});
const shimmerAnimationRTL = keyframes({
    '100%': {
        backgroundPosition: `-${BACKGROUND_OFF_SCREEN_POSITION}`
    },
    '0%': {
        backgroundPosition: BACKGROUND_OFF_SCREEN_POSITION
    }
});
function getStyles$1d(props) {
    const { isDataLoaded, className, theme, transitionAnimationInterval } = props;
    const { palette } = theme;
    const classNames = getGlobalClassNames(GlobalClassNames$N, theme);
    const isRTL = getRTL();
    return {
        root: [
            classNames.root,
            theme.fonts.medium,
            {
                position: 'relative',
                height: 'auto'
            },
            className
        ],
        shimmerWrapper: [
            classNames.shimmerWrapper,
            {
                background: `${palette.neutralLighter}
                    linear-gradient(
                      to right,
                      ${palette.neutralLighter} 0%,
                      ${palette.neutralLight} 50%,
                      ${palette.neutralLighter} 100%)
                    0 0 / 90% 100%
                    no-repeat`,
                animationDuration: '2s',
                animationTimingFunction: 'ease-in-out',
                animationDirection: 'normal',
                animationIterationCount: 'infinite',
                animationName: isRTL ? shimmerAnimationRTL : shimmerAnimation,
                transition: `opacity ${transitionAnimationInterval}ms`,
                selectors: {
                    [HighContrastSelector]: {
                        background: `WindowText
                        linear-gradient(
                          to right,
                          transparent 0%,
                          Window 50%,
                          transparent 100%)
                        0 0 / 90% 100%
                        no-repeat`
                    }
                }
            },
            isDataLoaded && {
                opacity: '0',
                position: 'absolute',
                top: '0',
                bottom: '0',
                left: '0',
                right: '0'
            }
        ],
        dataWrapper: [
            classNames.dataWrapper,
            {
                position: 'absolute',
                top: '0',
                bottom: '0',
                left: '0',
                right: '0',
                opacity: '0',
                background: 'none',
                backgroundColor: 'transparent',
                border: 'none',
                transition: `opacity ${transitionAnimationInterval}ms`
            },
            isDataLoaded && {
                opacity: '1',
                position: 'static'
            }
        ],
        screenReaderText: hiddenContentStyle
    };
}

var ShimmerElementType;
(function (ShimmerElementType) {
    /**
     * Line element type
     */
    ShimmerElementType[ShimmerElementType["line"] = 1] = "line";
    /**
     * Circle element type
     */
    ShimmerElementType[ShimmerElementType["circle"] = 2] = "circle";
    /**
     * Gap element type
     */
    ShimmerElementType[ShimmerElementType["gap"] = 3] = "gap";
})(ShimmerElementType || (ShimmerElementType = {}));
var ShimmerElementsDefaultHeights;
(function (ShimmerElementsDefaultHeights) {
    /**
     * Default height of the line element when not provided by user: 16px
     */
    ShimmerElementsDefaultHeights[ShimmerElementsDefaultHeights["line"] = 16] = "line";
    /**
     * Default height of the gap element when not provided by user: 16px
     */
    ShimmerElementsDefaultHeights[ShimmerElementsDefaultHeights["gap"] = 16] = "gap";
    /**
     * Default height of the circle element when not provided by user: 24px
     */
    ShimmerElementsDefaultHeights[ShimmerElementsDefaultHeights["circle"] = 24] = "circle";
})(ShimmerElementsDefaultHeights || (ShimmerElementsDefaultHeights = {}));

const getClassNames$16 = classNamesFunction();
class ShimmerLineBase extends BaseComponent {
    constructor(props) {
        super(props);
    }
    render() {
        const { height, styles, width, borderStyle, theme } = this.props;
        this._classNames = getClassNames$16(styles, {
            theme: theme,
            height,
            borderStyle
        });
        return (createElement("div", { style: { width: width ? width : '100%', minWidth: typeof width === 'number' ? `${width}px` : 'auto' }, className: this._classNames.root },
            createElement("svg", { width: "2", height: "2", className: this._classNames.topLeftCorner },
                createElement("path", { d: "M0 2 A 2 2, 0, 0, 1, 2 0 L 0 0 Z" })),
            createElement("svg", { width: "2", height: "2", className: this._classNames.topRightCorner },
                createElement("path", { d: "M0 0 A 2 2, 0, 0, 1, 2 2 L 2 0 Z" })),
            createElement("svg", { width: "2", height: "2", className: this._classNames.bottomRightCorner },
                createElement("path", { d: "M2 0 A 2 2, 0, 0, 1, 0 2 L 2 2 Z" })),
            createElement("svg", { width: "2", height: "2", className: this._classNames.bottomLeftCorner },
                createElement("path", { d: "M2 2 A 2 2, 0, 0, 1, 0 0 L 0 2 Z" }))));
    }
}

const GlobalClassNames$O = {
    root: 'ms-ShimmerLine-root',
    topLeftCorner: 'ms-ShimmerLine-topLeftCorner',
    topRightCorner: 'ms-ShimmerLine-topRightCorner',
    bottomLeftCorner: 'ms-ShimmerLine-bottomLeftCorner',
    bottomRightCorner: 'ms-ShimmerLine-bottomRightCorner'
};
function getStyles$1e(props) {
    const { height, borderStyle, theme } = props;
    const { palette } = theme;
    const globalClassNames = getGlobalClassNames(GlobalClassNames$O, theme);
    const borderStyles = !!borderStyle ? borderStyle : {};
    const sharedCornerStyles = {
        position: 'absolute',
        fill: palette.white
    };
    return {
        root: [
            globalClassNames.root,
            theme.fonts.medium,
            {
                height: `${height}px`,
                boxSizing: 'content-box',
                position: 'relative',
                borderTopStyle: 'solid',
                borderBottomStyle: 'solid',
                borderColor: palette.white,
                selectors: {
                    [HighContrastSelector]: {
                        borderColor: 'Window',
                        selectors: {
                            '> *': {
                                fill: 'Window'
                            }
                        }
                    }
                }
            },
            borderStyles
        ],
        topLeftCorner: [
            globalClassNames.topLeftCorner,
            {
                top: '0',
                left: '0'
            },
            sharedCornerStyles
        ],
        topRightCorner: [
            globalClassNames.topRightCorner,
            {
                top: '0',
                right: '0'
            },
            sharedCornerStyles
        ],
        bottomRightCorner: [
            globalClassNames.bottomRightCorner,
            {
                bottom: '0',
                right: '0'
            },
            sharedCornerStyles
        ],
        bottomLeftCorner: [
            globalClassNames.bottomLeftCorner,
            {
                bottom: '0',
                left: '0'
            },
            sharedCornerStyles
        ]
    };
}

const ShimmerLine = styled(ShimmerLineBase, getStyles$1e, undefined, {
    scope: 'ShimmerLine'
});

const getClassNames$17 = classNamesFunction();
class ShimmerGapBase extends BaseComponent {
    constructor(props) {
        super(props);
    }
    render() {
        const { height, styles, width, borderStyle, theme } = this.props;
        this._classNames = getClassNames$17(styles, {
            theme: theme,
            height,
            borderStyle
        });
        return (createElement("div", { style: { width: width ? width : '10px', minWidth: typeof width === 'number' ? `${width}px` : 'auto' }, className: this._classNames.root }));
    }
}

const GlobalClassNames$P = {
    root: 'ms-ShimmerGap-root'
};
function getStyles$1f(props) {
    const { height, borderStyle, theme } = props;
    const { palette } = theme;
    const globalClassNames = getGlobalClassNames(GlobalClassNames$P, theme);
    const borderStyles = !!borderStyle ? borderStyle : {};
    return {
        root: [
            globalClassNames.root,
            theme.fonts.medium,
            {
                backgroundColor: palette.white,
                height: `${height}px`,
                boxSizing: 'content-box',
                borderTopStyle: 'solid',
                borderBottomStyle: 'solid',
                borderColor: palette.white,
                selectors: {
                    [HighContrastSelector]: {
                        backgroundColor: 'Window',
                        borderColor: 'Window'
                    }
                }
            },
            borderStyles
        ]
    };
}

const ShimmerGap = styled(ShimmerGapBase, getStyles$1f, undefined, {
    scope: 'ShimmerGap'
});

const GlobalClassNames$Q = {
    root: 'ms-ShimmerCircle-root',
    svg: 'ms-ShimmerCircle-svg'
};
function getStyles$1g(props) {
    const { height, borderStyle, theme } = props;
    const { palette } = theme;
    const globalClassNames = getGlobalClassNames(GlobalClassNames$Q, theme);
    const borderStyles = !!borderStyle ? borderStyle : {};
    return {
        root: [
            globalClassNames.root,
            theme.fonts.medium,
            {
                width: `${height}px`,
                height: `${height}px`,
                minWidth: `${height}px`,
                boxSizing: 'content-box',
                borderTopStyle: 'solid',
                borderBottomStyle: 'solid',
                borderColor: palette.white,
                selectors: {
                    [HighContrastSelector]: {
                        borderColor: 'Window'
                    }
                }
            },
            borderStyles
        ],
        svg: [
            globalClassNames.svg,
            {
                display: 'block',
                fill: palette.white,
                selectors: {
                    [HighContrastSelector]: {
                        fill: 'Window'
                    }
                }
            }
        ]
    };
}

const getClassNames$18 = classNamesFunction();
class ShimmerCircleBase extends BaseComponent {
    constructor(props) {
        super(props);
    }
    render() {
        const { height, styles, borderStyle, theme } = this.props;
        this._classNames = getClassNames$18(styles, {
            theme: theme,
            height,
            borderStyle
        });
        return (createElement("div", { className: this._classNames.root },
            createElement("svg", { viewBox: "0 0 10 10", width: height, height: height, className: this._classNames.svg },
                createElement("path", { 
                    // tslint:disable-next-line:max-line-length
                    d: "M0,0 L10,0 L10,10 L0,10 L0,0 Z M0,5 C0,7.76142375 2.23857625,10 5,10 C7.76142375,10 10,7.76142375 10,5 C10,2.23857625 7.76142375,2.22044605e-16 5,0 C2.23857625,-2.22044605e-16 0,2.23857625 0,5 L0,5 Z" }))));
    }
}

const ShimmerCircle = styled(ShimmerCircleBase, getStyles$1g, undefined, { scope: 'ShimmerCircle' });

const getClassNames$19 = classNamesFunction();
class ShimmerElementsGroupBase extends BaseComponent {
    constructor(props) {
        super(props);
        this._getRenderedElements = (shimmerElements, rowHeight) => {
            const renderedElements = shimmerElements ? (shimmerElements.map((elem, index) => {
                const { type, ...filteredElem } = elem;
                switch (elem.type) {
                    case ShimmerElementType.circle:
                        return createElement(ShimmerCircle, Object.assign({ key: index }, filteredElem, { styles: this._getBorderStyles(elem, rowHeight) }));
                    case ShimmerElementType.gap:
                        return createElement(ShimmerGap, Object.assign({ key: index }, filteredElem, { styles: this._getBorderStyles(elem, rowHeight) }));
                    case ShimmerElementType.line:
                        return createElement(ShimmerLine, Object.assign({ key: index }, filteredElem, { styles: this._getBorderStyles(elem, rowHeight) }));
                }
            })) : (createElement(ShimmerLine, { height: ShimmerElementsDefaultHeights.line, styles: { root: [{ borderWidth: '0px' }] } }));
            return renderedElements;
        };
        this._getBorderStyles = (elem, rowHeight) => {
            const elemHeight = elem.height;
            const dif = rowHeight && elemHeight ? rowHeight - elemHeight : 0;
            let borderStyle;
            if (!elem.verticalAlign || elem.verticalAlign === 'center') {
                borderStyle = {
                    borderBottomWidth: `${dif ? Math.floor(dif / 2) : 0}px`,
                    borderTopWidth: `${dif ? Math.ceil(dif / 2) : 0}px`
                };
            }
            else if (elem.verticalAlign && elem.verticalAlign === 'top') {
                borderStyle = {
                    borderBottomWidth: `${dif ? dif : 0}px`,
                    borderTopWidth: `0px`
                };
            }
            else if (elem.verticalAlign && elem.verticalAlign === 'bottom') {
                borderStyle = {
                    borderBottomWidth: `0px`,
                    borderTopWidth: `${dif ? dif : 0}px`
                };
            }
            return {
                root: [{ ...borderStyle }]
            };
        };
        /**
         * User should not worry to provide which of the elements is the highest, we do the calculation for him.
         * Plus if user forgot to specify the height we assign their defaults.
         */
        this._findMaxElementHeight = (elements) => {
            const itemsDefaulted = elements.map((elem) => {
                switch (elem.type) {
                    case ShimmerElementType.circle:
                        if (!elem.height) {
                            elem.height = ShimmerElementsDefaultHeights.circle;
                        }
                    case ShimmerElementType.line:
                        if (!elem.height) {
                            elem.height = ShimmerElementsDefaultHeights.line;
                        }
                    case ShimmerElementType.gap:
                        if (!elem.height) {
                            elem.height = ShimmerElementsDefaultHeights.gap;
                        }
                }
                return elem;
            });
            const rowHeight = itemsDefaulted.reduce((acc, next) => {
                return next.height ? (next.height > acc ? next.height : acc) : acc;
            }, 0);
            return rowHeight;
        };
    }
    render() {
        const { styles, width, shimmerElements, rowHeight, flexWrap, theme } = this.props;
        this._classNames = getClassNames$19(styles, {
            theme: theme,
            flexWrap
        });
        const height = rowHeight ? rowHeight : this._findMaxElementHeight(shimmerElements ? shimmerElements : []);
        return (
        // tslint:disable-next-line:jsx-ban-props
        createElement("div", { style: { width: width ? width : 'auto' }, className: this._classNames.root }, this._getRenderedElements(shimmerElements, height)));
    }
}
ShimmerElementsGroupBase.defaultProps = {
    flexWrap: false
};

const GlobalClassNames$R = {
    root: 'ms-ShimmerElementsGroup-root'
};
function getStyles$1h(props) {
    const { flexWrap, theme } = props;
    const classNames = getGlobalClassNames(GlobalClassNames$R, theme);
    return {
        root: [
            classNames.root,
            theme.fonts.medium,
            {
                display: 'flex',
                alignItems: 'center',
                flexWrap: flexWrap ? 'wrap' : 'nowrap'
            }
        ]
    };
}

const ShimmerElementsGroup = styled(ShimmerElementsGroupBase, getStyles$1h, undefined, { scope: 'ShimmerElementsGroup' });

const TRANSITION_ANIMATION_INTERVAL = 200; /* ms */
const getClassNames$1a = classNamesFunction();
class ShimmerBase extends BaseComponent {
    constructor(props) {
        super(props);
        this.state = {
            contentLoaded: props.isDataLoaded
        };
    }
    componentWillReceiveProps(nextProps) {
        const { isDataLoaded } = nextProps;
        if (this._lastTimeoutId !== undefined) {
            this._async.clearTimeout(this._lastTimeoutId);
            this._lastTimeoutId = undefined;
        }
        if (isDataLoaded) {
            this._lastTimeoutId = this._async.setTimeout(() => {
                this.setState({
                    contentLoaded: isDataLoaded
                });
                this._lastTimeoutId = undefined;
            }, TRANSITION_ANIMATION_INTERVAL);
        }
        else {
            this.setState({
                contentLoaded: isDataLoaded
            });
        }
    }
    render() {
        const { styles, shimmerElements, children, isDataLoaded, width, className, customElementsGroup, theme, ariaLabel } = this.props;
        const { contentLoaded } = this.state;
        this._classNames = getClassNames$1a(styles, {
            theme: theme,
            isDataLoaded,
            className,
            transitionAnimationInterval: TRANSITION_ANIMATION_INTERVAL
        });
        const divProps = getNativeProps(this.props, divProperties);
        return (createElement("div", Object.assign({}, divProps, { className: this._classNames.root }),
            !contentLoaded && (createElement("div", { style: { width: width ? width : '100%' }, className: this._classNames.shimmerWrapper }, customElementsGroup ? customElementsGroup : createElement(ShimmerElementsGroup, { shimmerElements: shimmerElements }))),
            children && createElement("div", { className: this._classNames.dataWrapper }, children),
            ariaLabel && !isDataLoaded && (createElement("div", { role: "status", "aria-live": "polite" },
                createElement(DelayedRender, null,
                    createElement("div", { className: this._classNames.screenReaderText }, ariaLabel))))));
    }
}
ShimmerBase.defaultProps = {
    isDataLoaded: false
};

const Shimmer = styled(ShimmerBase, getStyles$1d, undefined, {
    scope: 'Shimmer'
});

const getRowClassNames = classNamesFunction();
const getClassNames$1b = classNamesFunction();
const SHIMMER_INITIAL_ITEMS$1 = 10;
const DEFAULT_SHIMMER_HEIGHT = 7;
const SHIMMER_LINE_VS_CELL_WIDTH_RATIO = 0.95;
class ShimmeredDetailsListBase extends BaseComponent {
    constructor(props) {
        super(props);
        this._onRenderShimmerPlaceholder = (index, rowProps) => {
            const { onRenderCustomPlaceholder, compact } = this.props;
            const { selectionMode, checkboxVisibility } = rowProps;
            const theme = this.props.theme;
            const showCheckbox = selectionMode !== SelectionMode.none && checkboxVisibility !== CheckboxVisibility.hidden;
            const rowStyleProps = {
                ...rowProps,
                theme: theme
            };
            const rowClassNames = getRowClassNames(getStyles$C(rowStyleProps), {
                theme: theme
            });
            const placeholderElements = onRenderCustomPlaceholder
                ? onRenderCustomPlaceholder()
                : this._renderDefaultShimmerPlaceholder(rowProps);
            return (createElement("div", { className: css(showCheckbox && rowClassNames.shimmerLeftBorder, !compact && rowClassNames.shimmerBottomBorder) },
                createElement(Shimmer, { customElementsGroup: placeholderElements })));
        };
        this._renderDefaultShimmerPlaceholder = (rowProps) => {
            const { columns, compact, cellStyleProps = DEFAULT_CELL_STYLE_PROPS } = rowProps;
            const shimmerElementsRow = [];
            const { rowHeight, compactRowHeight } = DEFAULT_ROW_HEIGHTS;
            const gapHeight = compact ? compactRowHeight : rowHeight;
            columns.map((column, columnIdx) => {
                const shimmerElements = [];
                const groupWidth = cellStyleProps.cellLeftPadding +
                    cellStyleProps.cellRightPadding +
                    column.calculatedWidth +
                    (column.isPadded ? cellStyleProps.cellExtraRightPadding : 0);
                shimmerElements.push({
                    type: ShimmerElementType.gap,
                    width: cellStyleProps.cellLeftPadding,
                    height: gapHeight
                });
                if (column.isIconOnly) {
                    shimmerElements.push({
                        type: ShimmerElementType.line,
                        width: column.calculatedWidth,
                        height: column.calculatedWidth
                    });
                    shimmerElements.push({
                        type: ShimmerElementType.gap,
                        width: cellStyleProps.cellRightPadding,
                        height: gapHeight
                    });
                }
                else {
                    shimmerElements.push({
                        type: ShimmerElementType.line,
                        width: column.calculatedWidth * SHIMMER_LINE_VS_CELL_WIDTH_RATIO,
                        height: DEFAULT_SHIMMER_HEIGHT
                    });
                    shimmerElements.push({
                        type: ShimmerElementType.gap,
                        width: cellStyleProps.cellRightPadding +
                            (column.calculatedWidth - column.calculatedWidth * SHIMMER_LINE_VS_CELL_WIDTH_RATIO) +
                            (column.isPadded ? cellStyleProps.cellExtraRightPadding : 0),
                        height: gapHeight
                    });
                }
                shimmerElementsRow.push(createElement(ShimmerElementsGroup, { key: columnIdx, width: `${groupWidth}px`, shimmerElements: shimmerElements }));
            });
            // When resizing the window from narrow to wider, we need to cover the exposed Shimmer wave until the column resizing logic is done.
            shimmerElementsRow.push(createElement(ShimmerElementsGroup, { key: 'endGap', width: '100%', shimmerElements: [{ type: ShimmerElementType.gap, width: '100%', height: gapHeight }] }));
            return createElement("div", { style: { display: 'flex' } }, shimmerElementsRow);
        };
        this._shimmerItems = props.shimmerLines ? new Array(props.shimmerLines) : new Array(SHIMMER_INITIAL_ITEMS$1);
    }
    render() {
        const { items, listProps, styles, theme, shimmerLines, onRenderCustomPlaceholder, enableShimmer, ...detailsListProps } = this.props;
        // Adds to the optional listProp classname a fading out overlay classname only when shimmer enabled.
        const classNames = getClassNames$1b(styles, {
            theme: theme,
            className: listProps && listProps.className,
            enableShimmer
        });
        const newListProps = { ...listProps, className: classNames.root };
        return (createElement(DetailsList, Object.assign({}, detailsListProps, { enableShimmer: enableShimmer, items: enableShimmer ? this._shimmerItems : items, onRenderMissingItem: this._onRenderShimmerPlaceholder, listProps: newListProps })));
    }
}

const getStyles$1i = (props) => {
    const { theme, className, enableShimmer } = props;
    const { palette } = theme;
    return {
        root: [
            theme.fonts.small,
            enableShimmer && {
                selectors: {
                    ':after': {
                        content: '""',
                        position: 'absolute',
                        top: 0,
                        right: 0,
                        bottom: 0,
                        left: 0,
                        backgroundImage: `linear-gradient(to bottom, transparent 30%, ${palette.whiteTranslucent40} 65%,${palette.white} 100%)`
                    }
                }
            },
            className
        ]
    };
};

const ShimmeredDetailsList = styled(ShimmeredDetailsListBase, getStyles$1i, undefined, { scope: 'ShimmeredDetailsList' });

/**
 * @deprecated Unused.
 */
var ValuePosition;
(function (ValuePosition) {
    ValuePosition[ValuePosition["Previous"] = 0] = "Previous";
    ValuePosition[ValuePosition["Next"] = 1] = "Next";
})(ValuePosition || (ValuePosition = {}));
const getClassNames$1c = classNamesFunction();
class SliderBase extends BaseComponent {
    constructor(props) {
        super(props);
        this._sliderLine = createRef();
        this._thumb = createRef();
        this._getAriaValueText = (value) => {
            if (this.props.ariaValueText && value !== undefined) {
                return this.props.ariaValueText(value);
            }
        };
        this._onMouseDownOrTouchStart = (event) => {
            if (event.type === 'mousedown') {
                this._events.on(window, 'mousemove', this._onMouseMoveOrTouchMove, true);
                this._events.on(window, 'mouseup', this._onMouseUpOrTouchEnd, true);
            }
            else if (event.type === 'touchstart') {
                this._events.on(window, 'touchmove', this._onMouseMoveOrTouchMove, true);
                this._events.on(window, 'touchend', this._onMouseUpOrTouchEnd, true);
            }
            this._onMouseMoveOrTouchMove(event, true);
        };
        this._onMouseMoveOrTouchMove = (event, suppressEventCancelation) => {
            if (!this._sliderLine.current) {
                return;
            }
            const { max, min, step } = this.props;
            const steps = (max - min) / step;
            const sliderPositionRect = this._sliderLine.current.getBoundingClientRect();
            const sliderLength = !this.props.vertical ? sliderPositionRect.width : sliderPositionRect.height;
            const stepLength = sliderLength / steps;
            let currentSteps;
            let distance;
            if (!this.props.vertical) {
                const left = this._getPosition(event, this.props.vertical);
                distance = getRTL() ? sliderPositionRect.right - left : left - sliderPositionRect.left;
                currentSteps = distance / stepLength;
            }
            else {
                const bottom = this._getPosition(event, this.props.vertical);
                distance = sliderPositionRect.bottom - bottom;
                currentSteps = distance / stepLength;
            }
            let currentValue;
            let renderedValue;
            // The value shouldn't be bigger than max or be smaller than min.
            if (currentSteps > Math.floor(steps)) {
                renderedValue = currentValue = max;
            }
            else if (currentSteps < 0) {
                renderedValue = currentValue = min;
            }
            else {
                renderedValue = min + step * currentSteps;
                currentValue = min + step * Math.round(currentSteps);
            }
            this._updateValue(currentValue, renderedValue);
            if (!suppressEventCancelation) {
                event.preventDefault();
                event.stopPropagation();
            }
        };
        this._onMouseUpOrTouchEnd = (event) => {
            // Synchronize the renderedValue to the actual value.
            this.setState({
                renderedValue: this.state.value
            });
            if (this.props.onChanged) {
                this.props.onChanged(event, this.state.value);
            }
            this._events.off();
        };
        this._onKeyDown = (event) => {
            let value = this.state.value;
            const { max, min, step } = this.props;
            let diff = 0;
            switch (event.which) {
                case getRTLSafeKeyCode(KeyCodes.left):
                case KeyCodes.down:
                    diff = -step;
                    break;
                case getRTLSafeKeyCode(KeyCodes.right):
                case KeyCodes.up:
                    diff = step;
                    break;
                case KeyCodes.home:
                    value = min;
                    break;
                case KeyCodes.end:
                    value = max;
                    break;
                default:
                    return;
            }
            const newValue = Math.min(max, Math.max(min, value + diff));
            this._updateValue(newValue, newValue);
            event.preventDefault();
            event.stopPropagation();
        };
        this._warnMutuallyExclusive({
            value: 'defaultValue'
        });
        this._id = getId('Slider');
        const value = props.value !== undefined ? props.value : props.defaultValue !== undefined ? props.defaultValue : props.min;
        this.state = {
            value: value,
            renderedValue: value
        };
    }
    /**
     * Invoked when a component is receiving new props. This method is not called for the initial render.
     */
    componentWillReceiveProps(newProps) {
        if (newProps.value !== undefined) {
            const value = Math.max(newProps.min, Math.min(newProps.max, newProps.value));
            this.setState({
                value: value,
                renderedValue: value
            });
        }
    }
    render() {
        const { ariaLabel, className, disabled, label, max, min, showValue, buttonProps, vertical, valueFormat, styles, theme } = this.props;
        const { value, renderedValue } = this.state;
        const thumbOffsetPercent = min === max ? 0 : ((renderedValue - min) / (max - min)) * 100;
        const lengthString = vertical ? 'height' : 'width';
        const onMouseDownProp = disabled ? {} : { onMouseDown: this._onMouseDownOrTouchStart };
        const onTouchStartProp = disabled ? {} : { onTouchStart: this._onMouseDownOrTouchStart };
        const onKeyDownProp = disabled ? {} : { onKeyDown: this._onKeyDown };
        const classNames = getClassNames$1c(styles, {
            className,
            disabled,
            vertical,
            showTransitions: renderedValue === value,
            showValue,
            theme: theme
        });
        const divButtonProps = buttonProps ? getNativeProps(buttonProps, divProperties) : undefined;
        return (createElement("div", { className: classNames.root },
            label && (createElement(Label, Object.assign({ className: classNames.titleLabel }, (ariaLabel ? {} : { htmlFor: this._id })), label)),
            createElement("div", { className: classNames.container },
                createElement("div", Object.assign({ "aria-valuenow": value, "aria-valuemin": min, "aria-valuemax": max, "aria-valuetext": this._getAriaValueText(value), "aria-label": ariaLabel || label, "aria-disabled": disabled }, onMouseDownProp, onTouchStartProp, onKeyDownProp, divButtonProps, { className: css(classNames.slideBox, buttonProps.className), id: this._id, role: "slider", tabIndex: disabled ? undefined : 0, "data-is-focusable": !disabled }),
                    createElement("div", { ref: this._sliderLine, className: classNames.line },
                        createElement("span", { ref: this._thumb, className: classNames.thumb, style: this._getThumbStyle(vertical, thumbOffsetPercent) }),
                        createElement("span", { className: css(classNames.lineContainer, classNames.activeSection), style: { [lengthString]: thumbOffsetPercent + '%' } }),
                        createElement("span", { className: css(classNames.lineContainer, classNames.inactiveSection), style: { [lengthString]: 100 - thumbOffsetPercent + '%' } }))),
                showValue && createElement(Label, { className: classNames.valueLabel }, valueFormat ? valueFormat(value) : value))));
    }
    focus() {
        if (this._thumb.current) {
            this._thumb.current.focus();
        }
    }
    get value() {
        return this.state.value;
    }
    _getThumbStyle(vertical, thumbOffsetPercent) {
        const direction = vertical ? 'bottom' : getRTL() ? 'right' : 'left';
        return {
            [direction]: thumbOffsetPercent + '%'
        };
    }
    _getPosition(event, vertical) {
        let currentPosition;
        switch (event.type) {
            case 'mousedown':
            case 'mousemove':
                currentPosition = !vertical ? event.clientX : event.clientY;
                break;
            case 'touchstart':
            case 'touchmove':
                currentPosition = !vertical ? event.touches[0].clientX : event.touches[0].clientY;
                break;
        }
        return currentPosition;
    }
    _updateValue(value, renderedValue) {
        const { step } = this.props;
        let numDec = 0;
        if (isFinite(step)) {
            while (Math.round(step * Math.pow(10, numDec)) / Math.pow(10, numDec) !== step) {
                numDec++;
            }
        }
        // Make sure value has correct number of decimal places based on number of decimals in step
        const roundedValue = parseFloat(value.toFixed(numDec));
        const valueChanged = roundedValue !== this.state.value;
        this.setState({
            value: roundedValue,
            renderedValue
        }, () => {
            if (valueChanged && this.props.onChange) {
                this.props.onChange(this.state.value);
            }
        });
    }
}
SliderBase.defaultProps = {
    step: 1,
    min: 0,
    max: 10,
    showValue: true,
    disabled: false,
    vertical: false,
    buttonProps: {}
};

const GlobalClassNames$S = {
    root: 'ms-Slider',
    enabled: 'ms-Slider-enabled',
    disabled: 'ms-Slider-disabled',
    row: 'ms-Slider-row',
    column: 'ms-Slider-column',
    container: 'ms-Slider-container',
    slideBox: 'ms-Slider-slideBox',
    line: 'ms-Slider-line',
    thumb: 'ms-Slider-thumb',
    activeSection: 'ms-Slider-active',
    inactiveSection: 'ms-Slider-inactive',
    valueLabel: 'ms-Slider-value',
    showValue: 'ms-Slider-showValue',
    showTransitions: 'ms-Slider-showTransitions'
};
const getStyles$1j = (props) => {
    const { className, titleLabelClassName, theme } = props;
    const classNames = getGlobalClassNames(GlobalClassNames$S, theme);
    const slideBoxActiveSectionStyles = !props.disabled && {
        backgroundColor: theme.palette.themePrimary,
        selectors: {
            [HighContrastSelector]: {
                backgroundColor: 'Highlight'
            }
        }
    };
    const slideBoxInactiveSectionStyles = !props.disabled && {
        backgroundColor: theme.palette.themeLight,
        selectors: {
            [HighContrastSelector]: {
                borderColor: 'Highlight'
            }
        }
    };
    const slideBoxActiveThumbStyles = !props.disabled && {
        border: `2px solid ${theme.palette.themePrimary}`,
        selectors: {
            [HighContrastSelector]: {
                borderColor: 'Highlight'
            }
        }
    };
    return {
        root: [
            classNames.root,
            theme.fonts.medium,
            {
                userSelect: 'none'
            },
            props.vertical && {
                marginRight: 8
            },
            ...[!props.disabled ? classNames.enabled : undefined],
            ...[props.disabled ? classNames.disabled : undefined],
            ...[!props.vertical ? classNames.row : undefined],
            ...[props.vertical ? classNames.column : undefined],
            className
        ],
        titleLabel: [
            {
                padding: 0
            },
            titleLabelClassName
        ],
        container: [
            classNames.container,
            {
                display: 'flex',
                flexWrap: 'nowrap',
                alignItems: 'center'
            },
            props.vertical && {
                flexDirection: 'column',
                height: '100%',
                textAlign: 'center',
                margin: '8px 0'
            }
        ],
        slideBox: [
            classNames.slideBox,
            getFocusStyle(theme),
            {
                background: 'transparent',
                border: 'none',
                flexGrow: 1,
                lineHeight: 28,
                display: 'flex',
                alignItems: 'center',
                selectors: {
                    ':active $activeSection': slideBoxActiveSectionStyles,
                    ':hover $activeSection': slideBoxActiveSectionStyles,
                    ':active $inactiveSection': slideBoxInactiveSectionStyles,
                    ':hover $inactiveSection': slideBoxInactiveSectionStyles,
                    ':active $thumb': slideBoxActiveThumbStyles,
                    ':hover $thumb': slideBoxActiveThumbStyles,
                    $thumb: [
                        {
                            borderWidth: 2,
                            borderStyle: 'solid',
                            borderColor: theme.palette.neutralSecondary,
                            borderRadius: 10,
                            boxSizing: 'border-box',
                            background: theme.palette.white,
                            display: 'block',
                            width: 16,
                            height: 16,
                            position: 'absolute'
                        },
                        props.vertical
                            ? {
                                left: -6,
                                margin: '0 auto',
                                transform: 'translateY(8px)'
                            }
                            : {
                                top: -6,
                                transform: getRTL() ? 'translateX(50%)' : 'translateX(-50%)'
                            },
                        props.showTransitions && {
                            transition: `left ${AnimationVariables.durationValue3} ${AnimationVariables.easeFunction1}`
                        },
                        props.disabled && {
                            borderColor: theme.palette.neutralTertiaryAlt,
                            selectors: {
                                [HighContrastSelector]: {
                                    borderColor: 'GrayText'
                                }
                            }
                        }
                    ]
                }
            },
            props.vertical
                ? {
                    height: '100%',
                    width: 28,
                    padding: '8px 0' // Make room for thumb at bottom of line
                }
                : {
                    height: 28,
                    width: 'auto',
                    padding: '0 8px' // Make room for thumb at ends of line
                },
            ...[props.showValue ? classNames.showValue : undefined],
            ...[props.showTransitions ? classNames.showTransitions : undefined]
        ],
        thumb: [classNames.thumb],
        line: [
            classNames.line,
            {
                display: 'flex',
                position: 'relative',
                selectors: {
                    $lineContainer: [
                        {
                            borderRadius: 4,
                            boxSizing: 'border-box'
                        },
                        props.vertical
                            ? {
                                width: 4,
                                height: '100%'
                            }
                            : {
                                height: 4,
                                width: '100%'
                            }
                    ]
                }
            },
            props.vertical
                ? {
                    height: '100%',
                    width: 4,
                    margin: '0 auto',
                    flexDirection: 'column-reverse'
                }
                : {
                    width: '100%'
                }
        ],
        lineContainer: [{}],
        activeSection: [
            classNames.activeSection,
            {
                background: theme.palette.neutralSecondary,
                selectors: {
                    [HighContrastSelector]: {
                        backgroundColor: 'WindowText'
                    }
                }
            },
            props.showTransitions && {
                transition: `width ${AnimationVariables.durationValue3} ${AnimationVariables.easeFunction1}`
            },
            props.disabled && {
                background: theme.palette.neutralTertiaryAlt,
                selectors: {
                    [HighContrastSelector]: {
                        backgroundColor: 'GrayText',
                        borderColor: 'GrayText'
                    }
                }
            }
        ],
        inactiveSection: [
            classNames.inactiveSection,
            {
                background: theme.palette.neutralTertiaryAlt,
                selectors: {
                    [HighContrastSelector]: {
                        border: '1px solid WindowText'
                    }
                }
            },
            props.showTransitions && {
                transition: `width ${AnimationVariables.durationValue3} ${AnimationVariables.easeFunction1}`
            },
            props.disabled && {
                background: theme.palette.neutralLight,
                selectors: {
                    [HighContrastSelector]: {
                        backgroundColor: 'GrayText',
                        borderColor: 'GrayText'
                    }
                }
            }
        ],
        valueLabel: [
            classNames.valueLabel,
            {
                flexShrink: 1,
                width: 30,
                lineHeight: '1' // using a string here meaning it's relative to the size of the font
            },
            props.vertical
                ? {
                    margin: '0 auto',
                    whiteSpace: 'nowrap',
                    width: 40
                }
                : {
                    margin: '0 8px',
                    whiteSpace: 'nowrap',
                    width: 40
                }
        ]
    };
};

const Slider = styled(SliderBase, getStyles$1j, undefined, {
    scope: 'Slider'
});

const _getDisabledStyles = memoizeFunction((theme) => {
    const { semanticColors } = theme;
    const SpinButtonTextColorDisabled = semanticColors.disabledText;
    const SpinButtonBackgroundColorDisabled = semanticColors.disabledBackground;
    return {
        backgroundColor: SpinButtonBackgroundColorDisabled,
        borderColor: 'transparent',
        pointerEvents: 'none',
        cursor: 'default',
        color: SpinButtonTextColorDisabled,
        selectors: {
            [HighContrastSelector]: {
                color: 'GrayText'
            }
        }
    };
});
const getArrowButtonStyles = memoizeFunction((theme, isUpArrow, customSpecificArrowStyles) => {
    const { semanticColors } = theme;
    const ArrowButtonTextColor = semanticColors.buttonText;
    const ArrowButtonTextColorHovered = semanticColors.buttonTextHovered;
    const ArrowButtonTextColorPressed = semanticColors.buttonTextChecked;
    const ArrowButtonBackgroundHovered = semanticColors.buttonBackgroundHovered;
    const ArrowButtonBackgroundPressed = semanticColors.buttonBackgroundChecked;
    const defaultArrowButtonStyles = {
        root: {
            outline: 'none',
            display: 'block',
            height: '50%',
            width: '14px',
            padding: '0',
            backgroundColor: 'transparent',
            textAlign: 'center',
            cursor: 'default',
            color: ArrowButtonTextColor
        },
        rootHovered: {
            backgroundColor: ArrowButtonBackgroundHovered,
            color: ArrowButtonTextColorHovered
        },
        rootChecked: {
            backgroundColor: ArrowButtonBackgroundPressed,
            color: ArrowButtonTextColorPressed,
            selectors: {
                [HighContrastSelector]: {
                    backgroundColor: 'Highlight',
                    color: 'HighlightText'
                }
            }
        },
        rootPressed: {
            backgroundColor: ArrowButtonBackgroundPressed,
            color: ArrowButtonTextColorPressed,
            selectors: {
                [HighContrastSelector]: {
                    backgroundColor: 'Highlight',
                    color: 'HighlightText'
                }
            }
        },
        rootDisabled: {
            opacity: 0.5,
            selectors: {
                [HighContrastSelector]: {
                    color: 'GrayText',
                    opacity: 1
                }
            }
        },
        icon: {
            fontSize: '6px',
            marginTop: '0',
            marginRight: '0',
            marginBottom: '0',
            marginLeft: '0'
        }
    };
    // No specific styles needed as of now.
    const defaultUpArrowButtonStyles = {};
    const defaultDownArrowButtonStyles = {};
    return concatStyleSets(defaultArrowButtonStyles, isUpArrow ? defaultUpArrowButtonStyles : defaultDownArrowButtonStyles, customSpecificArrowStyles);
});
const getStyles$1k = memoizeFunction((theme, customStyles) => {
    const { palette, semanticColors } = theme;
    const SpinButtonRootBorderColor = semanticColors.inputBorder;
    const SpinButtonRootBorderColorHovered = semanticColors.inputBorderHovered;
    const SpinButtonRootBorderColorFocused = semanticColors.inputFocusBorderAlt;
    const SpinButtonTextColorDisabled = semanticColors.disabledText;
    const SpinButtonInputTextColor = semanticColors.bodyText;
    const SpinButtonInputTextColorSelected = palette.white;
    const SpinButtonInputBackgroundColorSelected = palette.themePrimary;
    const SpinButtonIconDisabledColor = semanticColors.disabledText;
    const defaultStyles = {
        root: {
            outline: 'none',
            fontSize: FontSizes.medium,
            width: '100%',
            minWidth: '86px'
        },
        labelWrapper: {
            display: 'inline-flex'
        },
        labelWrapperStart: {
            float: 'left',
            marginRight: '10px'
        },
        labelWrapperEnd: {
            float: 'right',
            marginLeft: '10px'
        },
        labelWrapperTop: {
            marginBottom: '10px'
        },
        labelWrapperBottom: {
            marginTop: '10px'
        },
        icon: {
            padding: '2px 5px',
            fontSize: '20px'
        },
        iconDisabled: {
            color: SpinButtonIconDisabledColor
        },
        label: {
            pointerEvents: 'none',
            padding: '2px 0'
        },
        labelDisabled: {
            cursor: 'default',
            color: SpinButtonTextColorDisabled,
            selectors: {
                [HighContrastSelector]: {
                    color: 'GrayText'
                }
            }
        },
        spinButtonWrapper: {
            display: 'flex',
            boxSizing: 'border-box',
            height: '32px',
            minWidth: '86px',
            borderWidth: '1px',
            borderStyle: 'solid',
            borderColor: SpinButtonRootBorderColor
        },
        spinButtonWrapperTopBottom: {
            width: '100%'
        },
        spinButtonWrapperHovered: {
            borderColor: SpinButtonRootBorderColorHovered,
            outline: '2px dashed transparent',
            selectors: {
                [HighContrastSelector]: {
                    borderColor: 'Highlight',
                    outline: 'none'
                }
            }
        },
        spinButtonWrapperFocused: {
            borderColor: SpinButtonRootBorderColorFocused,
            outline: '2px dashed transparent',
            selectors: {
                [HighContrastSelector]: {
                    borderColor: 'Highlight',
                    outline: 'none'
                }
            }
        },
        spinButtonWrapperDisabled: _getDisabledStyles(theme),
        input: {
            boxSizing: 'border-box',
            boxShadow: 'none',
            borderStyle: 'none',
            marginTop: '0',
            marginRight: '0',
            marginBottom: '0',
            marginLeft: '0',
            fontSize: FontSizes.medium,
            color: SpinButtonInputTextColor,
            height: '100%',
            padding: '0 12px',
            outline: '0',
            textOverflow: 'ellipsis',
            display: 'block',
            float: 'left',
            width: 'calc(100% - 14px)',
            minWidth: '72px',
            overflow: 'hidden',
            cursor: 'text',
            userSelect: 'text'
        },
        inputTextSelected: {
            backgroundColor: SpinButtonInputBackgroundColorSelected,
            color: SpinButtonInputTextColorSelected,
            selectors: {
                [HighContrastSelector]: {
                    backgroundColor: 'Highlight',
                    borderColor: 'Highlight',
                    color: 'HighlightText'
                }
            }
        },
        inputDisabled: _getDisabledStyles(theme),
        arrowButtonsContainer: {
            outline: 'none',
            fontSize: '12px',
            display: 'block',
            float: 'left',
            height: '100%',
            cursor: 'default',
            padding: '0',
            boxSizing: 'border-box'
        },
        arrowButtonsContainerDisabled: _getDisabledStyles(theme)
    };
    return concatStyleSets(defaultStyles, customStyles);
});

const getClassNames$1d = memoizeFunction((styles, disabled, isFocused, keyboardSpinDirection, labelPosition = Position.start, className = undefined) => {
    return {
        root: mergeStyles(styles.root, className),
        labelWrapper: mergeStyles(styles.labelWrapper, _getStyleForLabelBasedOnPosition(labelPosition, styles)),
        icon: mergeStyles(styles.icon, disabled && styles.iconDisabled),
        label: mergeStyles(styles.label, disabled && styles.labelDisabled),
        spinButtonWrapper: mergeStyles(styles.spinButtonWrapper, _getStyleForRootBasedOnPosition(labelPosition, styles), !disabled && [
            {
                selectors: {
                    ':hover': styles.spinButtonWrapperHovered
                }
            },
            isFocused && {
                // This is to increase the specifity of the focus styles
                // and make it equal to that of the hover styles.
                selectors: {
                    '&&': styles.spinButtonWrapperFocused
                }
            }
        ], disabled && styles.spinButtonWrapperDisabled),
        input: mergeStyles('ms-spinButton-input', styles.input, !disabled && {
            selectors: {
                '::selection': styles.inputTextSelected
            }
        }, disabled && styles.inputDisabled),
        arrowBox: mergeStyles(styles.arrowButtonsContainer, disabled && styles.arrowButtonsContainerDisabled)
    };
});
/**
 * Returns the Style corresponding to the label position
 */
function _getStyleForLabelBasedOnPosition(labelPosition, styles) {
    switch (labelPosition) {
        case Position.start:
            return styles.labelWrapperStart;
        case Position.end:
            return styles.labelWrapperEnd;
        case Position.top:
            return styles.labelWrapperTop;
        case Position.bottom:
            return styles.labelWrapperBottom;
    }
}
/**
 * Returns the Style corresponding to the label position
 */
function _getStyleForRootBasedOnPosition(labelPosition, styles) {
    switch (labelPosition) {
        case Position.top:
        case Position.bottom:
            return styles.spinButtonWrapperTopBottom;
        default:
            return {};
    }
}

var KeyboardSpinDirection;
(function (KeyboardSpinDirection) {
    KeyboardSpinDirection[KeyboardSpinDirection["down"] = -1] = "down";
    KeyboardSpinDirection[KeyboardSpinDirection["notSpinning"] = 0] = "notSpinning";
    KeyboardSpinDirection[KeyboardSpinDirection["up"] = 1] = "up";
})(KeyboardSpinDirection || (KeyboardSpinDirection = {}));
let SpinButton = class SpinButton extends BaseComponent {
    constructor(props) {
        super(props);
        this._input = createRef$1();
        this._initialStepDelay = 400;
        this._stepDelay = 75;
        this._onFocus = (ev) => {
            // We can't set focus on a non-existing element
            if (!this._input.current) {
                return;
            }
            if (this._spinningByMouse || this.state.keyboardSpinDirection !== KeyboardSpinDirection.notSpinning) {
                this._stop();
            }
            this._input.current.select();
            this.setState({ isFocused: true });
            if (this.props.onFocus) {
                this.props.onFocus(ev);
            }
        };
        this._onBlur = (ev) => {
            this._validate(ev);
            this.setState({ isFocused: false });
            if (this.props.onBlur) {
                this.props.onBlur(ev);
            }
        };
        this._onValidate = (value, event) => {
            if (this.props.onValidate) {
                return this.props.onValidate(value, event);
            }
            else {
                return this._defaultOnValidate(value);
            }
        };
        /**
         * Validate function to use if one is not passed in
         */
        this._defaultOnValidate = (value) => {
            if (value === null || value.trim().length === 0 || isNaN(Number(value))) {
                return this._lastValidValue;
            }
            const newValue = Math.min(this.props.max, Math.max(this.props.min, Number(value)));
            return String(newValue);
        };
        this._onIncrement = (value) => {
            if (this.props.onIncrement) {
                return this.props.onIncrement(value);
            }
            else {
                return this._defaultOnIncrement(value);
            }
        };
        /**
         * Increment function to use if one is not passed in
         */
        this._defaultOnIncrement = (value) => {
            let newValue = Math.min(Number(value) + Number(this.props.step), this.props.max);
            newValue = precisionRound(newValue, this.state.precision);
            return String(newValue);
        };
        this._onDecrement = (value) => {
            if (this.props.onDecrement) {
                return this.props.onDecrement(value);
            }
            else {
                return this._defaultOnDecrement(value);
            }
        };
        /**
         * Increment function to use if one is not passed in
         */
        this._defaultOnDecrement = (value) => {
            let newValue = Math.max(Number(value) - Number(this.props.step), this.props.min);
            newValue = precisionRound(newValue, this.state.precision);
            return String(newValue);
        };
        /**
         * This is used when validating text entry
         * in the input (not when changed via the buttons)
         * @param event - the event that fired
         */
        this._validate = (event) => {
            if (this.state.value !== undefined && this._valueToValidate !== undefined && this._valueToValidate !== this._lastValidValue) {
                const newValue = this._onValidate(this._valueToValidate, event);
                if (newValue) {
                    this._lastValidValue = newValue;
                    this._valueToValidate = undefined;
                    this.setState({ value: newValue });
                }
            }
        };
        /**
         * The method is needed to ensure we are updating the actual input value.
         * without this our value will never change (and validation will not have the correct number)
         * @param event - the event that was fired
         */
        this._onInputChange = (event) => {
            const element = event.target;
            const value = element.value;
            this._valueToValidate = value;
            this.setState({
                value: value
            });
        };
        /**
         * Update the value with the given stepFunction
         * @param shouldSpin - should we fire off another updateValue when we are done here? This should be true
         * when spinning in response to a mouseDown
         * @param stepFunction - function to use to step by
         */
        this._updateValue = (shouldSpin, stepDelay, stepFunction) => {
            const newValue = stepFunction(this.state.value);
            if (newValue) {
                this._lastValidValue = newValue;
                this.setState({ value: newValue });
            }
            if (this._spinningByMouse !== shouldSpin) {
                this._spinningByMouse = shouldSpin;
            }
            if (shouldSpin) {
                this._currentStepFunctionHandle = this._async.setTimeout(() => {
                    this._updateValue(shouldSpin, this._stepDelay, stepFunction);
                }, stepDelay);
            }
        };
        /**
         * Stop spinning (clear any currently pending update and set spinning to false)
         */
        this._stop = () => {
            if (this._currentStepFunctionHandle >= 0) {
                this._async.clearTimeout(this._currentStepFunctionHandle);
                this._currentStepFunctionHandle = -1;
            }
            if (this._spinningByMouse || this.state.keyboardSpinDirection !== KeyboardSpinDirection.notSpinning) {
                this._spinningByMouse = false;
                this.setState({ keyboardSpinDirection: KeyboardSpinDirection.notSpinning });
            }
        };
        /**
         * Handle keydown on the text field. We need to update
         * the value when up or down arrow are depressed
         * @param event - the keyboardEvent that was fired
         */
        this._handleKeyDown = (event) => {
            // eat the up and down arrow keys to keep focus in the spinButton
            // (especially when a spinButton is inside of a FocusZone)
            if (event.which === KeyCodes.up || event.which === KeyCodes.down || event.which === KeyCodes.enter) {
                event.preventDefault();
                event.stopPropagation();
            }
            if (this.props.disabled) {
                this._stop();
                return;
            }
            let spinDirection = KeyboardSpinDirection.notSpinning;
            switch (event.which) {
                case KeyCodes.up:
                    spinDirection = KeyboardSpinDirection.up;
                    this._updateValue(false /* shouldSpin */, this._initialStepDelay, this._onIncrement);
                    break;
                case KeyCodes.down:
                    spinDirection = KeyboardSpinDirection.down;
                    this._updateValue(false /* shouldSpin */, this._initialStepDelay, this._onDecrement);
                    break;
                case KeyCodes.enter:
                case KeyCodes.tab:
                    this._validate(event);
                    break;
                case KeyCodes.escape:
                    if (this.state.value !== this._lastValidValue) {
                        this.setState({ value: this._lastValidValue });
                    }
                    break;
                default:
                    break;
            }
            // style the increment/decrement button to look active
            // when the corresponding up/down arrow keys trigger a step
            if (this.state.keyboardSpinDirection !== spinDirection) {
                this.setState({ keyboardSpinDirection: spinDirection });
            }
        };
        /**
         * Make sure that we have stopped spinning on keyUp
         * if the up or down arrow fired this event
         * @param event stop spinning if we
         */
        this._handleKeyUp = (event) => {
            if (this.props.disabled || event.which === KeyCodes.up || event.which === KeyCodes.down) {
                this._stop();
                return;
            }
        };
        this._onIncrementMouseDown = () => {
            this._updateValue(true /* shouldSpin */, this._initialStepDelay, this._onIncrement);
        };
        this._onDecrementMouseDown = () => {
            this._updateValue(true /* shouldSpin */, this._initialStepDelay, this._onDecrement);
        };
        this._warnMutuallyExclusive({
            value: 'defaultValue'
        });
        const value = props.value || props.defaultValue || String(props.min) || '0';
        this._lastValidValue = value;
        // Ensure that the autocalculated precision is not negative.
        const precision = props.precision || Math.max(calculatePrecision(props.step), 0);
        this.state = {
            isFocused: false,
            value: value,
            keyboardSpinDirection: KeyboardSpinDirection.notSpinning,
            precision
        };
        this._currentStepFunctionHandle = -1;
        this._labelId = getId('Label');
        this._inputId = getId('input');
        this._spinningByMouse = false;
        this._valueToValidate = undefined;
    }
    /**
     * Invoked when a component is receiving new props. This method is not called for the initial render.
     */
    componentWillReceiveProps(newProps) {
        this._lastValidValue = this.state.value;
        let value = newProps.value ? newProps.value : String(newProps.min);
        if (newProps.defaultValue) {
            value = String(Math.max(newProps.min, Math.min(newProps.max, Number(newProps.defaultValue))));
        }
        this.setState({
            value: value,
            precision: newProps.precision || this.state.precision
        });
    }
    render() {
        const { disabled, label, min, max, labelPosition, iconProps, incrementButtonIcon, incrementButtonAriaLabel, decrementButtonIcon, decrementButtonAriaLabel, title, ariaLabel, styles: customStyles, upArrowButtonStyles: customUpArrowButtonStyles, downArrowButtonStyles: customDownArrowButtonStyles, theme, ariaPositionInSet, ariaSetSize, ariaValueNow, ariaValueText, keytipProps, className } = this.props;
        const { isFocused, value, keyboardSpinDirection } = this.state;
        const classNames = this.props.getClassNames
            ? this.props.getClassNames(theme, !!disabled, !!isFocused, keyboardSpinDirection, labelPosition, className)
            : getClassNames$1d(getStyles$1k(theme, customStyles), !!disabled, !!isFocused, keyboardSpinDirection, labelPosition, className);
        return (createElement("div", { className: classNames.root },
            labelPosition !== Position.bottom && (createElement("div", { className: classNames.labelWrapper },
                iconProps && createElement(Icon, Object.assign({}, iconProps, { className: classNames.icon, "aria-hidden": "true" })),
                label && (createElement(Label, { id: this._labelId, htmlFor: this._inputId, className: classNames.label }, label)))),
            createElement(KeytipData, { keytipProps: keytipProps, disabled: disabled }, (keytipAttributes) => (createElement("div", { className: classNames.spinButtonWrapper, title: title && title, "aria-label": ariaLabel && ariaLabel, "aria-posinset": ariaPositionInSet, "aria-setsize": ariaSetSize, "data-ktp-target": keytipAttributes['data-ktp-target'] },
                createElement("input", { value: value, id: this._inputId, onChange: this._onChange, onInput: this._onInputChange, className: classNames.input, type: "text", autoComplete: "off", role: "spinbutton", "aria-labelledby": label && this._labelId, "aria-valuenow": !isNaN(Number(ariaValueNow)) ? ariaValueNow : !isNaN(Number(value)) ? Number(value) : undefined, "aria-valuetext": ariaValueText ? ariaValueText : isNaN(Number(value)) ? value : undefined, "aria-valuemin": min, "aria-valuemax": max, "aria-describedby": keytipAttributes['aria-describedby'], onBlur: this._onBlur, ref: this._input, onFocus: this._onFocus, onKeyDown: this._handleKeyDown, onKeyUp: this._handleKeyUp, readOnly: disabled, "aria-disabled": disabled, "data-lpignore": true, "data-ktp-execute-target": keytipAttributes['data-ktp-execute-target'] }),
                createElement("span", { className: classNames.arrowBox },
                    createElement(IconButton, { styles: getArrowButtonStyles(theme, true, customUpArrowButtonStyles), className: 'ms-UpButton', checked: keyboardSpinDirection === KeyboardSpinDirection.up, disabled: disabled, iconProps: incrementButtonIcon, onMouseDown: this._onIncrementMouseDown, onMouseLeave: this._stop, onMouseUp: this._stop, tabIndex: -1, ariaLabel: incrementButtonAriaLabel, "data-is-focusable": false }),
                    createElement(IconButton, { styles: getArrowButtonStyles(theme, false, customDownArrowButtonStyles), className: 'ms-DownButton', checked: keyboardSpinDirection === KeyboardSpinDirection.down, disabled: disabled, iconProps: decrementButtonIcon, onMouseDown: this._onDecrementMouseDown, onMouseLeave: this._stop, onMouseUp: this._stop, tabIndex: -1, ariaLabel: decrementButtonAriaLabel, "data-is-focusable": false }))))),
            labelPosition === Position.bottom && (createElement("div", { className: classNames.labelWrapper },
                iconProps && createElement(Icon, { iconName: iconProps.iconName, className: classNames.icon, "aria-hidden": "true" }),
                label && (createElement(Label, { id: this._labelId, htmlFor: this._inputId, className: classNames.label }, label))))));
    }
    focus() {
        if (this._input.current) {
            this._input.current.focus();
        }
    }
    /**
     * Gets the value of the spin button.
     */
    get value() {
        return this.props.value === undefined ? this.state.value : this.props.value;
    }
    _onChange() {
        /**
         * A noop input change handler.
         * https://github.com/facebook/react/issues/7027.
         * Using the native onInput handler fixes the issue but onChange
         * still need to be wired to avoid React console errors
         * TODO: Check if issue is resolved when React 16 is available.
         */
    }
};
SpinButton.defaultProps = {
    step: 1,
    min: 0,
    max: 100,
    disabled: false,
    labelPosition: Position.start,
    label: '',
    incrementButtonIcon: { iconName: 'ChevronUpSmall' },
    decrementButtonIcon: { iconName: 'ChevronDownSmall' }
};
SpinButton = __decorate([
    customizable('SpinButton', ['theme', 'styles'], true)
], SpinButton);

var StickyPositionType;
(function (StickyPositionType) {
    StickyPositionType[StickyPositionType["Both"] = 0] = "Both";
    StickyPositionType[StickyPositionType["Header"] = 1] = "Header";
    StickyPositionType[StickyPositionType["Footer"] = 2] = "Footer";
})(StickyPositionType || (StickyPositionType = {}));

class Sticky extends BaseComponent {
    constructor(props) {
        super(props);
        this._root = createRef$1();
        this._stickyContentTop = createRef$1();
        this._stickyContentBottom = createRef$1();
        this._nonStickyContent = createRef$1();
        this._placeHolder = createRef$1();
        this.syncScroll = (container) => {
            const { nonStickyContent } = this;
            if (nonStickyContent && this.props.isScrollSynced) {
                nonStickyContent.scrollLeft = container.scrollLeft;
            }
        };
        this._onScrollEvent = (container, footerStickyContainer) => {
            if (this.root && this.nonStickyContent) {
                this._setDistanceFromTop(this._getNonStickyDistanceFromTop(container));
                let isStickyTop = false;
                let isStickyBottom = false;
                if (this.canStickyTop) {
                    const distanceToStickTop = this.distanceFromTop - this._getStickyDistanceFromTop();
                    isStickyTop = distanceToStickTop < container.scrollTop;
                }
                // Can sticky bottom if the scrollablePane - total sticky footer height is smaller than the sticky's distance from the top of the pane
                if (this.canStickyBottom && container.clientHeight - footerStickyContainer.offsetHeight <= this.distanceFromTop) {
                    isStickyBottom =
                        this.distanceFromTop - container.scrollTop >= this._getStickyDistanceFromTopForFooter(container, footerStickyContainer);
                }
                this.setState({
                    isStickyTop: this.canStickyTop && isStickyTop,
                    isStickyBottom: isStickyBottom
                });
            }
        };
        this._getStickyDistanceFromTop = () => {
            let distance = 0;
            if (this.stickyContentTop) {
                distance = this.stickyContentTop.offsetTop;
            }
            return distance;
        };
        this._getStickyDistanceFromTopForFooter = (container, footerStickyVisibleContainer) => {
            let distance = 0;
            if (this.stickyContentBottom) {
                distance = container.clientHeight - footerStickyVisibleContainer.offsetHeight + this.stickyContentBottom.offsetTop;
            }
            return distance;
        };
        this._getNonStickyDistanceFromTop = (container) => {
            let distance = 0;
            let currElem = this.root;
            if (currElem) {
                while (currElem && currElem.offsetParent !== container) {
                    distance += currElem.offsetTop;
                    currElem = currElem.offsetParent;
                }
                if (currElem && currElem.offsetParent === container) {
                    distance += currElem.offsetTop;
                }
            }
            return distance;
        };
        this.state = {
            isStickyTop: false,
            isStickyBottom: false
        };
        this.distanceFromTop = 0;
    }
    get root() {
        return this._root.current;
    }
    get placeholder() {
        return this._placeHolder.current;
    }
    get stickyContentTop() {
        return this._stickyContentTop.current;
    }
    get stickyContentBottom() {
        return this._stickyContentBottom.current;
    }
    get nonStickyContent() {
        return this._nonStickyContent.current;
    }
    get canStickyTop() {
        return this.props.stickyPosition === StickyPositionType.Both || this.props.stickyPosition === StickyPositionType.Header;
    }
    get canStickyBottom() {
        return this.props.stickyPosition === StickyPositionType.Both || this.props.stickyPosition === StickyPositionType.Footer;
    }
    componentDidMount() {
        const { scrollablePane } = this.context;
        if (!scrollablePane) {
            return;
        }
        scrollablePane.subscribe(this._onScrollEvent);
        scrollablePane.addSticky(this);
    }
    componentWillUnmount() {
        const { scrollablePane } = this.context;
        if (!scrollablePane) {
            return;
        }
        scrollablePane.unsubscribe(this._onScrollEvent);
        scrollablePane.removeSticky(this);
    }
    componentDidUpdate(prevProps, prevState) {
        const { scrollablePane } = this.context;
        if (!scrollablePane) {
            return;
        }
        if (prevState.isStickyTop !== this.state.isStickyTop || prevState.isStickyBottom !== this.state.isStickyBottom) {
            scrollablePane.updateStickyRefHeights();
            // Sync Sticky scroll position with content container on each update
            scrollablePane.syncScrollSticky(this);
        }
    }
    shouldComponentUpdate(nextProps, nextState) {
        if (!this.context.scrollablePane) {
            return true;
        }
        const { isStickyTop, isStickyBottom } = this.state;
        return (isStickyTop !== nextState.isStickyTop ||
            isStickyBottom !== nextState.isStickyBottom ||
            this.props.stickyPosition !== nextProps.stickyPosition ||
            this.props.children !== nextProps.children ||
            (this._nonStickyContent &&
                this._nonStickyContent.current &&
                ((this._placeHolder &&
                    this._placeHolder.current &&
                    this._nonStickyContent.current.offsetHeight !== this._placeHolder.current.offsetHeight) ||
                    (this.stickyContentTop && this._nonStickyContent.current.offsetHeight !== this.stickyContentTop.offsetHeight) ||
                    (this.stickyContentBottom && this._nonStickyContent.current.offsetHeight !== this.stickyContentBottom.offsetHeight))));
    }
    render() {
        const { isStickyTop, isStickyBottom } = this.state;
        const { stickyClassName, children } = this.props;
        if (!this.context.scrollablePane) {
            return createElement("div", null, this.props.children);
        }
        return (createElement("div", { ref: this._root },
            this.canStickyTop && (createElement("div", { ref: this._stickyContentTop, "aria-hidden": !isStickyTop, style: { pointerEvents: isStickyTop ? 'auto' : 'none' } },
                createElement("div", { style: this._getStickyPlaceholderHeight(isStickyTop) }))),
            this.canStickyBottom && (createElement("div", { ref: this._stickyContentBottom, "aria-hidden": !isStickyBottom, style: { pointerEvents: isStickyBottom ? 'auto' : 'none' } },
                createElement("div", { style: this._getStickyPlaceholderHeight(isStickyBottom) }))),
            createElement("div", { style: this._getNonStickyPlaceholderHeight(), ref: this._placeHolder },
                createElement("div", { ref: this._nonStickyContent, className: isStickyTop || isStickyBottom ? stickyClassName : undefined, style: this._getContentStyles(isStickyTop || isStickyBottom) }, children))));
    }
    addSticky(stickyContent) {
        if (this.nonStickyContent) {
            stickyContent.appendChild(this.nonStickyContent);
        }
    }
    resetSticky() {
        if (this.nonStickyContent && this.placeholder) {
            this.placeholder.appendChild(this.nonStickyContent);
        }
    }
    setDistanceFromTop(container) {
        this._setDistanceFromTop(this._getNonStickyDistanceFromTop(container));
    }
    _setDistanceFromTop(distance) {
        const { scrollablePane } = this.context;
        if (this.distanceFromTop !== distance && scrollablePane) {
            this.distanceFromTop = distance;
            scrollablePane.sortSticky(this, true);
            this.forceUpdate();
            scrollablePane.syncScrollSticky(this);
        }
    }
    _getContentStyles(isSticky) {
        return {
            backgroundColor: this.props.stickyBackgroundColor || this._getBackground(),
            overflow: isSticky ? 'hidden' : ''
        };
    }
    _getStickyPlaceholderHeight(isSticky) {
        const height = this.nonStickyContent ? this.nonStickyContent.offsetHeight : 0;
        return {
            visibility: isSticky ? 'hidden' : 'visible',
            height: isSticky ? 0 : height
        };
    }
    _getNonStickyPlaceholderHeight() {
        const { isStickyTop, isStickyBottom } = this.state;
        if (isStickyTop || isStickyBottom) {
            const height = this.nonStickyContent ? this.nonStickyContent.offsetHeight : 0;
            return {
                height: height
            };
        }
        else {
            return {};
        }
    }
    // Gets background of nearest parent element that has a declared background-color attribute
    _getBackground() {
        if (!this.root) {
            return undefined;
        }
        let curr = this.root;
        while (window.getComputedStyle(curr).getPropertyValue('background-color') === 'rgba(0, 0, 0, 0)' ||
            window.getComputedStyle(curr).getPropertyValue('background-color') === 'transparent') {
            if (curr.tagName === 'HTML') {
                // Fallback color if no element has a declared background-color attribute
                return undefined;
            }
            if (curr.parentElement) {
                curr = curr.parentElement;
            }
        }
        return window.getComputedStyle(curr).getPropertyValue('background-color');
    }
}
Sticky.defaultProps = {
    stickyPosition: StickyPositionType.Both,
    isScrollSynced: true
};
Sticky.contextTypes = {
    scrollablePane: object
};

const getClassNames$1e = classNamesFunction();
class ColorCell extends GridCell {
}
class ColorPickerGridCellBase extends Component {
    constructor() {
        super(...arguments);
        /**
         * Render the core of a color cell
         * @returns - Element representing the core of the item
         */
        this._onRenderColorOption = (colorOption) => {
            // Build an SVG for the cell with the given shape and color properties
            return (createElement("svg", { className: this._classNames.svg, viewBox: "0 0 20 20", fill: getColorFromString(colorOption.color).str }, this.props.circle ? createElement("circle", { cx: "50%", cy: "50%", r: "50%" }) : createElement("rect", { width: "100%", height: "100%" })));
        };
        /**
         * Method to override the getClassNames func in a button.
         */
        this._getClassNames = (theme, className, variantClassName, iconClassName, menuIconClassName, disabled, checked, expanded, isSplit) => {
            const styles = getStyles$g(theme);
            return mergeStyleSets(this._classNames, {
                root: [
                    'ms-Button',
                    styles.root,
                    variantClassName,
                    className,
                    checked && ['is-checked', styles.rootChecked],
                    disabled && ['is-disabled', styles.rootDisabled],
                    !disabled &&
                        !checked && {
                        selectors: {
                            ':hover': styles.rootHovered,
                            ':focus': styles.rootFocused,
                            ':active': styles.rootPressed
                        }
                    },
                    disabled && checked && [styles.rootCheckedDisabled],
                    !disabled &&
                        checked && {
                        selectors: {
                            ':hover': styles.rootCheckedHovered,
                            ':active': styles.rootCheckedPressed
                        }
                    }
                ],
                flexContainer: ['ms-Button-flexContainer', styles.flexContainer]
            });
        };
    }
    render() {
        const { item, id, selected, disabled, styles, theme, circle, color, onClick, onHover, onFocus, onMouseEnter, onMouseMove, onMouseLeave, onWheel, onKeyDown, height, width, borderWidth } = this.props;
        this._classNames = getClassNames$1e(styles, {
            theme: theme,
            disabled,
            selected,
            circle,
            isWhite: this._isWhiteCell(color),
            height,
            width,
            borderWidth
        });
        return (createElement(ColorCell, { item: item, id: `${id}-${item.id}-${item.index}`, key: item.id, disabled: disabled, role: 'gridcell', onRenderItem: this._onRenderColorOption, selected: selected, onClick: onClick, onHover: onHover, onFocus: onFocus, label: item.label, className: this._classNames.colorCell, getClassNames: this._getClassNames, index: item.index, onMouseEnter: onMouseEnter, onMouseMove: onMouseMove, onMouseLeave: onMouseLeave, onWheel: onWheel, onKeyDown: onKeyDown }));
    }
    /**
     * Validate if the cell's color is white or not to apply whiteCell style
     * @param inputColor - The color of the current cell
     * @returns - Whether the cell's color is white or not.
     */
    _isWhiteCell(inputColor) {
        const color = getColorFromString(inputColor);
        return color.hex === 'ffffff';
    }
}
ColorPickerGridCellBase.defaultProps = {
    circle: true,
    disabled: false,
    selected: false,
    height: 20,
    width: 20,
    borderWidth: 2
};

const getStyles$1l = (props) => {
    const { theme, disabled, selected, circle, isWhite, height, width, borderWidth } = props;
    const { semanticColors } = theme;
    return {
        // this is a button that wraps the color
        colorCell: [
            {
                backgroundColor: semanticColors.bodyBackground,
                padding: 0,
                position: 'relative',
                boxSizing: 'border-box',
                display: 'inline-block',
                cursor: 'pointer',
                userSelect: 'none',
                height: height,
                width: width,
                selectors: {
                    // remove default focus border
                    [`.${IsFocusVisibleClassName} &:focus::after`]: { display: 'none' },
                    // add a custom focus border
                    [`.${IsFocusVisibleClassName} &:focus`]: { outline: `1px solid ${semanticColors.focusBorder}` }
                }
            },
            circle && {
                borderRadius: '100%'
            },
            selected && {
                padding: borderWidth,
                border: `${borderWidth}px solid ${theme.palette.neutralTertiaryAlt}`
            },
            !selected && {
                selectors: {
                    ['&:hover, &:active, &:focus']: {
                        backgroundColor: semanticColors.bodyBackground,
                        padding: borderWidth,
                        border: `${borderWidth}px solid ${theme.palette.neutralLight}`
                    }
                }
            },
            disabled && {
                color: semanticColors.disabledBodyText,
                pointerEvents: 'none',
                opacity: 0.3
            },
            isWhite &&
                !selected && {
                // fake a border for white
                backgroundColor: semanticColors.bodyDivider,
                padding: 1
            }
        ],
        // the <svg> that holds the color
        svg: [
            {
                width: '100%',
                height: '100%'
            },
            circle && {
                borderRadius: '100%'
            }
        ]
    };
};

const ColorPickerGridCell = styled(ColorPickerGridCellBase, getStyles$1l, undefined, { scope: 'ColorPickerGridCell' });

const getClassNames$1f = classNamesFunction();
class SwatchColorPickerBase extends BaseComponent {
    constructor(props) {
        super(props);
        this.navigationIdleDelay = 250 /* ms */;
        /**
         * When the whole swatchColorPicker is blurred,
         * make sure to clear the pending focused stated
         */
        this._onSwatchColorPickerBlur = () => {
            if (this.props.onCellFocused) {
                this._cellFocused = false;
                this.props.onCellFocused();
            }
        };
        /**
         * Render a color cell
         * @param item - The item to render
         * @returns - Element representing the item
         */
        this._renderOption = (item) => {
            const id = this._id;
            return (createElement(ColorPickerGridCell, { item: item, id: id, color: item.color, styles: this.props.getColorGridCellStyles, disabled: this.props.disabled, onClick: this._onCellClick, onHover: this._onGridCellHovered, onFocus: this._onGridCellFocused, selected: this.state.selectedIndex !== undefined && this.state.selectedIndex === item.index, circle: this.props.cellShape === 'circle', label: item.label, onMouseEnter: this._onMouseEnter, onMouseMove: this._onMouseMove, onMouseLeave: this._onMouseLeave, onWheel: this._onWheel, onKeyDown: this._onKeyDown, height: this.props.cellHeight, width: this.props.cellWidth, borderWidth: this.props.cellBorderWidth }));
        };
        /**
         * Callback passed to the GridCell that will manage triggering the onCellHovered callback for mouseEnter
         */
        this._onMouseEnter = (ev) => {
            if (!this.props.focusOnHover) {
                if (!this.isNavigationIdle || this.props.disabled) {
                    return true;
                }
                return false;
            }
            if (this.isNavigationIdle && !this.props.disabled) {
                ev.currentTarget.focus();
            }
            return true;
        };
        /**
         * Callback passed to the GridCell that will manage Hover/Focus updates
         */
        this._onMouseMove = (ev) => {
            if (!this.props.focusOnHover) {
                if (!this.isNavigationIdle || this.props.disabled) {
                    return true;
                }
                return false;
            }
            const targetElement = ev.currentTarget;
            // If navigation is idle and the targetElement is the focused element bail out
            // if (!this.isNavigationIdle || (document && targetElement === (document.activeElement as HTMLElement))) {
            if (this.isNavigationIdle && !(document && targetElement === document.activeElement)) {
                targetElement.focus();
            }
            return true;
        };
        /**
         * Callback passed to the GridCell that will manage Hover/Focus updates
         */
        this._onMouseLeave = (ev) => {
            const parentSelector = this.props.mouseLeaveParentSelector;
            if (!this.props.focusOnHover || !parentSelector || !this.isNavigationIdle || this.props.disabled) {
                return;
            }
            // Get the the elements that math the given selector
            const elements = document.querySelectorAll(parentSelector);
            // iterate over the elements return to make sure it is a parent of the target and focus it
            for (let index = 0; index < elements.length; index += 1) {
                if (elements[index].contains(ev.currentTarget)) {
                    /**
                     * IE11 focus() method forces parents to scroll to top of element.
                     * Edge and IE expose a setActive() function for focusable divs that
                     * sets the page focus but does not scroll the parent element.
                     */
                    if (elements[index].setActive) {
                        try {
                            elements[index].setActive();
                        }
                        catch (e) {
                            /* no-op */
                        }
                    }
                    else {
                        elements[index].focus();
                    }
                    break;
                }
            }
        };
        /**
         * Callback to make sure we don't update the hovered element during mouse wheel
         */
        this._onWheel = () => {
            this.setNavigationTimeout();
        };
        /**
         * Callback that
         */
        this._onKeyDown = (ev) => {
            if (ev.which === KeyCodes.up || ev.which === KeyCodes.down || ev.which === KeyCodes.left || ev.which === KeyCodes.right) {
                this.setNavigationTimeout();
            }
        };
        /**
         * Sets a timeout so we won't process any mouse "hover" events
         * while navigating (via mouseWheel or arrowKeys)
         */
        this.setNavigationTimeout = () => {
            if (!this.isNavigationIdle && this.navigationIdleTimeoutId !== undefined) {
                this.async.clearTimeout(this.navigationIdleTimeoutId);
                this.navigationIdleTimeoutId = undefined;
            }
            else {
                this.isNavigationIdle = false;
            }
            this.navigationIdleTimeoutId = this.async.setTimeout(() => {
                this.isNavigationIdle = true;
            }, this.navigationIdleDelay);
        };
        /**
         * Callback passed to the GridCell class that will trigger the onCellHovered callback of the SwatchColorPicker
         * NOTE: This will not be triggered if shouldFocusOnHover === true
         */
        this._onGridCellHovered = (item) => {
            const { onCellHovered } = this.props;
            if (onCellHovered) {
                return item ? onCellHovered(item.id, item.color) : onCellHovered();
            }
        };
        /**
         * Callback passed to the GridCell class that will trigger the onCellFocus callback of the SwatchColorPicker
         */
        this._onGridCellFocused = (item) => {
            const { onCellFocused } = this.props;
            if (onCellFocused) {
                if (item) {
                    this._cellFocused = true;
                    return onCellFocused(item.id, item.color);
                }
                else {
                    this._cellFocused = false;
                    return onCellFocused();
                }
            }
        };
        /**
         * Handle the click on a cell
         * @param item - The cell that the click was fired against
         */
        this._onCellClick = (item) => {
            if (this.props.disabled) {
                return;
            }
            const index = item.index;
            // If we have a valid index and it is not already
            // selected, select it
            if (index >= 0 && index !== this.state.selectedIndex) {
                if (this.props.onCellFocused && this._cellFocused) {
                    this._cellFocused = false;
                    this.props.onCellFocused();
                }
                if (this.props.onColorChanged) {
                    this.props.onColorChanged(item.id, item.color);
                }
                this.setState({
                    selectedIndex: index
                });
            }
        };
        this._id = props.id || getId('swatchColorPicker');
        this._warnMutuallyExclusive({
            focusOnHover: 'onHover'
        });
        this._warnConditionallyRequiredProps(['focusOnHover'], 'mouseLeaveParentSelector', !!this.props.mouseLeaveParentSelector);
        this.isNavigationIdle = true;
        this.async = new Async(this);
        let selectedIndex;
        if (props.selectedId) {
            selectedIndex = this._getSelectedIndex(props.colorCells, props.selectedId);
        }
        this.state = {
            selectedIndex
        };
    }
    componentWillReceiveProps(newProps) {
        if (newProps.selectedId !== undefined) {
            this.setState({
                selectedIndex: this._getSelectedIndex(newProps.colorCells, newProps.selectedId)
            });
        }
    }
    componentWillUnmount() {
        if (this.props.onCellFocused && this._cellFocused) {
            this._cellFocused = false;
            this.props.onCellFocused();
        }
    }
    render() {
        const { colorCells, columnCount, positionInSet, setSize, shouldFocusCircularNavigate, className, doNotContainWithinFocusZone, styles, cellMargin } = this.props;
        const classNames = getClassNames$1f(styles, {
            theme: this.props.theme,
            className,
            cellMargin
        });
        if (colorCells.length < 1 || columnCount < 1) {
            return null;
        }
        return (createElement(Grid, Object.assign({}, this.props, { items: colorCells.map((item, index) => {
                return { ...item, index: index };
            }), columnCount: columnCount, onRenderItem: this._renderOption, positionInSet: positionInSet && positionInSet, setSize: setSize && setSize, shouldFocusCircularNavigate: shouldFocusCircularNavigate, doNotContainWithinFocusZone: doNotContainWithinFocusZone, onBlur: this._onSwatchColorPickerBlur, theme: this.props.theme, 
            // tslint:disable-next-line:jsx-no-lambda
            styles: props => ({
                root: classNames.root,
                tableCell: classNames.tableCell,
                focusedContainer: classNames.focusedContainer
            }) })));
    }
    /**
     * Get the selected item's index
     * @param items - The items to search
     * @param selectedId - The selected item's id to find
     * @returns - The index of the selected item's id, -1 if there was no match
     */
    _getSelectedIndex(items, selectedId) {
        const selectedIndex = findIndex(items, item => item.id === selectedId);
        return selectedIndex >= 0 ? selectedIndex : undefined;
    }
}
SwatchColorPickerBase.defaultProps = {
    cellShape: 'circle',
    disabled: false,
    shouldFocusCircularNavigate: true,
    cellMargin: 10
};

const GlobalClassNames$T = {
    focusedContainer: 'ms-swatchColorPickerBodyContainer'
};
const getStyles$1m = (props) => {
    const { className, theme, cellMargin } = props;
    const classNames = getGlobalClassNames(GlobalClassNames$T, theme);
    return {
        root: {
            margin: '8px 0',
            borderCollapse: 'collapse'
        },
        tableCell: {
            padding: cellMargin / 2
        },
        focusedContainer: [
            classNames.focusedContainer,
            {
                clear: 'both',
                display: 'block',
                minWidth: '180px'
            },
            className
        ]
    };
};

const SwatchColorPicker = styled(SwatchColorPickerBase, getStyles$1m, undefined, { scope: 'SwatchColorPicker' });

const getClassNames$1g = classNamesFunction();
class TeachingBubbleContentBase extends BaseComponent {
    constructor(props) {
        super(props);
        this.rootElement = createRef$1();
        this._onKeyDown = (e) => {
            if (this.props.onDismiss) {
                if (e.which === KeyCodes.escape) {
                    this.props.onDismiss();
                }
            }
        };
        this.state = {};
    }
    componentDidMount() {
        if (this.props.onDismiss) {
            document.addEventListener('keydown', this._onKeyDown, false);
        }
    }
    componentWillUnmount() {
        if (this.props.onDismiss) {
            document.removeEventListener('keydown', this._onKeyDown);
        }
    }
    focus() {
        if (this.rootElement.current) {
            this.rootElement.current.focus();
        }
    }
    render() {
        const { children, illustrationImage, primaryButtonProps, secondaryButtonProps, headline, hasCondensedHeadline, hasCloseIcon, onDismiss, closeButtonAriaLabel, hasSmallHeadline, isWide, styles, theme, ariaDescribedBy, ariaLabelledBy } = this.props;
        let imageContent;
        let headerContent;
        let bodyContent;
        let footerContent;
        let closeButton;
        const classNames = getClassNames$1g(styles, {
            theme: theme,
            hasCondensedHeadline,
            hasSmallHeadline,
            isWide,
            primaryButtonClassName: primaryButtonProps ? primaryButtonProps.className : undefined,
            secondaryButtonClassName: secondaryButtonProps ? secondaryButtonProps.className : undefined
        });
        if (illustrationImage && illustrationImage.src) {
            imageContent = (createElement("div", { className: classNames.imageContent },
                createElement(Image, Object.assign({}, illustrationImage))));
        }
        if (headline) {
            const HeaderWrapperAs = typeof headline === 'string' ? 'p' : 'div';
            headerContent = (createElement("div", { className: classNames.header },
                createElement(HeaderWrapperAs, { className: classNames.headline, id: ariaLabelledBy }, headline)));
        }
        if (children) {
            const BodyContentWrapperAs = typeof children === 'string' ? 'p' : 'div';
            bodyContent = (createElement("div", { className: classNames.body },
                createElement(BodyContentWrapperAs, { className: classNames.subText, id: ariaDescribedBy }, children)));
        }
        if (primaryButtonProps || secondaryButtonProps) {
            footerContent = (createElement("div", { className: classNames.footer },
                primaryButtonProps && createElement(PrimaryButton, Object.assign({}, primaryButtonProps, { className: classNames.primaryButton })),
                secondaryButtonProps && createElement(DefaultButton, Object.assign({}, secondaryButtonProps, { className: classNames.secondaryButton }))));
        }
        if (hasCloseIcon) {
            closeButton = (createElement(IconButton, { className: classNames.closeButton, iconProps: { iconName: 'Cancel' }, title: closeButtonAriaLabel, ariaLabel: closeButtonAriaLabel, onClick: onDismiss }));
        }
        return (createElement("div", { className: classNames.content, ref: this.rootElement, role: 'dialog', tabIndex: -1, "aria-labelledby": ariaLabelledBy, "aria-describedby": ariaDescribedBy, "data-is-focusable": true },
            imageContent,
            createElement("div", { className: classNames.bodyContent },
                headerContent,
                bodyContent,
                footerContent),
            closeButton));
    }
}
// Specify default props values
TeachingBubbleContentBase.defaultProps = {
    hasCondensedHeadline: false,
    imageProps: {
        imageFit: ImageFit.cover,
        width: 364,
        height: 130
    }
};

const globalClassNames$3 = {
    root: 'ms-TeachingBubble',
    body: 'ms-TeachingBubble-body',
    bodyContent: 'ms-TeachingBubble-bodycontent',
    closeButton: 'ms-TeachingBubble-closebutton',
    content: 'ms-TeachingBubble-content',
    footer: 'ms-TeachingBubble-footer',
    header: 'ms-TeachingBubble-header',
    headerIsCondensed: 'ms-TeachingBubble-header--condensed',
    headerIsSmall: 'ms-TeachingBubble-header--small',
    headerIsLarge: 'ms-TeachingBubble-header--large',
    headline: 'ms-TeachingBubble-headline',
    image: 'ms-TeachingBubble-image',
    primaryButton: 'ms-TeachingBubble-primaryButton',
    secondaryButton: 'ms-TeachingBubble-secondaryButton',
    subText: 'ms-TeachingBubble-subText',
    // TODO: Button global class name usage should be converted to a styles function once
    //        Button supports JS styling, which means these button names can be removed.
    button: 'ms-Button',
    buttonLabel: 'ms-Button-label'
};
const bounceAnimation = keyframes({
    '0%': { transform: 'matrix3d(0.5, 0, 0, 0, 0, 0.5, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)' },
    '1.7%': { transform: 'matrix3d(0.658, 0, 0, 0, 0, 0.703, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)' },
    '2.35%': { transform: 'matrix3d(0.725, 0, 0, 0, 0, 0.8, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)' },
    '3.4%': { transform: 'matrix3d(0.83, 0, 0, 0, 0, 0.946, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)' },
    '4.7%': { transform: 'matrix3d(0.942, 0, 0, 0, 0, 1.084, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)' },
    '5.11%': { transform: 'matrix3d(0.971, 0, 0, 0, 0, 1.113, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)' },
    '6.81%': { transform: 'matrix3d(1.062, 0, 0, 0, 0, 1.166, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)' },
    '7.06%': { transform: 'matrix3d(1.07, 0, 0, 0, 0, 1.165, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)' },
    '8.76%': { transform: 'matrix3d(1.104, 0, 0, 0, 0, 1.12, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)' },
    '9.36%': { transform: 'matrix3d(1.106, 0, 0, 0, 0, 1.094, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)' },
    '10.66%': { transform: 'matrix3d(1.098, 0, 0, 0, 0, 1.035, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)' },
    '12.16%': { transform: 'matrix3d(1.075, 0, 0, 0, 0, 0.98, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)' },
    '12.61%': { transform: 'matrix3d(1.067, 0, 0, 0, 0, 0.969, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)' },
    '14.51%': { transform: 'matrix3d(1.031, 0, 0, 0, 0, 0.948, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)' },
    '14.96%': { transform: 'matrix3d(1.024, 0, 0, 0, 0, 0.949, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)' },
    '17.77%': { transform: 'matrix3d(0.99, 0, 0, 0, 0, 0.981, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)' },
    '18.37%': { transform: 'matrix3d(0.986, 0, 0, 0, 0, 0.989, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)' },
    '20.52%': { transform: 'matrix3d(0.98, 0, 0, 0, 0, 1.011, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)' },
    '22.22%': { transform: 'matrix3d(0.983, 0, 0, 0, 0, 1.016, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)' },
    '26.08%': { transform: 'matrix3d(0.996, 0, 0, 0, 0, 1.003, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)' },
    '29.93%': { transform: 'matrix3d(1.003, 0, 0, 0, 0, 0.995, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)' },
    '31.63%': { transform: 'matrix3d(1.004, 0, 0, 0, 0, 0.996, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)' },
    '37.64%': { transform: 'matrix3d(1.001, 0, 0, 0, 0, 1.002, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)' },
    '42.74%': { transform: 'matrix3d(0.999, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)' },
    '45.35%': { transform: 'matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)' },
    '49.9%': { transform: 'matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)' },
    '50%': { transform: 'matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)' },
    '52.15%': { transform: 'matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)' },
    '54.3%': { transform: 'matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)' },
    '56.46%': { transform: 'matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)' },
    '58.61%': { transform: 'matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)' },
    '64.16%': { transform: 'matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)' },
    '69.72%': { transform: 'matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)' },
    '80.83%': { transform: 'matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)' },
    '91.99%': { transform: 'matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)' },
    '100%': { transform: 'matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)' }
});
const opacityFadeIn = keyframes({
    '0%': {
        opacity: 0,
        animationTimingFunction: AnimationVariables.easeFunction2
    },
    '26.26%': { opacity: 1 },
    '100%': { opacity: 1 }
});
const rootStyle = (isWide) => {
    return [
        {
            display: 'block',
            maxWidth: 364,
            border: 0,
            outline: 'transparent',
            boxShadow: 'none !important',
            width: 'calc(100% + 1px)',
            animationName: `${bounceAnimation}, ${opacityFadeIn}`,
            animationDuration: '2000ms',
            animationTimingFunction: 'linear',
            animationFillMode: 'both'
        },
        isWide && {
            maxWidth: '456px'
        }
    ];
};
const headerStyle = (classNames, hasCondensedHeadline, hasSmallHeadline) => {
    if (hasCondensedHeadline) {
        return [classNames.headerIsCondensed];
    }
    if (hasSmallHeadline) {
        return [
            classNames.headerIsSmall,
            {
                selectors: {
                    ':not(:last-child)': {
                        marginBottom: '14px'
                    }
                }
            }
        ];
    }
    // Large headline is default
    return [
        classNames.headerIsLarge,
        {
            selectors: {
                ':not(:last-child)': {
                    marginBottom: '14px'
                }
            }
        }
    ];
};
const getStyles$1n = (props) => {
    const { calloutClassName, hasCondensedHeadline, hasSmallHeadline, isWide, primaryButtonClassName, secondaryButtonClassName, theme } = props;
    const hasLargeHeadline = !hasCondensedHeadline && !hasSmallHeadline;
    const { palette } = theme;
    const classNames = getGlobalClassNames(globalClassNames$3, theme);
    return {
        root: [classNames.root, theme.fonts.medium, calloutClassName],
        body: [
            classNames.body,
            {
                selectors: {
                    ':not(:last-child)': {
                        marginBottom: '20px'
                    }
                }
            }
        ],
        bodyContent: [
            classNames.bodyContent,
            {
                padding: '20px'
            },
            isWide && {
                maxWidth: '302px'
            }
        ],
        closeButton: [
            classNames.closeButton,
            {
                position: 'absolute',
                right: 0,
                top: 0,
                color: palette.white,
                fontSize: FontSizes.small,
                selectors: {
                    ':hover': {
                        background: 'transparent'
                    }
                }
            }
        ],
        content: [
            classNames.content,
            ...rootStyle(isWide),
            isWide && {
                display: 'flex'
            }
        ],
        footer: [
            classNames.footer,
            {
                display: 'flex',
                selectors: {
                    // TODO: global class name usage should be converted to a button styles function once Button supports JS styling
                    [`.${classNames.button}:not(:first-child)`]: {
                        marginLeft: '20px'
                    }
                }
            }
        ],
        header: [
            classNames.header,
            ...headerStyle(classNames, hasCondensedHeadline, hasSmallHeadline),
            (hasCondensedHeadline || hasSmallHeadline) && [
                DefaultFontStyles.medium,
                {
                    marginRight: '10px',
                    fontWeight: FontWeights.semibold
                }
            ]
        ],
        headline: [
            classNames.headline,
            {
                margin: 0,
                color: palette.white
            },
            hasLargeHeadline && [
                DefaultFontStyles.xxLarge,
                {
                    fontWeight: FontWeights.light
                }
            ]
        ],
        imageContent: [
            classNames.header,
            classNames.image,
            isWide && {
                display: 'flex',
                alignItems: 'center',
                paddingLeft: '20px',
                maxWidth: '154px'
            }
        ],
        primaryButton: [
            classNames.primaryButton,
            primaryButtonClassName,
            {
                backgroundColor: palette.white,
                borderColor: palette.white,
                whiteSpace: 'nowrap',
                selectors: {
                    // TODO: global class name usage should be converted to a button styles function once Button supports JS styling
                    [`.${classNames.buttonLabel}`]: [
                        DefaultFontStyles.medium,
                        {
                            color: palette.themePrimary
                        }
                    ],
                    ':hover': {
                        backgroundColor: palette.themeLighter,
                        borderColor: palette.themeLighter
                    },
                    ':focus': {
                        backgroundColor: palette.themeLighter,
                        borderColor: palette.white
                    },
                    ':active': {
                        backgroundColor: palette.white,
                        borderColor: palette.white
                    }
                }
            }
        ],
        secondaryButton: [
            classNames.secondaryButton,
            secondaryButtonClassName,
            {
                backgroundColor: palette.themePrimary,
                borderColor: palette.white,
                whiteSpace: 'nowrap',
                selectors: {
                    // TODO: global class name usage should be converted to a button styles function once Button supports JS styling
                    [`.${classNames.buttonLabel}`]: [
                        DefaultFontStyles.medium,
                        {
                            color: palette.white
                        }
                    ],
                    '&:hover, &:focus': {
                        backgroundColor: palette.themeDarkAlt,
                        borderColor: palette.white
                    },
                    ':active': {
                        backgroundColor: palette.themePrimary,
                        borderColor: palette.white
                    }
                }
            }
        ],
        subText: [
            classNames.subText,
            {
                margin: 0,
                fontSize: FontSizes.medium,
                color: palette.white,
                fontWeight: FontWeights.semilight
            }
        ],
        subComponentStyles: {
            callout: {
                root: [...rootStyle(isWide), theme.fonts.medium],
                beak: [
                    {
                        background: palette.themePrimary
                    }
                ],
                calloutMain: [
                    {
                        background: palette.themePrimary
                    }
                ]
            }
        }
    };
};

const TeachingBubbleContent = styled(TeachingBubbleContentBase, getStyles$1n, undefined, { scope: 'TeachingBubbleContent' });

const getClassNames$1h = classNamesFunction();
class TeachingBubbleBase extends BaseComponent {
    // Constructor
    constructor(props) {
        super(props);
        this.rootElement = createRef$1();
        this.state = {};
        this._defaultCalloutProps = {
            beakWidth: 16,
            gapSpace: 0,
            setInitialFocus: true,
            doNotLayer: false,
            directionalHint: DirectionalHint.rightCenter
        };
    }
    focus() {
        if (this.rootElement.current) {
            this.rootElement.current.focus();
        }
    }
    render() {
        const { calloutProps: setCalloutProps, targetElement, onDismiss, isWide, styles, theme } = this.props;
        const calloutProps = { ...this._defaultCalloutProps, ...setCalloutProps };
        const stylesProps = {
            theme: theme,
            isWide,
            calloutClassName: calloutProps ? calloutProps.className : undefined
        };
        const classNames = getClassNames$1h(styles, stylesProps);
        const calloutStyles = classNames.subComponentStyles
            ? classNames.subComponentStyles.callout
            : undefined;
        return (createElement(Callout, Object.assign({ target: targetElement, onDismiss: onDismiss }, calloutProps, { className: classNames.root, styles: calloutStyles, hideOverflow: true }),
            createElement("div", { ref: this.rootElement },
                createElement(TeachingBubbleContent, Object.assign({}, this.props)))));
    }
}
TeachingBubbleBase.defaultProps = {
    /**
     * Default calloutProps is deprecated in favor of private `_defaultCalloutProps`.
     * Remove in next release.
     * @deprecated In favor of private `_defaultCalloutProps`.
     */
    calloutProps: {
        beakWidth: 16,
        gapSpace: 0,
        setInitialFocus: true,
        doNotLayer: false,
        directionalHint: DirectionalHint.rightCenter
    }
};

const TeachingBubble = styled(TeachingBubbleBase, getStyles$1n, undefined, { scope: 'TeachingBubble' });

class ThemeGenerator {
    /* Sets an IThemeSlotRule to the given color and cascades it to the rest of the theme, updating other IThemeSlotRules in the theme that
     *   inherit from that color.
     * isInverted: whether it's a dark theme or not, which affects the algorithm used to generate shades
     * isCustomization should be true only if it's a user action, and indicates overwriting the slot's inheritance (if any)
     * overwriteCustomColor: a slot could have a generated color based on its inheritance rules (isCustomized is false), or a custom color
                              based on user input (isCustomized is true), this bool tells us whether to override existing customized colors */
    static setSlot(rule, color, isInverted = false, isCustomization = false, overwriteCustomColor = true) {
        if (!rule.color && rule.value) {
            // not a color rule
            return;
        }
        if (overwriteCustomColor) {
            let colorAsIColor;
            if (typeof color === 'string') {
                colorAsIColor = getColorFromString(color); // the ! is a lie here but we'll verify it in the next line
                if (!colorAsIColor) {
                    throw 'color is invalid in setSlot(): ' + color;
                }
            }
            else {
                colorAsIColor = color;
            }
            ThemeGenerator._setSlot(rule, colorAsIColor, isInverted, isCustomization, overwriteCustomColor);
        }
        else if (rule.color) {
            ThemeGenerator._setSlot(rule, rule.color, isInverted, isCustomization, overwriteCustomColor);
        }
    }
    /* Sets the color of each slot based on its rule. Slots that don't inherit must have a color already.
     * If this completes without error, then the theme is ready to use. (All slots will have a color.)
     * setSlot() can be called before this, but this must be called before getThemeAs*().
     * Does not override colors of rules where isCustomized is true (i.e. doesn't override existing customizations).
     */
    static insureSlots(slotRules, isInverted) {
        // Get all the "root" rules, the ones which don't inherit. Then "set" them to trigger updating dependent slots.
        for (const ruleName in slotRules) {
            if (slotRules.hasOwnProperty(ruleName)) {
                const rule = slotRules[ruleName];
                if (!rule.inherits && !rule.value) {
                    if (!rule.color) {
                        throw 'A color slot rule that does not inherit must provide its own color.';
                    }
                    ThemeGenerator._setSlot(rule, rule.color, isInverted, false, false);
                }
            }
        }
    }
    /* Gets the JSON-formatted blob that describes the theme, usable with the REST request endpoints
     * { [theme slot name as string] : [color as string],
     *  "tokenName": "#f00f00",
     *  "tokenName2": "#ba2ba2",
     *   ... }
     */
    static getThemeAsJson(slotRules) {
        const theme = {};
        for (const ruleName in slotRules) {
            if (slotRules.hasOwnProperty(ruleName)) {
                const rule = slotRules[ruleName];
                theme[rule.name] = rule.color ? rule.color.str : rule.value || '';
            }
        }
        return theme;
    }
    /*
     * Gets code-formatted load theme blob that can be copy and pasted.
     */
    static getThemeAsCode(slotRules) {
        const attributeTemplate = "    {0}: '{1}',\n";
        let output = '';
        output += 'loadTheme({\n  palette: {\n';
        for (const ruleName in slotRules) {
            if (slotRules.hasOwnProperty(ruleName)) {
                const rule = slotRules[ruleName];
                const camelCasedName = rule.name.charAt(0).toLowerCase() + rule.name.slice(1);
                const outputColor = rule.color ? '#' + rule.color.hex : rule.value || '';
                output += format(attributeTemplate, camelCasedName, outputColor);
            }
        }
        output += '  }\n});';
        return output;
    }
    /* Gets the theme as a list of SASS variables that can be used in code
     * $tokenName: "[theme:tokenName, default:#f00f00]";
     * $tokenName2: "[theme:tokenName2, default:#ba2ba2]";
     * ...
     */
    static getThemeAsSass(slotRules) {
        const sassVarTemplate = '${0}Color: "[theme: {1}, default: {2}]";\n';
        let output = '';
        for (const ruleName in slotRules) {
            if (slotRules.hasOwnProperty(ruleName)) {
                const rule = slotRules[ruleName];
                const camelCasedName = rule.name.charAt(0).toLowerCase() + rule.name.slice(1);
                output += format(sassVarTemplate, camelCasedName, camelCasedName, rule.color ? rule.color.str : rule.value || '');
            }
        }
        return output;
    }
    /* Gets the theme formatted for PowerShell scripts
     * @{
     * "tokenName" = "#f00f00";
     * "tokenName2" = "#ba2ba2";
     * ...
     * }
     */
    static getThemeForPowerShell(slotRules) {
        const psVarTemplate = '"{0}" = "{1}";\n';
        let output = '';
        for (const ruleName in slotRules) {
            if (slotRules.hasOwnProperty(ruleName)) {
                const rule = slotRules[ruleName];
                if (rule.value) {
                    // skip this one, it's not a color
                    continue;
                }
                const camelCasedName = rule.name.charAt(0).toLowerCase() + rule.name.slice(1);
                let outputColor = rule.color ? '#' + rule.color.hex : rule.value || '';
                // powershell endpoint uses the RGBA format
                if (rule.color && rule.color.a && rule.color.a !== 100) {
                    outputColor += String(rule.color.a.toString(16));
                }
                output += format(psVarTemplate, camelCasedName, outputColor);
            }
        }
        return '@{\n' + output + '}';
    }
    /* Sets the given slot's color to the appropriate color, shading it if necessary.
       Then, iterates through all other rules (that are this rule's dependents) to update them accordingly.
       isCustomization=true means it's a user provided color, set it to that raw color
       isCustomization=false means the rule it's inheriting from changed, so updated using asShade */
    static _setSlot(rule, color, isInverted, isCustomization, overwriteCustomColor = true) {
        if (!rule.color && rule.value) {
            // not a color rule
            return;
        }
        if (overwriteCustomColor || !rule.color || !rule.isCustomized || !rule.inherits) {
            // set the rule's color under these conditions
            if ((overwriteCustomColor || !rule.isCustomized) && !isCustomization && rule.inherits && isValidShade(rule.asShade)) {
                // it's inheriting by shade
                if (rule.isBackgroundShade) {
                    rule.color = getBackgroundShade(color, rule.asShade, isInverted);
                }
                else {
                    rule.color = getShade(color, rule.asShade, isInverted);
                }
                rule.isCustomized = false;
            }
            else {
                rule.color = color;
                rule.isCustomized = true;
            }
            // then update dependent colors
            for (const ruleToUpdate of rule.dependentRules) {
                ThemeGenerator._setSlot(ruleToUpdate, rule.color, isInverted, false, overwriteCustomColor);
            }
        }
    }
}

/* This is the set of rules for our default theme.
   We start with three base slots, defining the background, foreground (text), and
   primary color (sometimes called theme color). Each Fabric slot is generated from
   shades (or tints) of one of those three, creating the Fabric palette.
   Then, we have semantic slots, the new thing intended to eventually replace the
   Fabric palette. The semantic slots inherit from the Fabric palette. */
/* The most minimal set of slots we start with. All other ones can be generated based on rules.
 * This is not so much an enum as it is a list. The enum is used to insure "type"-safety.
 * For now, we are only dealing with color. */
var BaseSlots;
(function (BaseSlots) {
    BaseSlots[BaseSlots["primaryColor"] = 0] = "primaryColor";
    BaseSlots[BaseSlots["backgroundColor"] = 1] = "backgroundColor";
    BaseSlots[BaseSlots["foregroundColor"] = 2] = "foregroundColor";
})(BaseSlots || (BaseSlots = {}));
/* The original Fabric palette, only for back-compat. */
var FabricSlots;
(function (FabricSlots) {
    FabricSlots[FabricSlots["themePrimary"] = 0] = "themePrimary";
    FabricSlots[FabricSlots["themeLighterAlt"] = 1] = "themeLighterAlt";
    FabricSlots[FabricSlots["themeLighter"] = 2] = "themeLighter";
    FabricSlots[FabricSlots["themeLight"] = 3] = "themeLight";
    FabricSlots[FabricSlots["themeTertiary"] = 4] = "themeTertiary";
    FabricSlots[FabricSlots["themeSecondary"] = 5] = "themeSecondary";
    FabricSlots[FabricSlots["themeDarkAlt"] = 6] = "themeDarkAlt";
    FabricSlots[FabricSlots["themeDark"] = 7] = "themeDark";
    FabricSlots[FabricSlots["themeDarker"] = 8] = "themeDarker";
    FabricSlots[FabricSlots["neutralLighterAlt"] = 9] = "neutralLighterAlt";
    FabricSlots[FabricSlots["neutralLighter"] = 10] = "neutralLighter";
    FabricSlots[FabricSlots["neutralLight"] = 11] = "neutralLight";
    FabricSlots[FabricSlots["neutralQuaternaryAlt"] = 12] = "neutralQuaternaryAlt";
    FabricSlots[FabricSlots["neutralQuaternary"] = 13] = "neutralQuaternary";
    FabricSlots[FabricSlots["neutralTertiaryAlt"] = 14] = "neutralTertiaryAlt";
    FabricSlots[FabricSlots["neutralTertiary"] = 15] = "neutralTertiary";
    // deprecated: neutralSecondaryAlt, // BaseSlots.foregroundColor, Shade[Shade.Shade4]);
    FabricSlots[FabricSlots["neutralSecondary"] = 16] = "neutralSecondary";
    FabricSlots[FabricSlots["neutralPrimaryAlt"] = 17] = "neutralPrimaryAlt";
    FabricSlots[FabricSlots["neutralPrimary"] = 18] = "neutralPrimary";
    FabricSlots[FabricSlots["neutralDark"] = 19] = "neutralDark";
    FabricSlots[FabricSlots["black"] = 20] = "black";
    FabricSlots[FabricSlots["white"] = 21] = "white"; // BaseSlots.backgroundColor, Shade[Shade.Unshaded]);
})(FabricSlots || (FabricSlots = {}));
/* List of all the semantic color slots for this theme.
 * This is not so much an enum as it is a list. The enum is used to insure "type"-safety. */
var SemanticColorSlots;
(function (SemanticColorSlots) {
    SemanticColorSlots[SemanticColorSlots["bodyBackground"] = 0] = "bodyBackground";
    SemanticColorSlots[SemanticColorSlots["bodyText"] = 1] = "bodyText";
    SemanticColorSlots[SemanticColorSlots["disabledBackground"] = 2] = "disabledBackground";
    SemanticColorSlots[SemanticColorSlots["disabledText"] = 3] = "disabledText";
})(SemanticColorSlots || (SemanticColorSlots = {}));
function themeRulesStandardCreator() {
    const slotRules = {};
    /*** BASE COLORS and their SHADES */
    // iterate through each base slot and make the SlotRules for those
    mapEnumByName(BaseSlots, (baseSlot) => {
        // first make the SlotRule for the unshaded base Color
        slotRules[baseSlot] = {
            name: baseSlot,
            isCustomized: true,
            dependentRules: []
        };
        // then make a rule for each shade of this base color, but skip unshaded
        mapEnumByName(Shade, (shadeName, shadeValue) => {
            if (shadeName === Shade[Shade.Unshaded]) {
                return;
            }
            const inherits = slotRules[baseSlot];
            const thisSlotRule = {
                name: baseSlot + shadeName,
                inherits: slotRules[baseSlot],
                asShade: shadeValue,
                isCustomized: false,
                isBackgroundShade: baseSlot === BaseSlots[BaseSlots.backgroundColor] ? true : false,
                dependentRules: []
            };
            slotRules[baseSlot + shadeName] = thisSlotRule;
            inherits.dependentRules.push(thisSlotRule);
            return void 0;
        });
        return void 0;
    });
    // set default colors for the base colors
    slotRules[BaseSlots[BaseSlots.primaryColor]].color = getColorFromString('#0078d4');
    slotRules[BaseSlots[BaseSlots.backgroundColor]].color = getColorFromString('#fff');
    slotRules[BaseSlots[BaseSlots.foregroundColor]].color = getColorFromString('#333');
    // set default colors for shades (the slot rules were already created above and will be used if the base colors ever change)
    slotRules[BaseSlots[BaseSlots.primaryColor] + Shade[Shade.Shade1]].color = getColorFromString('#eff6fc');
    slotRules[BaseSlots[BaseSlots.primaryColor] + Shade[Shade.Shade2]].color = getColorFromString('#deecf9');
    slotRules[BaseSlots[BaseSlots.primaryColor] + Shade[Shade.Shade3]].color = getColorFromString('#c7e0f4');
    slotRules[BaseSlots[BaseSlots.primaryColor] + Shade[Shade.Shade4]].color = getColorFromString('#71afe5');
    slotRules[BaseSlots[BaseSlots.primaryColor] + Shade[Shade.Shade5]].color = getColorFromString('#2b88d8');
    slotRules[BaseSlots[BaseSlots.primaryColor] + Shade[Shade.Shade6]].color = getColorFromString('#106ebe');
    slotRules[BaseSlots[BaseSlots.primaryColor] + Shade[Shade.Shade7]].color = getColorFromString('#005a9e');
    slotRules[BaseSlots[BaseSlots.primaryColor] + Shade[Shade.Shade8]].color = getColorFromString('#004578');
    // set default colors for shades (the slot rules were already created above and will be used if the base colors ever change)
    slotRules[BaseSlots[BaseSlots.foregroundColor] + Shade[Shade.Shade1]].color = getColorFromString('#eaeaea');
    slotRules[BaseSlots[BaseSlots.foregroundColor] + Shade[Shade.Shade2]].color = getColorFromString('#c8c8c8');
    slotRules[BaseSlots[BaseSlots.foregroundColor] + Shade[Shade.Shade3]].color = getColorFromString('#a6a6a6');
    slotRules[BaseSlots[BaseSlots.foregroundColor] + Shade[Shade.Shade4]].color = getColorFromString('#767676');
    slotRules[BaseSlots[BaseSlots.foregroundColor] + Shade[Shade.Shade5]].color = getColorFromString('#666666');
    slotRules[BaseSlots[BaseSlots.foregroundColor] + Shade[Shade.Shade6]].color = getColorFromString('#3c3c3c');
    slotRules[BaseSlots[BaseSlots.foregroundColor] + Shade[Shade.Shade7]].color = getColorFromString('#212121');
    slotRules[BaseSlots[BaseSlots.foregroundColor] + Shade[Shade.Shade8]].color = getColorFromString('#000000');
    function _makeFabricSlotRule(slotName, inheritedBase, inheritedShade, isBackgroundShade = false) {
        const inherits = slotRules[BaseSlots[inheritedBase]];
        const thisSlotRule = {
            name: slotName,
            inherits: inherits,
            asShade: inheritedShade,
            isCustomized: false,
            isBackgroundShade: isBackgroundShade,
            dependentRules: []
        };
        slotRules[slotName] = thisSlotRule;
        inherits.dependentRules.push(thisSlotRule);
    }
    _makeFabricSlotRule(FabricSlots[FabricSlots.themePrimary], BaseSlots.primaryColor, Shade.Unshaded);
    _makeFabricSlotRule(FabricSlots[FabricSlots.themeLighterAlt], BaseSlots.primaryColor, Shade.Shade1);
    _makeFabricSlotRule(FabricSlots[FabricSlots.themeLighter], BaseSlots.primaryColor, Shade.Shade2);
    _makeFabricSlotRule(FabricSlots[FabricSlots.themeLight], BaseSlots.primaryColor, Shade.Shade3);
    _makeFabricSlotRule(FabricSlots[FabricSlots.themeTertiary], BaseSlots.primaryColor, Shade.Shade4);
    _makeFabricSlotRule(FabricSlots[FabricSlots.themeSecondary], BaseSlots.primaryColor, Shade.Shade5);
    _makeFabricSlotRule(FabricSlots[FabricSlots.themeDarkAlt], BaseSlots.primaryColor, Shade.Shade6);
    _makeFabricSlotRule(FabricSlots[FabricSlots.themeDark], BaseSlots.primaryColor, Shade.Shade7);
    _makeFabricSlotRule(FabricSlots[FabricSlots.themeDarker], BaseSlots.primaryColor, Shade.Shade8);
    _makeFabricSlotRule(FabricSlots[FabricSlots.neutralLighterAlt], BaseSlots.backgroundColor, Shade.Shade1, true);
    _makeFabricSlotRule(FabricSlots[FabricSlots.neutralLighter], BaseSlots.backgroundColor, Shade.Shade2, true);
    _makeFabricSlotRule(FabricSlots[FabricSlots.neutralLight], BaseSlots.backgroundColor, Shade.Shade3, true);
    _makeFabricSlotRule(FabricSlots[FabricSlots.neutralQuaternaryAlt], BaseSlots.backgroundColor, Shade.Shade4, true);
    _makeFabricSlotRule(FabricSlots[FabricSlots.neutralQuaternary], BaseSlots.backgroundColor, Shade.Shade5, true);
    _makeFabricSlotRule(FabricSlots[FabricSlots.neutralTertiaryAlt], BaseSlots.backgroundColor, Shade.Shade6, true); // bg6 or fg2
    _makeFabricSlotRule(FabricSlots[FabricSlots.neutralTertiary], BaseSlots.foregroundColor, Shade.Shade3);
    _makeFabricSlotRule(FabricSlots[FabricSlots.neutralSecondary], BaseSlots.foregroundColor, Shade.Shade4);
    _makeFabricSlotRule(FabricSlots[FabricSlots.neutralPrimaryAlt], BaseSlots.foregroundColor, Shade.Shade5);
    _makeFabricSlotRule(FabricSlots[FabricSlots.neutralPrimary], BaseSlots.foregroundColor, Shade.Unshaded);
    _makeFabricSlotRule(FabricSlots[FabricSlots.neutralDark], BaseSlots.foregroundColor, Shade.Shade7);
    _makeFabricSlotRule(FabricSlots[FabricSlots.black], BaseSlots.foregroundColor, Shade.Shade8);
    _makeFabricSlotRule(FabricSlots[FabricSlots.white], BaseSlots.backgroundColor, Shade.Unshaded, true);
    // manually set initial colors for the primary-based Fabric slots to match the default theme
    slotRules[FabricSlots[FabricSlots.themeLighterAlt]].color = getColorFromString('#eff6fc');
    slotRules[FabricSlots[FabricSlots.themeLighter]].color = getColorFromString('#deecf9');
    slotRules[FabricSlots[FabricSlots.themeLight]].color = getColorFromString('#c7e0f4');
    slotRules[FabricSlots[FabricSlots.themeTertiary]].color = getColorFromString('#71afe5');
    slotRules[FabricSlots[FabricSlots.themeSecondary]].color = getColorFromString('#2b88d8');
    slotRules[FabricSlots[FabricSlots.themeDarkAlt]].color = getColorFromString('#106ebe');
    slotRules[FabricSlots[FabricSlots.themeDark]].color = getColorFromString('#005a9e');
    slotRules[FabricSlots[FabricSlots.themeDarker]].color = getColorFromString('#004578');
    slotRules[FabricSlots[FabricSlots.themeLighterAlt]].isCustomized = true;
    slotRules[FabricSlots[FabricSlots.themeLighter]].isCustomized = true;
    slotRules[FabricSlots[FabricSlots.themeLight]].isCustomized = true;
    slotRules[FabricSlots[FabricSlots.themeTertiary]].isCustomized = true;
    slotRules[FabricSlots[FabricSlots.themeSecondary]].isCustomized = true;
    slotRules[FabricSlots[FabricSlots.themeDarkAlt]].isCustomized = true;
    slotRules[FabricSlots[FabricSlots.themeDark]].isCustomized = true;
    slotRules[FabricSlots[FabricSlots.themeDarker]].isCustomized = true;
    /*** SEMANTIC SLOTS */
    // This code is commented out for now but left for future semantic color customization.
    // create the SlotRule for a semantic slot
    // function _makeSemanticSlotRule(semanticSlot: SemanticColorSlots, inheritedFabricSlot: FabricSlots): void {
    //   const inherits = slotRules[FabricSlots[inheritedFabricSlot]];
    //   const thisSlotRule = {
    //     name: SemanticColorSlots[semanticSlot],
    //     inherits: slotRules[FabricSlots[inheritedFabricSlot]],
    //     isCustomized: false,
    //     dependentRules: []
    //   };
    //   slotRules[SemanticColorSlots[semanticSlot]] = thisSlotRule;
    //   inherits.dependentRules.push(thisSlotRule);
    // }
    // Basic simple slots
    // _makeSemanticSlotRule(SemanticColorSlots.bodyBackground, FabricSlots.white);
    // _makeSemanticSlotRule(SemanticColorSlots.bodyText, FabricSlots.neutralPrimary);
    return slotRules;
}

const getClassNames$1i = classNamesFunction();
class ToggleBase extends BaseComponent {
    constructor(props) {
        super(props);
        this._toggleButton = createRef$1();
        this._onClick = (ev) => {
            const { disabled, checked: checkedProp, onChange, onChanged, onClick } = this.props;
            const { checked } = this.state;
            if (!disabled) {
                // Only update the state if the user hasn't provided it.
                if (checkedProp === undefined) {
                    this.setState({
                        checked: !checked
                    });
                }
                if (onChange) {
                    onChange(ev, !checked);
                }
                if (onChanged) {
                    onChanged(!checked);
                }
                if (onClick) {
                    onClick(ev);
                }
            }
        };
        this._warnMutuallyExclusive({
            checked: 'defaultChecked'
        });
        this._warnDeprecations({
            onAriaLabel: 'ariaLabel',
            offAriaLabel: undefined,
            onChanged: 'onChange'
        });
        this.state = {
            checked: !!(props.checked || props.defaultChecked)
        };
        this._id = props.id || getId('Toggle');
    }
    /**
     * Gets the current checked state of the toggle.
     */
    get checked() {
        return this.state.checked;
    }
    componentWillReceiveProps(newProps) {
        if (newProps.checked !== undefined) {
            this.setState({
                checked: !!newProps.checked // convert null to false
            });
        }
    }
    render() {
        const { as: RootType = 'div', className, theme, disabled, keytipProps, label, ariaLabel, onAriaLabel, offAriaLabel, offText, onText, styles } = this.props;
        const { checked } = this.state;
        const stateText = checked ? onText : offText;
        const badAriaLabel = checked ? onAriaLabel : offAriaLabel;
        const toggleNativeProps = getNativeProps(this.props, inputProperties, ['defaultChecked']);
        const classNames = getClassNames$1i(styles, {
            theme: theme,
            className,
            disabled,
            checked
        });
        //@ts-ignore
        return (createElement(RootType, { className: classNames.root },
            label && (createElement(Label, { htmlFor: this._id, className: classNames.label }, label)),
            createElement("div", { className: classNames.container },
                createElement(KeytipData, { keytipProps: keytipProps, ariaDescribedBy: toggleNativeProps['aria-describedby'], disabled: disabled }, (keytipAttributes) => (createElement("button", Object.assign({}, toggleNativeProps, keytipAttributes, { className: classNames.pill, disabled: disabled, id: this._id, type: "button", role: "switch" // ARIA 1.1 definition; "checkbox" in ARIA 1.0
                    , ref: this._toggleButton, "aria-disabled": disabled, "aria-checked": checked, "aria-label": ariaLabel ? ariaLabel : badAriaLabel, "data-is-focusable": true, onChange: this._noop, onClick: this._onClick }),
                    createElement("div", { className: classNames.thumb })))),
                stateText && createElement(Label, { className: classNames.text }, stateText))));
    }
    focus() {
        if (this._toggleButton.current) {
            this._toggleButton.current.focus();
        }
    }
    _noop() {
        /* no-op */
    }
}

const getStyles$1o = (props) => {
    const { theme, className, disabled, checked } = props;
    const { semanticColors } = theme;
    const pillUncheckedBackground = semanticColors.bodyBackground;
    const pillCheckedBackground = semanticColors.inputBackgroundChecked;
    const pillCheckedHoveredBackground = semanticColors.inputBackgroundCheckedHovered;
    const pillCheckedDisabledBackground = semanticColors.disabledBodySubtext;
    const thumbBackground = semanticColors.inputBorderHovered;
    const thumbCheckedBackground = semanticColors.inputForegroundChecked;
    const thumbDisabledBackground = semanticColors.disabledBodySubtext;
    const thumbCheckedDisabledBackground = semanticColors.disabledBackground;
    const pillBorderColor = semanticColors.smallInputBorder;
    const pillBorderHoveredColor = semanticColors.inputBorderHovered;
    const pillBorderDisabledColor = semanticColors.disabledBodySubtext;
    const textDisabledColor = semanticColors.disabledText;
    return {
        root: [
            'ms-Toggle',
            checked && 'is-checked',
            !disabled && 'is-enabled',
            disabled && 'is-disabled',
            theme.fonts.medium,
            {
                marginBottom: '8px'
            },
            className
        ],
        label: [
            'ms-Toggle-label',
            disabled && {
                color: textDisabledColor,
                selectors: {
                    [HighContrastSelector]: {
                        color: 'GrayText'
                    }
                }
            }
        ],
        container: [
            'ms-Toggle-innerContainer',
            {
                display: 'inline-flex',
                position: 'relative'
            }
        ],
        pill: [
            'ms-Toggle-background',
            getFocusStyle(theme, -3),
            {
                fontSize: '20px',
                boxSizing: 'border-box',
                width: '2.2em',
                height: '1em',
                borderRadius: '1em',
                transition: 'all 0.1s ease',
                borderWidth: '1px',
                borderStyle: 'solid',
                background: pillUncheckedBackground,
                borderColor: pillBorderColor,
                cursor: 'pointer',
                display: 'flex',
                alignItems: 'center',
                padding: '0 .2em'
            },
            !disabled && [
                !checked && {
                    selectors: {
                        ':hover': [
                            {
                                borderColor: pillBorderHoveredColor
                            }
                        ],
                        ':hover .ms-Toggle-thumb': [
                            {
                                selectors: {
                                    [HighContrastSelector]: {
                                        borderColor: 'Highlight'
                                    }
                                }
                            }
                        ]
                    }
                },
                checked && [
                    {
                        background: pillCheckedBackground,
                        borderColor: 'transparent',
                        justifyContent: 'flex-end'
                    },
                    {
                        selectors: {
                            ':hover': [
                                {
                                    backgroundColor: pillCheckedHoveredBackground,
                                    borderColor: 'transparent',
                                    selectors: {
                                        [HighContrastSelector]: {
                                            backgroundColor: 'Highlight'
                                        }
                                    }
                                }
                            ],
                            [HighContrastSelector]: {
                                backgroundColor: 'WindowText'
                            }
                        }
                    }
                ]
            ],
            disabled && [
                {
                    cursor: 'default'
                },
                !checked && [
                    {
                        borderColor: pillBorderDisabledColor
                    }
                ],
                checked && [
                    {
                        backgroundColor: pillCheckedDisabledBackground,
                        borderColor: 'transparent',
                        justifyContent: 'flex-end'
                    }
                ]
            ],
            !disabled && {
                selectors: {
                    '&:hover': {
                        selectors: {
                            [HighContrastSelector]: {
                                borderColor: 'Highlight'
                            }
                        }
                    }
                }
            }
        ],
        thumb: [
            'ms-Toggle-thumb',
            {
                width: '.5em',
                height: '.5em',
                borderRadius: '.5em',
                transition: 'all 0.1s ease',
                backgroundColor: thumbBackground,
                /* Border is added to handle high contrast mode for Firefox */
                borderColor: 'transparent',
                borderWidth: '.28em',
                borderStyle: 'solid',
                boxSizing: 'border-box'
            },
            !disabled &&
                checked && [
                {
                    backgroundColor: thumbCheckedBackground,
                    selectors: {
                        [HighContrastSelector]: {
                            backgroundColor: 'Window',
                            borderColor: 'Window'
                        }
                    }
                }
            ],
            disabled && [
                !checked && [
                    {
                        backgroundColor: thumbDisabledBackground
                    }
                ],
                checked && [
                    {
                        backgroundColor: thumbCheckedDisabledBackground
                    }
                ]
            ]
        ],
        text: [
            'ms-Toggle-stateText',
            {
                selectors: {
                    // Workaround: make rules more sepecific than Label rules.
                    '&&': {
                        padding: '0',
                        margin: '0 10px',
                        userSelect: 'none'
                    }
                }
            },
            disabled && {
                selectors: {
                    '&&': {
                        color: textDisabledColor,
                        selectors: {
                            [HighContrastSelector]: {
                                color: 'GrayText'
                            }
                        }
                    }
                }
            }
        ]
    };
};

const Toggle = styled(ToggleBase, getStyles$1o, undefined, { scope: 'Toggle' });

export { ActivityItem, Autofill, BaseAutoFill, Breadcrumb, BreadcrumbBase, BaseButton, ElementType, ButtonType, Button, ActionButton, CommandBarButton, CommandButton, CompoundButton, DefaultButton, MessageBarButton, PrimaryButton, IconButton, Calendar, DayOfWeek, DateRangeType, FirstWeekOfYear, Callout, FocusTrapCallout, DirectionalHint, Check, CheckBase, Checkbox, CheckboxBase, ChoiceGroup, ChoiceGroupBase, ChoiceGroupOption, Coachmark, COACHMARK_ATTRIBUTE_NAME, CoachmarkBase, MAX_COLOR_SATURATION, MAX_COLOR_HUE, MAX_COLOR_VALUE, MAX_COLOR_RGBA, cssColor, rgb2hex, hsv2hex, rgb2hsv, hsl2hsv, hsv2hsl, hsl2rgb, hsv2rgb, getColorFromString, getColorFromRGBA, getFullColorString, updateSV, updateH, updateA, Shade, isValidShade, isDark, getShade, getBackgroundShade, getContrastRatio, ColorPicker, ColorPickerBase, SelectableOptionMenuItemType, SelectableOptionMenuItemType as DropdownMenuItemType, ComboBox, VirtualizedComboBox, CommandBar, CommandBarBase, ContextualMenu, getSubmenuItems, canAnyMenuItemsCheck, ContextualMenuBase, ContextualMenuItemType, ContextualMenuItem, ContextualMenuItemBase, DatePicker, DatePickerBase, SELECTION_CHANGE, SelectionMode, SelectionDirection, Selection, SelectionZone, CollapseAllVisibility, DetailsList, DetailsListBase, buildColumns, ColumnActionsMode, ConstrainMode, ColumnDragEndLocation, DetailsListLayoutMode, CheckboxVisibility, DetailsRow, DetailsRowBase, DetailsRowCheck, Dialog, DialogBase, DialogContent, DialogContentBase, DialogFooter, DialogFooterBase, DialogType, VerticalDivider, DocumentCard, DocumentCardType, DocumentCardActions, DocumentCardActivity, DocumentCardLocation, DocumentCardPreview, DocumentCardTitle, DocumentCardLogo, DocumentCardStatus, Dropdown, DropdownBase, BaseExtendedPicker, BaseExtendedPeoplePicker, ExtendedPeoplePicker, Fabric, FabricBase, OverflowButtonType, FacepileBase, Facepile, BaseFloatingPicker, BaseFloatingPeoplePicker, FloatingPeoplePicker, createItem, SuggestionsStore, SuggestionItemType, SuggestionsHeaderFooterItem, SuggestionsControl, SuggestionsCore, FocusTrapZone, FocusZone, FocusZoneTabbableElements, FocusZoneDirection, Grid, GridCell, GroupedList, GroupedListBase, HoverCard, HoverCardBase, OpenCardMode, HoverCardType, ExpandingCard, ExpandingCardBase, ExpandingCardMode, PlainCard, PlainCardBase, Icon, IconBase, IconType, Image, ImageBase, ImageFit, ImageCoverStyle, ImageLoadState, Keytip, KeytipData, KeytipLayer, KeytipLayerBase, LabelBase, Label, Layer, LayerBase, LayerHost, Link, LinkBase, List, ScrollToMode, MarqueeSelection, MessageBar, MessageBarBase, MessageBarType, Modal, ModalBase, Nav, isRelativeUrl, NavBase, OverflowSet, OverflowSetBase, Overlay, OverlayBase, Panel, PanelType, Persona, PersonaBase, PersonaSize, PersonaPresence, PersonaInitialsColor, PersonaCoin, PersonaCoinBase, personaSize, personaPresenceSize, sizeBoolean, sizeToPixels, presenceBoolean, Suggestions, SuggestionActionType, SuggestionsItem, SuggestionsController, BasePicker, BasePickerListBelow, ValidationState, BasePeoplePicker, MemberListPeoplePicker, NormalPeoplePickerBase, CompactPeoplePickerBase, ListPeoplePickerBase, createGenericItem, NormalPeoplePicker, CompactPeoplePicker, ListPeoplePicker, PeoplePickerItemBase, PeoplePickerItem, PeoplePickerItemSuggestionBase, PeoplePickerItemSuggestion, TagPickerBase, TagPicker, TagItemBase, TagItem, TagItemSuggestionBase, TagItemSuggestion, PivotItem, Pivot, PivotBase, PivotLinkFormat, PivotLinkSize, Popup, PositioningContainer, ProgressIndicator, ProgressIndicatorBase, Rating, RatingBase, RatingSize, ResizeGroup, getMeasurementCache, getNextResizeGroupStateProvider, ResizeGroupBase, ScrollablePane, ScrollablePaneBase, ScrollbarVisibility, SearchBox, SearchBoxBase, BaseSelectedItemsList, BasePeopleSelectedItemsList, SelectedPeopleList, ExtendedSelectedItem, Shimmer, ShimmerBase, ShimmerElementType, ShimmerElementsDefaultHeights, ShimmerLine, ShimmerLineBase, ShimmerCircle, ShimmerCircleBase, ShimmerGap, ShimmerGapBase, ShimmerElementsGroup, ShimmerElementsGroupBase, ShimmeredDetailsList, ShimmeredDetailsListBase, Slider, ValuePosition, SliderBase, KeyboardSpinDirection, SpinButton, Spinner, SpinnerBase, SpinnerSize, SpinnerType, Sticky, StickyPositionType, AnimationClassNames, FontClassNames, ColorClassNames, AnimationStyles, AnimationVariables, DefaultPalette, DefaultFontStyles, registerDefaultFontFaces, FontSizes, FontWeights, IconFontSizes, createFontStyles, getFocusStyle, focusClear, hiddenContentStyle, PulsingBeaconAnimationStyles, getGlobalClassNames, ThemeSettingName, getTheme, loadTheme, createTheme, registerOnThemeChangeCallback, removeOnThemeChangeCallback, getThemedContext, HighContrastSelector, HighContrastSelectorWhite, HighContrastSelectorBlack, ScreenWidthMinSmall, ScreenWidthMinMedium, ScreenWidthMinLarge, ScreenWidthMinXLarge, ScreenWidthMinXXLarge, ScreenWidthMinXXXLarge, ScreenWidthMaxSmall, ScreenWidthMaxMedium, ScreenWidthMaxLarge, ScreenWidthMaxXLarge, ScreenWidthMaxXXLarge, ScreenWidthMinUhfMobile, getScreenSelector, normalize, noWrap, getFadedOverflowStyle, ZIndexes, buildClassMap, getIcon, registerIcons, registerIconAlias, unregisterIcons, setIconOptions, getIconClassName, InjectionMode, Stylesheet, concatStyleSets, fontFace, keyframes, mergeStyleSets, mergeStyles, SwatchColorPicker, SwatchColorPickerBase, ColorPickerGridCell, ColorPickerGridCellBase, TeachingBubble, TeachingBubbleBase, TeachingBubbleContent, TeachingBubbleContentBase, TextField, TextFieldBase, DEFAULT_MASK_CHAR, MaskedTextField, ThemeGenerator, BaseSlots, FabricSlots, SemanticColorSlots, themeRulesStandardCreator, Toggle, ToggleBase, Tooltip, TooltipBase, TooltipDelay, TooltipHost, TooltipHostBase, TooltipOverflowMode, Async, AutoScroll, BaseComponent, nullRender, provideContext, Customizations, CustomizerContext, Customizer, mergeCustomizations, mergeSettings, DelayedRender, EventGroup, FabricPerformance, GlobalSettings, KeyCodes, Rectangle, mergeAriaAttributeValues, findIndex, find, createArray, toMatrix, removeIndex, replaceElement, addElementAtIndex, flatten, arraysEqual, asAsync, assertNever, autobind, classNamesFunction, createRef$1 as createRef, css, customizable, DATA_PORTAL_ATTRIBUTE, setVirtualParent, getVirtualParent, getParent, getChildren, elementContains, setSSR, getWindow, getDocument, getRect, setPortalAttribute, portalContainsElement, findElementRecursive, elementContainsAttribute, getFirstFocusable, getLastFocusable, getFirstTabbable, getLastTabbable, focusFirstChild, getPreviousElement, getNextElement, isElementVisible, isElementTabbable, isElementFocusZone, isElementFocusSubZone, doesElementContainFocus, shouldWrapFocus, focusAsync, hoistMethods, unhoistMethods, hoistStatics, IsFocusVisibleClassName, initializeFocusRects, getInitials, isDirectionalKeyCode, addDirectionalKeyCode, getLanguage, setLanguage, getDistanceBetweenPoints, fitContentToBounds, calculatePrecision, precisionRound, setMemoizeWeakMap, resetMemoizations, memoize, memoizeFunction, merge, isIOS, shallowCompare, assign, filteredAssign, getId, resetIds, mapEnumByName, values, isMac, hasHorizontalOverflow, hasVerticalOverflow, hasOverflow, baseElementEvents, baseElementProperties, htmlElementProperties, anchorProperties, buttonProperties, divProperties, inputProperties, textAreaProperties, imageProperties, getNativeProps, getResourceUrl, setBaseUrl, getRTL, setRTL, getRTLSafeKeyCode, DATA_IS_SCROLLABLE_ATTRIBUTE, allowScrollOnElement, disableBodyScroll, enableBodyScroll, getScrollbarWidth, findScrollableParent, format, styled, warnDeprecations, warnMutuallyExclusive, warnConditionallyRequiredProps, warn, setWarningCallback };
